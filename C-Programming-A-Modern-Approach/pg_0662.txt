 

 

Q & À 637

else {
print£ ("Program terminates: longjmp called\n") ;
return 0;

}

£1() ;
print£f ("Program terminates normally\n") ;
return OD;

}

void f1(void)

{

printf ("£1 begins\n") ;
f2();
print£f("f1 returns\n") ;

}

void f2 (void)

(

print£ ("f2 begins\n") ;
longjmp (env, 1) ;
print£ ("f£2 returns\n") ;

}

The output of this program will be

setjmp returned O

f1 begins

f2 begins

Program terminates: longjmp called

The original call of setjmp returns O, so main calls f1. Next, f1 calls f2,
which uses longjmp to transfer control back to main instead of returning to f1.
When 1longjmp is executed, control goes back to the setmp call. This time,
setjmp returns | (the value specified in the longjmp call).

Q & À

You said that it’s important to store zero in errno before calling a library
function that may change it, but P’ve seen UNIX programs that test errno
without ever setting it to zero. What’s the story? [p. 629]

UNIX programs often contain calls of functions that belong to the operating sys-
tem. These sysfemn calls rely on errno, but they use it in a slightly different way
than described in this chapter. When such a call fails, it returns a special value
(such as —I or a null pointer) in addition to storing a value in errno. Programs
don’t necd to store zero in errno before such a call. because the function’s return
value alone indicates that an error occurred. Some functions in the C standard
library work this way as well, using errno not so much to signal an error as to
specify which error it was.
