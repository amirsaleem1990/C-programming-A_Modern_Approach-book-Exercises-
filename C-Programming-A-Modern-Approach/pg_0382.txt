15.2  Header Files 357

variable declaration 1s included in the source file that contains the variable's defini-
tion. enablinge the compiler to check that the two match.

Although sharing variables among files is a long-standing practice in the C
world, it has significant disadvantages, In Section 19.2, we'll see what the prob-
lems are and learn how to design programs that don't need shared variables.

Nested Includes

À header file may itself contain # include directives. Although this practice may
seem u bit odd, 1t can be quite useful in practice. Consider the stack.h file.
which contains the following prototypes:

int is empty (void) ;
int is full (void) ;

Since these f'unctions return only Ô or |. it's a good idea to declare their return type
to be Bool instead of int, where Bool 1s the type that we defined earlier in this
section:

Bool is empty (void) ;
Bool is full (void) ;

Of course. we’ll need to include the boolean. h file in stack. h so that the def-
inition of Bool is available when stack.h 1s compiled. (In C99, we’d include
<stdbool .h> instead of boolean.h and declare the return types of the two
functions to be boo1 rather than Bool.)

Traditionally. C programmers shun nested includes. (Early versions of C
didn’t allow them at all.) However, the bias against nested includes has largely
faded away, in part because nestedl includes are common practice in C++.

Protecting Header Files

If a source file includes the same header file twice. compilation errors may result.
This problem is common when header files include other header files. For exam-
ple. suppose that filel .h includes file3.h, file2.h includes file3.h.
and prog. c includes both filei .h and file2.h (see the figure at the top of
the next page). When prog. c is compiled. file3 .h will be compiled twice.

Including the same header file twice doesn’t always cause a compilation error.
If the file contains only macro definitions. function prototypes, and/or variable
declarations. there won°t be any difficulty. If the file contains a type definition.
however. we'Il get a compilation error.

Just to bc safe. itl's probably a good idea to protect all header files against mul-
tiple inclusion: that way. we can add type definitions to a file later without the risk
that we might forget to protect the file. In addition, we might save some time dur-
ing program development by avoidine unnecessary recompilation of the same
header file.
