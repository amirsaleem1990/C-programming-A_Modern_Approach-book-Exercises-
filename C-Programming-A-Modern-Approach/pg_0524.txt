 

194 À Stack Abstract Data Type 499

void make empty(Stack s)

(
;

bool is empty (Stack s)

(

s->top = Q0;

return s->top == OD;
}
bool is full (Stack s)
{

return s->top == s->size;
}
void push(Stack s, Item i)
{

if (is full(s))
terminate ("Error in push: stack is full.");
s->contents [s->top++] = i;

}

Item pop(Stack s)

{
if (is empty(s))
terminate ("Error in pop: stack is empty.") ;
return s->contents [--s->top] ;
}

The create function now calls malloc twice: once to allocate a stack _ type
structure and once to allocate the array that will contain the stack items. Either call
of malloc could fail, causing terminate to be called. The destroy function
must call £ree twice to release all the memory allocated by create.

The stackclient . c file can again be used to test the stack ADT. The calls
of create will need to be changed. however. since create now requires an
argument. For example, we could replace the statements

sl = create();
s2 = Create()

’

with the following statements:

sl = create (100) ;
s2 = create(200) ;

Implementing the Stack ADT Using a Linked List

Implementing the stack ADT using a dynamically allocated array gives us more
Mexibility than using a fixed-size array. However, the client 1s still required to spec-
ify a maximum size for a stack at the time 1t’s created. If we use à linked-list imple-
mentation instead, there won’t be any preset limit on the size of a stack.
