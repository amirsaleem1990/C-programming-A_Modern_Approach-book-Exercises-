648

Chapter 25

Q&AÀ

International Features

Changing the meaning of type char to handle larger character sets isn’t pos-
sible. since char values are—by definition—limited to single bytes. Instead, C
allows compilers to provide an extended character set. This character set may be
used for writing C programs (in comments and strings, for example), in the envi-
ronment in which the program is run. or in both places. C provides two techniques
for encoding an extended character set: multibyte characters and wide characters.
It also supplies functions that convert from one kind of encoding to the other.

Multibyte Characters

In a multibyte character encoding, each extended character is represented by a
sequence of one or more bytes. The number of bytes may vary. depending on the
character. C requires that any extended character set include certain essential char-
acters (letters, digits. operators, punctuation. and white-space characters); these
characters must be single bytes. Other bytes can be interpreted as the beginning of
a multibyte character.

 

 

Japanese Character Sets

The Japanese employ several different writing systems. The most complex, kanji
consists of thousands of symbols—far too many to represent in a one-byte encod-
ing. (Kanji symbols actually come from Chinese, which has a similar problem with
large character sets.) There’s no single way to encode kanj; common encodings
include JIS (Japanese Industrial Standard), Shift-JIS (the most popular encoding),
and EUC (Extended UNIX Code).

 

 

 

 

Some multibyte character sets rely on a sfate-dependent encoding. In this
kind of encoding, cach sequence of multibyte characters begins in an initial shift
state. Certain bytes encountered later (kKnown as a shift sequence) may change the
shift state, affecting the meaning of subsequent bytes. Japan's JIS encoding, for
example, mixes one-byte codes with two-byte codes: ‘“‘escape sequences” embed-
ded in strings indicate when to switch between one-byte and two-byte modes. (In
contrast, the Shift-JIS encoding is not state-dependent. Each character requires
either one or two bytes, but the first byte of à two-byte character can always be dis-
tinguished from a one-byte character.)

In any encoding, the C standard requires that a zero byte always represent a
null character, regardless of shift state. Also, a zero byte can‘t be the second (or
later) byte of a multibyte character.

The C library provides two macros, MB_LEN MAX and MB_CUR MAX, that
are related to multibyte characters. Both macros specify the maximum number of
bytes in a multibyte character. MB_LEN MAX (defined in <limits . h>) gives the
maximum for any supported locale: MB_CUR MAX (delined in <stdlib.h>)
gives the maximum for the current locale. (Changing locales may affect the inter-
pretation of multibyte characters.) Obviously, MB_CUR MAX can’t be larger than
MB LEN MAX.
