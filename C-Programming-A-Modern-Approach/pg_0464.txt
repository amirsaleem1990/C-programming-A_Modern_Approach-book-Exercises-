177

 

17.7  Pointers to Functions 439

At the point of the call, first is copied into list. (Pointers, like all arguments,
are passed by value.) The last line in the function changes the value of 1ist, mak-
Ing it point to the new node. This assignment doesn’t affect first. however.

Getling add_to _list to modify first is possible, but it requires pass-
ing add_to_list a pointer to first. Here’s the correct version of the func-
tion:

void add_to _list (struct node **list, int n)

(

struct node *new _node;

new_node = malloc (sizeof (struct node) ) ;

if (new_node == NULL) {
printf ("Error: malloc failed in add_to list\n") ;
exit (EXIT FAILURE) ;

new_node->value = n;
new_node->next = *list,;
*list = new node;

}

When we call the new version of add_to list, the first areument will be the
address of first:

add _ to _ list(&first, 10);

Since 1ist is assigned the address of first, we can use *#1ist as an alias for
£irst. In particular, assigning new_node to *1ist will modify first.

Pointers to Functions

We've seen that pointers may point to various kinds of data, including variables,
array elements, and dynamically allocated blocks of memory. But C doesn't
require that pointers point only to data; it’s also possible to have pointers to feic-
tions. Pointers to functions aren’t as odd as you might think. After all, functions
occupy memory locations, so every function has an address, just as each variable
has an address.

Function Pointers as Arguments

We can use function pointers in much the same way we use pointers to data. In par-
ticular, passing a function pointer as an argument is fairly common in C. Suppose
that we're writing a function named integrate that integrates a mathematical
lunction £ between points a and b. We*d like to make integrate as general as
possible by passing it £ as an argument. To achieve this effect in C, we*11 declare f
to be à pointer to a function. Assuming that we want to integrate functions that have
