634 Chapter 24  Error Handling

/

raise

PROGRAM

tsignal.c

 

After a signal has been handled, whether or not the handler needs to be reinstalled
Is implementation-defined. UNIX implementations typically leave the signal han-
dler installed after it's been used, but other implementations may reset the handler
lo SIG_DFT. In the latter case, the handler can reinstall itself by calling signal
before it returns.

 

C99 changes the signal-handling process in a few minor ways. When a signal
Is raised, an implementation may choose to disable not just that signal but others as
well. IF à signal-handling function returns from handling a SIGILL or SIGSEGV
signal (as well as a SIGFPE signal), the effect is undefined. C99 also adds the
restriction that if à signal occurs as a result of calling the abort function or the
raise function, the signal handier itself must not call raise.

The raise Function

int raise (int sig) ,

Although signals usually arise from run-time e€rrors or external events, it's occa-
sionally handy for a program to cause à signal to occur. The raise function does
just that, The argument to raise specifies the code for the desired signal:

raise (SIGABRT) ; /* raises the SIGABRT signal */

The return value of raise can be used to test whether the call was successful:
zero indicates success, while a nonzero value indicates failure.

Testing Signals

The following program illustrates the use of signals. First, it installs a custom han-
dler for the SIGINT signal (carefully saving the original handiler), then calls
raise_sig to raise that signal. Next, it installs SIG_IGN as the handier for the
SIGINT signal and calls raise_sig again. Finally, it reinstalls the original han-
dler for SIGINT, then calls raise_sig one last time.

/* Tests signals */

#Hinclude <signal.hs
#Hinclude <stdio.hs

void handler (int sia) ;
void raise sig (void) ;

int maiîn (void)

{

void (*orig handler) (int) ;
