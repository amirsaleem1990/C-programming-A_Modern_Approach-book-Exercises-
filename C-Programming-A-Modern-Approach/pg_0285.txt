260

Chapter 12  Pointers and Arrays

æ

compound literals »9,3

12.2

c1 } -.L)

 

 

 

i = p - q; /* i is 4 */
i = q - p; /* i is -4 */

 

Performing arithmetic on a pointer that doesn’t point to an array element causes
undefined behavior. Furthermore, the effect of subtracting one pointer from
another 1s undefined unless both point to elements of the same array.

 

Comparing Pointers

We can compare pointers using the relational operators (<, <=, >, >=) and the
equality operators (== and ! =). Using the relational operators to compare two
pointers is meaningful onty when both point to elements of the same array. The
outcome of the comparison depends on the relative positions of the two elements
in the array. For example, after the assi gnments

p = &a[5] ;
q = &a[1];

the value of p <= q is 0 and the value oOf p >= gis |.

Pointers to Compound Literals

It's legal for a pointer to point to an element within an array created by a com-
pound literal. A compound literal, you may recall, is a C99 feature that can be used
(O create an array with no name.

Consider the following example:

int *p = (int [1){3, o, 3, 4, 1},

p points to the first element of a five-element array containing the integers 3, O, 3,
4, and 1. Using a compound literal saves us the trouble of first declaring an array
variable and then making p point to the first clement of that array:

int all = {31 0, 3, 4, l};
int *p = &a[0];

Using Pointers for Array Processing

Pointer arithmetic allows us to visit the elements of an array by repeatedly incre-
menting a pointer variable. The following program fragment, which sums the ele-
ments of an array a, illustrates the technique. In this example, the pointer variable
