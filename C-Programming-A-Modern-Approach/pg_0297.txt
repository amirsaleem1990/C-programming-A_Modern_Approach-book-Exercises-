272

Chapter 12  Pointers and Arrays

Q:
À:

>.

Why is *a the same as a [] in a parameter declaration? [p. 266]

Both indicate that the argument is expected to be a pointer. The same operations on
a are possible in both cases (pointer arithmetic and array subscripting, in particu-
lar). And, in both cases, à itself can be assigned a new value within the function.
(Although C allows us to use the name of an array variable only as a “constant
pointer,” there’s no such restriction on the name of an array parameter.)

Is it better style to declare an array parameter as *a or a [] ?

That’s a tough one. From one standpoint. à [] is the obvious choice, since *a is
ambiguous (does the function want an array of objects or a pointer to a single
object?). On the other hand, many programmers argue that declaring the parameter
as *a is more accurate, since it reminds us that only a pointer is passed, not a copy
of the array. Others switch betwcen *a and a [] . depending on whether the func-
tilon uses pointer arithmetic or subscripting to access the elements of the array.
(That’s the approach l’Il use.) In practice, *a is more common than a [] . so you’d
better get used to it. For what it’s worth, Dennis Ritchie now refers to the a []
notation as “a living fossil” that “serves as much to confuse the learner as to alert
the reader.”

We”ve seen that arrays and pointers are closely related in C. Would it be accu-
rate to say that they’re interchangeable?

No. It's true that array parameters are interchangeable with pointer parameters, but
array variables aren’t the same as pointer variables. Technically. the name of an
array isn’t à pointer; rather, the C compiler converts it to a pointer when necessary.
To see this difference more clearly, consider what happens when we apply the
sizeof operalor to an array a. The value of sizeof (a) is the total number of
bytes in the array—the size of each element multiplied by the number of elements.
But if p is à pointer variable, sizeoëË (p) is the number of bytes required to store
a pointer value.

You said that treating a two-dimensional array as one-dimensional works
with ‘‘“most’”’ C compilers. Doesn*1 it work with all compilers? [p. 268]

No. Some modern “bounds-checking” compilers track not only the type of a
pointer, but—when it points to an array—also the length of the array. For example,
suppose that p is assigned a pointer to a [0] [0]. Technically, p points to the first
clement of a [0], a one-dimensional array. lf we increment p repeatedly in an
effort lo visit all the elements of a, we'I! go out of bounds once p goes past the last
element of a [0]. À compiler that performs bounds-checking may insert code to
check that p is used only to access elements in the array pointed to by a [0] : an
attempt to increment p past the end of this array would be detected as an error.

 

If a is a two-dimensional array, why can we pass a [0] —but not a itself—to
find_largest? Don°t both a and a [0] point to the same place (the begin-
ning of the array)? [p. 270]

They do, as a matter of fact—both point to element a [0] [0]. The problem is that
