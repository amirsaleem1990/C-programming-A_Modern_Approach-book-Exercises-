344

Chapter 14  The Preprocessor

to handle. (Note the use of #unde£ 10 undefine sqrt before defining the sqrt
macro. Às we'Il see in Section 21.1, the standard library is allowed to have both a
macro and a function with the same name. Undefining sqrt before defining our
own sqrt macro is a defensive measure, in case the library has already defined
sqrt as a macro.)

1 get an error when I try to use predefined macros suchas _ LINE — and
__FILE , Is there a special header that I need to include?

No. These macros are recognized automatically by the preprocessor. Make sure that
you have Mwo underscores at the beginning and end of each macro name, not one.

What’s the purpose of distinguishing between a ‘“hosted implementation” and
à ““freestanding implementation”? If a freestanding implementation doesn°t
even support the <stdio.h> header, what use is it? [p. 330]

À hosted implementation is needed for most programs (including the ones in this
book), which rely on the underlying operating system for input/output and other
essential services. À freestanding implementation of C would be used for pro-
grams that require no operating system (or only a minimal operating system). For
example, a freestanding implementation would be needed for writing the kernel of
an operating system (which requires no traditional input/output and therefore
doesn’t need <stdio.h> anyway). Freestanding implementations are also useful
for writinge software for embedded systems.

I thought the preprocessor was just an editor. How can it evaluate constant
expressions? [p. 334]

The preprocessor is more sophisticated than you might expect; it knows enough
about C to be able to evaluate constant expressions, although it doesn’t do so in
quite the same way as the compiler. (For one thing, the preprocessor treats any
undefined name as having the value 0. The other differences are too esoteric to go
into here.) In practice, the operands in a preprocessor constant expression are usu-
ally constants, macros that represent constants. and applications of the defined
operator.

Why does C provide the #i £de£ and #i fnde£ directives, since we can get
the same effect using the #i £ directive and the defined operator? [p. 335]

The #i fde£ and #i fndef directives have been a part of C since the 1970s. The
defined operator, on the other hand, was added to C in the 1980s during stan-
dardization. So the real question is: Why was defined added to the language?
The answer is that de£fined adds flexibility. Instead of just being able to test the
existence of a single macro using #ifde£ or #ifndef, we can now test any
number of macros using #i£ together with defined. For example. the following
directive checks whether FOO and BAR are defined but BAZ is not defined:

#if defined(FOO) && defined(BAR) && !defined(BAZ)
