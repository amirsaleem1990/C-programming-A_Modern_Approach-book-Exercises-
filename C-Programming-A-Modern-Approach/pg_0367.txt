342

Chapter 14  The Preprocessor

> ©

Q & À

Pve scen programs that contain a # on a line by itself. Is this legal?

Yes. This 1s the null directive; it has no cffect. Some programmers use null direc-
tives for spacing within conditional compilation blocks:

#if INT MAX < 100000
#

terror int type is too small

#
tendif

Blank lines would also work, of course, but the # helps the reader see the extent of
the block.

l’m not sure which constants in a program need to be defined as macros. Are
there any guidelines to follow? [p. 319]

One rule of thumb says that every numeric constant, other than O or }, should be a
macro. Character and string constants are problematic, since replacing a character
or string constant by a macro doesn’t always improve readability. 1 recommend
using a macro instead of a character constant or string literal provided that (1) the
constant is used more than once and (2) the possibility exists that the constant
might someday be modified. Because of rule (2). I don’t use macros such as

#+define NUL '\0!'

although some programmers do.

What does the # operator do if the argument that it’s supposed to ““stringize”
contains a " or \ character? [p. 324]

It converts " to \" and \ to \\. Consider the following macro:
#define STRINGIZE(x) #x

The preprocessor will replace STRINGIZE ("£oo") by "\"£oo\"".

I can°t get the following macro to work properly:
#define CONCAT (x,y) x##vy

CONCAT (a,b) gives ab, as expected, but CONCAT (a, CONCAT (b, c ) ) gives
an odd result. What’s going on?

Thanks to rules that Kernighan and Ritchie call “bizarre;’ macros whose replace-
ment lists depend on ## usually can’t be called in a nested fashion. The problem is
that CONCAT (a, CONCAT (b, c) ) isn'{ expanded in a ‘normal” fashion, with
CONCAT (b, C) yielding bc, then CONCAT (a, bc) giving abc. Macro parame-
ters that are preceded or followed by ## in à replacement list aren°t expanded at
