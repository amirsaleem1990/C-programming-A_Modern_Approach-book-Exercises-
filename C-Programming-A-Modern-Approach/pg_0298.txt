Section 12.1

Section 12.2

Section 12.3

l

3.

5.

Exercises 2173

a has the wrong type. When used as an argument, it’s a pointer to an array, but
find largest is expecting a pointer to an integer. However, a [0] has type
int *, so il’s an acceptable argument for £ind_largest. This concern about
types is actually good: if C weren*t so picky, we could make all kinds of horrible
pointer mistakes without the compiler noticing.

Exercises

Suppose that the following declarations are in effect:

int a[] = {5, 15, 34, 54, 14, 2, 52, 72};
int *p = &a[1], *q = &a[5];

(a) Whalt is the value of * (p+3) ?

(b) What is the value of * (g-3) ?

(c) What is the value of q - p?

(d) 1s the condition p < q true or false?
(e) Is the condition *p < *q true or false?

Suppose that high. 1low, and middle are all pointer variables of the same type, and that
low and high point to elements of an array. Why is the following statement illegal, and
how could it be fixed?

middle = (low + high) / 2:;

What will be the contents of the à array after the following statements are exccuted?

#define N 10

int a[N] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int *p = &a[0], *q = &a[N-1], temp;

while (p < q) (

temp = *p;
*p++ = *G;
*q-- = temp;

Rewrite the make_empty, is_empty. and is_f£ull functions of Section 10.2 to use the
pointer variable top_ptr instead of the integer variable top.

Suppose that à is a onc-dimensional array and p is a pointer variable. Assuming that the
assignment p = a has just been performed. which of the following expressions are illegal
because of mismatched types? Of the remaining expressions, which are true (have à nonzero
value)?

(a) p == a[o]
(b) p == &a[0]
(c) *p == alo]
(d) p[0] == a[o]

Rewrite the following function to use pointer arithmetic instead of array subscripting. (In
other words, eliminate the variable i and all uses of the [] operator.) Make as few changes
as possible.
