QaA

17.7  Pointers to Functions 441

zero 1f *p 1s “equal to” *g, and positive 1f *p 1s “greater than” *q. The terms “less
than;” “equal to” and ‘“greater than” are in quotes because it’s our responsibility to
determine how *p and *q are compared.

qsort has the following prototype:

void qsort (void *base, size t nmemb, size t size,
int (*compar) (const void *, const void *));

base must point to the first element in the array. (IF only a portion of the array 1s
to be sorted, we’Il make base point to the first element in this portion.) In the sim-
plest case, base is just the name of the array. nmemb 1s the number of clements to
be sorted (not necessarily the number of elements in the array). size 1s the size of
each array element, measured in bytes. compar is a pointer to the comparison
function. When qsort is called, it sorts the array into ascending order, calling the
comparison function whenever 1t needs to compare array elements.

To sort the inventory array of Section 16.3. we’d use the following call of
qsort:

gsort (inventory, num_parts, sizeof (struct part), compare _ parts) ;

Notice that the second argument is num_parts, not MAX PARTS; we don’! want
to sort thé entire inventory array, just the portion in which parts are currently
stored. The last argument, compare parts, 1s a function that compares two
part structurcs.

Writing the compare _ parts function isn’t as easy as you might expect.
qsort requires that its parameters have type void *. but we can’t access the
members of a part structure through à void * pointer; we need a pointer of type
struct part * instead. To solve the problem, wc'Il have compare parts
assign its parameters, p and q, to variables of type struct part *, thereby con-
verting them to the desired type. compare _parts can now use these variables to
access the members of the structures that p and q point to. Assuming that we want
to sort the inventory array into ascending order by part number. here’s how the
compare parts function might look:

int compare parts (const void *p, const void *g)

{

const struct part *p1l = p;
const struct part *ql = q;

1f (pl->number < ql->number)
return -l;

else if (pl->number == g1l->number)
return 0;
else

return l;

}

The declarations of p1 and ql include the word const to avoid getting a warning
from the compiler. Since p and q are const pointers (indicating that the objects
