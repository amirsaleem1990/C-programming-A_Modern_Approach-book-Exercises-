432

Chapter 17  Advanced Uses of Pointers

prev cur
L- _ __
list [3-* 30 °—l‘—’ 40 ' — 20 *—}-_" 10 |/|

Again, the test cur != NULL && cur->value != n iis true. so prev = cur,
cur = cur->next 1s executed once more:

 

 

 

 

B

 

prev

 

 

se [JH 1001 420107

Since cur now points to the node containing 20, the condition cur->value ! =
n 1s faise and the loop terminates.

Next, we’IIl perform the bypass required by step 2. The statement

 

prev->next = cur->next ;

makes the pointer in the previous node point to the node after the current node:

prev cur

list[:::]——ô{30 I *—r—'

We're now ready for step 3, releasing the memory occupied by the current node:

 

free (cur) ;

The following function. delete £from _list, uses the strategy that we’ve
just outlined. When given a list and an integer n. the function deletes the first node

containing n. If no node contains n. delete from list does nothing. In
either case, the function returns a pointer to the list.

struct node *delete £from list (struct node *list,

{

int n)

struct node *cur, *prev;

for (cur = list, prev = NULL;
cur != NULL && cCur->value

!= n;
prev = cur, cur = cCur->next)

—H — _— ——
