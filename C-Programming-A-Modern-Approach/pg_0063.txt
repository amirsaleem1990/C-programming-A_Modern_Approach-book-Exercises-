38

Chapter 3 Formatted Input/Ouiput

Ordinary characters in a format string are printed exactly as they appear in the
string; conversion specifications are replaced by the values to be printed. Consider
the following example:
int i, ];
float x, y;

i = 10;

j = 20;

x = 43.2892f;
y = 5527.0f;

©

printf("i = %d, j = %d, x = %f, y = %f£\n", i, j, x, Y);
This call of print£f produces the following output:
i = 10, j = 20, x = 43.289200, y = 5527.000000

The ordinary characters in the format string are simply copied to the output line.
The four conversion specifications are replaced by the values of the variables i, J.
x, and y, in that order.

 

C compilers aren’t required to check that the number of conversion specifications
in a format string matches the number of output items. The following call of
printf has more conversion specifications than values lo be printed:

printf("%d %d\n", i); — /*** WRONG ***/

print£ will print the value of i correctly, then print a second (meaningless) inte-
ger value. À call with too few conversion specifications has similar problems:

print£ ("td\n", i, 3); /*** WRONG ***/

In this case, printf prints the value of i but doesn*t show the value of .

Furthermore, compilers aren’t required to check that a conversion specifica-
tion is appropriate for the type of item being printed. If the programmer uses an
incorrect specification, the program will simply produce meaningless output. Con-
sider the following call of print£, in which the int variable i and the £float
variable x are in the wrong order:

printf("%£f %d\n", i, x); /*** WRONG ***/

Since print£ must obey the format string, it will dutifully display a float
value, followed by an int value. Unfortunately, both will be meaningless.

 

Conversion Specifications

Conversion specifications give the programmer a great deal of control over the
appcarance of output. On the other hand, they can be complicated and hard to read.
In fact, describing conversion specifications in complete detail 1s too arduous à
