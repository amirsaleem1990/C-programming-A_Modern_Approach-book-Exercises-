210

Chapter9 Functions

Q:

ÂÀ:

:;:Q:

A:

pointers to functions > 17,7

expression statements > 4.5

“Q:

Some programming languages allow procedures and functions to be nested
within cach other. Does C allow function definitions to be nested?

No. C does not permit the definition of one function to appear in the body of
another. Among other things, this restriction simplifies the compiler.

Why does the compiler allow the use of function names that aren°t followed by
parentheses? [p. 189]

We'Il see in a later chapter that the compiler treats à function name not followed by
parentheses as a pointer to the function. Pointers to lunctions have legitimate uses,
so the compiler can*t automatically assume that a function name without parenthe-
ses is an error. The statement

print _ pun;

is legal because the compiler treats print pun as a pointer and therefore an
expression, making this a valid (although pointless) expression statement.

In the function call £(a, b), how does the compiler know whether the
commia is punctuation or whether it°s an operator?

IL turns out that the arguments in a function call can’t be arbitrary expressions.
Instead, they must be “‘assignment expressions,” which can’t contain commas used
às operators unless they're enclosed in parentheses. In other words. in the call
£ (a, b) the comma is punctuation: in the call f ((a, b)) it’s an operator.

Do the names of parameters in a function prototype have to match the names
given later in the function°s definition? [p. 192]

No. Some programmeers take advantage of this fact by giving long names to param-
cters in the prototype, then Using shorter names in the actual definition. Or a
French-speaking programmer might use English names in prototypes, then switch
to more l'amiliar French names in function definitions.

[ still don’t understand why we bother with function prototypes. If we just put
definitions of all the functions before main, we>re covered, right?

Wrong. First, you’re assuming that only main calls the other functions. which is
unrealistic. In practice, some of the functions will call each other. If we put all
l'unction definitions above main, we'Il have to watch their order carefully. Calling
à function that hasn’t been defined yet can lead to big problems.

But that’s not all. Suppose that two functions call each other (which isn’t as
far-fetched as it may sound). No matter which function we define first. it will end
up calling à function that hasn*t been defined yet.

But there’s still more! Once programs reach a certain size, it won’t be feasible
(o put all the functions in one file anymore. When we reach that point, we'll need
prototypes lo tell the compiler about functions in other files.

l’ve seen function declarations that omit all information about parameters:
