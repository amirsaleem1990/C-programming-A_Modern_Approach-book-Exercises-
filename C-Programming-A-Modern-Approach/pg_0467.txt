442

Chapter 17  Advanced Uses of Pointers

to which they point should not be modified). they should be assigned only to
pointer variables that are also declared to be const.

Although this version of compare parts works, most C programmers
would write the function more concisely. First, notice that we can replace p1 and
ql by cast expressions:

int compare_parts(const void *p, const void *qg)

{

Lif (((struct part *) p)->number <
((struct part *) q)->number)

return -l;

else 1f (((struct part *) p)->number ==

((struct part *) q)->number)

return 0;

else
return 1l;

}

The parentheses around ( (struct part *) p) are necessary; without them, the
compiler would try to cast p->number to type struct part *.
We can make compare _parts even shorter by removing the i f statements:

int compare parts(const void *p, const void *q)

(

return ((struct part *) p)->number -
((struct part *) g)->number;
}

Subtracting q’s part number from p’s part number produces a negative result if p
has a smaller part number, zero if the part numbers are equal. and a positive result
if p has a larger part number. (Note that subtracting two integers is potentially
risky because of the danger of overflow. l’m assuming that part numbers are posi-
tive integers, so that shouldn’t happen here.)

To sort the inventory array by part name instead of part number, we’d use
the following version of compare parts:

int compare _parts(const void *p, const void *g)

{

return stromp(((struct part *) p)->name,
((struct part *) q)->name) ;
}

All compare_parts has to do is call stremp, which conveniently returns a
negative, zero, or positive result,

Other Uses of Function Pointers

Although l’ve emphasized the usefulness of function pointers as arguments to
other functions. that’s not all they’re good for. C treats pointers to functions just
like pointers to data: we can store function pointers in variables or use them as ele-
