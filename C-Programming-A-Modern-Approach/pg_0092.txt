> Q

>.

Q & À 67

(and indeed, both standards guarantee that this is the case, provided that the value
of a / b is “representable’’). The problem is that there are two ways for a / b and
a % b to satisfy this equality 1f either à or b is negative, as seen in C89, where
either -9 / 7 is —l and -9 % 7 is —2, or -9 / 7 is —2 and -9 $ 7 is 5. In the first
case, (-9 / 7) * 7 + -9 % 7 has the value —1 x 7 + —2 = —9, and in the second
case, (-9 / 7) * 7 + -9 % 7 has the value —2 x 7 + S = —9. By the time C99 rolled
around, most CPUs were designed to truncate the result of division toward zero, so
this was written into the standard as the only allowable outcome.

If C has Ivalues, does it also have rvalues? [p. 59]

Yes, indeed. An /value is an expression that can appear on the /eft side of an assign-
ment; an rvalue 1s an expression that can appear on the right side. Thus, an rvalue
could be a variable, constant, or more complex expression. In this book, as in the C
standard, we'Il use the term ‘’expression” instead of “rvalue.”

 

Why does C provide the ++ and -- operators? Are they faster than other

ways of incrementing and decrementing, or they are just more convenient? [p.
61]

C inherited ++ and -- from Ken Thompson’s earlier B language. Thompson
apparently created these operators because his B compiler could generate a more
compact translation for ++i than for i = i + 1. These operators have become a
deeply ingrained part of C (in fact, many of C’s most famous idioms rely on them).
With modern compilers, using ++ and -- won’t make a compiled program any
smaller or faster; the continued popularity of these operators stems mostly from
their brevity and convenience.

Do ++ and - - work with flcoat variables?

Yes; the increment and decrement operations can be applied to floating-point num-
bers as well as integers. In practice, however, it’s fairly rare to increment or decre-
ment a Éloat variable.
