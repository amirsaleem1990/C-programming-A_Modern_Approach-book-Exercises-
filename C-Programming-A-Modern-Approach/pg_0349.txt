324

Chapiter 14  The Preprocessor

Qa&A

The # Operator

Macro definitions may contain two special operators, # and ##. Neither operator is
recognized by the compiler: instead, they’re executed during preprocessing.

The # operator converts a macro argument into a string literal; it can appear
only in the replacement list of à parameterized macro. (The operation performed
by # Is known as “stringization” a term that m sure you won°{ find in the dictio-
nary.)

There are a number of uses for #; let’s consider just one. Suppose that we
decide to use the PRINT INT macro during debugging as a convenient way to
print the values of integer variables and expressions. The # operator makes it pos-
sible for PRINT INT to label each value that it prints. Here’s our new version of
PRINT INT:

f#idefine PRINT INT(n) printf (#n " = %d\n", n)

The # operator in front of n instructs the preprocessor to create a string literal from
PRINT INT ‘s argument. Thus, the invocation

PRINT _ INT(i/j) ;
will become
printf("i/j" "— %d\ﬁ", i/j)î

We saw in Section 13.1 that the compiler automatically joins adjacent string liter-
als, so this statement is equivalent to

print£f("i/j = %d\n", i/j);

When the program is executed. print£ will display both the expression i /j and
its value. If à is 11 and ; is 2, for example, the output will be

i/j = 5

The ## Operator

The ## operator can “paste” two tokens (identifiers, for example) together to form
a single token. (Not surprisingly. the ## operation is known as “token-pasting.”) If
one of the operands is a macro parameter, pasting occurs after the parameter has
been replaced by the corresponding argument. Consider the following macro:

#define MK ID(n) i##n

When MK_ID is invoked (as MK_ID(1). say), the preprocessor first replaces the
parameter n by the argument (1 In this case). Next, the preprocessor joins i and 1
to make a single token (i1). The following declaration uses MK_ ID to create three
identifiers:

int MK _ ID(1), MK ID({2), MK ID(3);
