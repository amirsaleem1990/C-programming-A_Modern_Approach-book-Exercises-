readline.h

readline.c

isspace lunction > 23.5

16.3  Nested Arrays and Structures 395

space characters before 11 begins storing characters. Not only will this solve the
new-line problem, but it also allows us to avoid storing any blanks that precede the
part name.

Since read_line is unrelated to the other functions in inventory. c, and
since il’s potentially reusable in other programs, l’ve decided to separate it from
inventory.c. The prototype for read_line will go in the readline.h
header file:

#ifndef READLINE H
iidefine READLINE H

/*k****‘k*k'k‘k%‘**‘k*k****‘k*‘k****‘k‘k***+******‘k‘**************—k-k*—k**

* read _ line: Skips leading white-space characters, then

* reads the remainder of the input line and *
# stores it in str. Truncates the line if its *
* length exceeds n. Returns the number of *
* characters stored. *
KKKN RERRARARAA RR AARR K

/

int read line(char str[(], int n);
tendif
We'Il put the definition of read_line in the readline. c file:

#finclude <ctype.h>
#include <stdio.h>
#include "readline.h"

int read line(char str{[], int nP)

{

int ch, à = O0;

while (isspace(ch = getchar()))

'

while (ch != '\n' && ch != EOF) {
if (i < n)
str[i++] = ch;
ch = getchar () ;
}
str[i)] = '\0*;
return i;

}
The expression
isspace (ch = getchar())

controis the first while statement. This expression calls getchar to read a char-
acter, stores the character into ch, and then uses the isspace function to test
whether ch is a white-space character. If not, the loop terminates with ch contain-
ing à character that's not white space. Section 15.35 explains why ch has type int
Instead of char and why it°s good to test for EOF.
