:{:Q=
æ
À:

compound literals > 9.3, 76.2

Q & À 415

u The function may not define a modifiable static variable.
u The function may not contain references to variables with internal linkage.

Such a function is allowed to define a variable that is both static and const,
but each inline definition of the function may create its own copy of the variable.

Using Inline Functions with GCC

Some compilers, including GCC, supported inline functions prior to the C99 stan-
dard. As a result, their rules for using inline functions may vary from the stan-
dard. In particular, the scheme described earlier (using the average.h and
average. c files) may not work with these compilers. Version 4.3 of GCC (not
available at the time this book was written) is expected to support inline func-
tions in the way described in the C99 standard.

Functions that are specified to be both static and inline should work
ne, regardless of the version of GCC. This strategy is legal in C99 as well, so it’s
the safest bet. À static inline function can be used within a single file or
placed in a header file and included into any source file that needs to call the func-
tion.

There’s another way to share an inline function among multiple files that
works with older versions of GCC but conflicts with C99. This technique involves
putting a definition of the function in a header file, specifying that the function is
both extern and inline, then including the header file into any source file that
contains à call of the function. À sécond copy of the definition—without the words
extern and inl ine—is placed in one of the source files. (That way, if the com-
piler is unable to “inline” the function for any reason, it will still have a definition.)

ÀA final note about GCC: Functions are ‘“inlined’’ only when optimization 1s
requested via the -O command-line option.

Q & À

Why are selection statements and iteration statements (and their ‘“inner”’
statements) considered to be blocks in C99? [p. 459]

This rather surprising rule stems from a problem that can occur when compound
literals are used in selection statements and iteration statements. The problem has
to do with the storage duration of compound literals, so let's take a moment to dis-
cuss that issue first.

The C99 standard states that the object represented by a compound literal has
static storage duration if the compound literal occurs outside the body of a func-
tion. Otherwise, it has automatic storage duration; as a result, the memory occu-
pied by the object is deallocated at the end of the block in which the compound
literal appears. Consider the following function, which returns a point structure
created using a compound literal:
