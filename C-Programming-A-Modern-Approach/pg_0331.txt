306

Chapter 13  Strings

Â:

:;:Qz

A:

EOF macro > 22,4

Yes, as the following example shows:

char fmt[] = "Zd\n";
int i;

print£ (fmt, i);

This ability opens the door to some intriguing possibilites—reading a format
string as input, for example.

If l want print£ to write a string str, can°t I just supply str as the format
string, as in the following example?

print£ (str) ;

Yes, but i£'s risky. If str contains the % character. you won't get the desired result.
since print£ will assume its the beginning of a conversion specification.

How can read_line detect whether getchar has failed to read a charac-
ter? [p. 287]

If it can’t read a character, either because of an error or because of end-of-file,
getchar returns the value EOF, which has type int. Here’s a revised version of
read_line that tests whether the return value of getchar is EOF. Changes are
marked in bold:

int read line(char str[], int n)

{

int ch, i = O0;

while ((ch = getchar()) != '\n' && ch != EOF)

L1£ (i < n)
str[i++] = ch;
str[i] = '\0';
return i;

}

Why does stremp return a number that’s less than, equal to, or greater than
zero? Also, does the exact return value have any significance? [p. 292]

stremp's return value probably stems from the way the function is traditionally
written. Consider the version in Kernighan and Ritchie’s The C Programming Lan-

guage:

int stromp(char *s, char *t)
{ ° °
int 1;
for (i = O; s[i] == t[i]; i++)
1f (s[i] == '\O')
return 0;
return s[i)] - tli];

}
