11.4

11.4  Pointers as Arguments 247

Pointers as Arguments

So far, we’ve managed to avoid a rather important question: What are pointers
good for? There’s no single answer to that question, since pointers have several
distinct uses in C. In this section. we’I] see how a pointer to a variable can be use-
ful as a function argument. We'I1 discover other uses for pointers in Section | 1.5
and in Chapters 12 and 17.

We saw in Section 9.3 that a variable supplied as an argument in a function
call is protected against change, because C passes arguments by value. This prop-
erty of C can be a nuisance if we want the function to be able to modify the vari-
able. In Section 9.3, we tied—and failed—to write a decompose function that
could modify two of its arguments.

Pointers offer a solution to this problem: instead of passing a variable x as the
argument to a function, we’I] supply &x, a pointer to x. We'll declare the corre-
sponding parameter p to be a pointer. When the function is called, p will have the
value &x. hence *p (the object that p points to) will be an alias for x. Each appear-
ance of *p in the body of the function wil] be an indirect reference to x, allowing
the function both to read x and to modify it.

To see this technique in action, let’s modify the decompose function by
declaring the parameters int _ part and frac_part to be pointers. The defini-
tion of decompose will now look like this:

void decompose (double x, long *int part, double *frac _part)

*int part = (long) x;
*frac _ part = x - *int part;

}

The prototype for decompose could be either
void decompose (double x, long *int part, double *frac part);
or
void decompose (double, long *, double *);
We'1l call decompose in the following way:
decompose (3.14159, &i, &d);

Because of the & operator in front of à and d. the arguments lo0 decompose are
pointers to i and d, not the valres of i and d. When decompose is called, the
value 3.14159 is copied into x, a pointer to i is stored in int part, and a
pointer to d is stored in frac_part:
