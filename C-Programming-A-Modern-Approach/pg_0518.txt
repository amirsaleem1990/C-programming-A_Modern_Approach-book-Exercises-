19.4

stackADT.h
(version 1)

194 A Stack Abstracit Daia Type 493

A Stack Abstract Data Type

To illustrate how abstract data types can be encapsulated using incomplete types,
we'1l develop a stack ADT based on the stack module described in Section 19.2. In
the process, we‘Il explore three different ways to implement the stack.

Defining the Interface for the Stack ADT

First, we‘1! need a header file that defines our stack ADT type and gives prototypes
for the functions that represent stack operations. Let’s name this file stack-
ADT .h. The Stack type will be à pointer to a stack_type structure that stores
the actual contents of the stack. This structure is an incomplete type that will be
completed in the file that implements the stack. The members of this structure will
depend on how the stack is implemented. Herc’s what the stackADT . h fîle will
look like:

#ifndef STACKADT H
#define STACKADT H

#include <stdbool .h> /* c99 only */
typedef struct stack type *Stack;

Stack create (void) ;

void destroy (Stack s) ;
void make empty ((Stack s) ;
bool is empty (Stack s) ;
bool is full (Stack s) ;
void push(Stack s, int i);
int pop(Stack s) ;

#endif

Clients that include stackADT.h will be able to declare variables of type
Stack, each of which is capable of pointing to a stack_type structure. Clients
can then call the functions declared in stackADT.h to perform operations on
stack variables. However, clients can’t access the members of the stack_type
structure, since that structure will be defined in à separate file.

Note that each function has a Stack parameter or returns a Stack value.
The stack functions in Section 19.3 had parameters of type Stack *. The rea-
son for the difference is that a Stack variable is now a pointer; it points to a
stack type structure that stores the contents of the stack, If a function needs
to modify the stack, it changes the structure itself, not the pointer to the struc-
ture.

Also note the presence of the create and destroy functions. À module
