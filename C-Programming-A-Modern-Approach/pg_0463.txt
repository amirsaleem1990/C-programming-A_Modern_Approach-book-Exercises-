438

Chapter 17

17.6

Advanced Uses of Pointers

printf ("Part Number Part Name "
"Quantity on Hand\n") ;
for (p = inventory; p != NULL; p = p->next)
print£("%7d %-25s%11d\n", p->number, p->name,
p->on _hand) ;

Notice the use of free in the insert function. insert allocates memory
for a part before checking to see if the part already exists. If it does, insert
releases the space to avoid a memory leak.

Pointers to Pointers

In Section 13.7, we came across the notion of à pointer to a pointer. In that section.
we used an array whose elements were of type char *: à pointer to one of the
array elements itself had type char * *. The concept of “pointers to pointers’’ also
pops up frequently in the context of linked data structures. In particular, when an
argument to à function is a pointer variable, we’II sometimes want the function to
be able to modify the variable by making it point somewhere else. Doing so
requires the use of a pointer to a pointer.

Consider the add_to _list function of Section 17.5, which inserts a node
at the beginning of a linked list. When we call add_to list., we pass it a
pointer to the first node in the original list; it then returns a pointer to the first node
in the updated list:

struct node *add_to list (struct node *list, int n)

{

Struct node *new _node;

new_node = malloc (sizeof (struct node) ) ;

if (new node == NULL) {
print£f ("Error: malloc failed in add to list\n") ;
exit (EXIT FAILURE) ;

new_node->value = n;
new_node->next = list;
return new node;

}

Suppose that we modify the function so that it assigns new _node to list
instead of returning new_node. In other words, let’s remove the return state-
ment from add_to_list and replace it by

list = new node;

Unfortunately, this idea doesn’t work. Suppose that we call add_to list in the
following way:

add_to list(first, 10);
