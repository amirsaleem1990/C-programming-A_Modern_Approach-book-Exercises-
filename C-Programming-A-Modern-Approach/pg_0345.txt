320

Chapter 14  The Preprocessor

#define STR _LEN 80

#define TRUE l
#define FALSE O
#define PI 3.14159
#*define CR t\r'
#define EOS t 0"

fdefine MEM _ ERR "Error: not enough memory"
Using #define to create names for constants has several significant advantages:

u /t makes programs easier to read. The name of the macro—if well-chosen—
helps the reader understand the meaning of the constant. The alternative 1s à
program full of “’Magic numbers” that can easily mystify the reader.

u Îf makes programs easier to modify. We can change the value of a constant
throughout à program by modifying à single macro definition. “Hard-coded”
constants are morc difficult to change, especially since they sometimes appear
in a slightly altered form. (For example, a program with an array of length 100
may have à loop that goes from 0 to 99. If we merely try to locate occurrences
of 100 in the program, we*ll miss the 99.)

u Ît helps avoid inconsistencies and typographical errors. 1Ë a numerical con-
stant like 3.14159 appears many times in a program, chances are 1l will
occasionally be written 3.1416 or 3.14195 by accident.

Although simple macros are most often used to define names for constants.
they do have other applications:

u Makine minor changes to the syntax of C. We can—in cffect—alter the syn-
tax of C by defining macros that serve as alternate names for C symbols. For
example. programmers who prefer Pascal’s begin and end to C’s { and }
can define the following macros:

#define BEGIN ({
#define END }

We could go so far as to invent our own language. For example, we might cre-
ate a LOOP ‘statement” that establishes an infinite loop:

#define LOOP for (;;)
Changing the syntax of C usually isn’t a good idea, though, since it can make

programs harder for others to understand.
u Renaming types. In Section 5.2. we created a Boolean type by renaming int:

#define BOOL ant

type definillons » 7.5 Although some programmers use macros for this purpose, type definitions are
a superior way to define type names.

u Controlling conditional compilation. Macros play an important role in con-
trolling conditional compilation. as we’1l see in Section 14.4. For example, the
presence of the following line in a program might indicate that 1t’s to be com-
