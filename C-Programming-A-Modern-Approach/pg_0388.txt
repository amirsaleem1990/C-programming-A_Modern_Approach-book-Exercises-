justify.c

word.c

15.3  Dividing a Program into Files 363

/* Formats a £ile of text */

#include <string.h>
Hinclude "line.h"
jinclude "word.h"

#define MAX WORD LEN 20

int main(void)
char word [MAX WORD LEN+2)] ;
int word _len;

clear line() ;

for (;;) |
read_word(word, MAX WORD LEN+1) ;
word _len = strlen (word) ;

if (word len == O) |
flush_line() ;
return 0;

)

if (word len > MAX WORD _ LEN)
word [MAX WORD LEN] = '*';

if (word len + 1 > space remaining()) {
write line();
clear line();

}

add_word (word) ;

}
}

Including both 1ine.h and word.h gives the compiler access to the function
prototypes in both files as it compiles justi£fy.c.

main uses a trick to handlce words that exceed 20 characters. When 1t calls
read_word. main tells it to truncate any word that exceeds 21 characters. After
read_word returns, main checks whether word contains a string that's longer
than 20 characters. If so. the word that was read must have been at least 21 charac-
ters long (before truncation), so main replaces the word's 21st character by an
asterisk.

Now it’s time to write word. c. Although the word .h header file has à pro-
totype for only one l'unction. read_word, we can put additional functions in
word. c if we nced to. Às it turns out, read_word 1s easier to write 1f we add a
small “helper” function, read_char. We'll assigen read_char the task of read-
ing à single character and, if ils a new-line character or tab, converting 1t to a
space. Having read _ word call read _ char instead of getchar solves the
problem of treating new-line characters and tabs as spaces.

Here s the word. c file:

#include <stdio.h>
Finclude "word.h"
