4.1  Arithmetic Operators 55

 

 

Implementation-Defined Behavior

The term implementation-defined will arise often enough that it?s worth taking a
moment to discuss it. The © standard deliberately leaves parts oi the language
unspecified, with the understanding that an “implementation”—the software needed
to compile, link, and execute programs on a particular platform—-will fill in the
details. As a result, the behavior of the program may vary somewhat from one
implementation to another. The behavior of the / and % operators for negative oper-
ands in C89 is an example of implementation-defined behavior.

Leaving parts of the language unspecified may seem odd or even dangerous,
but it reflects C’s philosophy. One of the language's goals is efficiency, which often
means matching the way that hardware behaves. Some CPUs yield —1 when —9 is
divided by 7, while others produce -—2; the C89 standard simply reflects this fact of
life.

I®s best to avoid writing programs that depend on implementation-defined
behavior. If that’'s not possible, at least check the manual carefully—the C standard
requires that implementation-defined behavior be documented.

 

 

Operator Precedence and Associativity

When an expression contains more than one operator, its interpretation may not be
immediately clear. For example, does i + j * k mean “add i and j, then multüply
the result by k;” or does it mean “multiply j and k, then add i””? One solution to
this problem is to add parentheses, writing either (i + j) * k or i + (j * k). Às
a general rule, C allows the use of parentheses for grouping in all expressions.

What if we don’t use parentheses, though? Will the compiler interpret i + j *
k as (i + j) * k or i + (j * k) ? Like many other languages, & uses operator
precedence rules to resolve this potential ambiguity. The arithmetic operators have
the following relative precedence:

Highest: +
*

(unary)

e

O

| >S= 1

Lowest: + (binary)

Operators listed on the same line (such as + and -) have equal precedence.

When two or more operators appear in the same expression, we can determine
how the compiler will interpret the expression by repeatedly putting parentheses
around subexpressions, starting with high-precedence operators and working down
to low-precedence operators. The following examples illustrate the result:

i + ; * k isequivalentto i + (j * k)
-i * -7 isequivalentto (-i) * (-7)
+i + j / K isequivalentto (+i) + (j / K)

Operator precedence rules alone aren’tenough when an expression contains two
or more operators at the same level of precedence. In this situalion, the associativity
