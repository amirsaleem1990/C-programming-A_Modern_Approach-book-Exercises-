
***************************page_001***************************
[ Covers VRs }S
KN.KING LS

 
   

C PROGRAMMIN

A Modern Ap})')”OCLCÎ& SECOND EDITION

 

 

 

 

 

 

 

***************************page_002***************************
K.N.KING

 
 
 
 
 
 
 
 
  
    
 
 

 

The first edition of C Progaemenany: À Modevit A p>
vas a mt withr students and faculty alike bécause uf its clarity

and comprehensiveness as well as its trademark Q&A sections.”

Kings spiral approach made the first edition accessible to à
broad range of réaders, from beginners to more acdvanced
students. The first edition was used at over 225 colleges.
making itone ofthe leading C texthooks of the last ten vears.

FEATURES OF THE SECOND EDITION
Coruplete coverage of boththe CS9 standarct nl the C99
standard, withall C99 changes clearlyv marked
Includes à quick reference to all CS9 ancl COO library
functions
lyxpandecd covcrage of GCC
New coverage of abstract data tvpes
(pdated to refleet today's CPUs uul operating systems
Nearly 500 exercises and programming projects—60% more
Hhan mn thie first edition
Source code and solntions to selected exercises and
programming projcets for students, available at the author's
website (Æukèa.com)

l’assword-protected instructor site (also at krkdne.con)

containing solutions to the remaining exercises and projocts,

plus PowerPoint presentations for most chapters

 

   

158N 978-0-393-97950-3

AN

 

  

 

“ thoroughly enjoyed reading the
second edition of C Programming
and | look forward to using it in
future courses.”

— Karen Reid, Senior Lecturer,
Department of Computer Science,
University of Toronto

“The second edition of King's
C Programming improves on an
already impressive base, and is the

} book l'recommend to anyone who

wants to learn-C,”
V

— Peter Seebach, moderator,

comp.lang.c.moderated

   
 

“l'assign C Programming to first-
year engineering students. It is
concise, clear, accessible to the
beginner, and yet also covers all

——

aspects of the language.”

— Professor Markus Bussmann,
Department of Mechanical and
Industrial Engineering, University
of Toronto

 

K. N. KING (Ph.D., University of
California, Berkeley) is an
associate professor of computer
science at Georgia State
University. He is also the author
of Modula-2: A Complete Guide

and Java Programming: From

the Beginning.

 

 

***************************page_003***************************
PREFAC

 

In computing, turning the obvious into the useful
is a living definition of the word “frustration.”

In the years since the first edition of C Programming: À Modern Approach was
published, a host of new C-based languages have sprung up—Java and C# foremost
among them—and related languages such as C++ and Perl have achieved greater
prominence. Still, C remains as popular as ever, plugging away in the background,
quietly powering much of the world’s software. It remains the lingua franca of the
computer universe, as it was in 1996.

But even C must change with the times. The need for a new edition of C Pro-
gramming: À Modern Approach became apparent when the C99 standard was pub-
lished. Moreover, the first edition. with its references to DOS and |6-bit processors,
was becoming dated. The second edition is fully up-to-date and has been improved
in many other ways as well.

What’s New in the Second Edition

Here’s a list of new features and improvements in the second edition:

= Complete coverage of both the C&9 standard and the C99 standard. The big-
gest difference between the first and second editions is coverage of the C99 stan-
dard. My goal was to cover every significant difference between C89 and C99,
including all the language features and library functions added in C99. Each
C99 change is clearly marked, either with “C99” in the heading of a section or—
in the case of shorter discussions—with a special icon in the left margin. I did
this partly to draw attention to the changes and partly so that readers who aren’t
interested in C99 or don*t have access to a C99 compiler will know what to skip.
Many of the C99 additions are of interest only to a specialized audience, but
some of the new features will be of use to nearly all C programmers.

xXi

***************************page_004***************************
XXII

Preface

u Includes a quick reference to all C89 and C99 library functions. Appendix

D in the first edition described all C89 standard library functions. In this edi-
tion, the appendix covers all C89 and C99 library functions.

m Expanded coverage of GCC. In the years since the first edition, use of GCC

(originally the GNU C Compiler, now the GNU Compiler Collection) has
spread. GCC has some significant advantages, including high quality, low (ie..
no) cost, and portability across a variety of hardware and software platforms.
In recognition of its growing importance, l’ve included more information about
GCC in this edition, including discussions of how to use it as well as common
GCC error messages and warnings.

= New coverage of abstract data types. In the first edition, a significant portion

of Chapter 19 was devoted to C++. This material seems less relevant today,
since students may already have learned C++, Java, or C# before reading this
book. In this edition, coverage of C++ has been replaced by a discussion of
how to set up abstract data types in C.

Expanded coverage of international features. Chapter 25, which is devoted
to C’s international features, is now much longer and more detailed. Informa-
tion about the Unicode/UCS character set and its encodings is a highlight of
the expanded coverage.

Updated to reflect today’s CPUs and operating systems. When I wrote the
first edition, 16-bit architectures and the DOS operating system were still rele-
vant to many readers, but such is not the case today. l’ve updated the discus-
sion to focus more on 32-bit and 64-bit architectures. The rise of Linux and
other versions of UNIX has dictated a stronger focus on that family of operat-
ing systems, although aspects of Windows and the Mac OS operating system
that affect C programmers are mentioned as well.

m More exercises and programming projects. The first edition of this book con-

tained 311 exercises. This edition has nearly 500 (498, to be exact). divided
into two groups: exercises and programming projects.

Solutions to selected exercises and programming projects. The most frequent
request | received from readers of the first edition was to provide answers to
the exercises. In response to this request, l’ve put the answers to roughly one-
third of the exercises and programming projects on the web at knking.com/
books/c2. This feature is particularly useful for readers who aren’t enrolled in
a college course and need a way to check their work. Exercises and projects
for which answers are provided are marked with a (D icon (the “W”’ stands for
‘“answer available on the Web”).

Password-protected instructor website. For this edition, l’ve built a new in-
structor resource site (accessible through knking.com/books/c2) containing
solutions to the remaining exercises and projects, plus PowerPoint presenta-
tions for most chapters. Faculty may contact me at chook@knking.com for a
password. Please use your campus email address and include a link to your
department’s website so that J can verify your identity.

***************************page_005***************************
Preface xxili

l've also taken the opportunity to improve wording and explanations through-
out the book. The changes are extensive and painstaking: every sentence has been
checked and—if necessary—rewritten.

Although much has changed in this edition, l've tried to retain the original
chapter and section numbering as much as possible. Only one chapter (the last one)
is entirely new, but many chapters have additional sections. In a few cases, existing
sections have been renumbered. One appendix (C syntax) has been dropped, but a
new appendix that compares C99 with C89 has been added.

Goals

The goals of this edition remain the same as those of the first edition:

u Be clear, readable, and possibly even entertaining. Many C books are too
concise for the average reader. Others are badly written or just plain dull. l’ve
triecl to give clear, thorough explanations, leavened with enough humor to hold
the reader’s interest.

= Be accessible to a broad range of readers. | assume that the reader has at least
à little previous programming experience, but ! don’t assume knowledge of a
particular language. l’ve tried to keep jargon to a minimum and to define the
terms that | use, l’ve also attempted (o separate advanced material from more
elementary topics, so that the beginner won°t get discouraged.

= Be authoritative without being pedantic. To avoid arbitrarily deciding what to
include and what not to include, l’ve tried to cover all the features of the C lan-
guage and library. At the same time, l’ve tried to avoid burdening the reader
with unnecessary detail.

m Be organized for easy learning. My experience in teaching C underscores the
importance of presenting the features of C gradually. l use à spiral approach, in
which difficult topics are introduced briefly, then revisited one or more times
later in the book with details added each time. Pacing 1s deliberate, with each
chapter building gradually on what has come before. For most students, this is
probably the best approach: it avoids the extremes of boredom on the one hand,
or ‘“information overload” on the other.

u Motivate language features. Instead of just describing each feature of the lan-
guage and giving a few simple examples of how the feature is used, l’ve tried to
motivate each feature and discuss how it’s used in practical situations.

= Emphasize style. 1s important for every C programmer to develop a consis-
tent style. Rather than dictating what this style should be, though, I usually
describe a few possibilities and let the reader choose the one that’s most
appealing. Knowing alternative styles 1s a big help when reading other people’s
programs (which programmers often spend a great deal of time doing).

m Avoid dependence on a particular machine, compiler, or operating system.
Since C 1s available on such a wide variety of platforms, Pve tried to avoid

***************************page_006***************************
 

XXxiv

Preface

 

dependence on any particular machine, compiler, or operating system. AIl pro-
grams are designed to be portable to a wide variety of platforms.

Use illustrations to clarify key concepts. V ve tried to put in as many figures as
| could, since I think these are crucial for understanding many aspects of C. In
particular, l’ve tried to “’animatc” algorithms whenever possible by showing
snapshots of data at different points in the computation.

What’s So Modern about A Modern Approach?

One of my most important goals has been to take a “modern approach” to C. Here
are some of the ways l've tried to achieve this goal:

Put C in perspective. Instead of treating C as the only programming language
worth knowing, J treat it as one of many useful languages. ! discuss what kind
of applications C is best suited for; T also show how to capitalize on C's
streneths while minimizing its weaknesses.

Emphasize standard versions of C. 1 pay minimal attention to versions of the
language prior to the C89 standard. There are just a few scattered references to
K&R C (the 1978 version of the language described in the first edition of Brian
Kernighan and Dennis Ritchie’s book, The C Programming Language). Appen-
dix C lists the major differences between C89 and K&R C.

Debunk myths. Today's compilers are often at odds with commonly held
assumptions about C. I don*t hesitate to debunk some of the myths about C or
challenge beliefs that have long been part of the C folklore (for example, the
belief that pointer arithmetic is always faster than array subscripting). l’ve re-
examined the old conventions of C, keeping the ones that are still helpful.

Emphasize software engineering. 1 treat C as a mature software engineering
tool, emphasizing how to use it to cope with issues that arise during program-
ming-in-the-large. I stress making programs readable, maintainable, reliable,
and portable, and I put special emphasis on information hiding.

Postpone C”s low-level features. These features, although handy for the kind
of systems programming originally done in C, are not as relevant now that C is
used for a great variety of applications. Instead of introducing them in the early
chapters, as many C books do, I postpone them until Chapter 20.

De-emphasize “manual optimization.” Many books teach the reader to write
tricky code in order to gain small savings in program efficiency. With today"s
abundance of optimizing C compilers, these techniques are often no longer
necessary; in fact, they can result in programs that are less efficient.

O&A Sections

Each chapter ends with a “Q&A section”—a series of questions and answers related
to material covered in the chapter. Topics addressed in these sections include:

***************************page_007***************************
QahÀ

/

cross-references » Praface

idiom

portability tip

Preface XXV

Frequently asked questions. Uve tried to answer questions that come up fre-
quently in my own courses, in other books, and on newsgroups related to C.

Additional discussion and clarification of tricky issues. Although readers
with experience in a variety of languages may be satisfied with a brief expla-
nation and a couple of examples, readers with less experience need more.
Side issues that don’t belong in the main flow. Some questions raise techni-
cal issues that won’t be of interest to all readers.

Material too advanced or too esoteric to interest the average reader. Ques-
tions of this nature are marked with an asterisk (*). Curious readers with a fair
bit of programming experience may wish to delve into these questions imme-
diately; others should definitely skip them on a first reading. Warning: These
questions often refer to topics covered in later chapters.

Common differences among C compilers. | discuss some frequently used (but
nonstandard) features provided by particular compilers.

Some questions in Q&À sections relate directly to specific places in the chap-

ter: these places are marked by a special icon to signal the reader that additional
information 1s available.

Other Features

In addition to Q&A sections, l’ve included a number of useful features, many of
which are marked with simple but distinctive icons (shown at left).

u Warnings alert readers to common pitfalls. C is famous for its traps; docu-
menting them all is a hopeless—if not impossible—task. l've tried to pick out
the pitfalls that are most common and/or most important.

= Cross-references provide a hypertext-like ability to locate information. Al-
though many of these are pointers to topics covered later in the book. some
point to previous topics that the reader may wish to review.

m Idioms—code patterns frequently seen in C programs—are marked for quick
reference.

u Portability tips give hints for wriüng programs that are independent of a par-
ticular machine, compliler, or operating system.

m Sidebars cover topics that aren°t strictly part of C but that every knowledge-
able C programmer should be aware of. (See “Source Code” on the next page
for an example of a sidebar.)

= Appendices provide valuable reference information.

Programs

Choosing illustrative programs isn’t an easy job. If programs are too brief and arti-
ficial, readers won’t get any sense of how the features are used in the real world. On
the other hand, 1f à program 1s foo realistic, its point can easily be lost in a forest of

***************************page_008***************************
XXVI

Preface

details. l’ve chosen a middle course, using small, simple examples to make con-
cepts clear when they're first introduced, then eradually building up to complete
programs. ! haven*t included programs of great length: it's been my experience that
instructors don't have the time to cover them and students don’t have the patience to
read them. ! don’t ignore the issues that arise in the creation of large programs,
though—Chapter 15 (Writing Large Programs) and Chapter 19 (Program Design)
cover them in detail.

l‘ve resisted the urge to rewrite programs to take advantage of the features of
C99, since not every reader may have access to à C99 compiler or wish to use C99.
[ have. however, used C99’s <stdbool .h> header in a few programs, because it
conveniently defines macros named bool, true, and false. If your compiler
doesn*t support the <stdbool .h> header, you'Il need to provide your own defi-
nitions for these names.

The programs in this edition have undergone one very minor change. The
main function now has the form int main (void) { … } in most cases. This
change reflects recommended practice and is compatible with C99, which requires
an explicit return type for each function.

 

 

Source Code

Source code for all programs is available at knking.com/books/c2. Updates, correc-
tions, and news about the book can also be found at this site.

 

 

 

 

Audience

This book is designed as a primary text for a C course at the undergraduate level.
Previous programming experience in a high-level language or assembler 1s helpful
but not necessary for a computer-literate reader (an “adept beginner,” as one of my
former editors put 1t).

Since the book is self-contained and usable for reference as well as learning, 1t
makes an excellent companion text for a course in data structures, compiler design,
operating systems, computer graphics, embedded systems, or other courses that use
C for projeet work. Thanks to its Q&A sections and emphasis on practical prob-
lems, the book will also appeal to readers who are enrolled in a training class or who
are learning C by self-study.

Organization

The book is divided into four parts:

= Basic Features of C. Chapters 1—10 cover enough of C to allow the reader to
write single-file programs using arrays and functions.

n Advanced Features of C. Chapters 11-20 build on the material in the earlier
chapters. The topics become a little harder in these chapters, which provide in-

***************************page_009***************************
Preface =— xXxvii

depth coverage of pointers, strings, the preprocessor, structures, unions, enu-
merations, and low-level features of C. In addition. two chapters (15 and 19)
offer guidance on program design.

= The Standard C Library. Chapters 21—27 focus on the C library, a large col-
lection of functions that come with every compiler. These chapters are most
likely to be used as reference material, although portions are suitable for lec-
tures.

u Reference. Appendix À gives a complete list of C operators. Appendix B de-
scribes the major differences between C99 and C89, and Appendix C covers
the differences between C89 and K&R C. Appendix D is an alphabetical listing
of all functions in the C89 and C99 standard libraries, with a thorough descrip-
tion of each. Appendix E lists the ASCII character set. An annotated bibliogra-
phy points the reader toward other sources of information.

ÀA full-blown course on C should cover Chapters 1—20 in sequence, with topics from
Chapters 21-27 added as needed. (Chapter 22, which includes coverage of file
inpul/output, is the most important chapter of this group.) À shorter course can omit
the following topics without losing continuity: Section 8.3 (variable-length arrays),
Section 9.6 (recursion), Section 12.4 (pointers and multidimensional arrays). Sec-
tion 12.5 (pointers and variable-length arrays), Section 14.5 (miscellaneous direc-
tives), Section 17.7 (pointers to functions), Section 17.8 (restricted pointers),
Section 17.9 (flexible array members), Section 18.6 (inline functions), Chapter 19
(program design), Section 20.2 (bit-fields in structures), and Section 20.3 (other
low-level techniques).

Exercises and Programming Projects

Having a variety of good problems is obviously essential for a textbook. This edi-
tion of the book contains both exercises (shorter problems that don°t require writing
a full program) and programming projects (problems that require writing or modi-
fying an entire program).

À few exercises have nonobvious answers (some individuals uncharitably call
these ‘“trick questions”—the nerve!). Since C programs often contain abundant
examples of such code, | feel it’s necessary to provide some practice. However, [Il
play fair by marking these exercises with an asterisk (*). Be careful with a starred
exercise: either pay close attention and think hard or skip it entirely.

Errors, Lack of (?)

l've taken great pains to ensure the accuracy of this book. Inevitably. however,
any book of this size contains a few errors. If you spot one, please contact me at
cbook@knking.com. l’d also appreciate hearing about which features you found
especially helpful, which ones you could do without, and what you’d like to see
added.

***************************page_010***************************
XXVIII

Preface

Acknowledgments

First, P’d like to thank my editors at Norton, Fred McFarland and Aaron Javsicas.
Fred got the second edition underway and Aaron stepped in with brisk efficiency to
bring it to completion. l’d also like to thank associate managing editor Kim Yi, copy
editor Mary Kelly, production manager Roy Tedoff, and editorial assistant Carly
Fraser.

1 owe a huge debt to the following colleagues, who reviewed some or all of the
manuscript for the second edition:

Markus Bussmann, University of Toronto

Jim Clarke, University of Toronto

Karen Reid, University of Toronto

Peter Seebach, moderator of comp.lang.c.moderated

Jim and Peter deserve special mention for their detailed reviews, which saved me
from a number of embarrassing stips. The reviewers for the first edition, in alpha-
betical order, were: Susan Anderson-Freed, Manuel E. Bermudez, Lisa J. Brown,
Steven C. Cater, Patrick Harrison, Brian Harvey, Henry H. Leitner, Darrell Long.
Arthur B. Maccabe. Carolyn Rosner. and Patrick Terry.

I received many useful comments from readers of the first edition; T thank
everyone who took the time to write. Students and collcagues at Georgia State Uni-
versity also provided valuable feedback. Ed Bullwinkel and his wife Nancy were
kind enough to read much of the manuscript. l’m particularly grateful to my depart-
ment chair, Yi Pan, who was very supportive of the project.

My wife, Susan Cole, was a pitlar of strength as always. Our cats, Dennis,
Pounce, and Tex, were also instrumental in the completion of the book. Pounce and
Tex were happy to contribute the occasional catfight to help keep me awake while
| was working late at night.

Finally, l’d like to acknowledge the late Alan J. Perlis, whose epigrams appear
at the beginning of each chapter. ! had the privilege of studying briefly under Alan
at Yale in the mid-70s. T think he'd be amused at finding his epigrams in a C book.

***************************page_011***************************
BRIEF CONTENTS

 

 

 

 

 

 

 

Basic Features of C The Standard C Library
1 Introducing C 1 21 The Standard Library 529
2 C Fundamentals 9 22 Input/Output 539
3 Formatted Input/Output 37 23 Library Support for Numbers
4 Expressions 53 and Character Data 589
5 Selection Statements 73 24 Error Handling 627
6 Loops 99 25 International Features 641
7 Basic Types 125 26 Miscellaneous Library
8 Arrays 161 Functions 677
9 Functions 183 27  Additional C99 Support for
10 Program Organization 219 Mathematics 705
Advanced Features of C Reference
11 Pointers 241 A C Operators 735
12 Pointers and Arrays 257 B C99 versus CB89 737
13 Strings 211 C  C89 versus K&R C 743
14 The Preprocessor 315 D Standard Library Functions 747
15 Writing Large Programs 349 E ASCII Character Set 801
16 Structures, Unions, and Bibliography 803
Enumerations 377 Index 807
17 Advanced Uses of Pointers 413
18 Declarations 457
19 Program Design 483
20 Low-Level Programming 509

 

 

 

 

 

***************************page_012***************************
CONTENTS

Preface

1.1

1.2

2.1

2.2

2.3
2.4

INTRODUCING C

History of C

Origins

Standardization

C-Based Languages

Strengths and Weaknesses of C
Strengths

Weaknesses

Effective Use of C

C FUNDAMENTALS

Writing a Simple Program

Program: Printing a Pun

Compiling and Linking

Integrated Development Environments
The General Form of a Simple Program
Directives

Functions

Statements

Printing Strings

Comments

Variables and Assignment

Types

Declarations

Assignment

*
ë.

QU S SSDSONDNUA 4 —

10
11
12
12

13
14
14
15
17
17
17
18

vil

***************************page_013***************************
Vili

Contents

2.5

2.6

2.1

2.8

Printing the Value of a Variable

Program: Computing the Dimensional Weight of a Box
Initialization

Printing Expressions

Reading Input

Program: Computing the Dimensional Weight of a Box
(Revisited)

Defining Names for Constants

Program: Converting from Fahrenheit to Celsius
Identifiers

Keywords

Layout of a C Program

FORMATTED INPUT/OUTPUT

3.1

3.2

The print£f Function

Conversion Specifications

Program: Using print£ to Format Numbers
Escape Sequences

The scan£ Function

How scan£ Works

Ordinary Characters in Format Strings
Confusing print£ with scanf

Program: Adding Fractions

EXPRESSIONS

4.1

4.2

4.3
4.4

4.5

Arithmetic Operators

Operator Precedence and Associativity
Program: Computing a UPC Check Digit
Assignment Operators

simple Assignment

Lvalues

Compound Assignment

Increment and Decrement Operators
Expression Evaluation

Order of Subexpression Evaluation
Expression Statements

SELECTION STATEMENTS

5.1

5.2

Logical Expressions
Relational Operators
Equality Operators
Logical Operators

The i£ Statement
Compound Statements

19
20
21
22
22

22
23
24
25
26
27

37

37
38
40
41
42
43
45
45
46

93

54
55
56
58
58
59
60
61
62
64
65

73

74
74
15
15
76
77

***************************page_014***************************
9.3

Contents

The else Clause

Cascaded i£ Statements

Program: Calculating a Broker's Commission
The “Dangling e1se” Problem

Conditional Expressions

Boolean Values in C89

Boolean Values in C99

The switch Statement

The Role of the break Statement

Program: Printing a Date in Legal Form

LOOPS

6.1

6.2

6.3

6.4

6.5

The while Statement

Infinite Loops

Program: Printing a Table of Squares
Program: Summing a Series of Numbers

The do Statement
Program: Calculating the Number of Digits in an Integer

The for Statement

for Statement Idioms

Omitting Expressions in a for Statement
for Statements in C99

The Comma Operator

Program: Printing a Table of Squares (Revisited)
Exiting from a Loop

The break Statement

The continue Statement

The goto Statement

Program: Balancing a Checkbook

The Nuli Statement

BASIC TYPES

71

7.2

7.3

Integer Types

Integer Types in C99

Integer Constants

Integer Constants in C99

Integer Overflow

Reading and Writing Integers

Program: Summing a Series of Numbers (Revisited)
Floating Types

Floating Constants

Reading and Writing Floating-Point Numbers
Character Types

Operations on Characters

Signed and Unsigned Characters

IX

78
80
81
82
83
84
85
86
88
89

99

99
101
102
102

103
104

105
106
107
108
109
110
111
111
112
113
114

116

125

125
128
128
129
130
130
131

132
133
134
134
135
136

***************************page_015***************************
 

X Contents

7.4

7.5

7.6

Arithmetic Types

Escape Sequences

Character-Handling Functions

Reading and Writing Characters using scan£ and printf
Reading and Writing Characters using getchar and
putchar

Program: Determining the Length of a Message
Type Conversion

The Usual Arithmetic Conversions

Conversion During Assignment

Implicit Conversions in C99

Casting

Type Definitions

Advantages of Type Definitions

Type Definitions and Portability

The sizeo£f Operator

8 _ ARRAYS

8.1

8.2

8.3

One-Dimensional Arrays

Array Subscripting

Program: Reversing a Series of Numbers
Array Initialization

Designated Initializers

Program: Checking a Number for Repeated Digits
Using the sizeo£ Operator with Arrays
Program: Computing Interest
Multidimensional Arrays

Initializing a Multidimensional Array
Constant Arrays

Program: Dealing a Hand of Cards

Variable-Lenagth Arrays (C99)

9 - FUNCTIONS

9.1

9.2
9.3

Defining and Calling Functions

Program: Computing Averages

Program: Printing a Countdown

Program: Printing a Pun (Revisited)

Function Definitions

Function Calls

Program: Testing Whether a Number Is Prime
Function Declarations

Arguments

Argument Conversions
Array Arguments
Variable-Length Array Parameters

136
137
138
139

140
141
142
143
145
146
147
149
149
150
151

161

161
162
164
164
165
166
167
168
169
171
172
172

174

183

183
184
185
186
187
189
190
191
193
194
195
198

***************************page_016***************************
10

11

12

9.4
9.5

9.6

Contents

Using static in Array Parameter Declarations
Compound Literals

The return Statement

Program Termination
The exit Function
Recursion

The Quicksort Algorithm
Program: Quicksort

PROGRAM ORGANIZATION
10.1 Local Variables
Static Local Variables
Parameters
10.2 External Variables
Example: Using External Variables to Implement a Stack
Pros and Cons of External Variables
Program: Guessing a Number
10.3 Blocks
10.4 Scope
10.55  Organizing a C Program
Program: Classifying a Poker Hand
POINTERS
11.1 Pointer Variables
Declaring Pointer Variables
11.2 The Address and Indirection Operators
The Address Operator
The Indirection Operator
11.3 Pointer Assignment
11.4 Pointers as Arguments
Program: Finding the Largest and Smallest Elements in an
Array
Using const to Protect Arguments
11.5  Pointers as Return Values
POINTERS AND ARRAYS

121

12.2

Pointer Arithmetic

Adding an Integer to a Pointer
Subtracting an Integer from a Pointer
Subtracting One Pointer from Another
Comparing Pointers

Pointers to Compound Literals

Using Pointers for Array Processing
Combining the * and ++ Operators

xi

200
200

201
202
203
204

205
207

219

219
220
221

221
221
222
224
227
228
229
230

241

241
242
243
243
244
245

247

249
250
251

257

257
258
239
259
260
260
260
262

***************************page_017***************************
 

XIl

Contents

13

14

12.3

12.4

12.5

Using an Array Name as a Pointer

Program: Reversing a Series of Numbers (Revisited)
Array Arguments (Revisited)

Using a Pointer as an Array Name

Pointers and Multidimensional Arrays

Processing the Elements of a Multidimensional Array
Processing the Rows of a Multidimensional Array
Processing the Columns of a Multidimensional Array
Using the Name of a Multidimensional Array as a Pointer
Pointers and Variable-Lenath Arrays (C99)

STRINGS

13.1

13.2

13.3

13.4
13.5

13.6

13.7

String Literals

Escape Sequences in String Literals
Continuing a String Literal

How String Literals Are Stored

Operations on String Literals

String Literals versus Character Constants
String Variables

Initializing a String Variable

Character Arrays versus Character Pointers
Reading and Writing Strings

Writing Strings Using print£ and puts
Reading Strings Using scanf and gets
Reading Strings Character by Character
Accessing the Characters in a String

Using the C String Library

The strcpy (String Copy) Function

The strlen (String Lenath) Function

The strcat (String Concatenation) Function
The stromp (String Comparison) Function
Program: Printing a One-Month Reminder List
String Idioms

Searching for the End of a String

Copying a String

Arrays of Strings

Command-Line Arguments

Program: Ghecking Planet Names

THE PREPROCESSOR

14.1
14.2
14.3

How the Preprocessor Works
Preprocessing Directives

Macro Definitions

Simple Macros
Parameterized Macros

263
264
265
266
267
267
268
269
269
270

2177

277
278
278
279
279
280
281
281
283
284
284
285
286
287

289
290
291
291
292
293
296
296
298
300
302
303

315
315
318
319

319
321

***************************page_018***************************
15

16

14.4

14.5

Contents

The # Operator

The ## Operator

General Properties of Macros
Parentheses in Macro Definitions
Creating Longer Macros

Predefined Macros

Additional Predefined Macros in C99
Empty Macro Arguments

Macros with a Variable Number of Arguments
The _ f£func__ |ldentifier
Conditional Compilation

The #i£f and #endi£ Directives
The defined Operator

The #ifde£ and #i£nde£ Directives
The #eli£f and #e1se Directives
Uses of Conditional Compilation
Miscellaneous Directives

The #error Directive

The #1ine Directive

The #pragma Directive

The Pragma Operator

WRITING LARGE PROGRAMS

15.1
15.2

15.3

15.4

Source Files

Header Files

The #include Directive

Sharing Macro Definitions and Type Definitions
Sharing Function Prototypes
Sharing Variable Declarations
Nested Includes

Protecting Header Files

#error Directives in Header Files
Dividing a Program into Files
Program: Text Formatting

Building a Multiple-File Program
Makefiles

Errors During Linking

Rebuilding a Program

Defining Macros Outside a Program

STRUCTURES, UNIONS, AND ENUMERATIONS

16.1

Structure Variables
Declaring Structure Variables
Initializing Structure Variables
Designated Initializers
Operations on Structures

xiii

324
324
325
326
328
329
330
331
332
333

333
334
335
335
336
337
338
338
339
340
341

349
349

350
351
353
354
355
357
357
358
359
359
366
366
368
369
371

377

377
378
379
380
381

***************************page_019***************************
xiv

Contents

17

16.2

16.3

16.4

16.5

Structure Types

Declaring a Structure Tag

Defining a Structure Type

Structures as Arguments and Return Values
Compound Literals

Nested Arrays and Structures

Nested Structures

Arrays of Structures

Initializing an Array of Structures

Program: Maintaining a Parts Database
Unions

Using Unions to Save Space

Using Unions to Build Mixed Data Structures
Adding a “Tag Field” to a Union
Enumerations

Enumeration Tags and Type Names
Enumerations as Integers

Using Enumerations to Declare “Tag Fields"

ADVANCED USES OF POINTERS

174

17.2

17.3

17.4

17.5

17.6

Dynamic Storage Allocation

Memory Allocation Functions

Null Pointers

Dynamically Allocated Strings

Using malloc to Allocate Memory for a String

Using Dynamic Storage Allocation in String Functions
Arrays of Dynamically Allocated Strings

Program: Printing a One-Month Reminder List (Revisited)

Dynamically Allocated Arrays

Using malloc to Allocate Storage for an Array
The calloc Function

The realloc Function

Deallocating Storage

The £ree Function

The “Dangling Pointer” Problem

Linked Lists

Declaring a Node Type

Creating a Node

The -> Operator

Inserting a Node at the Beginning of a Linked List
Searching a Linked List

Deleting a Node from a Linked List

Ordered Lists

Program: Maintaining a Parts Database (Revisited)

Pointers to Pointers

382
383
384
384
386
386
387
387
388
389

396
398
399
400
401
402
403
404

413

414
414
414
416
416
417
418
418

420
420
421
421
422
423
424
424
425
425
426
427
429
431
433
433

438

***************************page_020***************************
18

19

17.7

17.8
17.9

Contents

Pointers to Functions

Function Pointers as Arguments

The gsort Function

Other Uses of Function Pointers

Program: Tabulating the Trigonometric Functions
Restricted Pointers (C99)

Filexible Array Members (C99)

DECLARATIONS

18.1
18.2

18.3
18.4

18.5

18.6

Declaration Syntax

Storage Classes

Properties of Variables

The auto Storage Class

The static Storage Class

The extern Storage Class

The register Storage Class
The Storage Class of a Function
Summary

Type Qualifiers

Declarators

Deciphering Complex Declarations

Using Type Definitions to Simplify Declarations
Initializers

Uninitialized Variables

Inline Functions (C99)

Inline Definitions

Restrictions on Inline Functions

Using Inline Functions with GCC

PROGRAM DESIGN

19.1

19.2

19.3

19.4

Modules

Cohesion and Coupling

Types of Modules

Information Hiding

A Stack Module

Abstract Data Types

Encapsulation

Incomplete Types

A Stack Abstract Data Type

Defining the Interface for the Stack ADT
Implementing the Stack ADT Using a Fixed-Length Array
Changing the Item Type in the Stack ADT
Implementing the Stack ADT Using a Dynamic Array
Implementing the Stack ADT Using a Linked List

XV

439
439
440
442
443
445

447

457
457

459
459
460
461
462
463
464
465
466

467
468
470
470
472
472
473
474
475

483

484
486
486
487
487
491
492
492
493
493
495
496
497
499

***************************page_021***************************
 

XVi

Contents

20

21

22

19.5

Design Issues for Abstract Data Types
Naming Conventions

Error Handling

Generic ADTs

ADTs in Newer Languages

LOW-LEVEL PROGRAMMING

20.1

20.2

20.3

Bitwise Operators

Bitwise Shift Operators

Bitwise Complement, And, Exclusive Or, and Inclusive Or
Using the Bitwise Operators to Access Bits
Using the Bitwise Operators to Access Bit-Fields
Program: XOR Encryption

Bit-Fields in Structures

How Bit-Fields Are Stored

Other Low-Level Techniques

Defining Machine-Dependent Types

Using Unions to Provide Multiple Views of Data
Using Pointers as Addresses

Program: Viewing Memory Locations

The volatile Type Qualifier

THE STANDARD LIBRARY

211

21.2
21.3
21.4
21.5

Using the Library

Restrictions on Names Used in the Library
Functions Hidden by Macros

C89 Library Overview
C99 Library Changes
The <stddef .h> Header: Common Definitions

The <stdboo1 .h> Header (C99): Boolean Type and
Values

INPUT/OUTPUT

22.1

22.2

Streams

File Pointers

Standard Streams and Redirection

Text Files versus Binary Files

File Operations

Opening a File

Modes

Closing a File

Attaching a File to an Open Stream

Obtaining File Names from the Command Line
Program: Checking Whether a File Can Be Opened

502
502
502
503
503

509

509
510
Si1l
5i2
513
514
516
517
518
518
519
520
521
523

529

529
530
531
531
534

535

536

539

540
540
540
541
543
543
544
545
546
546
547

***************************page_022***************************
23

22.3

22.4

22.5

22.6
22.7

22.8

Contents

Temporary Files

File Buffering

Miscellaneous File Operations

Formatted I/O

The …print£ Functions

.print£ Conversion Specifications

C99 Changes to …print£ Conversion Specifications
Examples of .print£ Conversion Specifications
The .…scan£f Functions

…scanf Format Strings

.…scanf Conversion Specifications

C99 Changes to …scan£ Conversion Specifications
scanf Examples

Detecting End-of-File and Error Conditions
Character I/O

Output Functions

Input Functions

Program: Copying a File

Line [/O

Output Functions

Input Functions

Block |/O

File Positioning

Program: Modifying a File of Part Records
String I/O

Output Functions
Input Functions

LIBRARY SUPPORT FOR NUMBERS AND CHARACTER

DATA
23.1  The <float.h> Header: Characteristics of Floating
Types
23.2 The <limits.h> Header: Sizes of Integer Types
23.3  The <math.h> Header (C89): Mathematics
Errors
Trigonometric Functions
Hyperbolic Functions
Exponential and Logarithmic Functions
Power Functions
Nearest Integer, Absolute Value, and Remainder Functions
23.4 The <math.h> Header (C99): Mathematics

|EEE Floating-Point Standard
Types
Macros

XVvil

548
549
551
551
552
552
555
556
558
559
560
562
563
564
566
566
567
568
569
569
570
571

572
574
575

576
576

589

589
591

593
593
594
595
595
596
596
597
598
599
600

***************************page_023***************************
XVIII

 

Contents

 

24

25

23.5

23.6

Errors

Functions

Classification Macros

Trigonometric Functions

Hyperbolic Functions

Exponential and Logarithmic Functions

Power and Absolute Value Functions

Error and Gamma Functions

Nearest Integer Functions

Remainder Functions

Manipulation Functions

Maximum, Minimum, and Positive Difference Functions
Floating Multiply-Add

Comparison Macros

The <ctype.h> Header: Character Handling
Character-Classification Functions

Program: Testing the Character-Classification Functions
Character Case-Mapping Functions

Program: Testing the Case-Mapping Functions
The <string.h> Header: String Handling
Copying Functions

Concatenation Functions

Comparison Functions

Search Functions

Miscellaneous Functions

ERROR HANDLING

241
242

243

24,4

The <assert.h> Header: Diagnostics
The <errno.h> Header: Errors

The perror and strerror Functions

The <signal .h> Header: Signal Handling

Signal Macros

The signal Function
Predefined Signal Handlers
The raise Function
Program: Testing Signals

The <setjmp.h> Header: Nonlocal Jumps
Program: Testing setjmp/longjmp

INTERNATIONAL FEATURES

25.1

25.2

The <locale.h> Header: Localization
Categories

The setlocale Function

The localeconv Function

Multibyte Characters and Wide Characters

600
601
602
603
603
604
605
606
606
608
608
609
610
611
612
612
613
614
614
615
616
617
617
619
622

627
628
629
630
631
631
632
633
634
634
635
636

641
642
642
643
644
647

***************************page_024***************************
26

25.3

25.4
25.5

25.6

Contents

Multibyte Characters

Wide Characters

Unicode and the Universal Character Set
Encodings of Unicode
Multibyte/Wide-Character Conversion Functions
Multibyte/Wide-String Conversion Functions
Digraphs and Trigraphs

Trigraphs

Digraphs

The <iso646.h> Header: Alternative Spellings
Universal Character Names (C99)

The <wchar .h> Header (C99): Extended Multibyte and

Wide-Character Utilities

Stream Orientation

Formatted Wide-Character Input/Output Functions
Wide-Character Input/Output Functions

General Wide-String Utilities

Wide-Character Time-Conversion Functions
Extended Multibyte/Wide-Character Conversion Utilities
The <wctype .h> Header (C99): Wide-Character
Classification and Mapping Utilities
Wide-Character Classification Functions

Extensible Wide-Character Classification Functions
Wide-Character Case-Mapping Functions

Extensible Wide-Character Case-Mapping Functions

MISCELLANEOUS LIBRARY FUNCTIONS

26.1

26.2

26.3

The <stdarg.h> Header: Variable Arguments
Calling a Function with a Variable Argument List
The v..….print£ Functions

The v.….scan£ Functions

The <stdlib.h> Header: General Utilities
Numeric Conversion Functions

Program: Testing the Numeric Conversion Functions
Pseudo-Random Sequence Generation Functions

Program: Testing the Pseudo-Random Sequence Generation

Functions

Communication with the Environment
Searching and Sorting Utilities

Program: Determining Air Mileage
Integer Arithmetic Functions

The <time.h> Header: Date and Time
Time Manipulation Functions

Time Conversion Functions

Program: Displaying the Date and Time

xix

648
649
649
650
651
653
654
654
655
656
656

657
658
659
661
662
667
667

671
671
672
673
673

677

677
679
680
681
682
682
684
686

687
687
689
690
691
692
693
695
698

***************************page_025***************************
XX Contents

27  ADDITIONAL C99 SUPPORT FOR MATHEMATICS 705
271  The <stdint .h> Header (C99): Integer Types 705
<stdint .h> Types 706
Limits of Specified-Width Integer Types 707
Limits of Other Integer Types 708
Macros for Integer Constants 708
27.2  The <inttypes.h> Header (C99): Format Conversion of
Integer Types 709
Macros for Format Specifiers 710
Functions for Greatest-Width Integer Types 711
27.3 Complex Numbers (C99) 712
Definition of Complex Numbers 713
Complex Arithmetic 714
Complex Types in C99 714
Operations on Complex Numbers 715
Conversion Rules for Complex Types 715
27.4  The <complex.h> Header (C99): Complex Arithmetic 717
<complex.h> Macros 717
The CX _LIMITED RANGE Pragma 718
<complex.h> Functions 718
Trigonometric Functions 719
Hyperbolic Functions 720
Exponential and Logarithmic Functions 721
Power and Absolute-Value Functions 721
Manipulation Functions 722
Program: Finding the Roots of a Quadratic Equation 722
27.5  The <tgmath.h> Header (C99): Type-Generic Math 723
Type-Generic Macros 724
Invoking a Type-Generic Macro 725
21.6  The <fenv.h> Header (C99): Floating-Point Environment 726
Floating-Point Status Flags and Control Modes 727
<fenv.h> Macros 727
The FENV_ACCESS Pragma 728
Floating-Point Exception Functions 729
Rounding Functions 730
Environment Functions 730
Appendix À C Operators 735
Appendix B C99 versus C89 737
Appendix C _ C89 versus K&R C 743
Appendix D _ Standard Library Functions 747
Appendix E ASCII Character Set 801
Bibliography 803

Index 807

***************************page_026***************************
4

1.1

Introducing C

When someone says "| want a programming language in which
| need only say what | wish done," give him a lollipop.*

What is C? The simple answer—a widely used programming language developed
in the early 1970s at Bell Laboratories—conveys little of C*s special flavor. Before
we become immersed in the details of the language, let's take a look at where C
came from, what it was designed for, and how it has changed over the years (Sec-
tion 1.1). We'Il also discuss Cs strengths and weaknesses and see how to get the
most out of the language (Section 1.2).

History of C

Let's take a quick look at C’s history, from its origins, to its coming of age as a
standardized language, to its influence on recent languages.

Origins

C is a by-product of the UNIX operating system, which was developed at Bell Lab-
oratories by Ken Thompson, Dennis Ritchie, and others. Thompson single-hand-
edly wrote the original version of UNIX, which ran on the DEC PDP-7 computer,
an early minicomputer with only 8K words of main memory (this was 1969. after
all!). ,
Like other operating systems of the time, UNIX was written in assembly lan-
guage. Programs written in assembly language are usually painful to debug and
hard to enhance; UNIX was no exception. Thompson decided that a higher-level

 

“The epigrams at the beginning of each chapter arc from “Epigrams on Programmine” by Alan J. Perlis
(ACM SIGPLAN Notices (September, 1982): 7-13),

***************************page_027***************************
2

Chapter 1

introducing C

language was needed for the further development of UNIX. so he designed a small
language named B. Thompson based B on BCPL, a systems programming lan-
guage developed in the mid-1960s. BCPL, in turn, traces its ancestry to Algol 60,
one of the carliest (and most influential) programming languages.

Ritchie soon joined the UNIX project and began programming in B. In 1970.
Bell Labs acquired « PDP-1 1 for the UNIX project. Once B was up and running on
the PDP-11, Thompson rewrote a portion of UNIX in B. By 1971, it became
apparent that B was not well-suited to the PDP-11, so Ritchie began to develop an
extended version of B. He called his language NB (“New B”) at first, and then, as
it began to diverge more from B, he changed the name to C. The language was sta-
ble enough by 1973 that UNIX could be rewritten in C. The switch to C provided
an important benefit: portability. By writine C compilers for other computers at
Bell Labs, the team could get UNIX running on those machines as well.

Standardization

C continued to evolve during the 1970s, especially between 1977 and 1979. It was
during this period that the first book on C appeared. The C Programming Lan-
guage. written by Brian Kernighan and Dennis Ritchie and published in 1978.
quickly became the bible of C programmers. In the absence of an official standard
for C, this book—known as K&R or the “White Book” to aficionados—served as a
de facto standard.

During the 1970s, there were relatively few C programmers, and most of them
were UNIX users, By the 1980s, however, C had expanded beyond the narrow con-
fines of the UNIX world. C compilers became available on a variety of machines
running under different operating systems. In particular, C began to establish itself
on the fast-growing IBM PC platform.

With C's increasing popularity came problems. Programmers who wrote new
C compilers relied on K&R as a reference. Unfortunately, K&R was fuzzy about
some language features, so compilers often treated these features differently. Also,
K&R failed to make a clear distinction between which features belonged to C and
which were part of UNIX. To make matters worse, C continued to change after
K&R was published, with new features being added and a few older features
removed. The need for a thorough, precise, and up-to-date description of the lan-
guage soon became apparent. Without such a standard, numerous dialects would
have arisen, threatening the portability of C programs, one of the language’s major
strengths.

The development of a U.S. standard for C began in 1983 under the auspices of
the American National Standards Institute (ANSI). After many revisions, the stan-
dard was completed in 1988 and formally approved in December 1989 as ANSI
standard X3.159-1989. In 1990, it was approved by the International Organization
for Standardization (ISO) as international standard ISO/IEC 9899:1990. This ver-
sion of the language 1s usually referred to as C89 or C90, to distinguish it from the

***************************page_028***************************
1.1  Historyof C 3

original version of C, often called K&R C. Appendix C summarizes the major dif-
ferences between C89 and K&R C.

The language underwent a few changes in 1995 (described in a document
known as Amendment !). More significant changes occurred with the publication
of a new standard, ISO/TEC 9899:1999, in 1999. The language described in this
standard is commonly known as C99. The terms “ANST C” “ANSI/ISO C} and
“TSO C”—once used to describe C89—are now ambiguous, thanks to the existence
of two standards.

Because C99 isn’t yet universal, and because of the need to maintain millions
(if not billions) of lines of code written in older versions of C. l’Il use à special icon
(shown in the left margin) to mark discussions of features that were added in C99.
À compiler that doesn't recognize these features isn’t “C99-compliant.” If history
is any guide, it will be some years before all C compilers are C99-compliant, if they
ever are. Appendix B lists the major differences between C99 and C89.

C-Based Languages

C has had a huge influence on modern-day programming languages, many of
which borrow heavily from it. Of the many C-based languages, several are espe-
cially prominent:

wm C++ includes all the features of C, but adds classes and other features to sup-
port object-oriented programming.

u Java is based on C++ and therefore inherits many C features.
u C# is a more recent language derived from C++ and Java.

u Perl was originally a fairly simple scripting language; over time it has grown
and adopted many of the features of C.

Considering the popularity of thesc newer languages, it’s logical to ask
whether it’s worth the trouble to learn C. ! think it is, for several reasons. First,
learning C can give you greater insight into the features of C++, Java, C#, Perl, and
the other C-based languages. Programmers who learn one of these languages first
often fail to master basic features that were inherited from C. Second, there are a
lot of older C programs around; you may find yourself needing to read and main-
tain this code. Third, C is still widely used for developing new software, especially
in situations where memory or processing power is limited or where the simplicity
of C is desired. |

LF you haven’t already used one of the newer C-based languages, you'Il find
that this book is excellent preparation for learning these languages. It emphasizes
data abstraction, information hiding, and other principles that play a large role in
object-oriented programming. C++ includes all the features of C, so you’Il be able
to use everything you learn from this book if you later tackle C++. Many of the
features of C can be found in the other C-based languages as well.

***************************page_029***************************
 

 

 

Chapter 1 Introducing C

1.2 Strengths and Weaknesses of C

Like any other programming language, C has strengths and weaknesses. Both stem
from the language’s original use (writing operating systems and other systems
software) and its underlying philosophy:

= C is a low-level language. To serve as a suitable language for systems pro-
gramming, C provides access to machine-level concepts (bytes and addresses,
for example) that other programming languages try Lo hide. C also provides
operations that éorrespond closely to a computer’s built-in instructions, so that
programs can be fast. Since application programs rely on it for input/output. ‘
storage management, and numerous other services, an operating system can't
afford to be slow.

n C is a small language. C provides a more limited set of features than many
languages. (The reference manual in the second edition of K&R covers the
entire language in 49 pages.) To keep the number of features small, C relies
heavily on a “Hbrary” of standard functions. (A “function” is similar to what
other programming languages might call a “procedure.” “subroutine.” or
“method.”)

= C is a permissive language. C assumes that you know what you're doing, so it
allows you a wider degree of latitude than many languages. Moreover, C
doesn’t mandate the detailed error-checking found in other languages.

Strengths
C*s strengths help explain why the language has become so popular:

= Efficiency. Efficiency has been one of C’s advantages from the beginning.
Because C was intended for applications where assembly language had tradi-
tionally been used, it was crucial that C programs could run quickly and in
limited amounts of memory.

= Portability. Although program portability wasn't a primary goal of Ç, it has
turned out to be one of the language’s strengths. When a program must run on
computers ranging from PCs to supercomputers, it is often written in C. One
reason for the portability of C programs is that—thanks to C’s early associa-
tion with UNIX and the later ANSI/ISO standards—the language hasn°t splin-
tered into incompatible dialects. Another is that C compilers are small and
easily written. which has helped make them widely available. Finally, C itself
has features that support portability (although there’s nothing Lo prevent pro-
grammers from writing nonportable programs).

= Power. C*s large collection of data types and operators help make it a power-
ful language. In C, it’s often possible to accomplish quite a bit with just a l'ew
lines of code.

***************************page_030***************************
1.2  Strengths and Weaknesses of C 5

# Flexibility. Although C was originally designed for systems programming, it
has no inherent restrictions that limit it to this arena. C is now used for appli-
cations of all kinds, from embedded systems to commercial data processine.
Moreover, C imposes very few restrictions on the use of its features; opera-
tions that would be 1illegal in other languages are often permitted in C. For
example, C allows a character to be added to an integer value (or. for that mat-
ter, a floating-point number). This flexibility can make programming easier.
although it may allow some bugs to slip through.

m Standard library. One of C’s great strengths is its standard library, which con-
tains hundreds of functions for input/output, string handling, storage alloca-
tion, and other useful operations.

# Integration with UNIX. C 1s particularly powerful in combination with UNIX
(including the popular variant known as Linux). In fact, some UNIX tools
assume that the user knows C.

Weaknesses

C’s weaknesses arise from the same source as many of its streneths: C’s closeness
to the machine. Here are a few of C’s most notorious problems:

e C programs can be error-prone. C’s flexibility makes it an error-prone lan-
guage. Programming mistakes that would be caught in many other languages
can’t be detected by a C compiler. In this respect, C 1s a lot like assembly lan-
guage, where most errors aren't detected until the program 1s run. To make
matters worse, C contains a number of pitfalls for the unwary. In later chap-
ters, we'Il see how an extra semicolon can create an infinite loop or a missing
& symbol can cause a program crash.

w C programs can be difficult to understand. Although C is a small language
by most measures. it has a number of features that aren‘t found in all program-
ming languages (and that consequently are often misunderstood). These fea-
tures can be combined in a great variety of ways, many of which—although
obvious to the original author of a program—can be hard for others to under-
stand. Another problem 1s the terse nature of C programs. C was designed at a
time when interactive communication with computers was tedious at best. As
a result, C was purposefully kept terse to minimize the time required to enter
and edit programs. C’s flexibility can also be a negative factor; programmers
who are too clever for their own good can make programs almost impossible
to understand.

# C programs can be difficult to modify. Large programs written in C can be
hard to change 1f they haven’t been designed with maintenance in mind. Mod-
ern programming languages usually provide features such as classes and pack-
ages that support the division of a large program into more manageable pieces.
C, unfortunately, lacks such features.

***************************page_031***************************
 

6

Chapter 1 Introducing C

e 1411

 

 

Obfuscated C

Even C's most ardent admirers admit that C code can be hard to read. The annual
International Obfuscated C Code Contest actually encourages contestants to write
the most confusing C programs possible. The winners are truly baffling, as 1990's
“Best Small Program” shows:

vliljlklllsla[99];
main ()

{

for (scan£ ("%d", &s) ; *a-s; v=a [j*=v] -a [i] ,k=i<s,j+= (v=j<s&&
(!1K&&!!print£ (2+"\n\nsc"-(!1<<!j)," #0" [1°v?(1°j)&1:2] ) &&
++1||a[i])<s&&v&&v-i+j&&v+i-j))&&! (1%=s),v|| (i==j?a [i+=k]=0:
++a [i] )>=s*k&&++a [--a])

}

This program, written by Doron Osovlanski and Baruch Nissenbaum, prints all solu-
tions to the Eight Queens problem (the problem of placing eight queens on a
chessboard in such a way that no queen attacks any other queen). In fact, it works
for any number of queens between four and 99. For more winning programs, visit
www.ioccc.org, the contest's web site.

;

 

 

 

Effective Use of C

Using C effectively requires taking advantage of C’s strengths while avoiding its
weaknesses. Here are a few suggestions:

u Learn how to avoid C pitfalls, Hints for avoiding pitfalls are scattered through-
out this book—just look for the /A symbol. For a more extensive list of pitfalls,
see Andrew Koenig's C Traps and Pitfalls (Reading, Mass.: Addison-Wesley.
1989). Modern compilers will detect common pitfalls and issue warnings. but
no compiler spots them all.

= Use software tools to make programs more reliable. C programmers are pro-
lific tool builders (and users). One of the most famous C tools is named lint.
lint, which is traditionally provided with UNIX, can subject a program to a
more extensive error analysis than most C compilers. If lint (or a similar
program) is available, it’s a good idea to use 1t.\Another useful tool is a debug-
gcr. Because of the nature of C, many bugs can’t be detected by a C compiler:;
these show up instead in the form of run-time errors or incorrect output. Con-
sequently, using a good debugger is practically mandatory for C programmers.

# Take advantage of existing code libraries. One of the benetits of using C 1s
that so many other people also use it; il’s a good bet that they've written code
you can employ in your own programs. C code is often bundled into libraries
(collections of functions); obtaining a suitable library 1s a good way to reduce
errors—and save considerable programming effort. Libraries for common

***************************page_032***************************
> &

Q & À 7

tasks, including user-interface development, graphics, communications. data-
base management, and networking, are readily available. Some libraries are in
the public domain, some are open source, and some are sold commercially.

 

—Thc programming examples in this book follow one set of

conventions, but there are other, equally valid, conventions in use. (We*Il dis-
cuss some of the alternatives from time to time.) Which set you use 1s less
important than adopting some conventions and sticking to them.

 

In this book,
l'I1 illustrate a style that’s reasonably concise but still understandable.

u Sfick to the standard. Most C compilers provide language features and library
functions that aren’t part of the C89 or C99 standards. For portability. il's best
to avoid using nonstandard features and libraries unless they’re absolutely
necessary.

Q & À

What is this Q& À section anyway?

Glad you asked. The Q&AÀ section. which appears at the end of each chapter,
serves several purposes.

The primary purpose of Q&A 1s to tackle questions that are frequently asked
by students learning C. Readers can participate in a dialogue (more or less) with
the author, much the same as 1f they were attending one of my C classes.

Another purpose of Q&A 1s to provide additional information about topics
covered in the chapter. Readers of this book will likely have widely varying back-
grounds. Some will be experienced in other programming languages, whercas oth-
ers will be lcarning to program for the first time. Rcaders with experience in a
variety of languages may be satisfied with a brief explanation and a couple of
examples, but readers with less experience may need more. The bottom line: LF you
find the coverage of a topic to be sketchy, check Q&A for more details.

On occasion, Q&AÀ will discuss common differences among C compilers. For
example, we'll cover some frequently used (but nonstandard) features that are pro-
vided by particular compilers.

***************************page_033***************************
Chapter 1 Introducing C

Q:
À:

 

Where did 1int get its name?

Unlike the names of many other UNIX Lools, 1lint isn’t an acronym: it got its
name from the way it picks up pieces of “fluff” from a program.

>.

 

Z

Is there some way to force a compiler to do a more thorough job of error-
checking, without having to use lint?

A: Yes. Most compilers will do a more thorough check of à program if asked to. In
addition to checking for errors (undisputed violations of the rules of C), most com-
pilers also produce warning messages, Indicating potential trouble spots. Some
compilers have more than one ‘’‘warning level”; selecting a higher level causes the
compiler to check for more problems than choosing a lower level. If your compiler
supports warning levels, it’s a good idca to select the highest level, causing the
compiler to perform the most thorough job of checking that it’s capable of. Error-

acc»a1 checking options for the GCC compiler, which is distributed with Linux, are dis-
cussed in the Q&A section at the end of Chapter 2.

*Q:  Pm interested in making my program as reliable as possible. Are there any
other tools available besides 1int and debuggers?

A: Yes. Other common tools include ‘‘bounds-checkers” and “leak-finders.” C doesn’t
require that array subscripts be checked; a bounds-checker adds this capability. À
leak-finder helps locate ‘“memory leaks”: blocks of memory that are dynamically
allocated but never deallocated.

 

*Starred questions cover material too advanced or too esoteric to interest the average reader, and often
rcfer to topics covered in later chapters. Curious readers with a fair bit of programming experience may
wish to delve into these questions immediately; others should definitely skip them on a first reading.

***************************page_034***************************
2

2.1

PROGRAM

C Fundamentals

One man's constant is another man'’s variable.

This chapter introduces several basic concepts, including preprocessing directives,
functions, variables, and statements, that we'Il need in order to write even the sim-
plest programs. Later chapters will cover these topics in much greater detail.

To start off, Section 2.1 presents a small C program and describes how to com-
pile and link it, Section 2.2 then discusses how to generalize the program, and Sec-
tion 2.3 shows how to add explanatory remarks, known as comments. Section 2.4
introduces variables, which store data that may change during the execution of a
program, and Section 2.5 shows how to use the scanf function to read data into
variables. Constants—data that won’1 change during program execution—can be
given names, as Section 2.6 shows. Finally, Section 2.7 explains C’s rules for cre-
ating names (identifiers) and Section 2.8 gives the rules for laying out a program.

Writing a Simple Program

In contrast to programs written in some languages, C programs require little “boil-
erplate”—a complete program can be as short as a few lines.

Printing a Pun

The first program in Kernighan and Ritchie’s classic The C Programmine Lan-
guage is extremely short: it does nothing but write the message hello, world.
Unlike other C authors, L won’t use this program as my first example. | will, how-
ever, uphold another C tradition: the bad pun. Here’s the pun:

To C, or not to C: that 1s the question.

***************************page_035***************************
 

10

Chapter2 C Fundamentals

pun.c

The following program, which we'll name pun.c, displays this message each
time it iS run.

#include <stdio.h>

int main (void)

{

printf("To C, or not to C: that is the question.\n") ;
return 0;
}

Section 2.2 explains the form of this program in some detail. For now, PIl just
make a few brief observations. The line

#include <stdio.h>

is necessary to “include” information about C’s standard 1/O (inpuVoutput) library.
The program's executable code goes inside main. which represents the “main”’
program. The only line inside main is a command to display the desired message.
print£ is a function from the standard I/O library that can produce nicely for-
matted output. The \n code tells print£ to advance to the next line after printing
the message. The line

return 0;

indicates that the program “returns” the value 0 to the operating system when it ter-
minates.

Compiling and Linking

Despite its brevity, getting pun. c lo run is more involved than you might expeck.
First, we need to create a file named pun. c containing the program (any text edi-
tor will do). The name of the file doesn’t matter, but the .c extension is often
required by compilers.

Next, we've got to convert the program to a form that the machine can exe-
cute.

 

 

***************************page_036***************************
QaA

2.1 Writing a Simple Program 11

Fortunately, this process is often automated, so you won't find it too onerous. In
fact, the preprocessor is usually integrated with the compiler, so you probably
won't even notice it at work.

The commands necessary to compile and link vary, depending on the compiler
and operating system. Under UNIX, the C compiler 1s usually named cc. To com-
pile and link the pun. c program, enter the following command in a terminal or
command-line window:

©

% cc pun.c

(The % character 1s the UNIX prompt, not something that you need to enter.) Üi{1k—
ing 1s automatic when using CC: no separate link command ts necessary.

After compiling and linking the program, cc leaves the executable program in
a file named a.out by default. cc has many options; one of them (the -o option)
allows us to choose the name of the file containing the executable program. For
example, if we want the executable version of pun. c Lo be named pun, we would
enter the following command:

oe

CC -O Pull pun.c

 

 

 

 

 

 

***************************page_037***************************
12

Chapter2 C Fundamentals

2.2

QaâÂ

headers > 152

The General Form of a Simple Program

Let’s take a closer look at pun . c and see how we can generalize it a bit. Simple C
programs have the form

directives

int main(void)

{
}

In this template, and in similar templates elsewhere in this book, items printed in
Courier would appear in a C program exactly as shown: items in ifalics repre-
sent text to be supplied by the programmer.

Notice how the braces show where main begins and ends. C uses { and } in
much the same way thai some other languages use words like begin and end.
This illustrates a general point about C: it relies heavily on abbreviations and spe-
cial symbols, one reason that C programs are concise (or—less charitably—cryp-
tic).

Even the simplest C programs rely on three key language features: directives
(editing commands that modify the program prior to compilation), Functions
(named blocks of executable code, of which main 1s an example), and statements
(commands to be performed when the program is run). We'Il take a closer look at
these features now.

staterments

Directives

Before a C program 1s compiled, it is first edited by a preprocessor. Commands

intended for the preprocessor are called directives. Chapters 14 and 15 discuss

directives in detail. For now, we're interested only in the Zinclude directive.
The pun.. c program begins with the line

Hinclude <stdio.h>

This directive states that the information in <stdio.h> 1s to be “included” into
the program before it is compiled. <stdio .h> contains information about C’s
standard 1/O library. C has à number of headers like <stdio .h>: each contains
information about some part of the standard library. The reason we’re including
<stdio.h> 1s that C, unlike some programminge languages, has no built-in
‘“’read” and “write” commands. The ability to perform input and output is provided
instead by functions in the standard library.

Directives always begin with a # character, which distinguishes them from
other items in a C program. By default, directives are one line long: thère’s no
semicolon or other special marker at the end of a directive.

***************************page_038***************************
22  The General Form of a Simple Program 13

Functions

Functions are like “procedures” or ‘’subroutines’” in other programming lan-
suages—they're the building blocks from which programs are constructed. In fact,
a C program is little more than a collection of functions. Functions fall into two
categories: those written by the programmer and those provided as part of the C
implementation. l’It refer to the latter as library functions, since they belong to a
“library” of functions that are supplied with the compiler.

The term “function’” comes from mathematics, where a function is a rule for
computing à value when given one or more arguments:

fix)=x+1
g09» z)= y2 — z"

C uses the term ‘“function’” more loosely. In C, a function is simply a series of
statements that have been grouped together and given a name. Some functions
compute a value; some don’t. À function that computes a value uses the return
statement to specify what value it “returns.” For example, a function that adds ! to
its argument might execute the statement

return x + l;

while a function that computes the difference of the squares of its arguments might
execute the statement

return y * y - z * 2;

Although a C program may consist of many functions, only the main func-
tion is mandatory. main is special: it gets called automatically when the program
is executed. Until Chapter 9, where we'Il learn how to write other functions, main
will be the only function in our programs.

 

The name main is critical; it can*t be begin or start or even MAIN.

If main is a function, does it return a value? Yes: it returns a status code that
is given to the operating system when the program terminates. Let's take another
look at the pun . c program:

#include <stdio.h>

int main (void)

{

printf("To C, or not to C: that is the question.\n") ;
return 0;

}

The word int just before main indicates that the main function returns an inte-
ger value. The word void in parentheses indicates that main has no arguments.

***************************page_039***************************
14

Chapter2 C Fundamentals

return value of main >9,5

QaÂ

QaA

compound statement » 5.2

The statement
return 0;

has two effects: it causes the main function to terminate (thus ending the program)
and it indicates that the main function returns a value of 0. We'I1 have more to say
about main’s return value in a later chapter. For now, we’Il always have main
return the value O, which indicates normal program termination.

If there's no return statement at the end of the main function. the program
will still terminate. However, many compilers will produce a warning message
(because the function was supposed to return an integer but failed to).

Statements /

À statement is a command to be exccuted when the program runs. We*Il explore
statements later in the book. primarily in Chapters 5 and 6. The pun. c program
uses only two kinds of statements. One is the return statement: the other is the

function call. Asking a function to perform its assigned task is known as calling

the function. The pun . c program, for example, calls the printf function to dis-
play a string on the screen:

print£f ("To C, or not to C: that is the question.\n") ;

 

Printing Strings

printf is a powerful function that we*Il examine in Chapter 3. So far. we've only
used print£ to display a string literal—a series of characters enclosed in double
quotation marks. When print£ displays a string literal, it doesn’t show the quo-
tation marks.

  

Writing a new-line character termi-
& current output line; subsequent output goes onto the next line. To illus-
trate this point, consider the effect of replacing the statement

 

printf ("To C, or not to C: that is the question. \n") ;
by two calls of print£:

printf("To C, or not to C: ");
print£f ("that is the question.\n") ;

***************************page_040***************************
2.3

2.3  Comments 15

The first call of print£f writes To C, or not to C: . The second call writes
that is the question. and advances to the next line. The net effect 1s the
same as the orisinal print £—the user can't tell the difference.

The new-line character can appear more than once in a string literal. To dis-
play the message

Brevity is the soul of wit.
--Shakespeare

we could write

print£("Brevity is the soul of wit.\n --Shakespeare\n") ;

Comments

Our pun. c program still lacks something important: documentation. Every pro-
eram should contain identifying information: the program name, the date written,
the authôr, the purpose of the program, and so forth. In C, this information is
placed in comments. The symbol /* marks the beginning of a comment and the
symbol * / marks the end:

/* This is a comment */

Comments may appear almost anywhere in a program, either on separate lines
or on the same lines as other program text. Here's what pun .c might look like
with comments added at the beginning:

/* Name: pun.c * /
/* Purpose: Prints a bad pun. */
/* Author: K. N. King */

#include <stdio.h>

int main(void)

{

printf("To C, or not to C: that is the question.\n") ;
return 0;

}

Comments may extend over more than one line; once it has seen the / * sym-
bol, the compiler reads (and ignores) whatever follows until it encounters the */
symbol. If we like. we can combine a series of short comments into one long com-
ment:

/* Name: pun.c
Purpose: Prints a bad pun.
Author: K. N. King */

À comment like this can be hard to read, though, because it’s not casy to see where

***************************page_041***************************
16

Chapter2 C Fundamentals

æ

the comment ends. Putting * / on a line by itself helps:

/* Name: pun.c
Purpose: Prints a bad pun.
Author: K. N. King

*/
Even better, we can form a “box” around the comment to make it stand out:

/************************‘k*‘k**‘k‘k*********‘k******‘k**********

* Name: pun.c *
* Purpose: Prints a bad pun. *
* Author: K. N. King *

*******‘k******‘k*********‘k*******************‘k*****‘k*******/

Programmers often simplify boxed comments by omitting three of the sides:

/*
* Name: pun.c
* Purpose: Prints a bad pun.
* Author: K. N. King

*/
À short comment can go on the same line with other program code:
int main (void) /* Beginning of main program */

À comment like this 185 sometimes called a “winged comment.”

 

Forgetting to terminate a comment may cause the compiler to ignore part of your
program. Consider the following example:

print£ ("My ") ; /* forgot to close this comment...
print£ ("cat ") ;
print£ ("has ") ; /* so it ends here */

print£ ("fleas") ;

Because we’ve neglected to terminate the first comment, the compiler ignores the
middle two statements, and the example prints My fleas.

 

C99 provides a second kind of comment, which begins with // (two adjacent
slashes):

 

// Name: pun.c
// Purpose: Prints a bad pun.
// Author: K. N. King

***************************page_042***************************
2.4

range of int values > 7.1

QaÂA

2.4  Variables and Assignment 17

The newer comment style has a couple of important advantages. First, because a
comment automatically ends at the end of a line, there’s no chance that an untermi-
nated comment will accidentally consumepart of a program. Second, multiline
comments stand out better, thanks to the // that’s required at the beginning of
each line.

Variables and Assignment

Few programs are as simple as the one in Section 2.1. Most programs need to per-
form a series of calculations before producing output, and thus need a way to store
data temporarily during program execution. In C, as in most programming lan-
ouages, these storage locations are called variables.

Types

Every väriable must have a fype, which specifies what kind of data it will hold. C
has a wide variety of types. For now, we’Il limit ourselves to just two: int and
float. Choosing the proper type is critical, since the type affects how the variable
is stored and what operations can be performed on the variable. The type of a

 

 

Declarations

Variables must be declared—described for the benefit of the compiler—before
they can Le used. To declare a variable, we first specify the rype of the variable,
then its name. (Variable names are chosen by the programmer. subject to the rules
described in Section 2.7.) For example, we might declare variables height and
profit as follows:

int height ;
float profit;

***************************page_043***************************
 

18 Chapter2 C Fundamentals

The first declaration states that height is a variable of type int, meaning that
height can store an integer value. The second declaration says that profit 1s a
variable of type float.

 

Notice that each complete declaration ends with a semicolon.
Our first template for main didn’t include declarations. When main contains
declarations, these must precede statements:

int main (void)

{

declarations
statements

}

blocks =103 Às we'll see in Chapter 9, this Is true of functions in general, as well as blocks
(statements that contain embedded declarations). Às a matter of style. it’s a good
idea to leave a blank line between the declarations and the statements.

æ

 

Assignment

À variable can be given a value by means of assignment. For example, the state-

ments
height = 8B;
length = 12;

width = 10;

assign values to height, length, and width. The numbers 8, 12, and 10 are
said to be constants.

Before à variable can be assigned a value—or used in any other way, for that
matter—it must first be declared. Thus, we could write

int height ;
height = 8;

but not

height = 8; /*** WRONG ***/
int height;

***************************page_044***************************
2.4  Variables and Assignment 19

À constant assigned to a float variable usually contains a decimal point. For
example, if profit isa float variable, we might write

QaÂ

 

   

      

nce a variable has been assigne
value of another variable:

a value, 1t Can be used to help compute (ne

height B;

length-= 12;

width = 10;

volume = height * length * width; /* volume is now 960 */

In C. * represents the multiplication operator, so this statement multiplies the val-
ues stored in height, length. and width, then assigns the result to the vari-
able volume. In general, the right side of an assignment can be a formula (or
expression, in C terminology) involving constants, variables, and operators.

Printing the Value of a Variable

We can use printf to display the current value of a variable. For example, to
write the message

Height : ñ

where / is the current value of the height variable. we'd use the following call of
print£:

 

***************************page_045***************************
20

Chapter2 C Fundamentals

PROGRAM

dweight.c

we’d call print£ as follows:
print£ ("Profit: $%.2f\n", pro£fit) ;

There’s no limit to the number of variables that can be printed by a single call
of print£. To display the values of both the height and length variables, we
could use the following call of print£:

printf ("Height: %d Length: %“d\n", height, length) ;

Computing the Dimensional Weight of a Box

Shipping companies don°t especially like boxes that are large but very light, since
they take up valuable space in a truck or airplane. In fact, companies often charge
extra for such a box, basing the fee on its volume instead of its weight. In the
United States, the usual method is to divide the volume by 166 (the allowable num-
ber of cubic inches per pound). If this number—the box°s “dimensional” or “volu-
metric” weight—exceeds its actual weight, the shipping fee is based on the
dimensional weight. (The 166 divisor is for international shipments; the dimen-
sional weight of a domestic shipment is typically calculated using 194 instead.)

Let's say that you‘ve been hired by a shipping company to write a program
that computes the dimensional weight of a box. Since you're new to C, you decide
lo start off by writing a program that calculates the dimensional weight of a partic-
ular box that’s 12" x 10” x 8”. Division is represented by / in C, so the obvious
way to compute the dimensional weight would be

weight = volume / 166;

where weight and volume are integer variables representing the box’s weight
and volume. Unfortunately. this formula isn’t quite what we need. In C. when one
integer is divided by another. the answer is “truncated”: all digits after the decimal
point are lost. The volume of a 12” x 10” x 8” box will be 960 cubic inches. Divid-
ing by 166 gives the answer 5 instead of 5.783. so we have in effect rounded down
to the next lowest pound; the shipping company expects us to round uwp. One solu-
tion is to add 165 to the volume before dividing by 166:

weight = (volume + 165) / 166;

À volume of 166 would give a weight of 331/166, or 1, while a volume of 167
would yield 332/166, or 2. Calculating the weight in this fashion gives us the fol-
lowing program.

/* Computes the dimensional weight of a 12" x 10" x 8" box */
Hinclude <stdio.h>

int main (void)

{

***************************page_046***************************
variable initialization > 78.5

/

2.4  Variables and Assignment 21

int height, length, width, volume, weight;

height = 8B;
length = 12;
width = 10;

volume = height * length * width;
weight = (volume + 165) / 166;

printf ("Dimensions: %dx%dx%*d\n", length, width, heïight) ;
printf ("Volume (cubic inches): %d\n", volume) ;
printf ("Dimensional weight (pounds): *d\n", weight) ;

return 0;

The output of the program 1s

Dimensions: 12x10x8
Volume (cubic inches): 960
Dimensional weight (pounds): 6

Initialization

 

 

Attempting to access the value of an uninitialized variable (for example, by dis-
playing the variable using print£ or using il in an expression) may yield an
unpredictable result such as 2568, —30891, or some equally strange number. With
some compilers, worse behavior—even a program crash—may occur.

 

We can always give a variable an initial value by using assignment. of course.
But there’s an easier way: put the initial value of the variable in its declaration. For
example, we can declare the height variable and initialize it in one step:

 

***************************page_047***************************
22

Chapter2 C Fundamentals

2.5

& operator » 17.2

PROGRAM

Printing Expressions

print£ isn’t limited to displaying numbers stored in variables; it can display the
value of any numeric expression. Taking advantage of this property can simplify a
program and reduce the number of variables. For instance, the statements

volume = height * length * width;
print£ ("d\n"', volume) ;

could be replaced by
print£ ("4d\n"', height * length * width}) ;

print£'s ability to print expressions illustrates one of C’s general principles:
Wherever a value is needed, any expression of the same type will do.

Reading Input

Because the dweight . c program calculates the dimensional weight of just one
box, it isn’t especially useful. To improve the program, we’1l need to allow the user
to enter the dimensions.

 

Reading a float value requires a slightly different call of scan£:

scanf ("%f£", &X) ; /* reads a float value; stores into x */

£ works only with variables of type £loat, so l’m assuming that x is a float
variable. The "%£" string tells scan£ to look for an input value in Float format
(the number may contain a decimal point, but doesn*t have Lo).

Computing the Dimensional Weight of a Box (Revisited)

Here’s an improved version of the dimensional weight program in which the user

***************************page_048***************************
dweighi2.c

\2.6 Defining Names for Constants 23

/* Computes the dimensional weight of a
box from input provided by the user */

#include <stdio.h>

int main(void)

!

int height, length, width, volume, weight ;

print£ ("Enter height of box: ");
scanf ("$d", &height) ;

print£f ("Enter length of box: ") ;
scanf ("%d", &length) ;

printf ("Enter width of box: ");
scanf ("%*d", &width) ;

volume = height * length * width;
weight = (volume + 165) / 166;

print£ ("Volume (cubic inches): %d\n", volume) ;
printf ("Dimensional weight (pounds) : %d\n", weight) ;

return 0;
J
The output of the program has the following appearance (input entered by the user
is underlined):

Enter height of box:
Enter length of box: 12
Enter width of box: 10

Volume (cubic inches): 960
Dimensional weight (pounds) : 6

8
1

À message that asks the user to enter input (a prompt) normally shouldn’t end with
a new-line character, because we want the user to enter input on the same line as
the prompt itself. When the user presses the Enter key, the cursor automatically
moves to the next line—the program doesn't need to display a new-line character
to terminate the current line.

The dweight2 .c program suffers from one problem: it doesn't work cor-
rectly if the user enters nonnumeric input. Section 3.2 discusses this issue in more
detail.

 

***************************page_049***************************
24

Chapter2 C Fundamentals

parentheses in macros » 14,3

PROGRAM

celsius.c

 

Converting from Fahrenheit to Celsius

The following program prompts the user to enter a Fahrenheit temperature; it then
prints the equivalent Celsius temperature. The output of the program will have the
following appearance (as usual, input entered by the user is underlined):

Enter Fahrenheit temperature: 212
Celsius equivalent: 100.0

The program will allow temperatures that aren’{ integers; that’s why the Celsius
temperature is displayed as 100.0 instead of 100. Let’s look first at the entire
program, then see how it’s put together.

/* Converts a Fahrenheit temperature to Celsius */
#include <stdio.h>

#define FREEZING PT 32.0Ë
#define SCALE FACTOR (5.0f£ / 9.0Ë)

int main (void)
{

float fahrenheit, celsius;

print£ ("Enter Fahrenheit temperature: ");

***************************page_050***************************
2.7 Identifiers 25

scanf ("3f", &fahrenheit) ;
celsius = (fahrenheit - FREEZING PT) #* SCALE FACTOR;
print£f ("Celsius equivalent: %.1f\n", celsius) ;

return 0;

The £latement
celsius = (fahrenheit - FREEZING PT) * SCALE FACTOR;

converts the Fahrenheit temperature to Celsius. Since FREEZING_PT stands for
32.0£ and SCALE FACTOR stands for (5.0£ / 9.0£).the compiler sees this
statement as

celsius = (fahrenheit - 32.0f) * (5.0£ / 9.0OË£);

 

The call of print£ writes the Celsius temperature:

 

2.7 |dentifiers

æ

universal character names » 25.4

 

The following are not legal identifiers:

l0times get-next-char

The symbol 10times begins with a digit, not a letter or underscore. get -next -
char contains minus signs, not underscores.

-t distinguishes between upper-case and lower-case letters

in identifiers. For example, the following identifiers are all different:

job joB j0b jOB Job JoB JOb JOB

***************************page_051***************************
 

26

Chapter2 C Fundamentals

Qaâ

æ

Table 2.1
Keywords

These cight identifiers could all be used simultancously, each for a completely dif-
ferent purpose. (Talk about obfuscation!) Sensible programmers try to make identi-
fiers look different unless they're somehow related.

Since case matters in C, many programmers follow the convention of using
only lower-case letters in identifiers (other than macros), with underscores inseried
when necessary for legibility:

symbol table current page name _and address

Other programmers avoid underscores, instead using an upper-case letter to begin
each word within an identifier:

symbolTable  currentPage nameAndAddress

(The first letter is sometimes capitalized as well.) Although the former style 1s
common in traditional C, the latter style is becoming more popular thanks to its
widespread use in Java and C# (and. to a lesser extent, C++). Other reasonable
conventions exist; just be sure to capitalize an identifier the same way each time it
appears in a program. .

C places no limit on the maximum length of an identifier, so don’t be afraid to
use long, descriptive names. À name such as current page is a lot easier to
understand than a name like cp.

 

Because of C’s case-sensitivity, keywords must appear in programs exactly as
shown in Table 2.1, with all letters in lower case. Names of functions in the stan-
dard library (such as printf) contain only lower-case letters also. Avoid the
plight of the unfortunate programmer who enters an entire program in upper case,
only to find that the compiler can’t recognize keywords and calls of library func-
tIions.

***************************page_052***************************
2.8 Layout ofa C Program 27

 

AN

restrictions on identifiers > 27.17

 

 

 

Compressing programs in this fashion isn’t a good idea. In fact, adding spaces
and blank lines to a program can make it easier to read and understand. Fortunately,

***************************page_053***************************
 

28

Chapter2 C Fundamentais

C allows us to insert any amount of space—blanks, tabs, and new-line characters—
between tokens. This rule has several important consequences for program layout:

CEIN

u Statements can be divided over any number of lines. The following statement,

for example, is so long that it would be hard to squeeze it onto a single line:

printf ("Dimensional weight (pounds): %d\n",
(volume + INCHES PER POUND - 1) / INCHES PER POUND) ;

m Space between tokens makes it easier for the eye to separate them. For this

reason, l usually put a space before and after each operator:
volume = height * length * width;

] also put a space after each comma. Some programmers go even further, put-
ting spaces around parentheses and other punctuation.

u /ndentation can make nesting easier to spot. For example, we should indent

declarations and statements to make it clear that they’re nested inside main.

w Blank lines can divide a program into logical units, making it easier for the

reader to discern the program's structure. À program with no blank lines 1s as
hard to read as a book with no chapters.

The celsius.c program of Section 2.6 illustrates several of these guide-

lines. Let’s take a closer look at the main function in that program:

int main (void)

(

}

float fahrenheit, celsius;

printf ("Enter Fahrenheit temperature: ") ;
scanf ("%$f", &fahrenheit) ;

celsius = (fahrenheit - FREEZING PT) * SCALE FACTOR;
printf("Celsius equivalent: %.1£\n", celsius) ;

return 0;

First, observe how the space around =. -, and * makes these operators stand out.
Second, notice how the indentation of declarations and statements makes it obvi-
ous that they all belong to main. Finally, note how blank lines divide main into
five parts: (1) declaring the £ahrenheit and celsius variables; (2) obtaining
the Fahrenheit temperature; (3) calculating the value of celsius; (4) printing the
Celsius temperature; and (5) returning to the operating system.

While we>re on the subject of program layout, notice how l've placed the {

token underneath main () and put the matching } on a separate line, aligned with
{. Putting } on a separate line lets us insert or delete statements at the end of the
function; aligning it with { makes it easy to spot the end of main.

ÀA final note: Although extra spaces can be added berween tokens, it's not pos-

***************************page_054***************************
continuing a string > 73,7

Q & À 29

sible to add space wirhin a token without changing the meaning of the program or
causing an error. Writing
fl oat fahrenheit, celsius; /*** WRONG **+/

OT

£l
oat fahrenheit, celsius; /*** WRONG ***/

produces an error when the program is compiled. Putting a spacc inside a string lit-
eral is allowed, although it changes the meaning of the st1mÜ

 

 

Continuing a string from one line to the next requires a special technique that we'll
learn in a later chapter.

Q & À

***************************page_055***************************
30 Chapter2 C Fundamentals

Q:
A:

Q: Why is C so terse? It seems as though programs would be more readable if C
used begin and end instead of { and }, integer instead of int, and so
forth. [p. 12]

A:  Legend has it that the brevity of C programs 1s due to the environment that existed
in Bell Labs at the time the language was developed. The first C compiler ran on a
DEC PDP-11 (an early minicomputer); programmers used a teletype—essentially
a typewriter connected to a computer—to enter programs and print listings.
Because teletypes were very slow (they could print only 10 characters per second).
minimizing the number of characters in a program was clearly advantageous.

Q:
À:

 

A

***************************page_056***************************
Q & ÀA 31

 

Q: How can I tell if my program has an unterminated comment?
À

If you’re lucky, the program won’t compile because the comment has rendered the
program 1llegal. If the program does compile, there are several techniques that you
can use. Stepping through the program line by line with a debugger will reveal if
any lines are being skipped. Some IDESs display comments in a distinctive color to
distinguish them from surrounding code. If you’re using such an environment, you
can easily spot unterminated comments, since program text will have a different

lint>12  COlor if it’s accidentally included in a comment. À program such as lint can also
help.

Q:
À:

 

***************************page_057***************************
32

Chapter2 C Fundamentals

disabling code » /4.4

Q:
À:

external linkage > /8.2

æ

In any event, there’s a better way to disable portions of a program, as we’ll see
later.

Where does the £loat type get its name? [p. 17]

float 1s short for “floating-point.” a technique for storing numbers in which the
decimal point “floats.”” À float value 1s usually stored in two parts: the fraction
(or mantissa) and the exponent. The number 12.0 might be stored as 1.5 x 2°, for
example, where 1.5 1s the fraction and 3 1s the exponent. Some programming lan-
guages call this type real instead of float.

 

How many spaces should I use for indentation? [p. 28]

That’s a tough question. Leave too little space, and the eye has trouble detecting
indentation. Leave too much, and lines run off the screen (or page). Many C pro-
grammers indent nested statements eight spaces (one tab stop), which 1s probably
too much. Studies have shown that the optimum amount of indentation 1s three
spaces, but many programmers feel uncomfortable with numbers that aren°t a
power of two. Although ! normally préfer to indent three or four spaces, l’Il use
two spaces in this book so that my programs will fit within the margins.

***************************page_058***************************
Section 2.1

Section 2.2

Section 2.4

Section 2.7

©

©

©

@

Exercises 33

Exercises

Create and run Kernighan and Ritchie's famous “hello, world” program:

ffinclude <stdio.h>

int main(void)

{
}

Do you get a warning message from the compiler? If so, what's needed to make it go away?

print£ ("hello, world\n") ;

Consider the following program:
finclude <stdio.h>

int main(void)

{

print£f ("Parkinson's Law:\nWork expands so as to ");
printf ("fill the time\n") ;

print£ ("available for its completion.\n") ;

return 0;

}

(a) Identify the directives and statements in this program.
(b) What output does the program produce”

Condense the dweight.c program by (1) replacing the assignments to height.
length. and width with initializers and (2) removing the weight variable, instead cal-
culating (volume + 165) / 166 within the last print£.

Write a program that declares several int and float variables —without initializing
them—and then prints their values, [s therc any pattern to the values? (Usually there isn°t.)

Which of the following are not legal C identifiers?

(a) 100 bottles

(b) _100 bottles

(c) one__hundred __bottles
(d) bottles by the hundred_

Why 1s it not a good idea for an identifier to contain more than one adjacent underscore (as
in current balance. for example)?

Which of the following are keywords in C?
(a) for

(b) If

(c) main

(d) print£

(e) while

 

@) Answer available on the Web at knkine.com/books/c2.

***************************page_059***************************
34 Chapter2 C Fundamentals

Section 2.8

® 8

10.

LS

How many tokens are there in the following statement?

answer= (3*q-p*p) /3;
Insert spaces between the tokens in Exercise $ to make the statement casier to read.

In the Aweight .c program (Section 2.4). which spaces are essential?

Programming Projects

Write a program that uses print£ to display the following picture on the screen:

Write a program that computes the volume of a sphere with a 10-meter radius, using the for-
mula v = 4/3m”. Write the fraction 4/3 as 4 . O£/3.0f. (Try writing it as 4/3. What hap-
pens?) Hint: C doesn’t have an exponentiation operator, so you’Il need to multiply r by itself

twice to compute .

Modify the program of Programming Projeet 2 so that it prompts the user to enter the radius
of the sphere.

Write a program that asks the user to enter a dollars-and-cents amount, then displays the
amount with 5% tax added:

Enter an amount: 100.00

With tax added: $S105.00

Write a program that asks the user to enter a value for x and then displays the value of the
following polynomial:

30424 - 57 - 074 Tx — 6

Hint: C doesn’t have an exponentiation operator, so you’Il need to multiply x by itself
repeatedly in order to compute the powers of x. (For example, x * x * x is x cubed.)
Modify the program of Programming Project 5 so that the polynomial is evaluated using the
following formula:

((((Gx + 2)x — 5)x — Hx + 7)x—6

Note that the modified program performs fewer multiplications. This technique for evaluat-
ing polynomials 1s known as Horner’s Rule.

Write a program that asks the user to enter a U.S. dollar amount and then shows how to pay
that amount using the smallest number of $20, $10, $S, and $1 bills:

Enter a dollar amount: 93

$20 bills: 4
$S10 bills: 1
$5 bills: O
$S1 bills: 3

***************************page_060***************************
Programming Projects 35

Hint: Divide the amount by 20 to determine the number of $20 bills needed, and then reduce
the amount by the total value of the 520 bills. Repeat for the other bill sizes. Be sure to use
integer values throughout, not floating-point numbers.

Write a program that calculates the remaining balance on a loan after the first, second, and
third monthly payments:

Enter amount of loan: 20000.00
Enter interest rate: 6.0

Enter monthly payment: 3866.66

Balance remaining after first payment: $S19713.34
Balance remaining after second payment: $19425.25
Balance remaining after third payment: $19135.71

Display each balance with two digits after the decimal point. Hint: Each month. the balance
is decreased by the amount of the payment, but increased by the balance times the monthly
interest rate. To find the monthly intèrest rate, convert the interest rate entered by the user Lo
a percentage and divide it by 12.

***************************page_061***************************

***************************page_062***************************
3 Formatted Input/Output

In seeking the unattainable, simplicity only gets in the way.

scanf and print£, which support formatted reading and writing, are two of the
most frequently used functions in C. As this chapter shows, both are powerful but
tricky to use properly. Section 3.1 describes printf, and Section 3.2 covers
scanf. Neither section gives complete details, which will have to wait until Chap-

ter 22.

3.1 The print£ Function

 

37

***************************page_063***************************
38

Chapter 3 Formatted Input/Ouiput

Ordinary characters in a format string are printed exactly as they appear in the
string; conversion specifications are replaced by the values to be printed. Consider
the following example:
int i, ];
float x, y;

i = 10;

j = 20;

x = 43.2892f;
y = 5527.0f;

©

printf("i = %d, j = %d, x = %f, y = %f£\n", i, j, x, Y);
This call of print£f produces the following output:
i = 10, j = 20, x = 43.289200, y = 5527.000000

The ordinary characters in the format string are simply copied to the output line.
The four conversion specifications are replaced by the values of the variables i, J.
x, and y, in that order.

 

C compilers aren’t required to check that the number of conversion specifications
in a format string matches the number of output items. The following call of
printf has more conversion specifications than values lo be printed:

printf("%d %d\n", i); — /*** WRONG ***/

print£ will print the value of i correctly, then print a second (meaningless) inte-
ger value. À call with too few conversion specifications has similar problems:

print£ ("td\n", i, 3); /*** WRONG ***/

In this case, printf prints the value of i but doesn*t show the value of .

Furthermore, compilers aren’t required to check that a conversion specifica-
tion is appropriate for the type of item being printed. If the programmer uses an
incorrect specification, the program will simply produce meaningless output. Con-
sider the following call of print£, in which the int variable i and the £float
variable x are in the wrong order:

printf("%£f %d\n", i, x); /*** WRONG ***/

Since print£ must obey the format string, it will dutifully display a float
value, followed by an int value. Unfortunately, both will be meaningless.

 

Conversion Specifications

Conversion specifications give the programmer a great deal of control over the
appcarance of output. On the other hand, they can be complicated and hard to read.
In fact, describing conversion specifications in complete detail 1s too arduous à

***************************page_064***************************
Qa&À

3.1 The printf Function 39

task to tackle this early in the book. Instead, we'l1 just take a brief look at some of
their more important capabilities.

In Chapter 2, we saw that a conversion specification can include formatting
information. In particular, we used % .1£ to display a float value with one digit
after the decimal point. More generally, à conversion specification can have the
form %m.pX or %-m.pX, where m and p are integer constants and X 1s a letter.
Both mn and p are optional; if p is omitted, the period that separates m and p is also
dropped. In the conversion specification %10.2£. m is 10, p is 2, and X is £. In
the specification %10f. m is 10 and p (along with the period) 1s missing, but in the
specification % . 2£, p is 2 and mn 1s missing.

The minimum field width, m, specifies the minimum number of characters to
print. If the value to be printed requires fewer than /n characters, the value 1s right-
justified within the field. (In other words, extra spaces precede the value.) For
example, the specification %4d would display the number 123 as e123. (In this
chapter, l'Il use e to represent the space character.) If the value to be printed
requires more than m characters, the field width automatically expands to the nec-
essary size. Thus, the specification %4d would display the number 12345 as
12345—no digits are lost. Putting à minus sign in front of /n causes left justifica-
tion; the specification %-4d would display 123 as 123e.

The meaning of the precision, p, isn’t as easily described, since 1t depends on
the choice of X, the conversion specifier. X indicates which conversion should be
applied to the value before it’s printed. The most common conversion specifiers for
numbers are:

u d — Displays an integer in decimal (base 10) form. p indicates the minimum
number of digits to display (extra zeros are added to the beginning of the num-
ber if necessary); if » is omitted, it is assumed to have the value |. (In other
words, 3d 1s the same as % .1d.)

u e — Displays a floating-point number in exponential format (scientific nota-
tion). p indicates how many digits should appear after the decimal point (the
default is 6). If p is O, the decimal point 1s not displayed.

u £ — Displays a floating-point number in “fixed decimal” format, without an
exponent. p has the same meaning as for the e specifier.

u g — Displays a floating-point number in either exponential format or fixed
decimal format, depending on the number’s size. p indicates the maximum
number of significant digits (not digits after the decimal point) to be dis-
played. Unlike the £ conversion, the g conversion won’t show trailing zeros.
Furthermore, if the value to be printed has no digits after the decimal point, 9
doesn°t display the decimal point.

The g specifier is especially usefu! for displaying numbers whose size can’t be
predicted when the program is written or that tend to vary widely in size. When
used to print a moderately large or moderately small number, the g specifier uses
fixed decimal format. But when used to print a very large or very small number,
the g specifier switches to exponential format so that the number will require fewer
characters.

***************************page_065***************************
40 Chapter3  Formatted Input/Ouiput

specillers for Integers »7. ! There are many other specifiers besides %d. %e. %£. and %g. TIl gradually

specifiers for lioats 7.2 _ introduce many of them in subsequent chapters. For the f'ull list, and for a complete

specifiers for characters >7.3 | explanation of the other capabilities of conversion specifications, consult Section
specifiers for strings »133 | 22.3.

PROGRAM Using print£ to Format Numbers

The following program illustrates the use of print£ to print integers and float-
ing-point numbers in various formats.

tprintfe /* Prints int and float values in various formats */
finclude <stdio.h>

int main(void)

{
int i;
float x;

i
x

â0;
839.21É;

printf("|%d
printf("|%1

o\° o\°

return D0;

The | characters in the print£ format strings are there merely to help show
how much space each number occupies when printed; unlike % or \, the | charac-
ter has no special significance to print£. The output of this program is:

|40| 40|40 | 040|
| 839.210| 8.392e+02|839.21 |

Let's take a closer look at the conversion specifications used in this program:

O

u %d — Displays i in decimal form, using a minimum amount of space.

u %5d — Displays à in decimal form, using a minimum of five characters.
Since i requires only two characters. three spaces were added.

u %-5d — Displays i in decimal form, using a minimum of five characters;
since the value of à doesn’t require five characters, the spaces are added after-
ward (that is, i 1s left-justified in a field of length five).

u %5.3d — Displays à in decimal form, using a minimum of five characters
overall and a minimum of three digits. Since i is only two digits long, an extra
zero was added to guarantee three digits. The resulting number is only three
characters long, so two spaces were added, for a total of five characters (i is
right-justified).

u %10.3f — Displays x in fixed decimal form, using 10 characters overall,

***************************page_066***************************
escape sequences > 7.3

QaÂ

3.1 The printf Function 41

with three digits after the decimal point. Since x requires only seven charac-
ters (three before the decimal point, three after the decimal point, and one for
the decimal point itself), three spaces precede x.

u %10.3e — Displays x in exponential form, using 10 characters overall, with
three digits after the decimal point. x requires nine characters altogether
(including the exponent), so one space precedes x.

u %-10g — Displays x in either fixed decimal form or exponential form, using
10 characters overall. In this case, print£ chose to display x in fixed deci-
mal form. The presence of the minus sign forces left justification, so x 1s fol-
lowed by four spaces.

Escape Sequences

The \n code that we often use in format strings is called an escape sequence.
Escape sequences enable strings to contain characters that would otherwise cause
problems for the compiler, including nonprinting (control) characters and charac-
ters that have a special meaning to the compiler (such as "). We'1l provide a com-
plete list of escape sequences later; for now, here’s a sample:

Alert (bell) \a
Backspace \b
New line \n

Horizontaltab: \t

When they appear in print£ format strings, these escape sequences represent
actions to perform upon printing. Printing \a causes an audible beep on most
machines. Printing \b moves the cursor back one position. Printing \n advances
the cursor to the beginning of the next line. Printing \t moves the cursor to the
next tab stop.

À string may contain any number of escape sequences. Consider the following
printf example, in which the Fformat string contains six escape sequences:

printf ("Item\tUnit\tPurchase\n\tPrice\tDate\n") ;

Executing this statement prints a two-line headine:

Item Unit Purchase
Price Date

 

***************************page_067***************************
42

Chapter 3  Formatted Input/Ouiput

3.2

 

 

Forgetting to put the & symbol in front of a variable in à call of scan£ will have
unpredictable—and possibly disastrous—results. À program crash 1s a common
outcome. Ât the very least, the value that ts read from the input won't be stored in
the variable: instead, the variable will retain its old value (which may be meaning-
less if the variable wasn°’t given an initial value). Omitting the & is an extremely
common error—be careful! Some compilers can spot this error and produce a
warning message such as “format argument is not a pointer.” (The term pointer is
defined in Chapter 11; the & symbol is used to create à pointer to à variable.) IF you
get a warning, check for a missing &.

 

***************************page_068***************************
detecting errors in scanf£ >22.3

3.2  The scanf Function 43

Calling scan£ is a powerful but unforgiving way to read data. Many profes-
sional C programmers avoid scan£, instead reading all data in character form and
conveiting it to numeric form later. We'll use scan£ quite a bit, especially in the
early chapters of this book, because it provides a simple way to read numbers. Be
aware, however, that many of our programs won°t behave properly 1f the user
enters unexpected input. As we'll see later, il’s possible to have a program test
whether scanf successfully read the requested data (and attempt to recover 1if 1t
didn’t). Such tests are impractical for the programs in this book—they would add
too many statements and obscure the point of the examples.

How scan£ Works

scanf can actually do much more than l’ve indicated so far. It 1s essentially a
“pattern-matching” function that tries to match up groups of input characters with
conversion specifications.

Like the print£f function, scan£ is controlled by the format string. When it
is called, scan£ begins processing the information in the string, starting at the
left. For each conversion specification in the format string, scan£ tries to locate
an item of the appropriate type in the input data. skipping blank space 1f necessary.
scanf then reads the item, stopping when it encounters a character that can’t pos-
sibly belong to the item. If the item was read successfully, scan£ continues pro-
cessing the rest of the format string. If any item is not read successfully, scanf
returns immediately without looking at the rest of the format string (or the remain-
ing Iinput data).

As it searches for the beginning of a number, scan£ ignores white-space
characters (the space, horizontal and vertical tab, form-feed. and new-line charac-
ters). As a result, numbers can be put on a single line or spread out over several
lines. Consider the following call of scanf£:

scanf ("3d%d%$£3f", &i, &]j, &X, &y);
Suppose that the user enters three lines of input:

1
-20 .3
-à4 .0e3

scanf sees one continuous stream of characters:
ee11-2()e0e0e 3M1000e-4 ()E3N

(l'm using e to represent the space character and @ to represent the new-line char-
acter.) Since it skips over white-space characters as it looks for the beginning of
each number, scan£ will be able to read the numbers successfully. In the follow-
ing diagram, an s under a character indicates that it was skipped. and an r indi-
cates it was read as part of an input item:

ee10-2)000 31000e-4 ()e30
SSISYYYrsSSrIrssssrrrrrr

***************************page_069***************************
 

44

Chapter 3 Formatted Input/Output

QaA

scanf “peeks” at the final new-line character without actually reading it. This
new-line will be the first character read by the next call of scan£.

What rules does scan£ follow to recognize an integer or a floating-point
number? When asked to read an integer, scanf first searches for a digit, a plus
sign, or a minus sign; it then reads digits until it reaches a nondigit. When asked to
read a floating-point number, scanf looks for

a plus or minus sign (optional). followed by

a series of digits (possibly containing a decimal point), Followed by

an exponent (optional). An exponent consists of the letter e (or E), an optional
sign, and one or more digits.

The %$e, $£, and %g conversions are interchangeable when used with scanf: all
three follow the same rules for recognizing a floating-point number.

When scan£ encounters a character that can’t be part of the current item, the
character is ‘“‘put back” to be read again during the scanning of the next input item
or during the next call of scan£. Consider the following (admittedly pathological)
arrangement of our four numbers:

 

***************************page_070***************************
32  The scanf Function 45

Ordinary Characters in Format Strings

The concept of pattern-matching can be taken one step further by writing format
strings that contain ordinary characters in addition to conversion specifications.
The action that scanf takes when it processes an ordinary character in a format
string depends on whether or not it’s a white-space character.

#s White-space characters. When it encounters one or more consecutive white-
space characters in a format string, scan£ repeatedly reads white-space char-
acters from the input until it reaches a non-white-space character (which is
“put back”). The number of white-space characters in the format string is
irrelevant; one white-space character in the format string will match any num-
ber of white-space characters in the input. (Incidentally. putting a white-space
character in a format string doesn’t force the input to contain white-space
characters. À white-space character in a format string matches any number of
white-space characters in the input, including none.)

u Other characters. When it encounters a non-white-space character in a Fformat
string, scanf compares it with the next input character. If the two characters
match, scanf discards the input character and continues processing the for-
mat string. If the characters don t match, scan£ puts the offending character
back into the input, then aborts without further processing the format string or
reading characters from the input.

For example, suppose that the format string is "*d/%d". If the input is
e5/096

scanf skips the first space while looking for an integer, matches %d with 5.
matches / with /, skips a space while looking for another integer, and matches d
with 96. On the other hand, 1f the input is

e5e/096

scanf skips one space, matches %d with 5, then attempts to match the / in the
format string with a space in the input. There’s no match, so scan£ puts the space
back: the e / e 96 characters remain to be read by the next call of scan£. To allow
spaces after the first number, we should use the format string "%*d /%d" instead.

Confusing printf with scan£

Although calls of scanf and print£ may appear similar, there are significant
differences between the two functions; ignoring these differences can be hazardous
to the health of your program.

One common mistake is to put & in front of variables in a call of print£:

printf£f("%d %d\n", &i, &j) ; /*** WRONG ***/

***************************page_071***************************
 

46 Chapter 3 Formatted Input/Output

Fortunately. this mistake is fairly easy to spot: print£ will display a couple of
odd-looking numbers instead of the values of i and j.

Since scanf normally skips white-space characters when looking for data
items, there’s often no need for a format string to include characters other than
conversion specifications. Incorrectly assuming that scan£ format strings should
resemble printf format strings—another common error—may cause scanf lo
bchave in unexpected ways. Let’s see what happens when the following call of
scanf 1s executed:

scanf ("*d, %d", &i, &j);

scan£ will first look for an integer in the input. which it stores in the variable i.
scan£ will then try to match a comma with the next input character. IF the next
input character is a space, not a comma, scanf will terminate without reading a
value for j.

 

A Although print£ format strings often end with \n, putting a new-line character
at the end of a scan£ format string 1s usually a bad idea. To scan£, a new-line
character in a format string ts equivalent to a space; both cause scanf to advance
to the next non-white-space character. For example, 1f the format string 1s
"5d\n", scan£ will skip white space, read an integer, then skip to the next non-
Wwhite-space character. À format string like this can cause an interactive program to

“hang” until the user enters a nonblank character.

 

PROGRAM  Adding Fractions

To 1llustrate scan£'s ability to match patterns, consider the problem of reading a
fraction entered by the user. Fractions are customarily written in the form mumera-
torldenominator. Instead of having the user enter the numerator and denominator
of a fraction as separate integers, scanf makes it possible to read the entire frac-
tion. The following program, which adds two fractions, illustrates this technique.

addfrac.c _ /* Adds two fractions */
#include <stdio.h>
int main (void)
{

int numl, denoml, num2, denom2, result _ num, result _ denom;

print£ ("Enter first fraction: ") ;
scanf ("%d/$d", &numl, &denoml) ;

printf ("Enter second fraction: ") ;
scanf ("3d/5d", &num2, &denom2) ;

result num = numl * denom2 + num2 * denoml ;

***************************page_072***************************
À:

octal numbers » 7.1

hexadecimal numbers » 7.1

Q & À 47

result_denom = denoml * denom2 ;
printf ("The sum is %d/%d\n", result_num, result_denom) ;

return 0;

}

A session with this program might have the following appearance:
Enter first fraction: 5/6
Enter second fraction: 3/4
The sum is 38/24

Note that the resulting fraction isn°t reduced to lowest terms.

Q & À

***************************page_073***************************
48 Chapter 3  Formatted Input/Output

Â:

detecting errors in scan£ » 22.3

It’s easy for scan£ to put charac-
ters back into the buffer for subsequent reading. Chapter 22 discusses input buffer-
ing in more detail.

 

***************************page_074***************************
Section 3.1

Section 3.2

*4,

O *.

6.

Exercises 49

Exercises

What output do the following calls of printf produce?

(a) printf("%6d,%4d", 86, 1040) ;
(b) print£f("%12.5e", 30.253) ;

(c) printf("%.4f£", 83.162) ;

(d) printf("%-6.2g", .0000009979) ;

Write calls of printf that display a float variable x in the following formats.

(a) Exponential notation; left-justified in à field of size 8: one digit after the decimal point.

(b) Exponential notation: right-justified in a field of size 10: six digits after the decimal
point.

(c) Fixed decimal notation: left-justified in à field of size 8: three digits after the decimal
point.

(d) Fixed decimal notation; right-justified in à field of size 6: no digits after the decimal
point.

For each of the following pairs of scanf format strings, indicate whether or not the two
strings arc equivalent. If they*re not, show how they can be distinguished.

(u) "Zd" versus " %d"

(b) "%Sd-%$d-%d" versus "%=d -%d -%d"
(c) "Sf" versus "%£ "

(d) "Sf,=f" versus "S£, %f"

Suppose that we call scan£ as follows:
scanf ("$d%f%d", &i, &Xx, &]);
If the user enters

10.3 5 6

what will be the values of i, x, and j after the call? (Assume that i and j are int variables
and x is a float variable.)

Suppose that we call scan£ as follows:

scanf ("%f%d%£{", &x, &i, &y) ;

If the user enters

12.3 45.6 789

what will be the values of x, i. and y after the call? (Assume that x and y are float vari-

ables and i is an int variable.)

Show how to modify the addfrac. c program of Section 3.2 so that the user is allowed to
enter fractions that contain spaces before and after each / character.

 

*Starred exercises are tricky—the correct answer is usually not the obvious one, Read the question
thoroughly, review the relevant section if necessary, and be careful!

***************************page_075***************************
50

 

Chapter 3  Formatted Input/Output

@ |
2.

m 3
4.
5,

Programming Projects

Write a program that accepts a date from the user in the form »wn/dd/vyvy and then dis-
plays it in the form vyywmmdd:

Enter a date (mm/dd/yyyy) : 2/17/2011
You entered the date 20110217

Write a program that formats product information entered by the user. À session with the
program should look like this:

Enter item number: 583

Enter unit price: 13.5
Enter purchase date (mm/dd/yyyy) : 10/24/2010

 

Item Unit Purchase
Price Date
583 $ 13.50 10/24/2010

The item number and date should be left justified; the unit pricce should be right justified.
Allow dotlar amounts up to S9999.99. Hint: Use tabs to line up the columns.

Books are identified by an International Standard Book Number (ISBN). ISBNSs assigned
after January !, 2007 contain 13 digits, arranged in five groups, such as 978-0-393-97950-3.
(Older ISBNs use 10 digits.) The first group (the GS7 prefix) is currently either 978 or 9779.
The group identifier specifies the language or country of origin (for example. O and ! are
used in English-speaking countries). The publisher code identifies the publisher (393 is the
code for W. W. Norton). The irem number is assigned by the publisher to identify à specific
book (97950 is the code for this book). An ISBN ends with a check digit thats used to verify
the accuracy of the préceding digits. Write a program that breaks down an ISBN entered by
the user:

Enter ISBN: 978-0-393-97950-3
GS1 prefix: 978

Group identifier: O

Publisher code: 393

Item number: 97950

Check digit: 3

 

Note: The number of digits in cach group may vary: you cant assume that groups have the
lengths shown in this example. Test your program with actual ISBN values (usually found
on the back cover of à book and on the copyright page).

Write a program that prompts the user to enter a telephone number in the form (xxx) xxx-
XXxxx and then displays the number in the form xxX.Xxx.xxx:

Enter phone number [(xxx) xxx-xxxx}] : (404) 817-6900
You entered 404.817.6900

 

Write a program that asks the user to enter the numbers from | to 16 (in any order) and then
displays the numbers in a 4 by 4 arrangement, followed by the sums of the rows, columns.
and ciagonals:

Enter the numbers from 1 to 16 in any order:
16 3 2 13 5 10 11 896 7 12 & 15 18 1

***************************page_076***************************
Programming Projects S

Row sums: 34 34 34 34
Column sums: 34 34 34 34
Diagonal sums: 34 34

If the row, column, and diagonal sums are all the same (as they are in this example). the
numbers are said to form a magic square. The mugic square shown here appears in a 1514
engraving by artist and mathematician Albrecht Dürer. (Note that the middle numbers in the
last row give the date of the engraving.)

Modify the addfrac. c program of Section 3.2 so that the user enters both fractions at the
same time, separated by à plus sign:

Enter two fractions separated by a plus sign: 5/6+3/4
The sum is 38/24

***************************page_077***************************

***************************page_078***************************
4 Expressions

One does not learn computing by using a hand
calculator, but one can forget arithmetic.

One of C’s distinguishing characteristics is its emphasis on expressions—formulas
that show how to compute a value—rather than statements. The simplest expres-
sions are variables and constants. À variable represents a value to be computed as
the program runs: à constant represents a value that doesn't change. More compli-
cated expressions apply operators to operands (which are themselves expressions).
In the expression a + (b * c). the + operator is applied to the operands a and
(b * c), both of which are expressions in their own right.

Operators are the basic tools for building expressions, and C has an unusually
rich collection of them. To start off, C provides the rudimentary operators that are
found in most programming languages:

m Arithmetic operators. including addition, subtraction, multiplication, and divi-
sion.
# Relational operators to perform comparisons such as “i 1s grearer than 02

m Logical operators Lo build conditions such as “i is greuter than 0 and à is less
than 10”

But C doesn°t stop here; it goes on to provide dozens of other operators. There are
so many operators, in fact, that we'll need to introduce them gradually over the
first twenty chapters of this book. Mastering so many operators can be a chore, but
it’s essential to becoming proficient at C.

In this chapter, we*I1 cover some of C’s most fundamental operators: the arith-
metic operators (Section 4.1), the assignment operators (Section 4.2). and the
increment and decrement operators (Section 4.3). Section 4.1 also explains opera-
tor precedence and associativity, which are important for expressions that contain
more than one operator. Section 4.4 describes how C expressions are evaluated.
Finally, Section 4.5 introduces the expression statement, an unusual feature that
allows any expression to serve as a statement.

53

***************************page_079***************************
54

Chapter4  Expressions

4.1

Table 4.1
Arithmetic Operators

e 13N

undefined behavior > 4.4

QaA

Arithmetic Operators

The arithmetic operators—operators that perform addition, subtraction, multipli-
cation, and division—are the workhorses of many programming languages, includ-
ing C. Table 4.1 shows C*s arithmetic operators.

 

 

 

Unary Binary
Additive Multiplicative
+  unary plus +  addition *  multiplication
-  Unaryminus | -  Subtraction | /  division
% remainder

 

 

 

 

 

The additive and multiplicative operators are said to be binary because they
require /wo operands. The r#nary operators require one operand:

i = +1; /* + used as a unary operator */
j = -i; /* - used as a unary operator */

The unary + operator does nothing; in fact. it didn’t even exist in K&R C. It's used
primarily to emphasize that a numeric constant is positive.

The binary operators probably look familiar. The only one that might not is %,
the remainder operator. The value of à % j is the remainder when i is divided by
j. For example, the value of 10 % 3 is I, and the value of 12 % 4 is O.

The binary operators in Table 4.1—with the exception of %—allow either inte-
ger or floating-point operands, with mixing allowed. When int and float oper-
ands are mixed. the result has type float. Thus, 9 + 2 .5f has the value 11.5.
and 6.7£ / 2 has the value 3.35.

The / and % operators require special care:

 

u Using zero as the risht operand of either / or % causes undefined behavior.
È ©

 

***************************page_080***************************
4.1  Arithmetic Operators 55

 

 

Implementation-Defined Behavior

The term implementation-defined will arise often enough that it?s worth taking a
moment to discuss it. The © standard deliberately leaves parts oi the language
unspecified, with the understanding that an “implementation”—the software needed
to compile, link, and execute programs on a particular platform—-will fill in the
details. As a result, the behavior of the program may vary somewhat from one
implementation to another. The behavior of the / and % operators for negative oper-
ands in C89 is an example of implementation-defined behavior.

Leaving parts of the language unspecified may seem odd or even dangerous,
but it reflects C’s philosophy. One of the language's goals is efficiency, which often
means matching the way that hardware behaves. Some CPUs yield —1 when —9 is
divided by 7, while others produce -—2; the C89 standard simply reflects this fact of
life.

I®s best to avoid writing programs that depend on implementation-defined
behavior. If that’'s not possible, at least check the manual carefully—the C standard
requires that implementation-defined behavior be documented.

 

 

Operator Precedence and Associativity

When an expression contains more than one operator, its interpretation may not be
immediately clear. For example, does i + j * k mean “add i and j, then multüply
the result by k;” or does it mean “multiply j and k, then add i””? One solution to
this problem is to add parentheses, writing either (i + j) * k or i + (j * k). Às
a general rule, C allows the use of parentheses for grouping in all expressions.

What if we don’t use parentheses, though? Will the compiler interpret i + j *
k as (i + j) * k or i + (j * k) ? Like many other languages, & uses operator
precedence rules to resolve this potential ambiguity. The arithmetic operators have
the following relative precedence:

Highest: +
*

(unary)

e

O

| >S= 1

Lowest: + (binary)

Operators listed on the same line (such as + and -) have equal precedence.

When two or more operators appear in the same expression, we can determine
how the compiler will interpret the expression by repeatedly putting parentheses
around subexpressions, starting with high-precedence operators and working down
to low-precedence operators. The following examples illustrate the result:

i + ; * k isequivalentto i + (j * k)
-i * -7 isequivalentto (-i) * (-7)
+i + j / K isequivalentto (+i) + (j / K)

Operator precedence rules alone aren’tenough when an expression contains two
or more operators at the same level of precedence. In this situalion, the associativity

***************************page_081***************************
56

Chapter 4  Expressions

table of operators » Appendix A

PROGRAM

of the operators comes into play. An operator is said to be left associative if it groups
from left to right. The binary arithmetic operators (*, /, %, +, and -) are all left asso-
ciative, SO

i - j - k is equivalentto (i - j) - k
i * yj /XK isequivalentto (i * j) / K

An operator 1s right associative if it groups from right to left. The unary arithmetic
operators (+ and -) are both right associative, so

- +i is equivalentto -(+i)

Precedence and associativity rules are important in many languages, but espe-
cially so in C. However, C has so many operators (almost fifty!) that few program-
mers bother to memorize the precedence and associativity rules. Instead, they
consult a table of operators when in doubt or just use plenty of parentheses.

Computing a UPC Check Digit

For a number of years. manufacturers of goods sold in U.S. and Canadian stores
have put a bar code on each product. This code, known as a Universal Product
Code (UPC), identifies both the manufacturer and the product. Each bar code rep-
resents a {welve-digit number, which is usually printed underneath the bars. For
example, the following bar code comes from a package of Stouffer's French Bread

Pepperoni Pizza:

0°°13800'15173"" s

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Fhe digits
O 13800 15173 5

appear underneath the bar code. The first digit identifies the type of item (O or 7
for most items, 2 for items that must be weighed, 3 for drugs and health-related
merchandise, and S for coupons). The first group of five digits identifies the manu-
facturer (13800 is the code for Nestlé USA's Frozen Food Division). The second
group of five digits identifies the product (including package size). The final digit
Is a “check digit.” whose only purpose is to help identify an error in the preceding
chgits. If the UPC is scanned incorrectly, the first !! digits probably won'1 be con-
sistent with the last digit, and the store’s scanner will reject the entire code.
Here’s one method of computing the check digit:

Add the first, third, fifth, seventh, ninth, and eleventh digits.
Add the second, fourth, sixth, eighth, and tenth digits.

 

***************************page_082***************************
upc.c

4.1  Arithmetic Operators 57

Multiply the first sum by 3 and add it to the second sum.
Subtract ! from the total.

Compute the remainder when the adjusted total is divided by 10.
Subtract the remainder from 9.

Using the Stouffer’s example, we getO+3+0+1+1+3-=8 for the first sum and
1+8+0+5+7=21 for the second sum. Multiplying the first sum by 3 and add-
ing the second yields 45. Subtracting ! gives 44. The remainder upon dividing by
1O is 4. When the remainder is subtracted from 9, the result is 5. Here are a couple
of other UPCs, in case you want to try your hand at computing the check digit
(raiding the kitchen cabinet for the answer 1s not allowed):

Jif Creamy Peanut Butter (18 0z.): O 51500 24128 ?
Ocean Spray Jellied Cranberry Sauce (8 0z.): O 31200 01005 ?

The answers appear at the bottom of the page.

Let’s write a program that calculates the check digit for an arbitrary UPC.
We’1l ask the user to enter the first ! ! digits of the UPC, then we'll display the cor-
responding check digit. To avoid confusion, we'll ask the user to enter the number
in three parts: the single digit at the left, the first group of five digits, and the sec-
ond group of five digits. Here’s what a session with the program will look like:

Enter the first (single) digit: O

Enter first group of five digits: 13800
Enter second group of five digits: 15173
Check digait: S

 

Instead of reading each digit group as à five-digit number, we'Il read it as five
one-digit numbers. Reading the numbers as single digits is more convenient; also,
we won°t have to worry that one of the five-digit numbers is too large to store in an
int variable. (Some older compilers limit the maximum value of an int variable
to 32,767.) To read single digits, we’Il use scan£ with the 31d conversion speci-
fication, which matches a one-digit integer.

/* Computes a Universal Product Code check digit */
#include <stdio.h>

int main(void)
int d, il, i2, i3, i4, i5, j1, j2, j3., j4, J5,
first sum, second _ sum, total;

printf ("Enter the first (single) digit: ");

scanf ("%1d", &d) ;

printf ("Enter first group of five digits: ") ;
scanf ("%1d%1d%1d%1d$1d", &il, &i2, &i13, &i4, &i5);
printf ("Enter second group of five digits: ") ;
scanf ("%1d%1d%1d%1d%1d", &j1, &j2, &j3, &j4, &)5);

 

The missing check digits are 8 (Jif) and 6 (Occan Spray).

***************************page_083***************************
58 Chapter4  Expressions

first_sum = d + i2 + i4 + j1 + j3 + j5;
second_sum = il + i3 + i5 + j2 + j4;
total = 3 * first sum + second _sum;

print£ ("Check digit: %d\n", 9 - ((total - 1) % 10));

return 0;

Note that the expression 9 - ( (total - 1) % 10) could have been written
as 9 - (total - 1) % 10, but the extra set of parentheses makes it easier to
understand.

4.2 Assignment Operators

Once the value of an expression has been computed, we*I1 often need to store it in
a variable for later use. C's = (simple assignment) operator is used for that pur-
pose. For updating a value already stored in a variable, C provides an assortment of
compound assignment operators.

Simple Assignment

The effect of the assignment v = e is to evaluate the expression e and copy its value
into v. Às the following examples show, e can bc a constant. a variable, or a more
complicated expression:

5 ; /* i is now 5 */
j = i; /* j is now 5 */
k = 10 * i + j; /* k is now 55 */

i

 

conversion during assignment 7.4 | We'1l return to the topic of type conversion later.

   

***************************page_084***************************
4.2  Assignment Operators 59

 

 

Side Effects

We don’t normally expect operators to modify their operands, since operators in
mathematics don’t. Writing i + j doesn't modify either i or ;; it simply computes
the result of adding i and .

Most C operators don’t modify their operands, but some do. We say that these
operators have side effects, since they do more than just compute a value. The
simple assignment operator is the first operator we'’ve seen that has side effects; it
modifies its left operand. Evaluating the expression i = O produces the result O
and—as a side effect—assigns 0 to i.

 

_ m

 

 

 

Lvalues

Most C operators allow their operands to be variables, constants, or expressions
containing other operators. The assignment operator, however, requires an lvalne

***************************page_085***************************
60 Chapter4  Expressions

other assignment operators > 20. 1

QaÂÀ

>

as its left operand. An Ivalue (pronounced “IL-value”) represents an object stored in
computer memory, not a constant or the result of a computation. Variables are lval-
ues: expressions such as 10 or 2 * i are not. At this point, variables are the only
lvalues that we know about; other kinds of Ivalues will appear in later chapters.

Since the assignment operator requires an Ivalue as its left operand, it’s illegal
to put any other kind of expression on the left side of an assignment expression:

12 = j; /*** WRONG ***/
i + j = 0; /*** WRONG #**/
-i = ; /*** WRONG x*x*/

The compiler will detect errors of this nature. and you’I1 get an error message such
as “invalid [value in assignment.”

Compound Assignment

Assignments that use the old value of a variable to compute its new value are com-
mon in C programs. The following statement, for example, adds 2 to the value
stored in i:

 

-= *= /= %=

(We"Il cover the remaining compound assignment operators in a later chapter.) AIl
compound assignment operators work in much the same way:

v += e adds v to e, storing the result in v

v -= e subtracts e from v, storing the result in v

v *= e multiplies v by e. storing the result in v

v /= e divides v by e. storing the result in v

v = e computes the remainder when v is divided by e, storing the result in v

 

 

When using the compound assignment operators, be careful not to switch the two
characters that make up the operator. Switching the characters may yield an
expression that is acceptable to the compiler but that doesn’t have the intended
meaning. For example, il you meant t0 write i += j but typed i =+ j instead, the

***************************page_086***************************
4.3 _ Increment and Decrement Operators 61

program will still compile. Unfortunately, the latter expression is equivalent to
i = (+), which merely copies the value of  into i.

 

 

4.3 Increment and Decrement Operators

Two of the most common operations on a variable are ‘“incrementing” (adding 1)

and “decrementing” (subtracting 1). We can, of course, accomplish these tasks by
writing

 

e 14

At first glance, the increment and decrement operators are simplicity itself: ++
adds | to its operand, whereas - - subtracts |. Unfortunately, this simplicity 1S mis-
leading—the increment and decrement operators can be tricky to use. One compli-
cation is that ++ and -- can be used as prefix operators (++i and --i, for
example) or postfix operators (i++ and i--). The correctness of a program may
hinge on picking the proper version.

 

***************************page_087***************************
62

Chapter4  Expressions

4.4

 

The - - operator has similar properties:

l = 1;
print£ ("i is sd\n", --i); /* prints "i is O" */
printf("i is %“d\n", i); /* prints "i is O" */
i = 1;
printf ("i is $d\n", i--); /* prints "i is 1" */
print£("i is $d\n", i); /* prints "i is O" */
When ++ or -- is used more than once in the same expression, the result can

often be hard to understand. Consider the following statements:

l = 1;

j = 27

k = ++i + j++;

What are the values of i, , and k after these statements are executed? Since ài is

incremented before its value is used, but j is incremented afrer it is used, the last
statement 1s equivalent to

i =

Ci. H- }.J.
+ ++
pu. #

j =

/

so the final values of i, j, and k are 2, 3, and 4, respectively, In contrast, executing
the statements

i = 1;
j = 27
K = i++ + j++;

will give i, j, and k the values 2, 3, and 3, respectively.

 

Expression Evaluation

Table 4.2 summarizes the opcrators we’ve seen so far. (Appendix A has a similar
table that shows all operators.) The first column shows the precedence of each

***************************page_088***************************
44  Expression Evaluation 63

 

 

 

 

 

 

Table 4.2 Precedence … Name Symbol(s) Associativity
À Partial List of ] increment (postfix) - ++ left
C Operators decrement (postfix) --
2 increment (prefix) ++ right
decrement (prefix) __
unary plus +
unary minus _
3 multiplicative * / % left
4 additive + - left
5 assignment = #*= /= %$= += -= right

 

 

 

operator relative to the other operators in the table (the highest precedence 1s |; the
lowest 1s 5). The last column shows the associativity of each operator.

 

***************************page_089***************************
64 Chapter 4  Expressions

logical and and or operators » 5.1
conditional operator » 5.2

comma operator > 6.3

 

 

 

 

To prevent problems, it’s a good idea to avoid using the assignment operators
in subexpressions: instead, use à series of separate assignments. For example, the
statements above could be rewritten as

n v U ®
"
D H &UU

The value of c will always be 6 after these statements are executed.

***************************page_090***************************
registers » 18.2

4.5

Qa&ÂÀ

45  Expression Sitatements 65

 

 

 

 

 

 

Expression Statements

C has the unusual rule that ary expression can be used as a statement. That 1s, any
expression—regardless of its Lype or what 1t computes—can be turned into a state-
ment by appending a semicolon. For example, we could turn the expression ++i
into a statement:

++i;

When this statement 1s executed, i is first incremented. then the new value of i is
fetched (as though it were to be used in an enclosing expression). However, since
++i ISN’( part of à larger expression, its value 1s discarded and the next statement
executed. (The change to i is permanent, of course.)

Since its value 1s discarded, there’s little point in using an expression as a
statement unless the expression has a side effect. Let’s look at three examples. In

***************************page_091***************************
66 Chapter 4  Expressions

the first example, 1 1s stored into i, then the new value of i 1s fetched but not used:
Ll = 1;

In the second example, the value of i 1s fetched but not used; however, i 1s decre-
mented afterwards:

i--;

In the third example, the value of the expression i * j - 1 1s computed and then
discarded:

i * j - 1;

Since i and j aren’t changed, this statement has no effect and therefore serves no
purpose.

 

Î À slip of the finger can easily create a ‘“do-nothing’’ expression statement. For
example, instead of entering

i = ;;
we might accidentally type
L + J;

(This kind of error is more common than you might expect, since the = and + char-
acters usually occupy the same key.) Some compilers can detect meaningless
expression statements; you’Il get a warning such as “statement with no effect.”

 

Q & À

Â:

povÙ function » 23.3

 

Q: I want to apply the % operator to a floating-point operand, but my program
won’t compile. What can I do? [p. 54]

fmod lunction»233  À: The % operator requires integer operands. Try the fmod function instead.

Q: Why are the rules for using the / and % operators with negative operands so
complicated? [p. 54]

A: The rules aren’t as complicated as they may first appear. In both C89 and C99, the
goal is to ensure that the value of (a / b) * b + a % b will always be equal to a

***************************page_092***************************
> Q

>.

Q & À 67

(and indeed, both standards guarantee that this is the case, provided that the value
of a / b is “representable’’). The problem is that there are two ways for a / b and
a % b to satisfy this equality 1f either à or b is negative, as seen in C89, where
either -9 / 7 is —l and -9 % 7 is —2, or -9 / 7 is —2 and -9 $ 7 is 5. In the first
case, (-9 / 7) * 7 + -9 % 7 has the value —1 x 7 + —2 = —9, and in the second
case, (-9 / 7) * 7 + -9 % 7 has the value —2 x 7 + S = —9. By the time C99 rolled
around, most CPUs were designed to truncate the result of division toward zero, so
this was written into the standard as the only allowable outcome.

If C has Ivalues, does it also have rvalues? [p. 59]

Yes, indeed. An /value is an expression that can appear on the /eft side of an assign-
ment; an rvalue 1s an expression that can appear on the right side. Thus, an rvalue
could be a variable, constant, or more complex expression. In this book, as in the C
standard, we'Il use the term ‘’expression” instead of “rvalue.”

 

Why does C provide the ++ and -- operators? Are they faster than other

ways of incrementing and decrementing, or they are just more convenient? [p.
61]

C inherited ++ and -- from Ken Thompson’s earlier B language. Thompson
apparently created these operators because his B compiler could generate a more
compact translation for ++i than for i = i + 1. These operators have become a
deeply ingrained part of C (in fact, many of C’s most famous idioms rely on them).
With modern compilers, using ++ and -- won’t make a compiled program any
smaller or faster; the continued popularity of these operators stems mostly from
their brevity and convenience.

Do ++ and - - work with flcoat variables?

Yes; the increment and decrement operations can be applied to floating-point num-
bers as well as integers. In practice, however, it’s fairly rare to increment or decre-
ment a Éloat variable.

***************************page_093***************************
68 Chapter 4  Expressions

Section 4.1

e$e
“ °
.

When [ use the postfix version of ++ or --, just when is the increment or dec-
rement performed? [p. 62]

That's an excellent question. Unfortunately, it’s also a difficult one to answer. The
C standard introduces the concept of “sequence point” and says that ’updating the
stored value of the operand shall occur between the previous and the next sequence
point.’ There are various kinds of sequence points in C: the end of an expression
statement is one example. By the end of an expression statement, all increments
and decrements within the statement must have been performed; the next statement
can’t begin to execute until this condition has been met.

Certain operators that we’ll encounter in later chapters (logical and, logical or,
conditional, and comma) also impose sequence points. So do function calls: the
arguments in a function call must be fully evaluated before the call can be per-
formed. If an areument happens to be an expression containing à ++ Or -- opera-
tor, the increment or decrement must occur before the call can take place.

What do you mean when you say that the value of an expression statement is
discarded? [p. 65]

By definition, an expression represents a value. If i has the value 5, for example,
then evaluating i + 1 produces the value 6. Let’s turn i + 1 into a statement by
putting a semicolon after 1t:

i + 1;

When this statement is executed, the value of i + 1 is computed. Since we have
failed to save this value—or at least use it in some way—it 1s lost.

But what about statements like i = 1 ; ? l don°t see what is being discarded.

Don't forget that = is an operator in C and produces a value just like any other
operator. The assignment

1 = 1;

assigns | to i. The value of the entire expression is |, which is discarded. Discard-
ing the expression’s value 1s no great loss, since the reason for writing the state-
ment in the first place was to modify i.

Exercises

Show the output produced by cach of the following program fragments. Assume that i. j.
and k are int variables.
(a) i = 5; j = 3;
print£("%d $d", i / j, i $ j);
(b) i = 2; j = 3;
printf("%d", (i + 10) % j);
(c) i = 7; j = 8; k ;
printf("%$d", (i + 10) % k / j);

Il
Lo

***************************page_094***************************
 

Exercises 69

(d) i = 1; j = 2; k = 3;
print£("#d", (i + 5) % (j + 2) / K);
@ *2. Tf i and ; are positive integers, does (-i) /j always have the same value as - (i/j) ? Jus-
tify vour answer.

3.  What is the value of each of the following expressions in C89? (Give all possible values if
an expression may have more than one value.)

(a) 8 / 5

(b) -8 / 5
(c) 8 / -S
(d) -8 / -S

4, _ Repeat Exercise 3 for C99.

A

What is the value of each of the following expressions in C89? (Give all possible values if
an expression may have more than one value.)

(a) 8 % 5

(b) -8 % S
(c) 8 % -5
(d) -8 % -5

6. Repeat Exercise 5 for C99.

7, The algorithm for computing the UPC check digit ends with the following steps:

Subtract ! from the total.
Compute the remainder when the adjusted total 1s divided by 10.
Subtract the remainder from 9.

Tts tempting to try to simplify the algorithm by using these steps instead:

Compute the remainder when the total is divided by 10.
Subtract the remainder from 10.

Why doesn't this technique work?

S.  Would the upc.c program sull work if the expression 9 - ((total - 1) % 10) were
replacecd by (10 - (total % 10)) % 10?

Section 4.2 @ 9  Show the output produced by each of the following program fragments. Assume that i. j.
and k are int variables.

(a) 1 = 7; J

i *= j + l,'
printf("%d %d", i, j);
(b) i = J = k l;

i -= j -= k;
print£("%d %d %
(d) i = 2; j = 1; K = O0;
i *= j *= k;
print£("%d %d %d", i, j, kK);

***************************page_095***************************
70 Chapter 4  Expressions

Section 4.3

Section 4.4

10.

“11.

12,

@ 13.

14.

Show the output produced by each of the following program fragments. Assume that i and
j are int variables.

(a) i = 6;
Jj = i + ji;
printf("%d $d", i, 3);
(b) i = 5;
j=(i—-=2)+l;
print£("%d %*d", i, j);
(c) 1 = 7;

j = 6 + (i = 2.5);

print£f("%d %d", i, j);
(d) i = 2; j = 8;

j = (i = 6) + (3 = 3);

printf("%d %d", i, j);

Show the output produced by each of the following program fragments. Assume that i, j,
and k are int variables.

(a) i = 1;
print£("%d ", i++ - 1);
print£("%d", i);

(b) i = 10; j = 5;
print£("%d ", i++ - ++]);
print£("%d %d", i, j);

(c) i = 7; j = 8B8;
print£("%d ", i++ - --]) ;
printf£f ("%d %“d", i, j);

(d) i = 3; j = 4; k = 5;
print£("%d ", i++ - j++ + --K);
printf ("%d %d %d", i, j, kK);

Show the output produced by each of the following program fragments. Assume that i and
jare int variables.

(a) i = 5;
j = ++i * 3 - 2;
printf("%d *d", i, j);
(b) i = 5;
Jj = 3 - 2 * i++;
printf("%d %d", i, j);
(c) i = 7;

j = 3 * i-- + 2;

printf£("%d %d", i, j);
(d) i = 7;

j = 3 + --i * 2;

printf ("%d sd", i, ]j);

Only one of the expressions ++i and i++ 1s exactly the same as (i += 1): which 1s it?
Justify your answer.

Supply parentheses to show how a C compiler would interpret each of the following expres-
sions.

***************************page_096***************************
Section 4.5

15.

_LI|

Programming Projects 71

(a) a * b - C * d + e
(b) a / b % c / d

(c) - a- b + C - + d
(d)a * - b / c - d

Give the values of i and j after cach of the following expression statements has been exe-
cuted. (Assume that à has the value 1 initially and j has the value 2.)

(a) i += j;
(b) i--;

(c) à * j / i;
(d) i % ++];

Programming Projects

Write a program that asks the user to enter à two-digit number, then prints the number with
its digits reversed. À session with the program should have the following appearance:

Enter a two-digit number: 28
The reversal is: 82

Read the number using %d, then break it into two digits. Æinr: IFn 1s an integer, then n % 10
is the last digit in n and n / 10 is n with the last digit removed.

Extend the program in Programming Project ! to handle (/ree-digit numbers.

Rewrite the program in Programming Project 2 so that it prints the reversal of a three-digit
number without using arithmetic to split the number into digits. Hinr: See the upc .c pro-
gram of Section 4.1.

Write a program that reads an integer entered by the user and displays it in octal (base 8):

Enter a number between 0 and 32767: 1953

‘In octal, your number is: 03641

The output should be displayed using five digits, even if fewer digits are sufficient. Hint: To
convert the number to octal, first divide it by 8; the remainder is the last digit of the octal
number (1, in this case). Then divide the original number by & and repeat the process to
arrive at the next-to-last disit. (printf£ is capable of displaying numbers in base 8, as we Il
see in Chapter 7, so there’s actually an easier way to write this program.)

Rewrite the upc.c program of Section 4.1 so that the user enters ! | digits at one time,
instead of entering one digilt. then five digits, and then another five digits.

Enter the first 11 digits of a UPC: 01380015173
Check digit: S

 

European countries use a I3-digit code, known as a European Article Number (EAN)
instead of the 12-digit Universal Product Code (UPC) found in North America. Each EAN
ends with a check digit, just as a UPC does. The technique for calculating the check digit 1s
also similar:

Add the second, fourth. sixth, cighth, tenth. and twelfth digits.

Add the first, third. fifth. seventh, ninth, and eleventh digits.

Multiply the first sum by 3 and add it to the second sum.

***************************page_097***************************
72 Chapter4  Expressions

Subtract 1 from the total.
Compute the remainder when the adjusted total is divided by 10.
Subtract the remainder from 9.

For example, consider Güllüoglu Turkish Delight Pistachio & Coconut, which has an EAN
of 8691484260008. The first sum is6+1+8+2+0+0= 7, and the second sum is 8 + 9 +
4+4+6+0=31.Multiplying the first sum by 3 and adding the second yields 82. Subtraet-
ing | gives 81. The remainder upon dividing by 10 is 1. When the remainder is subtracted
from 9, the result is 8, which matches the last digit of the original code. Your job is to mod-
ify the upc .c program of Section 4.1 so that it caleulates the check digit for an EAN. The
user will enter the first 12 digits of the EAN as a single number:

Enter the first 12 digits of an EAN: 869148426000
Check digit: 8

 

***************************page_098***************************
B Selection Statements

Programmers are not to be measured by their ingenuity and
their logic but by the completeness of their case analysis.

return statement >2.2

expression statement > 4.5

 

This chapter discusses the selection statements and the compound statement.
(Chapter 6 covers the iteration statements, the jump statements. and the null state-
ment.) Before we can write 1£ statements, we’1] need logical expressions: condi-
tions that if statements can test. Section 5.1 explains how logical expressions are
built from the relational operators (<. <=, >. and >=), the equality operators (==
and ! =), and the logical operators (&&, | |, and !). Section 5.2 covers the i £ state-
ment and compound statement, as well as introducing the conditional operator
(?:). which can test a condition within an expression. Section 5.3 describes the
switch statement.

73

***************************page_099***************************
74

Chapter5 Selection Statements

5.1 Logical Expressions

Several of C’s statements, including the i£ statement. must test the value of an
expression to see if it is “true” or “false.”” For example, an i £ statement might need
to test the expression i < j; à true value would indicate that i is less than .

    

With this in mind, let’s look at the operators that are used to build logi-
cal expressions.

C”s relational operators (Table 5.1) correspond to the <, >, <, and 2 operators of
mathematics, except that they produce 0 (false) or ! (true) when used in expres-
sions. For example, the value of 10 < 11 is I; the value of 11 < 10 is 0.

Table 5.1
Relational Operators

 

The relational operators can be used to compare integers and floating-point
numbers, with operands of mixed types allowed. Thus, 1 < 2.5 has the value |,

while 5.6 < 4 has the value 0.

 

 

 

***************************page_100***************************
5.1  Logical Expressions 75

Equality Operators

Although the relational operators are denoted by the same symbols as in many
other programming languages, the equality operators have a unique appearance
(Table 5.2). The “equal to” operator is two adjacent = characters, not one, since a
sinele = character represents the assignment operator. The ‘’not equal to” operator
is also two characters: ! and =.

 

 

Table 5.2 Syrmnbol Meaning
Equality Operators _—= equal to
= not equal to

 

 

 

 

Clever programmers sometimes exploit the fact that the relational and equality
operators return integer values. For example. the value of the expression (i >= j)
+ (i == j) is either O, 1, or 2, depending on whether i 1s less than, greater than,
or equal to j, respectively. Tricky coding like this generally isn’t a good idea, how-
ever; it makes programs hard to understand.

More complicated logical expressions can be built from simpler ones by using the
logical operators: and, or, and not (Table 5.3). The ! operator is unary, while &&
and | | are binary.

 

Table 5.3
Logical Operators

 

The logical operators produce either O or ! as their result. Often, the operands
will have values of O or 1, but this isn°t a requirement; the logical operators treat
any nonzero operand as a true value and any zero operand as a false value.

The logical operators behave as follows:

m ! expr has the value | if expr has the value 0.

m expri && expr2 has the value 1 if the values of expr] and expr2 are both non-
Zero.

***************************page_101***************************
76 Chapter5  Selection Statements

u exprl | | expr2 hasthe value | if either expr/ or expr2 (or both) has a nonzero
value.

In all other cases, these operators produce the value 0.
Both && and | | perform “short-circuit” evaluation of their operands. That is,

 

 

Î Be wary of side effects in logical expressions. Thanks to the short-circuit nature of
the && and | | operators, side effects in operands may not always occur. Consider
the following expression:

i > O && +j > O

Although 3 1s apparently incremented as a side effect of evaluating the expression,
that isn’t always the case. If i > O is false, then ++j > O is not evaluated, so j isn’t
incremented. The problem can be fixed by changing the condition to ++j > O &&
i > O or, even better, by incrementing j separately.

 

 

5.2 The i£f Statement

The i £ statement allows a program to choose between two alternatives by testing
the value of an expression. In its simplest form, the i £ statement has the form

i £ statement 1f ( expression ) statement

Notice that the parentheses around the expression are mandatory; they’re part of
the 1 £ statement, not part of the expression. Also note that the word then doesn't
come after the parentheses, as it would in some programming languages.

***************************page_102***************************
e F3N

idiom

idiom

compound statement

5.2 The if Statement 77

When an i f statement is executed, the expression in the parentheses 1s evalu-
ated; if the value of the expression is nonzero—which C interprets as true—the
statement after the parentheses is executed. Here’s an example:

if (line num == MAX LINES)
line num = O0;

The statement line num = 0; is executed if the condition line num ==
MAX LINES is true (has a nonzero value).

 

Don’t confuse == (equality) with = (assignment). The statement
if (i == O)

tests whether i is equal to 0. However, the statement

i£ (ài = O)

assigns 0 to i, then tests whether the result is nonzero. In this case, the test always
fails.

Confusing == with = is perhaps the most common C programming error,
probably because = means “is equal to” in mathematics (and in certain program-
ming languages). Some compilers issue a warning if they notice = where == would
normally appear.

 

Ofiten the expression in an if statement will test whether a variable falls
within a range of values. To test whether O € i < n, for example, we’d write

if (O <= 1 & i < n)
To test the opposite condition (i is outside the range), we'd write
if (i < O || i >= n)

Note the use of the | | operator instead of the && operator.

Compound Statements
In our i f statement template, notice that statement is singular, not plural:
if ( expression ) statement

What if we want an i f statement to control Avo or more statements? That’s where
the compound statement comes in. A compound statement has the form

{ statements }

By putting braces around a group of statements, we can force the compiler to treal
it as a single statement.

***************************page_103***************************
 

78

i £ statement with
else clause

Chapter5  Selection Sitatements

Here’s an example of a compound statement:
{ line num = 0; page _num++; }

For clarity, PH! usually put a compound statement on several lines, with one state-
ment per line:

{

line_num = O0;
page _ num++;

}

Notice that each inner statement still ends with a semicolon, but the compound
statement itself does not.

Here’s what a compound statement would look like when used inside an if
statement:

if (line num == MAX LINES) |{
line num = 0;
page _num++;

}

 

An i£ statement may have an else clause:

LÉ ( expression ) statement else sratement

The statement that follows the word else is executed if the expression in paren-
theses has the value 0.

Here’s an example of an i f statement with an el se clause:

 

Notice that both ‘’inner” statements end with a semicolon.

When an if£ statement contains an else clause, a layout issue arises: where
should the else be placed? Many C programmers align it with the i£ at the
beginning of the statement, as in the previous example. The inner statements are

usually indented, but 1f they’re short they can be put on the same line as the i £ and
else:

 

***************************page_104***************************
52  The if Statement 79

There are no restrictions on what kind of statements can appear inside an if
statement. In fact. it’*s not unusual for i£ statements to be nested inside other i f
statements. Consider the following i f statement, which finds the largest of the
numbers stored in i, j, and k and stores that value in max:

if (i > 7)
if (i > k)
max = i;
else
max = kK;
else
if (j > k)
max = ];
else
max = k;

i f statements can be nested to any depth. Notice how aligning each e1se with the
matching i f makes the nesting easier to see. If you still find the nesting confusing,
don°t hesitate to add braces:

if (i > j) (|

if (i > k)
max = 1;
else
max = k;
} else |
if (j > K)
max = j;
else
max = k;

}

Adding braces to statements—even when they’re not necessary—is like using
parentheses in expressions: both techniques help make à program murè readable
while at the same time avoiding the possibility that the compiler won’t understand
the program the way we thought it did.

Some programmers use as many braces as possible inside i£ statements (and
iteration statements as well). À programmer who adopts this convention would
include à pair of braces for every i £ clause and every else clause:
if (i > j) |

if (i > Kk) |

max = i;
} else (
max = k;
}
} else {
if (j > k) |
max = ];
} else |
max = k;
}

}

***************************page_105***************************
80 Chapter5  Selection Statements

 

   

We'1l often need to test a series of conditions, stopping as soon as one of them is
true. À “cascaded” i£ statement is often the best way to write such a series of
tests. For example, the following cascaded if statement tests whether n is less
than O, equal to O. or greater than 0:

if (n < O)
printf("n is less than O\n") ;
else
if (n == O)
printf ("n is equal to O\n") ;
else

print£("n is greater than O\n") ;

Although the second i £ statement is nested inside the first, C programmers don*t
usually indent it. Instead, they align each e1se with the original i f:

 

Lf ( expression )
statement

else 1£ ( expression )
statement

else if ( expression )
statement

else
statement

 

***************************page_106***************************
PROGRAM

broker.c

5.2 The if Siatement 81

Calculating a Broker’s Commission

When stocks are sold or purchased through a broker, the broker’s commission 1s
often computed using à sliding scale that depends upon the value of the stocks
traded. Let's say that a broker charges the amounts shown in the following table:

Transaction size
Under $2,500
$2,500-$6,250
$6,250-$20,000
$20.000-$50,000

$50,000-$500,000

Over $500,000

Commission rate
$30 + 1.7%

$56 + 0.66%
476 + 0.34%
$100 + 0.22%
$155 + 0.11%
$255 + 0.09%

The minimum charge is $39. Our next program asks the user to enter the amount of
the trade, then displays the amount of the commission:

Enter value of trade:
Commission: $166.00

30000

The heart of the program is a cascaded i £ statement that determines which range
the trade falls into.

/* Calculates a broker's commission */
#include <stdio.h>

int main(void)

(

float commission, value;

print£ ("Enter value of trade: ");
scanf ("%£", &value) ;

if (value < 2500.00Ë)

commission = 30.00£ + .017f * value;
else if (value < 6250.00Ë)

commission = 56.00£f + .0066f£ * value;
else if (value < 20000.00f)

commission = 76.00f + .0034£ * value;
else if (value < 50000.00£f)

commission = 100.00f + .0022f * value;
else if (value < 500000.00Ëf)

commission = 155.00f + .0011£ * value;
else

commission = 255.00f + .0009£ * value;
if (commission < 39.00f)

commission = 39.00f;

printf ("Commission: $%.2f\n", commission) ;

return 0;

***************************page_107***************************
82 Chapter5  Selection Statements

The cascaded i£ statement could have been written this way instead (the
changes are indicated in bold):

if (value < 2500.00f)
commission = 30.00£ + .017f * value;

else if (value >= 2500.00f && value < 6250.00£f)
commission = 56.00f + .0066f * value;

else if (value >= 6250.00£ && value < 20000.00£)
commission = 76.00£ + .0034£ * value;

Although the program will still work, the added conditions aren’t necessary. For
example, the first à £ clause tests whether value is less than 2500 and, if so. com-
putes the commission. When we reach the second i £ test (Value >= 2500.00f
&& value < 6250.00f), we know that value can’t be less than 2500 and
therefore must be greater than or equal to 2500. The condition value >=
2500 .00£ will always be true, so there's no point in checking it.

 

This example illustrates the value of braces; if we’d used them in the original i f
statement, we wouldn’t have gotten into this situation 1n the first place.

***************************page_108***************************
52  The if Statement 83

Conditional Expressions

conditional
expression

 

The conditional expression i > j ? i - j in the first assignment to k returns the
value of either i or j, depending on which one is larger. Since i has the value |
and j has the value 2, the i > j comparison fails, and the value of the conditional
is 2, which is assigned to k. In the second assignment to k, the i >= 0 comparison
succeeds; the conditional expression (i >= O ? i : O) has the value !, which 1s
then added to j lo produce 3. The parentheses are necessary, by the way: the prece-
dence of the conditional operator is less than that of the other operators we”ve drs-
cussed so far, with the exception of the assignment operators.

 

***************************page_109***************************
84 Chapter5  Selection Statements

macro definitions 143 | Conditional expressions are also common in certain kinds of macro definitions.

 

***************************page_110***************************
52  The it Statement 85

type definitions » 7.5

enumerations » 16.5

œ

unsigned integer types > 7.7

<stdbool .h> header » 21.5

 

***************************page_111***************************
86

Chapter5  Selection Statements

break statement > 6.4

 

The switch Statement

[n everyday programming, we'll often necd to compare an expression against a
series of values to see which one it currently matches. We saw in Section 5.2 that a
cascaded i £ statement can be used for this purpose. For example, the following
cascaded i£ statement prints the English word that corresponds to a numerical
grade:

 

When this statement 1s executed, the value of the variable grade 1s tested against
4, 3, 2, 1, and O. If it matches 4, for example, the message Excellent is printed,
then the break statement transfers control to the statement following the
switch. If the value of grade doesn’t match any of the choices listed, the
default case applies, and the message I1legal grade 1s printed.

***************************page_112***************************
5.3 The switch Statement 87

 

Qa&ÂÀ In its most common form, the switch statement has the form
switch statement switch ( expression ) |
case constant-expression : statements
case constant-expression : statements

default : stratements

The switch statement is fairly complex; let’s look at its components one by one:

characters » 7.3

 

 

***************************page_113***************************
88 Chapter5  Selection Siatements

 

The Role of the break Statement

Now, let’s take a closer look at the mysterious break statement. Âs we've seen,
executing a break statement causes the program to ‘’break” out of the switch
statement; execulion continues at the next statement after the switch.

The reason that we need break has to do with the fact that the swi t ch state-
ment is really a form of “computed jump.!’ When the controlling expression is
evaluated, control jumps to the case label matching the value of the switch
expression. À case label is nothing more than a marker indicating a position within
the switch. When the last statement in the case has been executed, control ‘“falls
through” to the first statement in the following case; the case label for the next case
is ignored. Without break (or some other jump statement), control will flow from
one case into the next. Consider the following switch statement:

switch
case
case printf ("Good") ;

(grade) {
4 :
3 :
case 2:  printf ("Average") ;
1.
O
l

print£ ("Excellent") ;

case print£f ("Poor") ;
case 0:  printf ("Failing") ;
default: printf ("I11egal grade") ;

}

If the value of grade is 3, the message printed 1s

GoodAveragePoorFailingIllegal grade

 

Î Forgetting to use break is a common error. Although omitting break is some-
times done intentionally to allow several cases to share code, it’s usually just an
oversight.

 

***************************page_114***************************
PROGRAM

date.c

5.3 The switch Statement 89

Since deliberately falling through from one casc into the next is rare, il’s a
good idea to point out any deliberate omission of break:

switch (grade) ({
case 4: case 3: case 2: case 1:
num _passing++ ;
/* FALL THROUGH */
case 0: total grades++;
break ;
;

Without the comment, someone might later fix the “error” by adding an unwanted
break statement.

Although the last case in a switch statement never needs a break state-
ment, it‘s common practice to put one there anyway lo guard against a “missing
break” problem 1ï cases should later be added.

Printing a Date in Legal Form

Contracts and other legal documents are often dated in the following way:

Dated this day of . 20

Let's write a program that displays dates in this form. We'Il have the user enter the
date in month/day/year form, then we'Il display the date in “legal” form:

Enter date (mm/dd/yy) : 7/19/14
Dated this 19th day oË£ July, 2014.

We can get print£ to do most of the formatting. However, we’re left with two
problems: how to add “th” (or st” or “nd” or *rd”) to the day, and how to print the
month as a word instead of a number. Fortunately, the switch statement is ideal
for both situations: we’Il have one switch print the day suffix and another print
the month name.

/* Prints a date in legal form */
#include <stdio.h>

int main(void)

(

int month, day, year;

print£f ("Enter date (mm/dd/yy): ") ;
scanf("%d /%d /%d", &month, &day, &year) ;

print£f ("Dated this %d", day) ;
switch (day) |
case l: case 21: case 31:
printf ("st"); break;
case 2: case 22:
print£ ("nd") ; break;

***************************page_115***************************
90

Chapter5  Selection Statements

case 3: case 23:
printf ("rd") ; break;
default: print£ ("th") ; break;

}

print£f(" day of ") ;

switch (month) |
case 1: print£ ("January") ; break;
case 2: printf("February");  Dbreak;
case 3 print£f ("March") ; break ;
case 4 print£ ("April") ; break;
case 5:  print£ ("May") ; break;
case 6:  print£ ("June") ; break;
case 7 print£ ("July") ; break;
case 8: print£ ("August") ; break ;
case 9: printf ("September") ; break;
case 10: print£ ("October") ; break;

case 11: printf("November");  break;
case 12: printf ("December");  break;

}

print£(", 20%.2d.\n", year) ;
return 0;

;

Note the use of % . 2d to display the last two digits of the year. If we had used
&d instead, single-digit years would be displayed incorrectly (2005 would be
printed as 205).

Q & À

My compiler doesn’t give a warning when I use = instead of ==. Is there some
way to force the compiler to notice the problem? [p. 77]

Here’s a trick that some programmers use: instead of writing
if (iài == O)

they habitually write

if (O == i)

Now suppose that the == operator is accidentally written as =:
if (O = i)

The compiler will produce an error message. since it’s not possible to assign a
value to 0. ! don’t use this trick, because I think it makes programs look unnatural.
Also, it can be used only when one of the opcrands in the test condition isn’t an
Ivalue.

Fortunately, many compilers are capable of checking for suspect uses of the =
operator in if conditions. The GCC compiler, for example, will perform this

***************************page_116***************************
Q & À 91

check if the -Wparentheses option is used or if -Wall (all warnings) is
selected. GCC allows the programmer to suppress the warning in a particular case
by enclosing the i £ condition in a second set of parentheses:

i£ ((i = j))

C books seem to use several different styles of indentation and brace place-
ment for compound statements. Which style is best?

According to The New Hacker’s Dictionary (Cambridge, Mass.: MIT Press, 1996),
there are four common styles of indentation and brace placement:

m The K&R style, used in Kernighan and Ritchie’s The C Programming Lan-
guage, is the one l’ve chosen for the programs in this book. In the K&R style,
the left brace appears at the end of a line:

if (line num == MAX LINES) {
line num = O0;
page_num++;

}

The K&R style keeps programs compact by not putting the left brace on a line
by itself. À disadvantage: the left brace can be hard to find. (I don’t consider
this a problem, since the indentatièon of the inner statements makes it clear
where the left brace should be.) The K&R style is the one most often used in
Java, by the way.

m The A/lman style, named after Eric Allman (the author of sendmail and
other UNIX utilities), puts the left brace on a separate line:

if (line num == MAX LINES)

line num = 0;
page_num++;

;

This style makes it easy to check that braces come in matchins pairs.

u The Whitesmiths style, popularized by the Whitesmiths C compiler, dictates
that braces be indented:

if (line num == MAX LINES)

line num = 0;
page_num++ ;

}

m The GNU style, used in software developed by the GNU Project, indents the
braces, then further indents the inner statements:

if (line num == MAX LINES)

line num = 0;
page_num++;

;

***************************page_117***************************
92

Chapter5  Selection Statements

Which style you use is mainly a matter of taste: there’s no proof that one style
is clearly better than the others. In any event, choosing the right style is less impor-
tant than applying it consistently.

 

Q:
ÂÀ:

labels >6.4

Why doesn’t C99 have a better name for its Boolean type? [p. 85]

_ Bool isn’t a very elegant name, is it? More common names, such as bool or
boolean, weren't chosen because existine C programs might already define
these names, causing older code not to compile.

OK, so why wouldn’t the name _Bool break older programs as well?

The C89 standard specifies that names beginning with an underscore followed by
an uppercase letter are reserved for future use and should not be used by program-
mers.

The template given for the switch statement described it as the ‘“most com-
mon form.” Are there other forms? [p. 87]

The switch statement is a bit more general than described in this chapter.
although the description given here is general enough for virtually all programs.
For example, a switch statement can contain labels that aren’t preceded by the
word case, which leads to an amusing (?) trap. Suppose that we accidentally mis-
spell the word default:

switch (…) |

defual t :

}

The compiler may not detect the error, since it assumes that defualt is an ordi-
nary label.

l’ve scen several methods of indenting the switch statement. Which way is
best?

There are at least two common methods. One is to put the statements in each case
after the case label:

switch (coin) |
case 1: printf ("Cent") ;
break;
case 5:  print£ ("Nickel") ;
break;
case 10: printf ("Dime") ;
break;

***************************page_118***************************
Section 5.1

Exercises 93

case 25: printf ("Quarter") ;
break ;
}

If each case consists of a single action (a call of printf, in this example), the
break statement could even go on the same line as the action:

switch (coin) {
case 1: print£f ("Cent") ; break;
case 5: printf ("Nickel") ; break;
case 10: printf ("Dime") ; break;
case 25: print£f ("Quarter'"); break;

The other method 1s to put the statements under the case label, indenting the
statements to make the case label stand out:

switch (coin) (

case 1l:
print£ ("Cent") ;
break;

case 5:
print£ ("Nickel") ;
break ;

case 10:
print£f ("Dime") ;
break;

case 25:
print£ ("Quarter") ;
break ;

}

In one variation of this scheme, each case label is aligned under the word switch.

The first method 1s fine when the statements in each case are short and there
are relatively few of them. The second method is better for large switch state-
ments in which the statements in each case are complex and/or numerous.

Exercises

The following program fragments illustrate the relational and equality operators. Show the
output produced by each, assuming that i, j. and k are int variables.
(a) i = 2; j = 3;
k = 1 * ] == 6;
printf ("#d", kK);
(b) i = 5; j = 10; k =
print£("%d", k > i
(c) i = 3; j = 2; K = 1;
print£f ("%d", }
(d) i = 3; j = 4; k = 5;
print£ ("$d", i % j + i < k);

***************************page_119***************************
94 Chapter5 Selection Statements

@ 2. The following program fragments illustrate the logical operators. Show the output produced
by cach, assuming that i, j, and k are int variables.

(a) ù = 10; j = 5;

printf("%d", !i < j);
(b) i = 2; j = 1;
printf("%ad", !!i + !5);

(c) à = 5; j = 0; k = -5;
printf("%d", i && j || Kk);

(d) à = 1; j = 2; k = 3;
printf£("%d", i < j || k);

#3. — The following program fragments illustrate the short-circuit behavior of logical expressions.
Show the output produced by cach, assuming that i, j. and k are int variables.

(a) 1 = 3; 3 = 4; k = 5;
printf("%d ", i < } || ++j < K);
print£ ("%d %d %d", i, j, kK) ;

(b) i = 7; j = 8; k = 9;

printf("%d "
print£ ("%d
(c) i = 7; j

k

i - 7 && j++ < k);
gd", i, j, k);
k

(

œ c
Q

9 .

!

printf("%d ", (i = j) || ( = K)) ;
printf("%d %d %d", i, ], kK);

(d) i = 1; j = 1; k = 1;
print£("%d ", ++i || ++j && ++k) ;
print£f ("%d %d %*d", i, j, k);

@ #4. Write a single expression whose value is cither —!, O, or +1, depending on whether i is less
than, equal to, or greater than j. respectively.

Section 5.2 *5, Is the following i £ statement legal?

if (n >= 1 <= 10)
print£f("n is between 1 and 10\n") ;

If so. what does it do when n is equal to 0°?

@ #6. 1s the following i £ statement legal?

if (n == 1-10)
printf("n is between 1 and 10\n") ;

If so, what docs it do when n 1s equal to 5°

7.  What does the following statement print if à has the value 17? What does it print if à has the
value —17?

printf£f("%d\n", i >= 0 ? i : -i);

8.  The following i £ statement is unnecessarily complicated. Simplify it as much as possible.
(Hint: The entire statement can be replaced by a single assignment.)

if (age >= 13)
if (age <= 19)
teenager = true;
else
teenager = false;
else if (age < 13)
teenager = false;

***************************page_120***************************
Section 5.3

D*10.

|l.

Programming Projects 95

Âre the following i £ statements equivalent? Tf not, why not?

LËÉ (score >= 90)
print£ ("A") ;

else if (score >= 80)
print£f("B") ;

else if (score >= ”70)
printf ("C") ;

else if (score >= 60)
print£ ("D") ;

else
print£f("F") ;

if (score < 60)
print£f("F") ;

else if (score < ”70)
printf ("D") ;

else if (score < 80)
printf ("C") ;

else if (score < 90)
print£ ("B") ;

else
print£ ("A") ;

What output does the following program fragment produce? (Assume that i is an integer
variable.)

i = 1;

switch (i % 3) |
case 0: printf ("zero") ;
case 1: printf ("one") ;
case 2: printf ("two") ;

}

The following table shows telephone arca codes in the state of Georgia along with the larg-
est city in each area:

Areacode = Major city
229 Albany
404 Atlanta
470 Atlanta
478 Macon
678 Atlanta
706 Columbus
162 Columbus
710 Atlanta
912 Savannah

Write a switch statement whose controlling expression is the variable area_code. If the
value of area_code 1s in the table, the switch statement will print the corresponding
city name. Otherwise, the switch statement will display the message "Area code not
recognized". Use the techniques discussed in Section 5.3 to make the switch state-
ment as simple as possible.

Programming Projects

Write a program that calculates how many digits a number contains:

Enter a number: 374
The number 374 has 3 digits

You may assume that the number has no more than four digits. Hint: Use i£ statements to
test the number. For example, if the number is between O and 9, it has one digit. If the num-
ber is between 10 and 99, it has two dieits.

***************************page_121***************************
96

Chapter5  Selection Statemenis

© 2

à

Write a program that asks the user for à 24-hour time, then displays the time in |2-hour
form:

Enter a 24-hour time: 21:11
Equivalent 12-hour time: 9:11 PM

Be careful not to display 12:00 as 0:00.

Modify the broker . c program of Section 5.2 by making both of the following changes:

(a) Ask the user to enter the number of shares and the price per share, instead of the value
of the trade.

(b) Add statements that compute the commission charged by a rival broker ($33 plus 3é per

share for fewer than 2000 shares: S33 plus 2€ per share for 2000 shares or more). Dis-
play the rival's commission as well as the commission charged by the original broker.

Here’s a simplified version of the Beaufort scale, which is used to estimate wind force:

Speed (Kknois) Description
Less than | Calm

1-3 Light air
427 Breeze
2847 Gale
45—63 Storm
Above 63 Hurricane

Write à program that asks the user to enter a wind speed (in knots), then displays the corre-
sponding description.

In one state. single residents are subject to the following income tax:

Income Amount of tax
Not over $750 !% of income
$750-52,250 57.50 — plus 2% of amount over $750

$2.250-$3.750 $37.50 — plus 3% of amount over S2.250
$3.750-$5.250 $82.50 — plus 4% of amount over $3,750
$5,250-57,000 $142.50 plus 5% of amount over S5.250
Over $7,000 $230.00 plus 6% of amount over $7,000

Write a program that asks the user to enter the amount of taxable income. then displays the
lax due.

Modify the upc. c program of Section 4.1 so that it checks whether a UPC is valid. After
the user enters a UPC, the program will display either VALID or NOT VALID.

Write a program that finds the largest and smallest of four integers entered by the user:

Enter four integers: 21 43 10 35
Largest: 43
Smallest: 10

 

Use as few if statements as possible. Hint: Four i £ statements are sufficient.

The following table shows the daily flights from one city to another:

Departure time Arrival time
5:00 a.m. 10:16 a.m.
9:43 a.m. |1:52 a.m.

11:19 a.m. 1:31 p.m.

12:47 p.m. 3:00 p.m.

***************************page_122***************************
@ 10.

ll.

Programming Projects 97

2:00 p.m. 4+:08 p.m.
3:45 p.m. 5:55 p.m.
7:00 p.m. 9:20 p.m.
9:45 p.m. 11:58 p.m.

Write à program that asks user to enter a time (expressed in hours and minutes, using the 24-
hour clock). The program then displays the departure and arrival times for the Might whose
departure time is closest to that entered by the user:

Enter a 24-hour time: 13:15
Closest departure time is 12:47 p.m., arriving at 3:00 p.m.

Hint: Convert the input inlo à time expressed in minutes since midnight. and compare it to
the departure times, also expressed in minutes since midnight. For example, 13:15 is 13 x
60 + 15 = 795 minutes since midnight, which is closer to 12:47 p.m. (767 minutes since
midnight) than to any of the other departure times.

Write a program that prompts the user to enter two dates and then indicates which date
comes earlier on the calendar:

Enter first date (mm/dd/yy): 3/6/08
Enter second date (mm/dd/yy) : 5/17/07
5/17/07 is earlier than 3/6/08

Using the switch statement. write a program that converts a numerical grade into a letter
grade:

Enter numerical grade: 84
Letter grade: B

Use the following grading scale: À = 90-100, B = 80-89, C = 70-79, D = 60-69. F = 0-59.
Print an error message if the grade is larger than 100 or less than O. Hint: Break the grade
into two digits, then use a switch statement to test the ten’s digit.

Write a program that asks the user for a two-digit number. then prints the English word for
the number:

Enter a two-digit number: 45
You entered the number forty-five.

Hint: Break the numnber into two digits. Use one switch statement to print the word for the
first digit (“twenty” “thirty,” and so forth). Use a second switch statement to print the
word for the second digit. Don’t forget that the numbers between !! and 19 require special
treatment.

***************************page_123***************************

***************************page_124***************************
G Loops

À program without a loop and a structured
variable isn’t worth writing.

Chapter 5 covered C”s selection statements, i£ and switch. This chapter intro-
duces C's iteration statements, which allow us to set up loops.

À loop 1s a statement whose job is to repeatedly execute some other statement
(the loop body). In C, every loop has a controlling expression. Each time the loop
body is executed (an iteration of the loop), the controlling expression is evaluated:;
if the expression is true—has a value that’s not zero—the loop continues to exe-
cute.

 

The last two sections of this chapter are devoted to C features that are used in
conjunction with loops. Section 6.4 describes the break, continue. and goto

 
 

Stalements.

any statement within afunction. Section 6.5 covers the null statement, which can

be used to create loops with empty bodies.

 
 
   

6.1 The while Statement

Of all the ways to set up loops in C, the while statement is the simplest and most
fundamental. The while statement has the form

99

***************************page_125***************************
100

Chapter6 Loops

while statement

compound statements » 5.2

while ( expression ) statement

The expression inside the parentheses 1s the controlling expression, the statement
after the parentheses 1s the loop body. Here’s an example:

while (i < n) /* controlling expression */
i = i * 2; /* loop body */

Note that the parentheses are mandatory and that nothing goes between the right
parenthesis and the loop body. (Some languages require the word do.)

When à while statement is executed. the controlling expression is evaluated
first. IF its value is nonzero (true), the loop body is executed and the expression is
tested again. The process continues in this fashion—first testing the controlling
expression, then executing the loop body—until the controlling expression eventu-
ally has the value zero.

The following example uses a while statement to compute the smallest
power of 2 that is greater than or equal to a number n:

i = 1;
while (i < n)
ài = à * 2;

Suppose that n has the value 10. The following trace shows what happens when
the while statement 1s executed:

; =1; i isnow l.
Is i < n’ Yes: continue.
i =i *2; iisnow2.

Is i < n’ Yes; continue.
i =i *2; iisnowd4.
Is ài < n’ Yes; continue.

i=i*2; iisnowB.

Is i < n’ Yes; continue.

i =i *2; iisnow 6.

Is i <n°’ No; exit from loop.

Notice how the loop keeps going as long as the controlling expression (i < n) is
true. When the expression is false, the loop terminates, and i is greater than or
equal to n, as desired.

Although the loop body must be a single statement, that's merely a technical-
ity. If we want more than one statement, we can just use braces to create a single
compound statement:

while (i > O) {
printf ("T minus %d and counting\n", i);
i--;

}

***************************page_126***************************
QaÂ

idiom

6.1  The while Statement 101

Some programmers always use braces, even when they're not strictly necessary:

while (i < n) ({ /* braces allowed, but not required */
i = à * 2;

}

Âs a second example, let’s trace the execution of the following statements.
which display a series of ‘“countdown” messages:

i = 10;

while (i > O) |
printf ("T minus %d and counting\n", i);
i--;

}

Before the while statement is executed, the variable i is assigned the value 10.
Since 10 is greater than O, the loop body is executed, causing the message T
minus 10 and counting to be printed and i to be decremented. The condition
i > O 1s then tested again. Since 9 is greater than O, the loop body is executed once
more. This process continues until the message T minus 1 and counting is
printed and i becomes 0. The test i > O then fails. causing the loop to terminate.

The countdown example leads us to make several observations about the
while statement:

u The controlling expression is false when a while loop terminates. Thus,
when a loop controlled by the expression i > O terminates, L must be less than
or equal to 0. (Otherwise, we’d still be executing the loop!)

u The body of a while loop may not be executed at all. Since the controlling
expression is tested before the loop body is executed, it‘s possible that the
body isn’t executed even once. If i has a negative or zero value when the
countdown loop 1s first entered, the loop will do nothing.

u À while statement can often be written in a variety of ways. For example, we
could make the countdown loop more concise by decrementing i inside the
call of print£:

while (i > O)
printf ("T minus %d and counting\n", i--);

Infinite Loops

À while statement won’t terminate if the controlling expression always has a
nonzero value. In fact, C programmers sometimes deliberately create an infinite
loop by using a nonzero constant as the controlling expression:

while (1)

A while statement of this form will execute forever unless its body contains a
statement that transfers control out of the loop (break, goto, return) or calls a
function that causes the program to terminate.

***************************page_127***************************
 

102

Chapter6 Loops

PROGRAM

square.c

PROGRAM

Printing a Table of Squares

Let’s write a program that prints a table of squares. The program will first prompt
the user to enter a number ». It will then print n lines of output, with each line con-
taining a number between ! and n together with its square:

This program prints a table of squares.
Enter number of entries in table: S

l 1
2 4
3 9
à 16
5 25

Let’s have the program store the desired number of squares in a variable
named n. We'11 need a loop that repeatedly prints a number i and its square, start-
ing with i equal to !. The loop will repeat as long as à is less than or equal to n.
We'1l have to make sure to add ! to i each time through the loop.

We’1l write the loop as a while statement. (Frankly, we haven’1 got much
choice, since the while statement is the only kind of loop we’ve covered so far.)
Here's the finished program:

/* Prints a table of squares using a while statement */
#include <stdio.h>

int main (void)

(

int i, n;

printf("This program prints a table of squares.\n") ;
print£f ("Enter number of entries in table: ");
scanf ("3d", &n) ;

Ll = 1;

while (i <= n) |
print£f("%10d%10d\n", i, i * i);
i++;

}

return Q0;

Note how square. c displays numbers in neatly aligned columns. The trick
is to use a conversion specification like %10d instead of just d, taking advantage
of the fact that print£ right-justifies numbers when a field width is specified.

Summing a Series of Numbers

As a second example of the while statement, let’s write a program that sums a
scries of integers entered by the user. Here’s what the user will see:

***************************page_128***************************
6.2  The do Statement 103

This program sums a series of integers.
Enter integers (0 to terminate): 8 23 71 S O
The sum is: 107

 

Clearly we’ll need a loop that uses scanf to read a number and then adds the
number to a running total.

Letting n represent the number just read and sum the total of all numbers pre-
viously read, we end up with the following program:

sum.c /* Sums a series of numbers */
#Hinclude <stdio.h>
int maiîin(void)

int n, sum = O0;

print£f ("This program sums a series of integers.\n") ;
printf ("Enter integers (0 to terminate) : ");

scanf ("%d", &n) ;

while (n != 0) {
sum += n;
scanf ("$d", &n) ;
}

printf ("The sum is: %d\n", sum) ;

return 0;

}

Notice that the condition n ! = O 1s tested just after a number is read, allowing the
loop to terminate as soon as possible. Also note that there are two identical calls of
scan£, which is often hard to avoid when using while loops.

6.2

do statement

 

***************************page_129***************************
 

104

Chapter 6

PROGRAM

Let’s rewrite the countdown example of Section 6.1, using a do statement this
time:

 

, Since 9 is greater than O, the loop body 1s exe-
cuted a second time. This process continues until the message T minus 1 and
counting is printed and i becomes 0. The test i > O now fails, causing the loop

to terminate. As this example shows, AH&TeIS/SmrEmEN TIS OEn iNaisEinEsrbe

 

do
print£f("T minus %d and counting\n", i--);
while (i > O);

À careless reader might think that the word while was the beginning of a while
statement.

Calculating the Number of Digits in an Integer

Although the while statement appears in C programs much more often than the
do statement, the latter is handy for loops that must execute at least once. To illus-
trate this point, let’s write a program that calculates the number of digits in an inte-
ger entered by the user:

Enter a nonnegative integer: 60
The number has 2 digit(s).

Our strategy will be to divide the user’s input by 10 repeatedly until 1
becomes 0; the number of divisions performed is the number of digits. Clearly
we’1! need some kind of loop, since we don°t know how many divisions it will take
to reach 0. But should we use a while statement or a do statement’ The do state-
ment turns out to be more attractive, because every integer—even O—has at least
one digit. Here’s the program:

 

***************************page_130***************************
6.3  The for Sitatement 105

numdigits.c _ /* Calculates the number of digits in an integer */
#include <stdio.h>

inct maiîn(void)

{

int digits = O, n;

printf ("Enter a nonnegative integer: ");
scanf ("%d", &n) ;

do {
n /= 10;
digits++;

} while (n > O);

print£f ("The number has %d digit (s).\n", digits) ;

return 0;

 

We now come to the last of C’s loops: the For statement. Don’t be discouraged by
the for statement’s apparent complexity; it’s actually the best way to write many
loops. The £or statement is idcal for loops that have a “countine” variable, but it’s
versatile enough to be used for other kinds of loops as well.

for statement

 

When this £or statement is executed, the variable i is initialized to 10, then i is
tested to see if it’s greater than O. Since it is, the message T minus 10 and

***************************page_131***************************
106

Chapter 6 Loops

Q&ÂÀ

counting 1s printed, then i is decremented. The condition i > O is then tested
again. The loop body will be executed 10 times in all, with i varyine from 10
down to |.

The for statement is closely related to the while statement. In fact, except
in a few rare cases, a for loop can always be replaced by an equivalent while
loop:

exprl ;

while ( expr2 ) |
statement
expr3 ;

}

Às this pattern shows, expr/ is an initialization step that’s performed only once.
before the loop begins to execute, expr2 controls loop termination (the loop contin-
ues executing as long as the value of expr2 is nonzero), and expr3 is an operation
to be performed at the end of each loop iteration. Applying this pattern to our pre-
vious £or loop example, we arrive at the following:

i = 10;

while (i > O) |
printf ("T minus %d and counting\n", i);
i--;

}

Studying the equivalent while statement can help us understand the fine
points of a £or statement. For example, suppose that we replace i-- by --i in
our £or loop example:

for (i = 10; i > O; --i)
print£f("T minus %d and counting\n", i);

How does this change affect the loop? Looking at the equivalent while loop, we
see that it has no effect:

i = 10;

while (i > 0O) |
printf ("T minus %d and counting\n", i);
--j;

}

Since the first and third expressions in a for statement are executed as statements,
their values are irrelevant—they*re useful only for their side effects. Consequently,
these two expressions are usually assignments or increment/decrement expres-
sions.

for Statement Idioms

The £or statement is usually the best choice for loops that “count up” (increment
a variable) or ‘‘count down” (decrement a variable). À for statement that counts
up or down a total of n times will usually have one of the following forms:

***************************page_132***************************
6.3  The for Sitatement 107

= Counting up from 0 to n-1:
idiom for (i = O0; i < n; i++)
= Counting up fron 1 ton:
idiom for (i = 1; i <= n; i++)
= Counting down from nl to 0:
idiom for (i=n-1; i >= 0; i--)
= Counting down from n to 1:
idiom for (i = n; 1 > 0O; i--)

Imitating these patterns will help you avoid some of the following errors,
which beginning C programmers often make:

u Using < instead of > (or vice versa) in the controlling expression. Notice that
“counting up” loops use the < or <= operator, while “counting down” loops
rely on > Or >=.

u Using == in the controlling expression instead of <, <=. >, Or >=. À control-
ling expression needs to be true at the beginning of the loop, then later become
false so that the loop can terminate. À test such as i == n doesn’t make much
sense, because it won°t be true initially.

m ‘“Off-by-one” errors such as writing the controlling expression as i <= n
instead of i < n.

 

***************************page_133***************************
108

Chapier6 Loops

Qa&A

idiom

To compensate for omitting the third expression, we’ve arranged for i to be decre-
mented inside the loop body.

 

@ŒD  for Statements in C99

In C99, the first expression in a £or statement can be replaced by a declaration.
This feature allows the programmer to declare a variable for use by the loop:

for (int i = O; i < n; i++)

The variable i need not have been declared prior to this statement. (In fact, if a
declaration of i already exists, this statement creates a new version of i that will
be used solely within the loop.)

À variable declared by a £or statement can*t be accessed outside the body of
the loop (we say that it’s not visible outside the loop):

for (int i = 0; i < n; i++) |

praint£("%d", i); /* legal; i is visible inside loop */
}
printf("%d", i): /-k*—k WRONG ***/

Having a £or statement declare its own control variable is usually a good
idea: it’s convenient and it can make programs easier to understand. However, if
the program needs to access the variable after loop termination, it’s necessary to
use the older form of the £for statement.

Incidentally, a £or statement may declare more than one variable, provided
that all variables have the same type:

for (int à = O, j = 0; i < n; i++)

***************************page_134***************************
comma expression

macro definitions > 74.3

 

6.3  The for Statement 109

The Comma Operator

On occasion, we might like to write a £or statement with two (or more) initializa-
tion expressions or one that increments several variables each time through the
loop. We can do this by using a commma expression as the first or third expression
inthe £or statement.

À comma expression has the form

expril , expr2

where expr/ and expr2 are any two expressions. À comma expression is evaluated
in two steps: First, expr/ is evaluated and its value discarded. Second, expr2 is
evaluated; its value is the value of the entire expression. Evaluating expr/ should
always have a side effect; if it doesn°t. then expr/ serves no purpose.

For example. suppose that à and j have the values ! and 5, respectively. When
the comma expression ++i, i + j is evaluated, i is first incremented, then i + j
is evaluated, so the value of the expression is 7. (And, of course. i now has the
value 2.) The precedence of the comma operator is less than that of all other opera-
tors, by the way, so there’s no need to put parentheses around ++i and i + j.

Occasionally, we'Il need to chain together a series of comma expressions, just
as we sometimes chain assignments together. The comma operator is left associa-
tive, so the compiler interprets

((à = 1), G = 2)), (K = (i + j))

Since the left operand in a comma expression is evaluated before the right operand.
the assignments i = 1, j = 2, and k = i + j will be performed from left to right.

The comma operator is provided for situations where C requires a single
expression, but we’d like to have two or imore expressions. In other words, the
comma operator allows us to “glue” two expressions together to form a single
expression. (Note the similarity to the compound statement, which allows us to
treat a group of statements as a single statement.)

The need to glue expressions together doesn’t arise that often. Certain macro
definitions can benefit from the comma operator, as we’Il see in a later chapter.
The for statement 1s the only other place where the comma operator is likely to be
found. For example, suppose that we want to initialize two variables when entering
a for statement. Instead of writing
sum = 0;
for (i = 1; l <= N; i++)

sum += i;

we can write

***************************page_135***************************
110

Chapter6 Loops

PROGRAM

square2.c

square3.c

for (sum = O, i = 1; i <= N; i+<)
sum += i;

The expression sum = O, i = 1 first assigns O to sum, then assigns 1 to i. With
additional commas, the £or statement could initialize more than two variables.

Printing a Table of Squares (Revisited)

The square. c program (Section 6.1) can be improved by converting its while
loop to a £or loop:

/* Prints a table of squares using a for statement */
#include <stdio.h>

int main (void)

{

int i, n;

print£ ("This program prints a table of squares.\n") ;
printf ("Enter number of entries in table: "),
scanf ("$d", &n);

Éor (i = 1; i <= n; i++)
printf("310d%10d\n", i, i * i),

return 0;

We can use this program to illustrate an important point about the for state-
ment: C places no restrictions on the three expressions that control its behavior.
Although these expressions usually initialize, test, and update the same variable.
there's no requirement that they be related in any way. Consider the following ver-
sion of the same program:

/* Prints a table of squares using an odd method */
#include <stdio.h>

int main(void)

(

int i, n, odd, square;

print£("This program prints a table of squares.\n") ;
print£ ("Enter number of entries in table: "),
scanf ("3d", &n}) ;

i = 1;

odd = 3;

for (square = 1; i <= n; odd += 2) |{
print£ ("%10d%10d\n", i, square) ;
++i;

***************************page_136***************************
linked lists » 77,5

6.4

6.4 Exiting from a Loop 111

square += odd;

}

return 0;

}

The for statement in this program initializes one variable (square), tests
another (i), and increments a third (odd). i 1s the number to be squared, square
is the square of i, and odd is the odd number that must be added to the current
square to get the next square (allowing the program to compute consecutive
squares without performing any multiplications).

The tremendous flexibility of the £or statement can sometimes be useful;
we’1l find it to be a great help when working with linked lists. The for statement
can easily be misused, though, so don’t go overboard. The for loop in
square3 .c would be a lot clearer if we rearranged its pieces so that the loop 1s
clearly controlled by i.

Exiting from a Loop

We*ve seen how to write loops that have an exit point before the loop body (using
while and for statements) or after it (using do statements). Occasionally, how-

ever, we’Il need a loop with an exit point in the middle. We may even want à loop

 

The break Statement

We've already discussed how a break stalement can transfer control out of a
switch statement. The break statement can also be used to jump out of a
while, do, or £or loop.

Suppose that we're writing a program that checks whether a number n is
prime. Our plan is to write a for statement that divides n by the numbers between
2 and n —- !. We should break out of the loop as soon as any divisor is found;
there’s no need to try the remaining possibilities. After the loop has terminated, we
can use an i f statement to determine whether termination was premature (hence n
isn’t prime) or normal (n is prime):

for (d = 2; d < n; d++)
if (n % == 0)
break ;

***************************page_137***************************
112 Chapter6 Loops

if (d < n)
print£("%d is divisible by gd\n', n, d);
else

print£f("%d is prime\n", n) ;

The break statement is particularly usefu! for writing loops in which the exit
point is in the middle of the body rather than at the beginning or end. Loops that
read user input, terminating when a particular value is entered. often fall into this
category:

for (;;) {
printf ("Enter a number (enter O to stop): ");
scanf ("d", &n) ;
if (n == O)
break ;
printf£f ("%d cubed is %d\n"', n, n * n * n});

)

 

The continue Statement

The continue statement doesn’t really belong here, because it doesn’t exit from
a loop. lt’s similar to break. though, so its inclusion in this section isn*L com-
pletely arbitrary. break transfers control just past the end of a loop., while
continue transfers control to à point just before the end of the loop body. With
break, control leaves the loop; with cont inue, control remains inside the loop.
There's another difference between break and continue: break can be used
in switch statements and loops (while, do, and for), whereas continue is
limited to loops.

The following example, which reads a series of numbers and compules their
sum, illustrates a simple use of cont inue. The loop terminates when 10 nonzero
numbers have been read. Whenever the number O is read. the continue state-
ment is executed, skipping the rest of the loop body (the statements sum += i ;
and n++ ; ) but remaining inside the loop.

***************************page_138***************************
6.4  Exiting from a Loop 113

n = 0;

sum = Q0;

while (n < 10) |
scan£("%$d", &i) ;

L£ (i == O)

continue ;
sum += ji;
n++;

/* continue jumps to here */

}

If continue were not available, we could have written the example as follows:

n = 0;
sum = O0;
vhile (n < 10) {
scanf ("td", &i);
if (i != O) |
sum += i;
n++ ;

)
|

@

variable-length arrays > 8.3

labeled statement

goto statement

 

If C didn’t have a break statement, here’s how we might use a goto state-
ment Lo exit prematurely from a loop:

for (d = 2; d < n; d++)
if (n Ÿ d == O)
goto done ;

***************************page_139***************************
114

Chaptier6 Loops

QaÂ

exit function » 9.5

PROGRAM

done :
if (d < n})

print£f("%d is divisible by $d\n"', n, d);
else

printf("%d is prime\n", n) ;

 

Balancing a Checkbook

Many simple interactive programs are menu-based: they present the user with a list
of commands to choose from. Once the user has selected a command. the program
performs the desired action, then prompts the user For another command. This pro-
cess continues until the user selects an “exit” or “quit” command.

The heart of such a program will obviously be a loop. Inside the loop will be
statements that prompt the user for a command, read the command, then decide
what action to take:

for (;;) |
prompt user to enter command ;
read command ;
execute command ;

}

Executing the command will require a switch statement (or cascaded i £ state-
ment):

for (;;) {
prompt user to enter command ;
read command ;
switch (connnand) {
case command,: perform operation,; break;

***************************page_140***************************
checking.c

6.4  Exiting from a Loop 115

case command, : perform operation,; break;

case command,: perform operation,; break;
default: print error message ; break;

}
}

To illustrate this arrangement, let’s develop a program that maintains a check-
book balance. The program will offer the user a menu of choices: clear the account
balance, credit money to the account, debit money from the account, display the
current balance, and exit the program. The choices are represented by the integers
O, 1. 2,. 3, and 4, respectively. Here’s what a session with the program will look
like:

*** ACME checkbook-balancing program ***
Commands: O=clear, 1=credit, 2=debit, 3=balance, 4=exit

Enter command: 1

Enter amount of credit: 1042.56
Enter command: 2

Enter amount of debit: 133.79
Enter command: 1

Enter amount of credit: 1754.32
Enter command: 2

Enter amount of debit: 1400
Enter command: 2

Enter amount of debit: 68

Enter command: 2

Enter amount of debit: 50

Enter command: 3

Current balance: $1145.09

Enter command: 4

 

When the user enters the command 4 (exit), the program needs to exit from the
switch statement and the surrounding loop. The break statement won’t help,
and we’d prefer not to use a goto statement. Instead. we’1l have the program exe-
cute a return statement, which will cause the main function to return to the
operating system.

/* Balances a checkbook */
#include <stdio.h>

int maiïn(void)
{
int cmd;
float balance = O.0f, credit, debit;

print£f ("*** ACME checkbook-balancing program *#**\n") ;
print£ ("Commands: O=clear, 1=credit, 2=debit, ") ;
print£ ("3=balance, 4=exit\n\n") ;

***************************page_141***************************
 

 

116 Chapter6&6 Loops

for (;:) |
printf ("Enter command: ") ;
scanf ("*d", &cmd) ;
switch (cmd) {

case Ô0:
balance = O.OÉ;
break ;
case l:
printf ("Enter amount of credit: ") ;

scanf ("%f", &credit) ;
balance += credit;
break;

case 2:
printf ("Enter amount of debit: ");
scanf ("%*£", &debit) ;
balance -= debit;
break ;

case 3:
print£ ("Current balance: $%.2f\n", balance) ;
break;

case 4:
return 0;

default :
printf ("Commands: O=clear, 1=credit, 2=debit, ") ;
printf ("3=balance, 4=exit\n\n") ;
break;

}
}

}

Note that the return statement is not followced by a break statement. À break
immediately following a return can never be executed. and many compilers will
ISsue à warning message.

6.5

eF 4 e

 

***************************page_142***************************
6.5  The Null Statement 117

reading characters » 7.3

/

 

***************************page_143***************************
118

Chapter6 Loops

 

 

Q&A

 

Q:  Section 6.3 says that, except in rare cases, £or loops can be converted to

while loops using a standard pattern. Can you give an example of such a
case? [p. 106]

***************************page_144***************************
> .&

Q & À 119

When the body of a £or loop contains a continue statement, the while pat-
tern shown in Section 6.3 is no longer valid. Consider the following example from
Section 6.4:

n = 0;

sum = OD;

while (n < 10) |
scanf£ ("%d"', &i) ;
if (i == O)

continue ;

sum += i;
n++;

}

At first glance, it looks as though we could convert the while loop into a £or
loop:

sum = O0;
fFor (n = 0; n < 10; n++) |
scanf ("$d", &i) ;
if (i == O)
continue ;
sum += i;

}

Unfortunately, this loop isn’t equivalent to the original. When i 1s equal to O. the
original loop doesn’t increment n. but the new loop does.

Which form of infinite loop is preferable, while (1) or £or (; ; ) ? [p. 108]

C programmers have traditionally preferred for (; ; ) for reasons of efficiency;
older compilers would often force programs to test the 1 condition each time
through the while loop. With modern compilers, however, there should be no dif-
ference in performance.

l’ve heard that programmers should never use the continue statement. Is
this true?

It’s true that continue statements are rare. Still, continue 1s handy once in a
while. Suppose we’re writing a loop that reads some input data, checks that 1t’s
valid, and, if so, processes the input in some way. If there are a number of validity
tests, or 1f they’re complex, continue can be helpful. The loop would look
something like this:

for (;;) |{
read data ;
Lf£ (data fails first test)
continue ;
if (data fails second test)
continue ;

***************************page_145***************************
120 Chapter6 Loops

if (data fails last test)
continue ;
process data ;

}

 

Q: Does the null statement have any uses besides indicating that the body of a
loop is empty? [p. 116]

A:  Very few. Since the null statement can appear wherever a statement is allowed,
there are many potential uses for the null statement. In practice. however, there’s
only one other use of the null statement, and it’s rare.

Suppose that we need to put a label at the end of a compound statement. A
label can’t stand alone: it must always be followed by a statement. Puttins a null
statement after the label solves the problem:

{

goto end of stmt;

end _of stmt: ;

}

Q:  Are there any other ways to make an empty loop body stand out besides put-
ting the null statement on a line by itself? [p. 1171

À: _ Some programmers use a dummy continue statement:

for (d = 2; d < n & n % d != 0O0; d++)
continue ;

Others use an empty compound statement:

for (d = 2; d<n& n %d'!= 0; d++)

O

***************************page_146***************************
Section 6.1 [.

Section 6.2

Section 6.3 *3,

*8,

0.

Section 6.4 @ 10.

|!.

ID

Exercises 121

Exercises

What output does the following program fragment produce?

i = 1;

while (i <= 128) Ç{
print£("%d ", i);
i *= 2;

}

What output does the following program fragment produce”

i = 9384;

do {
print£("%d ", i);
i /= 10;

} while (i > O);

What output does the following £or statement produce?
for (i = 5, j = i - 1; i > O, j > O; --i, j = i - 1)
printf("%d ", i);

Which one of the following statements is not equivalent to the other two (assuming that the
loop bodies are the same)?

(a) for (i = O; i < 10; i++)
(b) for (i = O; i < 10; ++i)
(c) for (i = 0O; i++ < 10; )

Which one of the following statements is not equivalent to the other two (assuming that the
loop bodies are the same)?

(a) while (i < 10) (...}
(b) £or (; i < 10;) {.….}
(c) do {...} while (i < 10);

Translate the program fragment of Exercise | into à sinele For statement.
Transtate the program fragment of Exercise 2 into à single £or statement.

What output does the following Éor statement produce?

f£or (i = 10; i >= 1; i /= 2)
print£f("%d ", i++);

Translate the for statement of Exercise 8 into an equivalent while statement. You will
neecl one statement in addition to the while loop itself.

Show how to replace à continue statement bv an equivalent aoto statement.
; ] g

What output does the following program fragment produce?

***************************page_147***************************
122 Chapter6 Loops

Section 6.5 *13,

sum = 0;
for (i = 0; i < 10; i++) (
i£f (i % 2)
continue;
sum += i;

}

print£ ("d\n", sum) ;

The following “prime-testing” loop appeared in Section 6.4 as an example:
for (àd = 2; à < n; d++)
if (n % d == O)
break ;
This loop isn’t very efficient. Its not necessary to divide n by all numbers between 2 and
n — | to determine whether it’s prime. In fact, we need only check divisors up to the square

root of n. Modify the loop to take advantage of this fact. Hint: Don't try to compute the
square root of n; instead, compare d * d with n.

Rewrite the following loop so that its body is empty:

for (n 0; m > 0; n++)

m /= 2;
Find the error in the fotlowing program fragment and fix it.

if (n % 2 == 0O);
printf ("n is even\n") ;

Programming Projects

Write a program that finds the largest in à series of numbers entered by the user. The pro-
gram must prompt the user to enter numbers one by one. When the user enters O or a nega-
tive number, the program must display the largest nonnegative number entered:

Enter a number: 60

Enter a number: 38.33
Enter a number: 4.89
Enter a number: 100.62
Enter a number: 75.2295
Enter a number: O

The largest number entered was 100.62

Notice that the numbers aren’t necessarily integers.

Write a program that asks the user to enter two integers, then calculates and displays their
greatest common divisor (GCD):

Enter two integers: 12 28
Greatest common divisor: 4

Hint: The classic algorithm for computing the GCD, known as Euclid’s algorithm, goes as
follows: Let m and n be variables containing the two numbers. Tf n is O, then stop: m con-
tains the GCD. Otherwise, compute the remainder when m is divided by n. Copy n into m
and copy the remainder into n. Then repeat the process, starting with testing whether n is O.

***************************page_148***************************
_Ul

6.

Programming Projects 123

Write a program that asks the user to enter a fraction. then reduces the fraction to lowest
terms:

Enter a fraction: 6/12
In lowest terms: 1/2

 

Hint: To reduce a fraction to lowest terms. first compute the GCD of the numerator and
denominator. Then divide both the numerator and denominator by the GCD.

Add a toop to the broker .c program of Section 5.2 so that the user can enter more than
one trade and the program will calculate the commission on each. The program should ter-
minate when the user enters O as the trade value:

Enter value of trade: 30000
Commission: S166.00

Enter value of trade: 20000
Commission: $144.00

Enter value of trade: O

Programming Project | in Chapter 4 asked you to write a program that displays a two-digit
number with its digits reversed. Generalize the program so that the number can have one,
two, three, or more digits. Hinr: Use a do loop that repeatedly divides the number by 10,
stopping when it reaches O.

Write a program that prompts the user to enter a number n. then prints all even squares
between | and n. For example, if the user enters 100, the program should print the follow-

ing:
4
16
36

64
100

Rearrange the square3 .c program so that the £or loop initializes i, tests i, and incre-
ments i. Don't rewrite the program; in particular, don’t use any multiplications.

Write a program that prints a one-month calendar. The user specifies the number of days in
the month and the day of the week on which the month begins:

Enter number of days in month: 31
Enter starting day of the week (1=Sun, 7=Sat): 3

1 2 3 & 5

6 7 8 S 10 11 12

13 14 15 16 17 18 19

20 21 22 23 24 25 26
27 28 29 30 31

Hint: This program isn’t as hard as it looks. The most important part is a for statement that
uses a variable i to count from ! to n, where n is the number of days in the month, printing
each value of i. Inside the loop, an i £ statement tests whether i is the last day in a week: if
so. 1t prints a new-line character.

Programming Project 8 in Chapter 2 asked you to write a program that calculates the
remaining balance on à loan after the first, second, and third monthly payments. Modify the
program so that it also asks the user to enter the number of payments and then displays the
balance remaining after each of these payments.

***************************page_149***************************
124

Chapter6 Loops

10.

|l.

12.

Programming Project 9 in Chapter 5 asked you to write a program that determines which of
two dates comes earlier on the calendar. Generalize the program so that the user may enter
any number of dates. The user will enter 0/0/0 to indicate that no more dates will be entered:

Enter
Enter
Enter
Enter

a
a
a
a

5/17/07

date (mm/dd/vy) : 3/6/08
date (mm/dd/yy): 5/17/07
date (mm/dd/yy) : 6/3/07
date (mm/dd/yy) : 0/0/0
is the earliest date

The value of the mathematical constant e can be expressed as an infinite series:
e=l+1/1!+1/2!+1/31 + ….

Write a program that approximates e by computing the value of

1+1/1!+ 1221 + 1/31 4 . + Vn!

where » is an integer entcred by the user.

Modify Programming Project 11 so that the program continues adding terms until the cur-
rent term becomes less than €, where € is a small (Moating-point) number entered by the

USEr.

***************************page_150***************************
7

fA

 

Basic Types

Make no mistake about it: Computers process numbers—
not symbols. We measure our understanding (and control)
by the extent to which we can arithmetize an activity.

So far, we’ve used only two of C’s basic (built-in) types: int and float. (We've
also seen _Bool. which is a basic type in C99.) This chapter describes the rest of

the basic types and discusses important issues about types in general. Section 7.1
reveals the full range of integer types. which include_

andrunsignedrintegers: Section 7.2 introduces the

  
 

  

 

ection 7.3 covers the char type, which we'll need in order to work with charac-
ter data. Section 7.4 tackles the thorny topic of converting à value of one type to an
equivalent value of another. Section 7.5 shows how to use typedef to define new
type names. Finally, Section 7.6 describes the sizeoË£ operator. which measures
the amount of storage required for a type.

Integer Types

C supports two fundamentally different kinds of numeric types: integer types and
floating types. Values of an integer type are whole numbers, while values of a

floating type can have a fractional part as well. Theinteger types, in tum, are

 

 

 

125

***************************page_151***************************
126 Chapter 7  Basic Types

 

***************************page_152***************************
Table 7.1
Integer Types on a
6-bit Machine

Table 7.2
Integer Types on a
32-bit Machine

Table 7.3
Integer Types on a
64-bit Machine

<limits. h> header »23.2

/.1

Integer Types

127

 

***************************page_153***************************
128 Chapter 7  Basic Types

æ

signed char type » 7.3

unsigned char type > 7.3

_Bool type »5.2

 

***************************page_154***************************
7.1 Integer Types 129

 

***************************page_155***************************
130 Chapter 7  Basic Types

 

***************************page_156***************************
/.1 _ Integer Types 131

 

PROGRAM

 

Sum2.C /* Sums a series of numbers (using long variables) */
#include <stdio.h>
int main (void)
{

long n, sum = O;

print£f("This program sums a series of integers.\n'") ;

***************************page_157***************************
132 Chapter 7  Basic Types

print£ ("Enter integers (0 to terminate): ");

scanf ("%1d", &n);
while (n != O) {
SUMm += n;
scanf£f ("31d", &n);

}

printf ("The sum is: %1d\n", sum) ;

return 0;

 

7.2 Floating Types

The integer types aren’t suitable For all applications. Sometimes we'll need vari-
ables that can store numbers with digits after the decimal point, or numbers that are
exceedingly large or small. Numbers like these are stored in floating-point format
(so called because the decimal point ‘‘floats’”’).

      

***************************page_158***************************
subnormal numbers > 23,4

Table 7.4
Floating Type
Characteristics
(TEEE Standard)

<f£loat .h> header » 23.1

æ

complex types » 27.3

Qa&ÂÀ

/.2  Floating Types 133

bits. As a result, a single-precision number has a maximum value of approximately
3.40 x 10%, with a precision of about 6 decimal digits.

The |EEE standard also describes two other formats, single extended precision
and double extended precision. The standard doesn't specify the number of bits in
these formats, although it requires that the single extended type occupy at least 43
bits and the double extended type at least 79 bits. For more information about the
|EEE standard and floating-point arithmetic in general, see "What every computer
scientist should know about floating-point arithmetic” by David Goldberg (ACM
Computing Surveys, vol. 23, no. 1 (March 1991): 5-48).

es

 

Table 7.4 shows the characteristics of the floating types when implemented
according to the IEEE standard. (The table shows the smallest positive normalized
values. Subnormal numbers can be smaller.) The long double lype isn’t shown
in the table, since its length varies from one machine to another, with 80 bits and
128 bits being the most common sizes.

 

 

 

 

Type Smallest Positive Value Largest Value Precision
float 1.17549 x 107 3.40282 x 10? 6 digits
double 2.22507 x 107* 1.79769 x 10°°$ 15 digits

 

On computers that don*t follow the IEEE standard, Table 7.4 won't be valid.
In fact. on some machines, float may have the same set of values as double, or
double may have the same values as long double. Macros that define the
characteristics of the floating types can be found in the <float .h> header.

In C99. the floating types are divided into two categories. The £loat, dou-
ble, and long double types fall into one category, called the real floating
types. Floating types also include the complex types (£loat Complex, dou-
ble Complex, and long double Complex). which are new in C99,

Floating Constants

Floating constants can be written in a variety of ways. The following constants, for
example, are all valid ways of writing the number 57.0:

57.0 57. 57.0e0 57E0 5.7e1 5.7e+1 .57e2 5S570.e-l

À floating constant must contain à decimal point and/or an exponent; the exponent
indicates the power of 10 by which the number is to be scaled. If an exponent 1s
present, it must be preceded by the leiter E (or e). An optional + or - sign may
appear after the E (or e).

By default, floating constants are stored as double-precision numbers. In other
words, when a C compiler finds the constant 57.0 in a program, it arranges for the
number to be stored in memory in the same format as a double variable. This
rule generally causes no problems, since double values are converted automati-
cally to £loat when necessary.

***************************page_159***************************
134 Chapter 7  Basic Types

8

QaÂ

QaÂ

@

7.3

QaÂ

ASCII character set » Appendix E

On occasion. it may be necessary to force the compiler to store a floating con-
stant in £loat or long double format. To indicate that only single precision is
desired, put the letter F (or £) at the end of the constant (for example, 57 . OF). To
indicate that a constant should be stored in long double format, put the letter L
(or 1) at the end (57 . OL).

C99 has a provision for writing floating constants in hexadecimal. Such a con-
stant begins with Ox or OX (like a hexadecimal integer constant). This feature is
rarely used.

Reading and Writing Floating-Point Numbers

Âs we’ve discussed, the conversion specifications %e, f, and %g are used for
reading and writing single-precision floating-point numbers. Values of types dou -
ble and long double require slightly different conversions:

m When reading a value of type double, put the letter 1 in front of e, f, or g:

double d;

scanf ("31f", &d);

Note: Use 1 only in a scan£ format string, not a printf string. In a
print£ format string, the e, f, and g conversions can be used to write either
float or double values. (C99 legalizes the use of %le, %1F, and %1g in
calls of print£, although the 1 has no effect.)

= When reading or writing a value of type long double, put the letter L in
front of e, £, or g:

long double 1d;

scanf£ ("%$Lf", &ld);
print£ ("%Lf", 1d);

Character Types

The only remaining basic type is char, the character type. The values of type
char can vary from one computer to another, because different machines may
have different underlying character sets.

 

 

Character Sets

Today's most popular character set is ASCII (American Standard Code for Informa-
tion Interchange), a 7-bit code capable of representing 128 characters. In ASCII,
the digits O to 9 are represented by the codes 0110000-0111001, and the upper-
case letters À to Z are represented by 1000001—1011010. ASCII is often extended

***************************page_160***************************
7.3  Character Types 135

to a 256-character code known as Latin-1 thai provides the characters necessary
for Western European and many African languages.

 

m es

 

A variable of type char can be assigned any single character:

char ch;

ch = 'a'; /* lower-case a */
ch = 'A'; /* upper-case A */
ch = '0'; /* zero * /
ch = !" "; /* space */

Notice that character constants are enclosed in single quotes, not double quotes.

Operations on Characters

Working with characters in C is simple. because of one fact: C treats characters as
small integers. After all, characters are encoded in binary, and it doesn't take much
imagination to view these binary codes as integers. In ASCIL, for example, charac-
ter codes range from 0000000 to 1111111, which we can think of as the integers
from O to 127. The character ' a' has the value 97, " A* has the value 65, " O' has
the value 48, and " " has the value 32. The connection between characters and
integers in C is so strong that character constants actually have int type rather
than char type (an interesting fact, but not one that will often matter to us).

When a character appears in a computation, C simply uses its integer value.
Consider the following examples, which assume the ASCHI character set:

char ch;

int i;

i = 'a'; /* i is now 97 */
ch = 65; /* ch is now 'A' */
ch = ch + 1; /* ch is now 'B' */
ch++; /* ch is now 'C' */

Characters can be compared, just as numbers can. The following i £ statement
checks whether ch contains a lower-case letter; if so, it converts ch to upper case.

if a' < ch & ch <= 'z!)

( ;
ch ch - ‘'a' + 'A';

Comparisons such as 'a' <= ch are done using the integer values of the charac-
ters involved. These values depend on the character set in use, so programs that use
<, <=, >, and >= to compare characters may not be portable.

The fact that characters have the same properties as numbers has some advan-
tages. For example. we can easily write a for statement whose control variable
steps through all the upper-case letters:

for (ch = 'A!'; ch <= 'Z'; ch++)

***************************page_161***************************
136

Chapter 7  Basic Types

QaAÀ

portability tip

enumerated types > 16.5

æ

_Bool type »5.2

On the other hand, treating characters as numbers can lead to various programmine
errors that won't be caught by the compiler, and lets us write meaningless expres-
sions such as 'a' * 'b' / 'c'. t can also hamper portability. since our pro-
grams may be based on assumptions about the underlying character set. (Our for
loop, for example, assumes that the letters from À to Z have consecutive codes.)

Signed and Unsigned Characters

Since C allows characters to be used as integers, it shouldn’t be surprising that the
char type—like the integer types—exists in both signed and unsigned versions.
Signed characters normally have values between —128 and 127. while unsigned
characters have values between O and 255.

The C standard doesn't specify whether ordinary char is a signed or an
unsigned type; some compilers treat it as a signed type. while others treat it as an
unsigned type. (Some even allow the programmer to select, via a compiler option,
whether char should be signed or unsigned.)

Most of the time, we don’t really care whether char is signed or unsigned.
Once in a while, though. we do. especially if we're using a character variable to
store a small integer. For this reason, C allows the use of the words signed and
unsigned to modify char:

signed char sch;
unsigned char uch;

Don't assume that char is either signed or unsigned by default. If it mat-
ters, use signed char or unsigned char ‘nstead of char.

In light of the close relationship between characters and integers, C89 uses the
term integral types to refer to both the integer types and the character types. Enu-
merated types are also integral types.

C99 doesn't use the term ‘’integral types.” Instead, it expands the meaning of
“integer types” to include the character types and the enumerated types. C99’s
_Bool type 1s considered to be an unsigned integer type.

Arithmetic Types

The integer types and floating types are collectively known as arithmetic types.
Here's a summary of the arithmetic types in C89, divided into categories and sub-
categories:

m Intecral types
e char
e Signed integer types (signed char, short int, int. long int)

e Unsigned integer types (unsigned char, unsigned short int.
unsigned int, unsigned long int)

***************************page_162***************************
 

7.3 _ Character Types 137

e Enumerated types
m Floating types (£loat, double, long double)

@ C99 has a more complicated hierarchy lor its arithmetic types:

u ÎInteger types
e char

e Signed integer types, both standard (signed char. short int. int,
long int, long long int) and extended

e Unsigned integer types, both standard (unsigned char, unsigned
short int, unsigned int, unsigned long int. unsigned
long long int, Bool) and extended

e Enumerated types
m Floating types
e Real floating types (Float, double. long double)

e Complex types (Éloat _Complex, double Complex, long dou-
ble Complex)

Escape Sequences

À character constant is usually one character enclosed in single quotes. as we’ve
seen In previous examples. However, certain special characters—including the
new-line character—can’t be written in this way, because they*re invisible (non-
printing) or because they can’t be entered from the keyboard. So that programs can
deal with every character in the underlying character set, C provides a special nota-
tion, the escape sequence.

There are two kinds of escape sequences: character escapes and numeric
escapes. We saw à partial list of character escapes in Section 3.1: Table 7.5 gives
the complete set.

 

 

Table 7.5 Name Escape Sequence
Character Escapes Alcrt (bell) \a
Backspace \b
Form feed \f
New line \n
Carriage return \r
Horizontal tab \t
Vertical tab \v
Backslash \ \
Question mark \ ?
Single quote \"
Double quote \"

 

 

 

The \a. \b. \£. \r, \t, and \v escapes represent common ASCII control
characters. The \n escape represents the ASCII line-feed character. The \\ escape
allows a character constant or string to contain the \ character. The \' escape

***************************page_163***************************
138 Chapter 7  Basic Types

Qa&AÀ

trigraph sequences » 25.3

œ

universal characler names » 25.4

allows a character constant to contain the ' character, while the \ " escape allows a
string to contain the " character. The \ ? escape is rarely used.

Character escapes are handy, but they have a problem: the list of character
escapes doesn't include all the nonprinting ASCII characters, just the most com-
mon. Character escapes are also useless for representing characters beyond the
basic 128 ASCI characters. Numeric escapes, which can represent any character,
are the solution to this problem.

To write a numeric escape for a particular character, first look up the charac-
ter’s octal or hexadecimal value in a table like the one in Appendix E. For example.
the ASCIT escape character (decimal value: 27) has the value 33 in octal and 1B in
hex. Either of these codes can be used to write an escape sequence:

u An octal escape sequence consists of the \ character followed by an octal
number with at most three digits. (This number must be representable as an
unsigned character, so its maximum value is normally 377 octal.) For exam-
ple, the escape character could be written \33 or \033. Octal numbers in
escape sequences—unlike octal constants—don't have to begin with O.

u À hexadecimal escape sequence consists of \x followed by a hexadecimal
number. Although C places no limit on the number of digits in the hexadeci-
mal number, 1t must be representable as an unsigned character (hence it can°t
exceed FF if characters are eight bits long). Using this notation, the escape
character would be written \x1b or \x1B. The x must be in lower case, but
the hex digits (such as b) can be upper or lower case.

When used as a character constant, an escape sequence must be enclosed in
single quotes. For example, a constant representing the escape character would be
written '\33' (or "\x1b'). Escape sequences tend to get a bit cryptic, so ils
often a good 1dea to give them names using #define:

#define EsC '\33' /* ASCII escape character */

Escape sequences can be embedded in strings as well, as we saw in Section 3.1.
Escape sequences aren’t the only special notations for representing charac-
ters. Trigraph sequences provide a way to represent the characters #. [. \, ], *, {,
, }, and -, which may not be available on keyboards in some countries. C99
adds universal character names, which resemble escape sequences. Unlike escape
sequences, however, universal character names are allowed in identifiers.

 

Character-Handling Functions

Earlier in this section, we saw how to write an 1 £ statement that converts a lower-
case letter to upper-case:

if a' <= ch & ch <= 'z')

(l
ch ch - 'a' + 'A',;

This isn’t the best method, though. A faster—and more portable—way to convert
case 1s to call C’s toupper library function:

***************************page_164***************************
7.3  Character Types 139

ch = toupper (ch) ; /* converts ch to upper case */

When 1t’s called, toupper checks whether its argument (ch in this case) is a
lower-case letter. If so, 1t returns the corresponding upper-case letter. Otherwise,
toupper returns the value of the argument. In our example, we’ve used the
assignment operator to store the return value of toupper back into the ch vari-
able, although we could just as easily have done something else with it—stored it
in another variable, say, or tested it in an i £ statement:

if (toupper (ch) == 'A')

Programs that call toupper need to have the following #include directive
at the top:

#include <ctype.h>

toupper 1isn’t the only useful character-handling function in the C library. Sec-
tion 23.5 describes them all and gives examples of their use.

Reading and Writing Characters using scan£ and print£

The &c conversion specification allows scanf and print£ to read and write sin-
gle characters:

char ch;
scanf ("%$c", &ch) ; /* reads a single character */
print£("%c", ch); /* writes a single character */

scanf doesn’t skip white-space characters before reading a character. If the
next unread character is a space, then the variable ch in the previous example will
contain a space after scan£ returns. To force scan£ to skip white space before
reading a character, put a space in its format string just before %c:

scanf (" %c", &ch); /* skips white space, then reads ch */

Recall from Section 3.2 that a blank in a scan£ format string means ‘’skip zero or
more white-space characters.”

Since scan£ doesn'{ normally skip white space, itl’s easy to detect the end of
an input line: check to see 1f the character just read is the new-line character. For
example, the following loop will read and ignore all remaining characters in the
current input line:

do {
scanf ("%c", &ch) ;
} while (ch != '\n'),

When scanf is called the next time, it will read the first character on the next
input line.

***************************page_165***************************
140

Chapter 7  Basic Types

QaÂÀ

macros > 14.3

Reading and Writing Characters using getchar and putchar

C provides other ways to read and write single characters. In particular, we can use
the getchar and putchar functions instead of calling scanf and printf.
putchar writes a single character:

putchar (ch) ;

Fach time getchar is called, it reads one character, which it returns. In order to
save this character, we must use assignment to store it in a variable:

ch = getchar(); /* reads a character and stores it in ch */

getchar actually returns an int value rather than a char value (the reason will
be discussed in later chapters). As a result. it’s not unusual for a variable to have
type int rather than char 1f it will be used to store a character read by getchar.
Like scan£f, getchar doesn’t skip white-space characters as it reads.

Using getchar and putchar (rather than scanf and printF) saves time
when the program is executed, getchar and putchar are fast for two reasons.
First, they're much simpler than scanf and print£, which are designed to read
and write many kinds of data in a variety of formats. Second. getchar and
putchar are usually implemented as macros for additional speed.

getchar has another advantage over scan£: because it returns the charac-
ter that it reads, getchar lends itself to various C idioms, including loops that
search for a character or skip over all occurrences of a character. Consider the
scan£ loop that we used to skip the rest of an input line:

do |
scanf ("%c", &ch) ;
} while (ch != '\n');

Rewriting this loop using getchar gives us the followineg:

do |
ch = getchar();
} while (ch != '\n');

Moving the call of getchar into the controlling expression allows us to condense
the loop:

while ((ch = getchar()) != '\n')

‘

This loop reads a character, stores it into the variable ch. then tests if ch is nol
equal to the new-line character. If the test succeeds, the loop body (which is empty)
is executed, then the loop test is performed once more, causing a new character to
be read. Actually, we don’t even need the ch variable; we can just compare the
return value of getchar with the new-line character:

***************************page_166***************************
idiom

idiom

PROGRAM

7.3 Character Types 141

while (getchar() != '\n') /* skips rest of line */

.
t

The resulting loop is a well-known C idiom that’s cryptic but worth learning.

getchar is useful in loops that skip characters as well as loops that search
for characters. Consider the following statement, which uses getchar to skip an
indefinite number of blank characters:

while ((ch = getchar()) == ' ‘) /* skips blanks */

t

When the loop terminates, ch will contain the first nonblank character that
getchar encountered.

 

Be careful if you mix getchar and scan£ in the same program. scanf has a
tendency to leave behind characters that it has “peeked” at but not read, including
the new-line character. Consider what happens if we try to read a number first, then
a character:

printf ("Enter an integer: ") ;
scanf ("%d", &i) ;

printf ("Enter a command: ") ;
command = getchar () ;

The call of scan£f will leave behind any characters that weren’t consumed during
the reading of i, including (but not limited to) the new-line character. getchar
will fetch the first leftover character, which wasn’t what we had in mind.

 

Determining the Length of a Message

To illustrate how characters are read, let’s write a program that calculates the
leneth of a message. After the user enters the message, the program displays the
tength:

Enter a message: Brevity is the soul of wit.
Your message was 27 character(s) long.

 

The length includes spaces and punctuation, but not the new-line character at the
end of the message.

We*I1 need a loop whose body reads a character and increments a counter. The
loop will terminate as soon as a new-line character turns up. We could use either
scanf or getchar to read characters, most C programmers would choose
getchar. Using a straightforward while loop, we might end up with the follow-
ing program.

***************************page_167***************************
142 Chapter 7  Basic Types

length.e _ /* Determines the length of a message */
#include <stdio.h>

int main(void)

{

char ch;
int len = O0;

printf ("Enter a message: ") ;
ch = getchar () ;
while (ch != '\n') {

len++;

ch = getchar ();

}

print£ ("Your message was %d character(s) long.\n", len) ;

return 0;

Recalling our discussion of idioms involving while loops and getchar. we
realize that the program can be shortened:

lengih2.c _ /* Determines the length of a message */
#finclude <stdio.h>

int main(void)

{

int len = O0;

print£ ("Enter a message: ") ;
while (getchar() != '\n')
len++;
printf ("Your message was %d character(s) long.\n", len) ;

return 0;

7.4 Type Conversion

Computers tend to be more restrictive than C when it comes to arithmetic. For a
computer to perform an arithmetic operation, the operands must usually be of the
same size (the same number of bits) and be stored in the same way. À computer
may be able to add two 16-bit integers directly. but not a 16-bit integer and a 32-bit
Integer or a 32-bit integer and a 32-bit floating-point number.

Ç, on the other hand, allows the basic types to be mixed in expressions. We
can combinc integers, floating-point numbers, and even characters in a single
expression. The C compiler may then have to generate instructions that convert

***************************page_168***************************
Q&ÂÀ

 

 

7.4  Type Conversion 143

some operands to different types so that the hardware will be able to evaluate the
expression. If we add a 16-bit short and a 32-bit int, for example, the compiler
will arrange for the short value to be converted to 32 bits. If we add an int and
a float, the compiler will arrange for the int to be converted to float format.
This conversion is a little more complicated, since int and float values are
stored in different ways.

Because the compiler handles these conversions automatically, without the
programmer’s involvement, they’re known as implicit conversions. C also allows
the programmer to perform explicit conversions, using the cast operator. Il dis-
cuss implicit conversions first, postponing explicit conversions until later in the
section. Unfortunately, the rules for performing implicit conversions are somewhat
complex, primarily because C has so many different arithmetic types.

Implicit conversions are performed 1n the following situations:

=n When the operands in an arithmetic or logical expression don’t have the same
type. (C performs what are known as the usual arithmetic conversions.)

#n When the type of the expression on the right side of an assignment doesn't
match the type of the variable on the left side.

= When the type of an argument in a function call doesn‘t match the type of the
corresponding parameter.

#n When the type of the expression in a return statement doesn’t match the
function’s return type.

We’Il discuss the first two cases now and save the others for Chapter 9.

The Usual Arithmetic Conversions

The usual arithmetic conversions are applied to the operands of most binary opera-
tors, including the arithmetic, relational, and equality operators. For example, let's
say that £ has type float and i has type int. The usual arithmetic conversions
will be applied to the operands in the expression £ + i, because their types aren't
the same. Clearly it’s safer to convert i to type £Joat (matching £*s type) rather
than convert £ to type int (matching i’s type). An integer can always be con-
verted to float; the worst that can happen is a minor loss of precision. Convert-
ing a floating-point number to int, on the other hand, would cost us the fractional
part of the number. Worse still, we’d get a completely meaningless result if the
original number were larger than the largest possible integer or smaller than the
smallest integer.

The strategy behind the usual arithmetic conversions is to convert operands to
the ‘“‘narrowest” type that will safely accommodate both values. (Roughly speak-
ing, one type is narrower than another if it requires fewer bytes to store.) The types
of the operands can often be made to match by converting the operand of the nar-
rower type to the type of the other operand (this act is known as promotion).
Among the most common promotions are the infegral promotions, which convert
a character or short integer to type int (or to unsigned int in some cases).

***************************page_169***************************
144

Chapter 7  Basic Types

We can divide the rules for performing the usual arithmetic conversions into
two cases:

= The type of either operand is a floating type. Use the following diagram to
promote the operand whose type is narrower:

long double

T
double

T

float

That is, if one operand has type long double, then convert the other oper-
and to type long double. Otherwise, if one operand has type double, con-
vert the other operand to type double. Otherwise, if one operand has type
£loat, convert the other operand to type float. Note that these rules cover
mixtures of integer and floating types: if onc operand has type long int. for
example, and the other has type double, the long int operand is converted
to double.

# Neither operand type is a floating type. First perform integral promotion on
both operands (guaranteeing that neither operand will be a character or short

integer). Then use the following diagram to promote the operand whose type
is narrower:

unsigned long int

Î

long int

Î

unsigned int

Î

int

There’s one special case. but it occurs only when long int and unsigned int
have the same length (32 bits, say). Under these cireumstances, if one operand has
type long int and the other has type unsigned int, both are converted to
unsigned long int.

 

When a signed operand is combined with an unsigned operand, the signed operand
is converted to an unsigned value. The conversion involves adding or subtracting a
multiple of n + |, where n is the largest representable value of the unsigned type.
This rule can cause obscure programming errors.

Suppose that the int variable i has the value —10 and the unsigned int
variable u has the value 10. If we compare i and u using the < operator, we might
expect to get the result ! (true). Before the comparison, however, i is converted to
unsigned int. Since a negative number can’t be represented as an unsigned
integer, the converted value won't be —IO. Instead. the value 4,294.967,296 is
added (assuming that 4,294,967.295 is the largest unsigned int value). giving

***************************page_170***************************
7.4  Type Conversion 145

a converted value of 4,294,967,286. The comparison i < u wil] therefore produce
0. Some compilers produce a warning message such as “comparison berween
sigred and unsigned” when a program attempts to compare a signed number with
an unsigned number.

Because of traps like this one, it’s best to use unsigned integers as little as pos-
sible and, especially, never mix them with signed integers.

 

The following example shows the usual arithmetic conversions in action:

char c;

short int s;

int i;

unsigned int u;

long int 1l;

unsigned long int ul;

float Ê;

double d;

long double ld;

i = i + C; /* c is converted to int * /
i = i + S; /* s is converted to int */
u = U + i; /* i is converted to unsigned int */
l = 1 + u; /* u is converted to long int */
ul = ul + l; /* l is converted to unsigned long int */
f = £ + ul; /* ul is converted to float */
d = d +Ê; /* £ is converted to double */
ld = ld + d; /* à is converted to long double */

Conversion During Assignment

The usual arithmetic conversions don*t apply to assignment. Instead, C follows the
simple rule that the expression on the right side of the assignment is converted to
the type of the variable on the left side. If the variable’s type is at least as “wide” as
the expression’s, this will work without a snag. For example:

char c;

int i;

Eloat £f;

double d;

i = C; /* c is converted to int * /
f = i; /* i is converted to float */
d = Î; /* f is converted to double */

Other cases are problematic. Assigning a floating-point number to an integer
variable drops the fractional part of the number:

int 32;

i = 842.97; /* i is now 842 */
i = -842.97; /* i is now -842 */

***************************page_171***************************
146

Chapter 7 Basic Types

Q&AÀ

æ

_Bool type »5.2

Moreover, assigning a value to a variable of a narrower type will give a meaning-
less result (or worse) if the value is outside the range of the variable’s type:

c = 10000; /*** WRONG ***/
i = 1.0e20; /*** WRONG ***/
É = 1.0e100; /*** WRONG **+/

À “narrowing” assignment may elicit a warning from the compiler or from tools
such as 1int.

I(s à good idea to append the £ suffix to a floating-point constant if it will be
assigned to a £loat variable., as we*ve been doing since Chapter 2:

Ê 3.141559ËÉ;

Without the suffix, the constant 3.14159 would have type double, possibly
causing a warning message.

Implicit Conversions in C99

The rules for implicit conversions in C99 are somewhat different from the rules in
C89, primarily because C99 has additional types (_Bool, long long types,
extended integer types, and complex Lypes).

For the purpose of defining conversion rules, C99 gives each integer type an
‘“Integer conversion rank.” Here are the ranks from highest to lowest:

|.1ong long int, unsigned long long int
2. long int, unsigned long int

3.int, unsigned int

4. short int, unsigned short int

3. char. signed char, unsigned char

6. Bool

For simplicity, l'm ignoring extended integer types and enumerated types.

In place of C89’s integral promotions. C99 has “integer promotions,” which
involve converting any type whose rank is less than int and uns igned int to
int (provided that all values of the type can be represented using int) or else to
unsigned int.

Âs in C89, the C99 rules for performing the usual arithmetic conversions can
be divided into two cases:

# The type of either operand is a floating type. As long as neither operand has a
complex type, the rules are the same as before. (The conversion rules for com-
plex types will be discussed in Section 27.3.)

# Neither operand type is a floating type. First perform integer promotion on
both operands. If the types of the two operands are now the same, the process
ends, Otherwise, use the following rules, stopping at the first one that applies:

e If both operands have signed types or both have unsigned types, convert the

***************************page_172***************************
cast expression

7.4  Type Conversion 147

operand whose type has lesser integer conversion rank to the type of the
operand with greater rank.

e If the unsigned operand has rank greater or equal to the rank of the type of
the signed operand, convert the signed operand to the type of the unsigned
operand.

e If the type of the signed operand can represent all of the values of the type
of the unsigned operand, convert the unsigned operand to the type of the
signed operand.

e Otherwise, convert both operands to the unsigned type corresponding to the
type of the signed operand.

Incidentally, all arithmetic types can be converted to _Bool type. The result
of the conversion is O if the original value is 0; otherwise, the result is I.

Casting

Although C’s implicit conversions are convenient, we sometimes need a greater
degree of control over type conversion. For this reason, C provides casfs. À cast
expression has the form

( tvpe-name ) expression

type-name specifies the type to which the expression should be converted.
The following example shows how to use a cast expression to compute the
fractional part of a float value:

float f, frac part;
frac _ part = £ - (int) £;

The cast expression (int) £ represents the result of converting the value of £ to
type int. C*s usual arithmetic conversions then require that (int) £ be con-
verted back to type float before the subtraction can be performed. The differ-
ence between f and (int) £ is the fractional part of £. which was dropped
during the cast.

Cast expressions enable us to document type conversions that would take
place anyway:

i = (int) f; /* f is converted to int */

They also enable us to overrule the compiler and force it to do conversions that we
want. Consider the following example:

float quotient ;
int dividend, divisor;

quotient dividend / divisor;

***************************page_173***************************
148

Chapter 7 Basic Types

Âs il’s now written, the result of the division—an inteser—will be converted to
float lorm before being stored in quotient. We probably want dividend
and divisor converted to £loat before the division, though, so that we get a
more exact answer. À cast expression will do the trick:

quotient = (float) dividend / divisor;

divisor doesn't necd a cast, since casting dividend to float forces the
compiler to convert divi sor to Float also.

Incidentally, C regards ( type-name ) as a unary operator. Unary operators
have higher precedence than binary operators, so the compiler interprets

(£loat) dividend / divisor
as
((£loat) dividend) / divisor

If you find this confusing, note that there are other ways to accomplish the same
effect:

quotient = dividend / (float) divisor;
or
quotient = (float) dividend / (float) divisor;

Casts are sometimes necessary to avoid overflow. Consider the following
example:

long i;
int j = 1000;

i = j * j; /* overflow may oceur */

Àt first glance, this statement looks fine. The value of ÿ * j is 1.000,000, and i is
a long. so it can easily store values of this size, right? The problem is that when
(wo int values are multiplied, the result will have int type. But j * ÿ is too
large to represent as an int on some machines, causing an overflow. Fortunately.
using a cast avoids the problem:

i = (long) j * ;

Since the cast operator takes precedence over *. the first j is converted to long
type, forcing the second j to be converted as well. Note that the statement

i = (long) (j * j); /*** WRONG ***/

wouldn't work, since the overflow would already have occurred by the time of the
cast.

***************************page_174***************************
1.5

QaÂÀ

7.5  Type Definitions 149

Type Definitions

In Section 5.2. we used the #define directive to create a macro that could be
used as a Boolean type:

#define BOOL aint

There’s a better way to set up a Boolean type, though, using a feature known as a
type definition:

typede£f int Bool;

Notice that the name of the type being defined comes /ast. Note also that l’ve capi-
talized the word Bool. Capitalizing the first letter of a type name isn’t required;
it’s just a convention that some C programmers employ.

Using typedef to define Bool causes the compiler to add Bool to the list
of type names that it recognizes. Bool can now be used in the same way as the
built-in type names—in variable declarations, cast expressions, and elsewhere. For
example, we might use Bool to declare variables:

Bool flag; /* same as int flag; */

The compiler treats Bool as a synonym for int; thus, flag is really nothing
more than an ordinary int variable.

Advantages of Type Definitions

Type definitions can make a program more understandable (assuming that the pro-
grammer has been careful to choose meaningful type names). For example, sup-
pose that the variables cash in and cash out will be used to store dollar
amounts. Declaring Dollars as

typedef float Dollars;

and then writing

Dollars cash in, cash out;
IS more informative than just writing
float cash in, cash out;

Type definitions can also make a program easier to modify. If we later decide
that Dollars should really be defined as double, all we need do is change the
type definition:

typedef double Dollars;

***************************page_175***************************
150

Chapter 7  Basic Types

portability tip

The declarations of Dollars variables need not be changed. Without the type
definition, we would need to locate all £loat variables that store dollar amounts
(not necessarily an easy task) and change their declarations.

Type Definitions and Portability

Type definitions are an important tool for writing portable programs. One of the
YP p &P prog
problems with moving a program from one computer to another is that types may

have different ranges on different machines. If i is an int variable, an assignment
like

i = 100000;

is fine on a machine with 32-bit integers, but will fail on a machine with 16-bit
integers.

lor greater portability, consider using typedeË to define new names for
integer types.

Suppose that we're writing à program that needs variables capable of storing
product quantities in the range O-50,000. We could use long variables for this
purpose (since they're guaranteed to be able to hold numbers up to at least
2,147,483,647), but we'd rather use int variables, since arithmetic on int values
may be faster than operations on long values; also, int variables may take up
less space.

Instead of using the int type to declare quantity variables. we can define our
own “quantity” type:

typedef int Quantity;
and use this type to declare variables:
Quantity ;

When we transport the program to a machine with shorter integers, we’Il change
the definition of Quantity:

typedef long Quantity;

This technique doesn*t solve all our problems, unfortunately, since changing the
definition of Quantity may affect the way Quant i ty variables are used. At the
very least, calls of print£ and scan£ that use Quant ity variables will need to
be changed, with %d conversion specifications replaced by $1 d.

The C library itself uses typede£ to create names for types that can vary
from one C implementation to another; these types often have names that end with
_t.suchas ptrdiff t, size t,andwchar t. The exact definitions of these
types will vary, but here are some typical examples:

***************************page_176***************************
æ

<stdint .h> header »27.1

7.6

sizeof expression

e F VN

7.6  The sizeof Operator 151

typedef long int ptrdif£f t;
typedef unsigned long int size t;
typedef int wchar t;

In C99, the <stdint .h> header uses typede£Ë to define names for integer
types with a parlicular number of bits. For example, int32_ t is a signed integer
type with exactly 32 bits. Using these types is an effective way to make programs
more portable.

The sizeof Operator

The sizeof operator allows a program to determine how much memory is
required to store values of a particular type. The value of the expression

sizeof ( rfype-name )

is an unsigned integer representing the number of bytes required to store a value
belonging to type-name. sizeoË (char) is always 1, but the sizes of the other
types may vary. On a 32-bit machine. sizeof (int) is normally 4. Note that
sizeof is a rather unusual operator, since the compiler itself can usually deter-
mine the value of a sizeoË expression.

The sizeof operator can also be applied to constants, variables, and expres-
sions in general. If à and j are int variables, then sizeoËf (i) is 4 on a 32-bit
machine, as is sizeoË (i + j). When applied to an expression—as opposed to a
type—sizeof doesn’t require parentheses; we could write sizeof i instead of
sizeof (i). However, parentheses may be needed anyway because of operator
precedence. The compiler would interpret sizeoËf i + j as (sizeof i) + ,
because sizeof—a unary operator—takes precedence over the binary + opera-
tor. To avoid problems, l always use parentheses in sizeoË expressions.

Printing a sizeof value requires care, because the type of a sizeof expres-
sion is an implementation-defined type named size_t. In C89, it's best to con-
vert the value of the expression to a known type before printing it. size_t 1s
guaranteed to be an unsigned integer type, so it’s safest to cast a sizeoËf expres-
sion to unsigned long (the largest of C89’s unsigned types) and then print it
using the Slu conversion:

printf£f ("Size of int: %lu\n", (unsigned long) sizeof (int)) ;

In C99, the size t type can be larger than unsigned long. However, the
printf function in C99 is capable of displaying size_ t values directly. without
needing a cast. The trick is to use the letter z in the conversion specification, fol-
lowed by one of the usual integer codes (typically u):

print£("Size of int: %zu\n", sizeof (int)) ; /* C99 only */

***************************page_177***************************
152

Chapter 7  Basic Types

Q & À

Section 7.1 says that %o and %x arc used to write unsigned integers in octal
and hex notation. How do I write ordinary (signed) integers in octal or hex?
[p. 130]

You can use %o and %x to print à signed integer as long as its value isn’t negative.
These conversions cause print£ (o treat « signed integer as though it were
unsigned; in other words, print£ will assume that the sign bit is part of the num-
ber's magnitude. Às long as the sign bit is O, there’s no problem. If the sign bit is 1,
print£f will print an unexpectedly large number.

But what if the number /s negative? How can I write it in octal or hex?

There’s no direct way Lo print a negative number in octal or hex. Fortunately, the
need to do so is pretly rare. You can, of course. test whether the number is negative
and print a minus sign yourself:
if (i < O)

print£("-gx", -i);

else
printf("#x", i);

Why are floating constants stored in double form rather than float form?
[p. 133]

For historical reasons. C gives preference to the double type; float is treated
as à second-class citizen. Consider, for instance. the discussion of float in Ker-
nighan and Ritchie’s The C Programming Language: “The main reason for using
float is to save storage in large arrays, or, less often, to save time on machines
where double-precision arithmetic is particularly expensive.” C originally man-
dated that all floating-point arithmetic be done in double precision. (C89 and C99
have no such requirement.)

What do hexadecimal floating constants look like, and what are they good
for? [p. 134]

À hexadecimal floating constant begins with Ox or OX and must contain an expo-
nent, which 1s preceded by the letter P (or p). The exponent may have à sign, and
the constant may end with £. F, 1. or L. The exponent is expressed in decimal. but
represents à power of 2, not a power of 10. For example. Ox1 . Bp3 represents the
number 1.6875 x 2° = 13.5. The hex digit B corresponds to the bit pattern 1011.
The B occurs to the right of the period. so each | bit represents a negative power of
2. Summing these powers of 2 (27" + 27* + 2*) yields .6875.

Hexadecimal floating constants are primarily useful for specifying constants
that require great precision (including mathematical constants such as e and ).
Hex numbers have a precise binary representation, whereas a constant written in
decimal may be subject to a tiny rounding error when converted to binary. Hexa-

***************************page_178***************************
:5:Q;
Â:

varlable-length argument lists
»-26.1

Q & À 153

decimal numbers are also useful For defining constants with extreme values, such
as the values of the macros in the <float .h> header. These constants are easy to
write in hex but difficult to write in decimal.

Why do we use %1 £ to read a double value but %£ to print it? [p. 134]

This is a tough question to answer. First, notice that scan£ and print£ are
unusual functions in that they aren°t restricted to à fixed number of arguments. We
say that scan£ and print£ have variable-length argument lists. When functions
with variable-length argument lists are called, the compiler arranges for float
arguments to be converted automatically to type double. As a result. print£
can°t distinguish between float and double arguments. This explains why %f
works for both £loat and double arguments in calls of print£.

scan£. on the other hand. is passed a pointer to a variable. 3£ tells scan£ to
store a Ffloat value at the address passed to it, while 1 £ tells scan£ to store a
double value at that address. The distinction between float and double is
crucial here. If given the wrong conversion specification, scan£ will likely store
the wrong number of bytes (not to mention the fact that the bit pattern for a £loat
isn’t the same as that for a double).

What’s the proper way to pronounce char? [p. 134]

There’s no universally accepted pronunciation. Some people pronounce char in
the same way as the first syllable of ‘’character”’ Others say “char.” as in

char broiled;

When does it matter whether a character variable is signed or unsigned? [p.
136]

If we store only 7-bit characters in the variable. it doesn’t matter. since the sign bit
will be zero. If we plan to store 8-bit characters, however, we'Il probably want the
variable to have unsigned char type. Consider the following example:

ch = '\xdb';

If ch has been declared to have type char. the compiler may choose to treat it as à
signed character (many compilers do). As long as ch is used only as a character,
there won*t be any problem. But if ch is ever used in a context that requires the
compiler to convert its value to an integer, we*re likely to have trouble: the result-
ing integer will be negative, since ch’s sign bit is |.

Here*s another situation: In some kinds of programs, it’s customary to use
char variables to store one-byte integers. IË we're writing such a program, we'll
have to decide whether each variable should be signed char or unsigned
char, just as we must decide whether ordinary integer variables should have Lype
int or unsigned int.

I don’t understand how the new-line character can be the ASCIT line-feed
character. When a user enters input and presses the Enter Kkey, doesn°t the
program read this as a carriage-return character or a carriage return plus a
line feed? [p. 137]

***************************page_179***************************
154

Chapter 7  Basic Types

A:

:;:Q=
À:

trigraph sequences » 25.3

Q:

Nope. As part of C’s UNIX heritage. it always regards the end of à line as being
marked by a single line-feed character. (In UNIX text files, a single line-feed char-
acter—Dbut no carriage return—appears at the end of cach line.) The C library takes
care of translating the user’s keypress into a line-feed character. When a program
reads from a file, the I/O library translates the file’s end-of-line marker (whatever it
may be) into a single line-feed character. The same transformations occur—in
reverse—when output is written to the screen or to a file. (See Section 22.1 for
details.)

Although these translations may scem confusing, they serve an important pur-
pose: insulating programs from details that may vary from one operating system to
another.

What’s the purpose of the \? escape sequence? [p. 138]

The \ ? escape is related Lo trigraph sequences, which begin with ? ?. IF you should
put ?? In a string, there's a possibility that the compiler will mistake it for the
beginning of a trigraph. Replacing the second ? by \ ? fixes the problem.

If getchar is faster, why would we ever want to use scanf to read individ-
ual characters? [p. 140]

Although it’s not as fast as getchar, the scanf function is more flexible. As we
saw previousty, the "%c" format string causes scan£ to read the next input char-
acter; " %c" causes it to read the next non-white-space character. Also, scanf is
good at reading characters that are mixed in with other kinds of data. Let’s say that
our input data consisis of an integer, then a single nonnumeric character, then
another integer. By using the format string "%d%c%d", we can get scanf to read
all three items.

Under what circumstances do the integral promotions convert a character or
short integer to unsigned int? [p. 143]

The integral promotions yield an unsigned int if the int type isn°t large
enough to include all possible values of the original type. Since characters are usu-
ally eight bits long, they are almost always converted to int. which is guaranteed
to be at least 16 bits long. Signed short integers can always be converted to int as
well. Unsigned short integers are problematic. IŸ short integers have the same
length as ordinary integers (as they do on a 16-bit machine), then unsigned short
integers will have to be converted to unsigned int. since the largest unsigned
short integer (65,535 on a 16-bit machine) is larger than the largest int (32,767).

Exactly what happens if I assign a value to a variable that’s not large enough
to hold it? [p. 146]

Roughly speaking. if the value is of an integral type and the variable is of an
unsigned type, the extra bits are thrown away; if the variable has a signed type. the
result is implementation-defined. Assigning a floating-point number to a vari-
able—integer or floating—that’s too small to hold it produces undefined behavior:
anything can happen. including program termination.

***************************page_180***************************
:%:Q:

ÂÀ:

varlable-length arrays > 8.3

Section 7.1 |.

Section 7.2 2.

Exercises 155

Why does C bother to provide type definitions? Isn’t defining a BOOL macro
just as good as defining a Bool type using typede£f? [p. 149]

There are two important differences between type definitions and macro defini-
tions. First, type definitions are more powerful than macro detinitions. In particu-
lar, array and pointer types can’t be defined as macros. Suppose that we try to use a
macro to define a “pointer to integer” type:

#define PTR TO _INT int *
The declaration

PTR TO _ INT p, G, r;

will become

int * p, q, r;

after preprocessing. Unfortunately, only p is a pointer; q and r are ordinary integer
variables. Type definitions don’t have this problem.

Second, typedef names are subject to the same scope rules as variables: a
typedef name defined inside a function body wouldn’t be recognized outside the
function. Macro names, on the other hand, are replaced by the preprocessor wher-
ever they appear.

You said that compilers ‘““can usually determine the value of a sizeof expres-
sion” Can°’t a compiler a/ways determine the value of a sizeof expression?

[p. 151]

In C89, yes. In C99, however, there’s one exception. The compiler can’t determine
the size of a variable-length array, because the number of elements in the array
may change during the execution of the program.

Exercises

Give the decimal value of each of the following integer constants.
(a) 077

(b) Ox77

(c) OXABC

Which of the following are not legal constants in C? Classify.each legal constant as either
integer or floating-point.

(a) 010E2

(b) 32.1E+5

(c) 0790

(d) 100 000

(e) 3.978e-2

***************************page_181***************************
156 Chapter 7  Basic Types

® 3.

Section 7.3 © 4

Qn

Section 7.4 0.

@ 10.

[l.

Which of the following are not legal types in C?

(a) short unsigned int
(b) short float

(c) long double
(d) unsigned long

I c is a variable of type char, which one of the following statements is illegal?
(a) i += c; /* i has type int */

(b) ce = 2 * c - 1;

(c) putchar (c) ;

(d) print£ (c) ;

Which one of the following is not a legal way to write the number 65? (Assume that the
character set 1s ASCII.)

(Zl) À!

(b) 0b1000001

(c) 0101

(d) Ox41

For each of the following 1tems of data, specify which one of the types char, short, int.
or long is the smallest one guarantced to be large enough to store the item.

(a) Days in a month

(b) Days in a year

(c) Minutes in a day

(d) Seconds in a day

For each of the following character escapes, give the equivalent octal escape. (Assume that
the character set is ASCII.) You may wish to consult Appendix E, which lists the numerical
codes for ASCIT characters.

(a) \b
(b) \n
(c) \r
(d) \t

Repeat Exercise 7, but give the equivalent hexadecimal escape.
Suppose that i and j arc variables of type int. What is the type of thc expression i / j +
'a'?

Suppose that i is a variable of type int, j is à variable of type 1ong, and k is a variable of
type unsigned int. What is the type of the expression i + (int) j * kK?

Suppose that i is a variable of type int,. £ is a variable of type float. and d is a variable
of type double. What is the type of the expression i * £ / d?

Suppose that i is à variable of type int, £ is a variable of type Float, and d is a variable
of type double. Explain what conversions take place during the execution of the following
statement:

d = à + f;

***************************page_182***************************
Section 7.5

13.

|5.

9

Programming Projects 157

Assume that à program contains the following declarations:

char c = '\1';
short s = 2;
int i = -3;

long m = 5;
float £ = 6.5ËÉ;
double d = 7.5;

Give the value and the type of each expression listed below.

(a) c * i (c) £ / € (e) £ - d
(b) Ss + m (d) d / s (F) (int) £

Does the following statement always compute the fractional part of £ correctty (assuming
that £ and frac_part are float variables)”?

frac _ part = £ - (int) f;

If not, what's the problem”

Use typedef to create types named Int8, Int16. und Int32. Define the types so that
they represent 8-bit, 16-bit. and 32-bit intégers on your machine.

Programming Projects

The square2. c program of Section 6.3 will fail (usually by printing strange answers) if
i * i exceeds the maximum int value. Run the program and determine the smallest value
of n that causes failure. Try changing the type of i to short and running the progräm
again. (Don’t forget to update the conversion specifications in the call of print£!) Then
try lJong. From these experiments. what can you conclude about the number of bits used Lo
storc integer types on your machine?

Modify the square2 . c program of Section 6.3 so that it pauses after every 24 squares and
displays the following message:

Press Enter to continue...

After displaying the message, the program should use getchar to read a character.
getchar won't allow the program to continue unuil thèe user presses the Enter key.

Modify the sum2 . c program of Section 7.1 to sum a series of double values.

Write a program that translates an alphabetic phone number into numerie form:

Enter phone number: CALLATT
2255288

(In case you don't have a tclephone nearby. here are the letters on the keys: 2=ABC, 3=DEF,
4=GHT, 5=JKL, 6=MNO, 7=PRS, 8=TUV. 9=WXY.) If the original phone number contains
nonalphabetic characters (digits Or punctuation, for example), leave them unchanged:

Enter phone number: 1-800-COL-LECT
1-800-265-5328

 

You may assume that any letters entered by the user are upper case.

***************************page_183***************************
158

Chapter 7  Basic Types

® 5.

tO.

ll.

12.

In the SCRABBLE Crossword Game, players form words using small tiles, each containing
à letter and a face value. The face value varies from onc letter to another, based on the let-
ter’s rarity. (Here are the face values: |: AEILNORSTU, 2: DG, 3: BCMP, 4: FHVWY, 5: K.
8: JX, 10: QZ.) Write a program that computes the value of à word by summing the values
of its letters:

Enter a word: pitfall
Scrabble value: 12

Your program should allow any mixture of lower-case and upper-case letters in the word.
Hint: Use the toupper library function.

Write a program that prints the values of sizeof (int). sizeof (short).
sizeoËf (long), sizeof (£loat), sizeof (double) and sizeof (long dou-
ble).

Modify Programming Project 6 from Chapter 3 so thut the user may add, subtract. multiply,
or divide two fractions (by entering either +, -. *. or / between the fractions).

Modify Programming Project 8 from Chapter 5 so that the user enters a time using the 12-
hour clock. The input will have the form hours : minutes followed by either A, P, AM, or PM
(either lower-case or upper-case). White space is allowed (but not required) between the
numerical time and the AM/PM indicator. Examples of valid input:

1:15P

:15PM
:15p

:15pm
:15 P
:15 PM
:15 p
:15 pm

HHHHHeu

You may assume that the input has one of these forms; there is no need to test for errors.
Write a program that asks the user for a 12-hour time, then displays the time in 24-hour
form:

Enter a 12-hour time: 9:11 PM
Equivalent 24-hour time: 21:11

See Programming Project 8 for a description of the input format.

Write a program that counts the number of vowels (a, e, i, o, and u) in à sentence:

Enter a sentence: And that's the way it is.
Your sentence contains 6 vowels.

 

Write a program that takes a first name and last name entered by the user and displays the
last name, a comma, and the first initial, followed by a period:

Enter a first and last name: LIloyd Fosdick
Fosdick, L.

 

The user's input may contain extra spaces before the first name, between the first and last
names, and after the last name.
Write à program that evaluates an expression:

Enter an expression: 1+2.5*3
Value of expression: 10.5

***************************page_184***************************
| 3.

|4.

15.

Programming Projects 159

The operands in the expression are floating-point numbers; the operators are +, -, *, and /.
The expression 1s evaluated from left to right (no operator takes precedence over any other
operator’).

Write a program that calculates the average word lenath for a sentence:

Enter a sentence: It was deja vu all over again.
Average word length: 3.4

 

For simplicity, your program should consider a punctuation mark to be parl of the word to
which it is attached. Display the average word length to onc decimal place.

Write a program that uses Newton’s method to compute the square root of a positive float-
ing-point number:

Enter a positive number: 3
Square root: 1.73205

Let x be the number entered by the user. Newton’s method requires an initial guess y for the
squarc root of x (we'Il use y = 1). Successive guesses are found by computing the average of
y and x/y. The following table shows how the square root of 3 would be found:

Average of

 

x y x/y y and x/y
3 1 3 2

3 2 1.5 1.75

3 1.75 1.71429 ].73214

3 173214 1.73196 1.73205

3 - 1.73205 = 1.73205 1.73205

Note that the values of y get progressively closer to the true square root of x. For greater
accuracy, your program should use variables of type double rather than £loat. Have the
program terminate when the absolute value of the difference between the old value of y and
the new value of y is less than the product of .00001 and y. Hint: Call the fabs l'unction to
find the absolute value of a double. (You'll need to include the <math.h> header at the
beginning of your program in order to use fabs.)

Write a program that computes the factorial of a positive integer:

Enter a positive integer: 6
Factorial of 6: 720

(a) Use a short variable to store the value of the factorial. What 1s the largest value of n
for which the program correctly prints the factorial of n°

(b) Repeat part (a), using an int variable instead.

(c) Repeat part (a), using a long variable instead.

(d) Repeat part (a), using a long long variable instead (if your compiler supports the
long long type).

(e) Repeat part (a), using a float variable instead.

(f) Repeat part (a), using a double variable instead.

(g) Repeat part (a), using a 1long double variable instead.

In cases (e)-(e). the program will display a close approximation of the factorial, not neces-
sarily the exact value.

***************************page_185***************************

***************************page_186***************************
8.1

Arrays

If a program manipulates a large amount of data,
it does so in a small number of ways.

So far, the only variables we've seen are scalar: capable of holding a single data
item. C also supports aggregate variables, which can store collections of values.
TFhere are two kinds of aggregates in C: arrays and structures. This chapter shows
how to declare and use arrays, both one-dimensional (Section 8.1) and multidi-
mensional (Section 8.2). Section 8.3 covers C99’s variable-length arrays. The
focus of the chapter 1S on one-dimensional arrays, which play a much bigger role
in C than do multidimensional arrays. Later chapters (Chapter 12 in particular)
provide additional information about arrays; Chapter 16 covers structures.

One-Dimensional Arrays

An array is à data structure containing a number of data values, all of which have
the same type. These values, known as elements, can be individually selected by
their position within the array.

The simplest kind of array has just one dimension. The elements of a one-
dimensional array are conceptually arranged one after another in a single row (or
column, 1f you prefer). Here’s how we might visualize a one-dimensional array

named a:
_ 101

To declare an array, we must specify the rvpe of the array’s eclements and the
number of elements. For example, to declare that the array a has 10 elements of
type int. we would write

 

 

int a[10] ;

161

***************************page_187***************************
162

Chapter 8  Arrays

constant expressions >-5.3

e E3N

lvalues > 4.2

idiom

idiom

idiom

The elements of an array may be of any type; the length of the array can be speci-
fied by any (integer) constant expression. Since array lengths may need to be
adjusted when the program is later changed, using a macro to define the length of
an array 1s an excellent practice:

#*define N 10

int a [N] ;

Array Subscripting

To access a particular eclement of an array, we write the array name followed by an
integer value in square brackets (this is referred to as subscripting or indexing the
array). Array elements are always numbered starting from 0, so the elements of an
array of length n are indexed from 0 to n — 1. For example, if à is an array with 10
elements, they’re designated by a [(0], a [1], … a [9], as the following figure
shows:

a[0] a[1] a(2] a[3) alé] a(5] a[6] a[7] a(8] af{e]

 

Expressions of the form a [i] are Ivalues, so they can be used in the same way as
ordinary variables:

a[(0] = 1;
print£f("%d\n", a[5]) ;
++a [i] ;

In general, if an array contains elements of type 7, then each element of the array 1s
treated as if it were a variable of type 7. In this example, the clements a [0O],
a [5]. and a [i] behave like int variables.

Arrays and for loops go hand-in-hand. Many programs contain for loops
whose job is to perform some operation on every element in an array. Here are a
few examples of typical operations on an array a of length N

for (i = O; i < N; i++)
a[i] = O0; /* clears a */
for (i = O; i < N; i++)
scanf ("%d", &a[il); /* reads data into a */
for (i = O; i < N; i++)
sum += a[i]; /* sums the elements o£f a */

Notice that we must use the & symbol when calling scanf£ to read an array ele-
ment, just as we would with an ordinary variable.

***************************page_188***************************
/

8.1  One-Dimensional Arrays 163

 

C doesn’t require that subscript bounds be checked; if a subscript goes out of
range, the program’s behavior is undefined. One cause of a subscript going out of
bounds: forgetting that an array with n elements is indexed from O to n — |, not | to
n. (Às one of my professors liked to say, “In this business, you’re always off by
one.’ He was right, of course.) The following example illustrates a bizarre effect
that can be caused by this common blunder:

int a[10], i;

for (i = 1; 1 <= 10; i++)
ali] = O;

With some compilers, this innocent-looking for statement causes an infinite loop!
When i reaches 10, the program stores O into a [10]. But a [10] doesn’t exist,
so O goes into memory immediately after a [9] . If the variable i happens to fol-
low a [9] in memory—as might be the case—then i will be reset to O, causing the
loop to start over.

 

An array subscript may be any integer expression:
a[i+j#10] = 0;

The expression can even have side effects:

i = 0;
while (i < N)
a[li++] = O;

Let’s trace this code. After i 1s set to O, the while statement checks whether i is
less than N. If it is, O 1s assigned to a [0], i is incremented, and the loop repeats.
Note that a [++i] wouldn’t be right, because O would be assigned to a [1] during
the first loop iteration.

 

Be careful when an array subscript has a side effect. For example, the following
loop—which 1s supposed to copy the elements of the array b into the array a—
may not work properly:

i = 0;
while (i < N)
a[i] = b[i++];

The expression a [i] = b[i++] accesses the value of i and also modifies i else-
where in the expression, which—as we saw in Section 4.4—causes undefined
behavior. Of course, we can easily avoid the problem by removing the increment
from the subscript:

for (i = O0; i < N; i++)
a[i] = bli];

 

***************************page_189***************************
164

Chapter8&  Arrays

PROGRAM

reverse.c

initializers > 78.5

Reversing a Series of Numbers

Our first array program prompts the user to enter a series of numbers, then writes
the numbers in reverse order:

Enter 10 numbers: 34 82 49 102 7 94 23 11 50 31
In reverse order: 31 50 11 23 94 7 102 49 82 34

 

Our strategy will be to store the numbers in an array as they’re read. then go
through the array backwards. printing the clements one by one. In other words, we

won't actually reverse the elements in the array, but we'1l make the user think we
did.

/* Reverses a series of numbers */
finclude <stdio.h>

#define N 10

int main (void)

{
int a(n], i;
printf ("Enter %d numbers: ", N);
for (i = O; i < N; i++)
scanf ("%d", &alil]) ;
print£("In reverse order:") ;
for (ài = N - 1; l >= O; i--)
print£(" %d", a[il);
print£ ("\n") ;
return 0;
}

This program shows just how useful macros can be in conjunction with arrays.
The macro N is used four times in the prosram: in the declaration of a, in the
print£ that displays a prompt, and in both for loops. Should we later decide to
change the size of the array. we need only edit the definition of N and recompile
the program. Nothing else will need to be altered; even the prompt will still be cor-
l'ect.

Array Initialization

An array. like any other variable, can be given an initial value at the time it's
declared, The rules are somewhat tricky, though, so we'Il cover some of them now
and save others until later.

The most common form of array initializer is à list of constant expressions
enclosed in braces and separated by commas:

int a[10] = {1, 2, 3, 4, 5, 6, 7, B, 9, 10};

***************************page_190***************************
8.1 _ One-Dimensional Arrays 165

If the initializer 1s shorter than the array, the remaining elements of the array are
siven the value 0:

int a[10] = ({1, 2, 3, 4, 5, 6};
1,

/* initial value of a is ( 2, 3, 4, 5, 6, 0, O, O, O} */

Using this feature, we can easily initialize an array to all zeros:

int a[10] = ({0};
/* initial value of a is (o, o, 0, 0, O, O, 0, O, O, O} */

It’s illegal for an initializer to be completely empty, so we’ve put a single O inside
the braces. It's also illegal for an initializer to be /onger than the array it initial-
iZes.

If an initializer 1s present, the lensth of the array may be omitted:

int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

The compiler uses the length of the initializer to determine how long the array 1s.
The array still has a fixed number of elements (10, in this example), just as 1f we
had specified the length explicitly.

Designated Initializers

lt’s often the case that relatively few elements of an array need to be initialized
explicitly; the other elements can be given default values. Consider the following
example:

int a[15] = {o, o, 29, 0, 0, 0, 0, O, 0, 7, O, O, O, O, 48};

We want element 2 of the array to be 29, element 9 to be 7. and element 14 to be
48, but the other values are just zero. For a large array. writing an initializer in this
fashion is tedious and error-prone (what 1f there were 200 zeros between two of the
nonzero values”).

C99’s designated initializers can be used to solve this problem. Here’s how
we could redo the previous example using a designated initializer:

int a[15] = {[2] = 29, [9] = 7, [14] = 48},

Each number in brackets 1s said to be a designator.

Besides being shorter and easier to read (at least for some arrays), designated
initializers have another advantage: the order in which the elements are listed no
longer matters. Thus, our previous example could also be written in the following
way:

int a[15] = {[14] = 48, [9] = 7, [2]) = 29};

Designators must be integer constant expressions. If the array being initialized
has length n, each designator musi be between 0 and n — |. However, 1f the length
of the array is omitted, a designator can be any nonnegative integer. In the latter
case, the compiler will deduce the length of the array from the largest designator.

***************************page_191***************************
166

Chapter 8  Arrays

QaÂÀ

PROGRAM

repdigit.c

In the following example, the fact that 23 appears as a designator will force the
array to have leneth 24:

int b[] = {[5] 10, [23] = 13, [11] 36, [15] = 29};

An initializer may use both the older (element-by-element) technique and the
newer (designated) technique:

int c[10] = (5, 1, 9, [4] = 3, 7, 2, [8] = 6};,

This initializer specifies that the array’s first three elements will be 5, |. and 9. Ele-
ment 4 will have the value 3. The two elements after element 4 will be 7 and 2.
Finally. element 8 will have the value 6. AIl elements for which no value is speci-
filed will default to zero.

Checking a Number for Repeated Digits

Our next program checks whether any of the digits in a number appear more than
once. After the user enters a number, the program prints either Repeated digit
or No repeated digit:

Enter a number: 28212
Repeated digit

 

The number 28212 has a repeated digit (2): a number like 9357 doesn’t.

The program uses an array of Boolean values to keep track of which digits
appear in a number. The array, named digit_seen, is indexed from O to 9 to
correspond to the 10 possible digits. Initially, every element of the array is false.
(The initializer for digit_seen is {£alse }, which only initializes the first ele-
ment of the array. However. the compiler will automatically make the remaining
elements zero, which is equivalent to false.)

When given a number n, the program examines n°s digits one at a time, stor-
ing each into the digit variable and then using it as an index into digit seen.
Ifdigit_seen [digit] is true, then digit appears at least twice in n. On the
other hand, if digit seen [digit] is false, then digit has not been seen
before, so the program sets digit seen [digit] to true and keeps going.

/* Checks numbers for repeated digits */

finclude <stdbool.h> /* C99 only */
Hinclude <stdio.h>

int main (void)

{
bool digit seen[10] = {false},
int digit;
long n;

print£ ("Enter a number: ") ;
scan£("%1d", &n) ;

***************************page_192***************************
æ

<stdbool .h> header »21.5

 

8.1  One-Dimensional Arrays 167

while (n > O) (
digit = n % 10;
i£f (digit seen[digit])

break;
digit_seen[digit] = true:;
n /= 10;
}
if (n > O)
print£f ("Repeated digit\n") ;
else

print£ ("No repeated digit\n") ;

return 0;

This program uses the names bool, true, and false. which are defined in
C99d's <stdboo!1 .h> header. IT your compiler doesn°t support this header. you*Il
need to define these names yourself. One way to do so is to put the following lines
above the main function:

#define true 1
#define false O
typedef int bool;

Notice that n has type long, allowing the user to enter numbers up to
2,147.483,647 (or more, on some machines).

Using the sizeof Operator with Arrays

The sizeoË operator can determine the size of an array (in bytes). If à is an array
of 10 integers, then sizeo£f (a) is typically 40 (assuming that each integer
requires four bytes).

We can also use sizeof lo measure the size of an array element, such as
a [0] . Dividing the array size by the element size gives the length of the array:

sizeof (a) / sizeof (a{(0o])

Some programmers use this expression when the length of the array is needed. To
clear the array a, for example, we could write

for (i = 0; i « sizeof(a) / sizeof(a[0]); i++)
a[i] = O;

With this technique, the loop doesn't have to be modified if the array length should
change at à later date. Using a macro to represent the array length has the same
advantage, of course, but the si zeof technique is slightly better. since there’s no
macro name to remember (and possibly get wrong).

One minor annoyance is that some compilers produce a warning message for
the expression i < sizeof (a) / sizeof (a [0] ). The variable i probably has

***************************page_193***************************
168

Chapter8  Arrays

parameterized macros > 14.3

PROGRAM

type int (a signed type), whereas sizeof produces a value of type size t (an
unsigned type). We know from Section 7.4 that comparing a signed integer with an
unsigned integer is a dangerous practice, although in this case it’s safe because
both i and sizeof (a) / sizeof (a [0] ) have nonnegative values. To avoid a
warning, we can add a cast that converts sizeof (a) / sizeof (a[0]) toa
signed integer:

for (i = 0; i < (int) (sizeof(a) / sizeof (a[0])); i++)
a[i] = O0;

Writing (int) (sizeof (a) / sizeoËf (a [0] )) is a bit unwieldy; defin-
ing à macro that represents 1t is often helpful:

#define SIZE ((int) (sizeof(a) / sizeof(a[0])))

for (i = O0; i < SIZE; i++)
a[i] = O0;

If we‘re back to using a macro, though, what's the advantage of sizeof? We'll
answer that question in a later chapter (the trick is to add a parameter to the
macro).

Computing Interest

Our next program prints a table showing the value of S100 invested at different
rates of interest over a period of years. The user will enter an interest rate and the
number of years the money will be invested. The table will show the value of the
money at one-year intervals—at that interest rate and the next four higher rates—
assuming that interest is compounded once à year. Here's what a session with the
program will look like:

Enter interest rate: 6
Enter number of years: 5

Years 6% 7% 8% 9% 10%
1l 1106.00 107.00 108.00 109.00 110.00
2 112.36 114.49 116.64 118.881 121.00
3 119.10 122.50 125.97 129.50 133.10
4 126.25 131.088 136.055 141.116 1146.41
5 133.82 140.26 146.93 153.86 161.055

Clearly, we can use à For statement to print the first row. The second row 1s à
little trickier. since its values depend on the numbers in the first row. Our solution
is to store the first row in an array as il‘s computed, then use the values in the array
to compute the second row. Of course, this process can be repeated for the third
and later rows. We'll end up with two £or statements, one nested inside the other.
The outer loop will count from ! to the number of years requested by the user. The
inner loop will increment the interest rate from its lowest value to its highest value.

***************************page_194***************************
82  Multidimensional Arrays 169

interest.c _ /* Prints a table of compound interest */
#include <stdio.h>

#define NUM RATES ((int) (sizeof (value) / sizeof (value [0])))
#define INITIAL BALANCE 100.00

int main (void)
int i, low rate, num years, year;
double value [5] ;

print£ ("Enter interest rate: ");
scan£ ("=d", &low rate) ;

print£f ("Enter number of years: ") ;
scanf ("5d", &num years) ;

print£ ("\nYears") ;
for (i = 0; i < NUM RATES; i++) (

print£f ("%6d%%", low rate + i);
value[i] = INITIAL BALANCE;

}

print£ ("\n") ;

for (year = 1; year <= num years; year++) {
printf ("%3d , year) ;
for (i = 0; i < NUM RATES; i++) |
value[i] += (low rate + i) / 100.0 * value[i];
print£ ("7.2f£", value[i]) ;

}

print£("\n") ;

}

return 0;

;

Note the use of NUM _RATES to control two of the for loops. If we later
change the size of the value array, the loops will adjust automatically.

8.2 Multidimensional Arrays

An array may have any number of dimensions. For example, the following declara-
tion creates a two-dimensional array (a matrix, in mathematical terminology):

int m{[5] [9] ;

The array m 'has 5 rows and 9 columns. Both rows and columns are indexed from O,
as the following figure shows:

***************************page_195***************************
170

Chaptier8  Arrays

/N

comma operator > 6.3

arrays ot pointers » 73.7

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

To access the element of m in row i, column j. we must write m[{i] [7 ]. The
expression m[i] designates row i of m, and m[i] [j] then selects element j in
this row,.

 

Resist the temptation to write m[i,j] instead of m[i] [j]. C treats the comma
as an operator in this context, som[i,j] 1s the same asm[j].

 

Although we visualize two-dimensional arrays as tables, thal's not the way
they’re actually stored in computer memory. C stores arrays in row-major order, with
row 0 first, then row !, and so forth. For example, here’s how the m array 1s stored:

row 0 row 1 row 4

 

 

 

 

We'1l usually ignore this detail, but sometimes 1t will affect our code.

Just as £or loops go hand-in-hand with one-dimensional arrays, nested for
loops are ideal for processing multidimensional arrays. Consider. for example, the
problem of inmitializing an array for use as an identity matrix. (In mathematics, an
identity matrix has l’s on the main diagonal. where the row and column index are
the same, and 0s everywhere else.) We'11 need to visit each element in the array in
some systematic fashion. À pair of nested £or loops—one that steps through every
row index and one that steps through each column index—is perfect for the job:

#define N 10

double ident [N] [N] ;
int row, col;

for (row = 0; row < N; row++)
for (col = 0; col < N; col++)
if (row == col)
ident [row] [col] = 1.0;
else

ident [row] [co1] = 0.0;

Multidimensional arrays play a lesser role in C than in many other program-
ming languages, primarily because C provides a more flexible way to store multi-
dimensional data: arrays of pointers.

***************************page_196***************************
82  Mullidimensional Arrays

Initializing a Multidimensional Array

171

We can create an initializer for a two-dimensional array by nestine one-dimen-

sional initializers:

int m[(5] [9] = |

I

-—

-—

{
{
{
{
(

HHoork

/

—

'

bHeepuy…

’

—

—

OOOOH

/

-—

—

Hbeepeu

'

—

-—

OOH:;OH

/

-—

—

OO OH;O

'

-—

-—

HOOOH

/

=—

L d

-—

beunueye

/

l}l
o},
o},
o}.

1}}

/

Each inner initializer provides values for one row of the matrix. Initializers for
higher-dimensional arrays are constructed in a similar fashion.
C provides à variety of ways to abbreviate initializers for multüidimensional

arrays:

u |f an initializer isn’t large enough to fill a multidimensional array, the remain-
ing elements are given the value O. For example, the following initializer fills

only the first three rows of m:

—

—

OOOOH

—

-—

HHHpuyu

l,
0,
l,

—

—

O0H0O0tk”+

int m[5) [9] = {{1, 1,
{o, 1,
{o0, 1,
u |f an inner list isn‘t long enough to fill
row are initialized to 0:
int m[5] [9] = {{1, 1,
{o, 1,
{o, 1,
{1, 1,
{1, 1,
u We can even omit the inner braces:

int m[5] [9]

'

-

—

}HHOoo#H

—

—

beppey

-—

—

OOOOH+

—

—

beHep

-—

—

OOHOH

the last two rows will contain zéros:

o, 1, 1, 1},

1

, 0, 1, O},

o, 0, 1, O}};

a row, the remaining elements in the

—

-

O OO HO

-—

—

O OO HO

— -—

H OOOH

—

=—

—

H OOOHkH

—

-—

—

HeHHey

HOOOH

—

=—

—

E

Once the compiler has seen enough values to fill one row. it begins filline the

next.

 

Omutting the inner braces in a multidimensional array initializer can be risky, since
an extra element (or even worse, a missing element) will affect the rest of the ini-
tializer. Leaving out the braces causes some complilers to produce a warning mes-

sage such as “missine braces around initializer”

 

C99's designated initializers work with multidimensional arrays. For example.
we could creale a 2 x 2 identity matrix as follows:

***************************page_197***************************
172

Chapter8  Arrays

const type qualifier > 78.3

PROGRAM

time function »26.3

srand funclion »> 26.2

rand function »26.2

double ident [2) [2) = {[0] (0] = 1.0, [(1) [1] = 1.0};

Às usual, all elements for which no value 1s specified will default to zero.

Constant Arrays

Any array, whether one-dimensional or multidimensional. can be made ‘’constant”
by starting its declaration with the word const:

const char hex chars[] =
{'o', '1', '2', ‘3', ‘4', ‘5*, !6', ‘7', '8', ‘9',

'A', ‘B', ‘C', 'D', 'E', ‘F'};

An array that’s been declared const should not be modified by the program; the
compiler will detect direct attempts to modify an clement.

Declaring an array to be const has a couple of primary advantages. It docu-
ments that the program won°t change the array, which can be valuable information
for someone reading the code later. It also helps the compiler catch errors, by
informing it that we don't intend to modify the array.

const isn’t limited to arrays; it works with any variable, as we'll see later.
However, const 1s particularly useful in array declarations, because arrays may
contain reference information that won’t change during program execution.

Dealing a Hand of Cards

Our nexl program illustrates both two-dimensional arrays and constant arrays. The
program deals à random hand from a standard deck of playing cards. (In case you
haven't had time to play games recently, each card in a standard deck has a suir—
clubs, diamonds, hearts, or spades—and a rank—two, three, four, five, six, seven,
eight, nine, ten, jack, queen, king, or ace.) We'Il have the user specify how many
cards should be in the hand:

Enter number of cards in hand: S
Your hand: 7c 2s 5d as 2h

It’s not immediately obvious how we’d write such a program. How do we pick
cards randomly from the deck? And how do we avoid picking the same card twice?
Let’s tackle these problems separately.

To pick cards randomly, we'1l use several C library functions. The t ime func-
tion (from <time .h>) returns the current time, encoded in a single number. The
srand function (from <stdlib.h>) initializes C’s random number generator.
Passing the return value of time to srand prèvents the program from dealing the
same cards every time we run it. The rand function (also from <stdlib.h>)
produces an apparently random number each time it’s called. By using the % oper-
ator, we can scale the return value from rand so that it falls between O and 3 (for
suits) or between O and 12 (for ranks).

To avoid picking the same card twice. we’1l need to keep track of which cards
have already been chosen. For that purpose, we’Il use an array named in_hand

***************************page_198***************************
deal.c

82  Multidimensional Arrays 173

that has four rows (one for each suit) and 13 columns (one for each rank). In other
words, each element in the array corresponds to one of the 52 cards in the deck. AIl
elements of the array will be failse to start with. Each time we pick a card at ran-
dom, we’ll check whether the element of in_ hand corresponding to that card 1s
true or false. If it’s true, we’ll have to pick another card. If it’s false, we’ll store
true in that card's array element to remind us later that this card has already been
picked.

Once we've verified that a card is ‘“new’—not already selected—we'1l need to
translate its numerical rank and suit into characters and then display the card. To
translate the rank and suit to character form, we'll set up two arrays of charac-
ters—one for the rank and one for the suit—and then use the numbers to subscript
the arrays. These arrays won't change during program execution, so we may as
well declare them to be const.

>

 

/* Deals a random hand of cards */

#include <stdbool .h> /* C99 only */
#include <stdio.h>

#include <stdlib.h>

#finclude <time.h>

#define NUM SUITS 4
#define NUM RANKS 13

int main (void)
{
bool in hand [NUM SUITS] [NUM RANKS] = {false};
int num cards, rank, suit;
const char rank code[] = {'2','3','4','5','6','7','8',
l9llltl'ljl'lql'lkl’lal};
const char suit code[] = {'c','d','h','s'};

srand ( (unsigned) time (NULL) ) ;

printf ("Enter number of cards in hand: ") ;
scanf ("3d", &num _ cards) ;

print£ ("Your hand:") ;
while (num cards > O) {

suit = rand() % NUM SUITS; /* picks a random suit */
rank = rand() % NUM RANKS; /* picks a random rank */
i£ (!in hand[suit] [rank]) {

in_hand [suit] [rank] = true;

num_cards--;

©

printf(" %c%c", rank code [rank], suit code [suit]) ;

}
}

print£("\n") ;

return 0;

***************************page_199***************************
174

Chapter8  Arrays

8.3

reverse2.c

Notice the initializer for the in_hand array:
bool in_hand [NUM SUITS] [NUM _ RANKS] = {false};

Even though in_hand is a two-dimensional array, we can use a single pair of
braces (at the risk of possibly incurring a warning from the compiler). Also, we*ve
supplied only one value in the initializer, knowing that the compiler will fill in O
(faise) for the other elements.

Variable-Length Arrays (C99)

Section 8.1 stated that the length of an array variable must be specified by a con-
stant expression, In C99. however, it’s sometimes possible to use an expression
that’s not constant. The following modification of the reverse . c program (Sec-
tion 8.1) illustrates this ability:

/* Reverses a series of numbers using a variable-length
array - C99 only */

#include <stdio.h>

int main(void)

{

int i, n;

print£ ("How many numbers do you want to reverse? ");
scanf ("=d", &n) ;

int af[n]; /* C99 only - length of array depends on n */

print£ ("Enter %d numbers: ", n);
for (i = 0; i < n: i++)
scanf ("*d", &a[i]);

printf ("In reverse order:") ;
for (i = n-1; i >= O; i--)

printf(" %d", a[il);
print£("\n") ;

return 0;

}

The array à in this program is an example of a variable-length array (or VLA for
short). The length of a VLA is computed when the program is executed. not when
the program is compiled. The chief advantage of a VLA is that the programmer
doesn’t have to pick an arbitrary length when declaring an array; instead. the pro-
gram itsclf can calculate exactly how many elements are needed. If the program-
mer makes the choice, it’s likely that the array will be too long (wasting memory)
or too short (causing the program to fail). In the reverse2. c program, the num-

***************************page_200***************************
static storage duration > 78.2

> ©

> Q

Q & À 175

ber entered by the user determines the length of a; the programmer doesn't have to
choose a fixed length, unlike in the original version of the program.

The length of a VLA doesn*t have Lo be spccified by a single variable. Arbi-
trary expressions, possibly containing operators, are also legal. For example:

int a[(3#*i+5] ;
int b[3j+k] ;

Like other arrays. VLAs can be multidimensional:
int c[m] [n] ;

The primary restriction on VLAs is that they can*t have static storage duration.
(We haven*‘t yet seen any arrays with this property.) Another restriction 1s thal a
VLA may not have an initializer.

Variable-length arrays are most often seen in functions other than main. One
big advantage of a VLA that belongs to a function £ is that it can have a different
length each time £ is called. We’Il explore this fcature in Section 9.3.

Q & À

Why do array subscripts start at 0 instead of 1? [p. 162]

Having subscripts begin at O simplifies the compiler a bit. Also, it can make array
subscripting marginally faster.

What if I want an array with subscripts that go from 1 to 10 instead of 0 to 9

Here’s a common trick: declare the array to have !! elements instead of 10. The
subscripts will go from O to 10, but you can just ignore element 0.

Is it possible to use a character as an array subscript?

Yes. because C treats characters as integers. You*I1 probably need to “scale” the
character before you use it as a subscript, though. Let's say that we want the
letter count array to keep track of a count for each letter in the alphabet. The
array will need 26 elements, so we’d declare it in the following way:

int letter count [26] ;

However, we can’t use letters to subscript 1etter _ count directly, because their
integer values don't fall between O and 25. To scale a lower-case letter to the
proper range, we can simply subtract ' a ' ; lo scale an upper-case letter, we'Il sub-
tract 'A'. For example, if ch contains a lower-case letter, we’d write

letter count [ch-'a'] = 0;

to clear the count that corresponds to ch. À minor caveat: this technique isn’t com-
pletely portable, because it assumes that letters have consecutive codes. However,
it works with most character sets, including ASCII.

***************************page_201***************************
176

Chapter8  Arrays

Q:

memcpy function » 23.6

It seems like a designated initializer could end up initializing an array element
more than once. Consider the following array declaration:

int a[] = {4, 9, 1, 8, [0] = 5, 7};

Is this declaration legal, and if so, what is the length of the array? [p. 166]

Yes, the declaration is legal. Here’s how it works: as it processes an initializer list.
the compiler keeps track of which array element is to be initialized next. Normally,
the next element is the one following the element that was last initialized. How-
ever, when a designator appears in the list, it forces the next element be the one
represented by the designator, even if rhat element has already been initialized.

Here ‘s a step-by-step look at how the compiler will process the initializer for
the array a:

The 4 initializes element 0; the next element to be initialized is clement 1.

The 9 initializes element ]: the next eclement to be initialized is element 2.

The | initializes element 2: the next element to be initialized 1s element 3.

The 8 initializes element 3; the next element to be initialized is element 4.

The [0] designator causes the next element to become O, so the 5 initializes
element O (replacing the 4 previously stored there). The next clement to
be initialized 1s element 1.

The 7 initializes element ! (replacing the 9 previously stored there). The next
element to be initialized is element 2 (which is irrelevant since we*re at
the end of the list).

The net effect is the same as if we had written
int a(] = {5, 7, 1, 8};

Thus, the leneth of this array 1s four.

The compiler gives me an error message if I try to copy one array into another
by using the assignment operator. What’s wrong?
Although it looks quite plausible, the assignment

a = b; /* a and b are arrays */

is indeed 1llegal. The reason for its illegality isnt obvious: it has to do with the
peculiar relationship between arrays and pointers in C, a topic we*ll explore in
Chapter 12.

The simplest way to copy one array into another is to use a loop that copies the
elements, one by one:

for (i = O; i < N: i++)
a[i] = bl[i];

Another possibility is to use the memcpy (*memory copy”) function from the
<string.h> header. memcpy 1s a low-leve] function that simply copies bytes
from one place to another. To copy the array b into the array a. use memcpy as
follows:

***************************page_202***************************
Section 8.1

Section 8.2

@

ID

9

Exercises 177

memcpy (a, b, sizeof (a)) ;

Many programmers prefer memcopy, especially for large arrays, because it’s poten-
tially faster than an ordinary loop.

Section 6.4 mentioned that C99 doesn°t allow a goto statement to bypass the
declaration of a variable-length array. What’s the reason for this restriction?

The memory used to store a variable-length array is usually allocated when the
declaration of the array is reached during program execution. Bypassing the decla-
ration using a goto statement could result in a program accessing the elements of
an array that was never allocated.

Exercises

We discussed using the expression sizeof (a) / sizeof (a [0] ) to calculate the num-
ber of elements in an array. The expression sizeoË (a) / sizeof (r), where r is the type
of a's elements. would also work, but il’s considered an inferior technique. Why?

The Q&A section shows how to use a letter as an array subscript. Describe how to use a
digit (in character form) as a subscript.

Write a declaration of an array named weekend containing seven bool values. Include an
initializer that makes the first and last values true; all other values should be false.

(C99) Repeat Exercise 3, but this time use a designated initializer. Make the initializer as
short as possible.

The Fibonacci numbers are O. 1. 1. 2. 3. 5. 8, 13, …, where each number is the sum of the
two preceding numbers. Write a program fragment that declares an array named
fib numbers of length 40 and fills the array with the first 40 Fibonacci numbers. Hint:
Fill in the first two numbers individually, then use a loop to compute the remaining num-
bers.

Calculators, watches, and other electronic devices often rely on seven-segment displays for
numerical output. To form a digit, such devices “turn on” some of the seven segments while
leaving others “off””:

Suppose that we want to set up an array that remembers which segments should be “on” for
each digit. Let’s number the segments as follows:

L
5 ê_|1
s| , [2
Here’s what the array might look like, with each row representing one digit:

const int segments[10] [7] = {{1, 1, 1, 1, 1, 1, O}, —}:

l’ve given you the first row of the initializer; fill in the rest.

***************************page_203***************************
178

Chapter8  Arrays

@ 7.

10.

[l.

ue

Using the shorteuts described in Section 8.2, shrink the initializer for the segments array
(Exercise 6) as much as you can.

Write a declaration for a two-dimensional array named temperature readings that
stores one month of hourly temperature readings. (For simplicity. assume that a month has
30 days.) The rows of the array should represent days of the month; the columns should rep-
resent hours of the day.

Using the array of Exercise 8. write a program fragment that computes the average tempera-
ture for a month (averaged over all days of the month and all hours of the day).

Write à declaration for an 8 x 8 char array named chess _board. Include an initializer
that puts the following data into the array (one character per array clement):

r nbgqkbnr
PPPPPPPP

PPPPPPPP
RNBOQOKBNR
Write à program fragment that declares an 8 x 8 char array named checker board and
then uses a loop to store the l'ollowing data into the array (one character per array element):

BRBRBRBR
RBRBRBRB
BRBRBRBR
RBRBRBRB
BRBRBRBR
RBRBRBRRB
BRBRBRBR
RBRBRERB

Hint: The element in row /, column j, should be the letter B if / + / is an even number.

Programming Projects

Modify the repdigit .c program of Section 8.1 so that it shows which digits (if any)
were repeated:

Enter a number: 939577
Repeated digit (s): 7 9

Modify the repdigit .c program of Section 8.1 so that it prints à table showing how
many times each digit appears in the number:

Enter a number: 41271092
Digit : 0 12 3 4 5 6 7 8 89
Occurrences : 1. 2 2 01000101

Modify the repdigit .c program of Section 8.1 so that the user can enter more than one
number to be tested l'or repeated digits. The program should terminate when the user enters
a number thats less than or equal to 0.

***************************page_204***************************
n

6.

Programming Projects 179

Modify the reverse.c program of Section 8.1 to use the expression (int)
(sizeof (a) / sizeof (a [0] )) (or a macro with this value) for the array length.

Modify the interest .c program of Section 8.1 so that it compounds interest monrhly
instead of annually. The form of the output shouldn't change: the balance should still be
shown at annual intervals.

The prototypical Internet newbie is a fellow named B1FF, who has a unique way of writine
messages. Here’s a typical B1FF communiqué:
H3Y DUD3, C 15 RI1ILLY COOL!!! ! ! E! !!!

Write a “B1FF filter* that reads a message entered by the user and translates it into B1FF-
speak:

Enter message: Hey dude, C is rilly cool
In B1FF-speak: H3Y DUD3, C 15 R1LLY COOL! ! !! !! ! 111

 

Your program should convert the message to upper-case letters, substitute digits for certain
letters (A>4, B>8, E>3, I>1, O>0, S>5), and then append 10 or so exclamation marks.
Hint: Store the original message in an array of characters, then go back through the array,
transiating and printing characters one by one.

Write a program that reads a 5 x 5 array of integers and then prints the row sums and the
column sums:

 

 

 

 

Enter row 1: 8 3 9 O 10
Enter row 2: 3 5 17 1 1l
Enter row 3: 2 B 6 23 l
Enter row 4: 15 7 3 2 9
Enter row 5: 6 14 2 6 0

 

Row totals: 30 27 40 36 28
Column totals: 34 37 37 32 21

Modify Programming Project 7 so that it prompts for five quiz grades for each of five stu-
dents, then computes the total score and average score for each student, and the average
score, high score, and low score for cach quiz.

Write a program that generates à ‘“random walk” across a 10 x 10 array. The array will con-
tain characters (all * . * initially). The program must randomly “walk” from element to ele-
ment, always going up, down. left. or right by one element. The elements visited by the
program will be labeled with the letters A through Z, in the order visited. Herc's an example
of the destred output:

A ..
B CLD
F E
H G
Ï .
J ‘ . à
K..RsTUVY
LMPO Wx
N O

Hint: Use the srand and rand functions (see deal .c) to generate random numbers.
After senerating a number, look at its remainder when divided by 4. There are four possible
values for the remainder—0, !. 2, and 3—indicating the direction of the next move. Before
performing a move. check that (a) it won’t go outside the array, and (b) it doesn't take us to

***************************page_205***************************
180

Chapter 8

Arrays

10.

ll.

13.

14.

15.

an element that already has à letter assigned. If either condition is violated. try moving In
another direction. If all four directions are blocked. the program must terminate. Herc's an
example of premature termination:

Y is blocked on all four sides, so there’s no place to put Z.

Modify Programming Project 8 from Chapter 5 so that the departure times are stored in an
array and the arrival times are stored in a second array. (The times are integers, representing
the number of minutes since midnight.) The program will use a loop to scarch the array of
departure times for thc one closest to the time entered by the user.

Modify Programming Project 4 from Chapter 7 so that the program labels its output:

Enter phone number: 1-800-COL-LECT
In numeric form: 1-800-265-5328

The program will need to store the phone number (cither in its original form or in its
numeric form) in an array of characters until it can be printed. You may assume that the
phone number is no more than 15 characters long.

 

Modify Programming Project S from Chapter 7 so that the SCRABBLE values of the letters
are storecl in an array. The array will have 26 elements, corresponding to the 26 letters of the
alphabet. For example, element O of the array will store | (because the SCRABBLE value of
the letter À 1s 1), element ! of the array will store 3 (because the SCRABBLE value of the
letter B is 3), and so forth. As each character of the input word is read, the program will use
the array to determine the SCRABBLE value of that character. Use an array initializer to set
up the array.

Modify Programming Projeet 11 from Chapter 7 so that the program labels its output:

Enter a first and last name: Lloyd Fosdick
You entered the name: Fosdick, L.

 

The program will need to store the last name (but not the first name) in an array of characters
until it can be printed. You may assume that the last name is no more than 20 characters long.

Write a program that reverses the words in a sentence:

Enter a sentence: you can cage a swallow can't you?
Reversal of sentence: you can't swallow a cage can you?

 

Hint: Use à loop to read the characters one by one and store them in a one-dimensional
char array. Have the loop stop at à period, question mark, or exclamation point (the “termi-
nating character”), which is saved in a separate char variable. Then use à second loop to
scarch backward through the array for the beginning of the last word. Print the last word,
then search backward for the next-to-last word. Repeat until the beginning of the array 1s
reached. Finally, print the terminating character.

Onc of the oldest known eneryption techniques is the Caesar cipher, attributed to Julius Cae-
sar. I involves replacing each letter in a message with another letter that is à lixed number of

***************************page_206***************************
16.

l'7.

Programming Projects 181

positions later in the alphabet. (IF thé replacement would go past the letter Z the cipher
“wraps around” to the beginning of the alphabct. For example, 1f each letter is replaced by
the letter two positions after it. then Y would be replaced by À. and Z would be replaced by
B.) Write à program that encrypts a message using a Caesar cipher. The user will enter the
message to be encrypted and the shift amount (the number of positions by which letters
should be shifted):

Enter message to be encrypted: Go ahead, make my day.
Enter shift amount (1-25): 3
Encrypted message: Jr dkhdg, pdnh pb gdb.

 

Notice that the program can decrypt a message if the user enters 26 minus the original key:

Enter message to be encrypted: Jr dkhdg, pdnh pb qdb.
Enter shift amount (1-25): 23
Encrypted message: Go ahead, make my day.

 

You may assumc that the message does not excecd 80 characters. Characters other than let-
ters should be left unchanged. Lower-case letters remain lower-case when encrypted, and
upper-case letters remain upper-case. Hint: To handle the wrap-around problem, use the
expression ( (ch - 'A') +n) % 26 + 'A' lo calculate the encrypted version of an upper-
case letter. where ch stores the letter and n stores the shift amount. (You'Il need a similar
expression for lower-case letters.)

Write a program that tests whether two words are anagrams (permutations of the same let-
ters):

Enter first word: smartest
Enter second word: mattress
The words are anagrams.

Enter first word: dumbest
Enter second word: stumble
The words are not anagrams.

Write a loop that reads the first word, character by character, using an array of 26 integers to
keep track of how many times each letter has been seen. (For example. after the word smart-
esr has been read, the array should contain the valucs 100010000000100001220
0 0000. reflecting the fact that smartest contains one a, one € one n, One r, two s's and
two s.) Use another loop to read the second word. except this time decrementing the corre-
sponding array element as each letter is read. Both loops should ignore any characters that
aren*t letters, and both should treat upper-case letters in the same way as lower-case letters.
After the second word has been read, use a third loop to check whether all the clements in
the array are zero. If so. the words are anagrams. Hint: You may wish to use functions from
<ctype.h>, such as isalpha and tolower.

Write a program that prints an n X n magic square (a square arrangement of the numbers
° - . .

| 2. …. n7 in which the sums of the rows, columns, and diagonals are all the same). The

user will specify the value of n:

This program creates a magic square of a specified size.
The size must be an odd number between 1 and 99.
Enter size of magic square: S

177 24 l 8 15
23 5 7 14 16
4 6 13 20 22
10 12 19 21 3

11 18 25 2 9

***************************page_207***************************
182 Chapter 8  Arrays

Store the magic square in a two-dimensional array. Start by placing the number ! in the mid-
dle of row 0. Place each of the remaining numbers 2, 3, …. n? by moving up one row and
over one column. Any attempt to go outside the bounds of the array should “wrap around”
to the opposite side of the array. For example, instead of storing the next number in row —I,
we would store it in row n — 1 (the last row). Instead of storing the next number in column ».
we would store it in column O. If a particular array element is already occupied, put the
number directly below the previously stored number. IF your compiler supports variable-
length arrays, declare the array to have n rows and n columns. !f not, declare the array to
have 99 rows and 99 columns.

***************************page_208***************************
9.1

Functions

If you have a procedure with ten
parameters, you probably missed some.

We saw in Chapter 2 that a function is simply a series of statements that have been
grouped together and given a name. Although the term “function” comes from
mathematics. C functions don*t always resemble math functions. In C, a function
doesn't necessarily have arguments, nor does it necessarily compute à value. (In
some programming languages, a “function” returns a value, whereas a “’procedure”
doesn*t. C lacks this distinction.)

Functions are the building blocks of C programs. Each function 1s essentially a
smalt program, with its own declarations and statements. Using functions, we can
divide a program into small pieces that are easier for us—and others—to under-
stand and modify. Functions can take some of the tedium out of programming by
allowing us to avoid duplicating code that’s used more than once. Moreover, func-
tions are reusable: wc can take a function that was originally part of one program
and use it in others.

Our programs so far have consisted of just the main function. In this chapter,
we'll see how to write functions other than main, and we’ll learn more about
main itself. Section 9.1 shows how to define and call functions. Section 9.2 then
discusses function declarations and how they differ from function definitions.
Next, Section 9.3 examines how arguments are passed to functions. The remainder
of the chapter covers the return statement (Section 9.4), the related issue of pro-
eram termination (Section 9.5), and recursion (Section 9.6).

 

Defining and Calling Functions

Before we go over the formal rules for defining a function, let’s look at three sim-
ple programs that define functions.

183

***************************page_209***************************
184

Chapter9 Functions

PROGRAM

eF3N

Computing Averages

Suppose we often need to compute the average of two double values. The C
lrbrary doesn't have an ‘“‘average” function, but we can easily define our own.
Here’s what it would look like:

double average (double a, double b)

{

return (a + b) / 2;

}

The word double at the beginning is average'’s return type: the type of data
that the function returns each time its called. The identifiers a and b (the func-
tion’s parameters) represent the two numbers that will be supplied when aver-
age is called. Each parameter must have a type (just like every variable has a
type); In this example, both à and b have type double. (It may look odd. but the
word double must appear twice, once for a and once for b.) À function parame-
ter is essentially a variable whose initial value will be supplied later, when the
function 1s called.

Every function has an executable part, called the body. which is enclosed in
braces. The body of average consists of a single return statement. Executing
this statement causes the function to “return” to the place from which it was called:
the value of (a + b) / 2 will be the value returned by the function.

To call à function. we write the function name, followed by a list of argu-
ments. For example, average (x, y) is a call of the average function. Argu-
ments are used to supply information to a function: in this case. average needs
to kKnow which two numbers to average. The effect of the call average (x, y) is
to copy the values of x and y into the parameters a and b. and then execute the
body of average. An argument doesn’t have to be à variable; any expression of a
compatible type will do, allowing us to write average (5.1, 8.9) or aver-
age (x/2, y/3).

We'll put the call of average in the place where we need to use the return
value. For example. we could write

printf ("Average: %g\n", average(x, y));

to compute the average of x and y and then print it. This statement has the follow-
ing effect:

The average function is called with x and y as arguments.

x and y are copied into a and b.

average executes its return statement, returning the average of à and b.
print£ prints the value that average returns. (The return value of
average becomes one of print£'s arguments.)

L tV —

#

Note that the return value of average isn’t saved anywhere; the program prints it
and then discards it. If we had necded the return value later in the program. we
could have captured it in à variable:

***************************page_210***************************
average.c

PROGRAM

 

9.1  Defining and Calling Functions 185

avg = average(x, y);

This statement calls average. then saves its return value in the variable ava.
Now, let’s use the average function in a complete program. The followine
program reads three numbers and computes their averages. one pair at a ume:

Enter three numbers: 3.5 9.6 10.2
Average of 3.5 and 9.6: 6.55
Average of 9.6 and 10.2: 9.9
Average of 3.5 and 10.2: 6.85

 

Among other things, this program shows that a function can be called as often as
we need.

/* Computes pairwise averages of three numbers */
#include <stdio.h>

double average (double a, double b)

(

return (a + b) / 2;

}

int main (void)

{

double x, y, z;

print£ ("Enter three numbers: ") ;
scanf ("S1f51£3121", EXx, &y, EKZ) ;
print£ ("Average of %g and %g: %g\n", x, y, average(x, y));
printf ("Average of %g and %g: %g\n"', y, z, average(y, Zz));
print£ ("Average of %g and %g: %g\n"', x, z, average(x, z));

return 0;

}

Notice that l’ve put the definition of average before main. We'Il see in Section
9.2 that putting average after main causes problems.

Printing a Countdown

Not every function returns a value. For example. a function whose job is to pro-
duce output may not need to return anything. To indicate that a function has no
return value, we specify that its return type is void. (void is a type with no val-
ues.) Consider the following function. which prints the message T minus » and
counting, where n is supplied when the function 1s called:

void print count (int n)

{

printf("T minus %d and counting\n", n);

}

***************************page_211***************************
186

Chapter9 Functions

countdown.c

PROGRAM

print_count has one parameter. n. of type int. lIt returns nothing, so l’ve
specified void as the return type and omitted the return statement. Since
print_count doesn’t return a value, we can°t call it in the same way we call
average. Instead, a callof print count must appear in a statement by itself:

print count (i) ;
Here's a program that calls print _count 10 times inside a loop:
/* Prints a countdown */

#include <stdio.h>

void print count (int n)

{
print£("T minus %d and counting\n", n);
}
int main(void)
{
int i;
for (ài = 10; i > O; --i)

print _ count (i) ;

return 0;

}

Initially, à has the value 10. When print_count is called for the first time,
i is copied into n, so that n takes on the value 1O as well. As a result. the first call
ofprint count vwill print

T minus 10 and counting
print_count then returns to the point at which it was called, which happens to
be the body of a £or statement. The £or statement resumes where it left off, dec-

rementing i to 9 and testing whether it’s greater than O. Ttis, so print count is
called again, this time printing

T minus 9 and counting

Each time print_count is called, i is different, so print count will print
10 different messages.

Printing a Pun (Revisited)

Some functions have no parameters at all. Consider print_pun, which prints a
bad pun each time it’s called:

void print pun (void)

{

print£ ("To C, or not to C: that is the question.\n") ;

}

***************************page_212***************************
pun2.c

function definition

9.1  Defining and Calling Functions 187

The word void in parentheses indicates that print pun has no arguments.
(This time, we*re using void as à placeholder that means “‘nothing goes here.”)

To call à function with no arguments. we write the function’s name, followed
by parentheses:

print _pun () ;

The parentheses must be present, even though there are no arguments.
Here’s a tiny program that tests the print pun function:

/* Prints a bad pun */
#include <stdio.h>

void print _ pun (void)

(

printf ("To C, or not to C: that is the question.\n") ;

}

int main(void)

(
print_pun () ;
return 0;

}

The execution of this program begins with the first statement in main, which
happens to be a call of print pun. When print_pun begins to execute, it in
turn calls print£ to display a string. When print£ returns, print_pun re-
turns to main.

Function Definitions

Now that we’ve seen several examples, let’s look at the general form of a function
definition:

return-type function-name ( paramerers )

{

declarations
sStatements

The return type of a function is the type of value that the function returns. The
following rules govern the return type:

u Functions may not return arrays, but there are no other restrictions on the
return type.

# Specifying that the return type is void indicates that the function doesn't
return a value.

***************************page_213***************************
188 Chapter9 Functions

æ

 

After the function name comes a list of parameters. Each parameter is pre-
ceded by a specification of its type; parameters are separated by commas. If the
function has no parameters. the word void should appear between the parenthe-

ses. Note: À separate type must be specified for each parameter. even when several
parameters have the same type:

double average (double a, b) /*** WRONG ***/

{

return (a + b) / 2;

}

The body of a function may include both declarations and statements. For
example, the average function could be written

double average (double a, double b)

{
double sum: /* declaration */
sum = a + b; /* statement */
return sum / 2; /* statement */

;

 

***************************page_214***************************
>

Q&A

expression statements > 4.5

 

9.1  Defining and Calling Functions 189

Function Calls

À function call consists of a function name followed by a list of arguments.
enclosed in parentheses:

average (x, y)
print count (i)
print pun()

 

If the parentheses are missing, the function won°t get called:
print pun; /*** WRONG ***/

The result is a legal (albeit meaningless) expression statement that looks correct,
but has no effect. Some compilers issue à warning such as “sratement with no

effect.”

 

À call of a void function is always followed by a semicolon to turn it into a
statement:

print _count (i) ;
print pun() ;

À call of a non-void function, on the other hand. produces a value that can be
stored in a variable, tested. printed, or used in some other way:

avg = average(x, y);
if (average(x, y) > O)

print£ ("Average is positive\n") ;
print£("The average is %g\n", average(x, y));

The value returned by à non-void function can always be discarded 1f it’s not
needed:

average(x, y) ; /* discards return value */

This call of average 1s an example of an expression statement: a statement that
evaluates an expression but then discards the result.

[gnoring the return value of average is an odd thing to do. but for some
functions it makes sense.

 

***************************page_215***************************
190

Chapter9 Functions

casting » 7.4

PROGRAM

prime.c

 

Testing Whether a Number Is Prime

To see how functions can make programs easier to understand, let’s write a pro-
gram that tests whether a number 1s prime. The program will prompt the user to
enter « number, then respond with a message indicating whether or not the number
Is prime:

Enter a number: 34

Not prime

Instead of putting the prime-lesting details in main. we'll define a separate func-
tion that returns true 1f its parameter 1s a prime number and false if it isn°t.
When given a number n, the is_prime function will divide n by each of the
numbers between 2 and the square root of n: if the remainder is ever 0. we know
that n isn’t prime.

/* Tests whether a number is prime */

#include <stdbool.h> /* C99 only */
Hinclude <stdio.h>

bool is prime (int nD)

(

int divisor;

if (n «= 1)
return false;
for (divisor = 2; divisor * divisor <= n; divisor++)
if (n % divisor == O)
return false;
return true;

}

int main(void)

{

int n;

printf ("Enter a number: ") ;
scanf ("$d", &n) ;
if (is prime(n))
print£ ("Prime\n") ;
else
printf ("Not prime\n") ;

***************************page_216***************************
9.2  Function Declarations 191

return O0;

}

Notice that main contains a variable named n even though is prime’s
parameter 1s also named n. In general, a function may declare a variable with the
same name as a variable in another function. The two variables represent different
locations in memory, so assigning a new value to one variable doesn’t change the
other. (This property extends to parameters as well.) Section 10.1 discusses this
point in more detail.

Âs is_prime demonstrates, a function may have more than one return
statement. However, we can execute just one of these statements during a given
call of the function, because reaching a return statement causes the function to
return to where it was called. We’1l learn more about the return statement in
Section 9.4.

 

#Hinclude <stdio.h>

int main(void)

{

double x, y, Z;

print£ ("Enter three numbers: ") ;
scanf ("%1£%1£%1f", &X, &Y, E&Z);
printf ("Average of %g and %g: %g\n"', x, y, average(x, y));
print£ ("Average of %g and %g: %g\n", y, z, average(y, Zz));
print£ ("Average of %g and %g: %g\n"', x, z, average(x, z))

’

return 0;

}

double average (double a, double b)

{

return (a + b) / 2;

}

 

***************************page_217***************************
192 Chapter 9 Functions

default argument promotions > 9.3

function declaration

QaA

 

#include <stdio.h>

double average (double a, double b); /* DECLARATION */

int main (void)

(

double x, y, Z;

print£f ("Enter three numbers: ") ;

scanftf ("S1£$1lES1£", E&EX, &y, E&Z) ;

print£f ("Average of %g and %g: %g\n"', x, y, average(x, y

print£ ("Average of %g and %g: %g\n", y, z, average(y, z
( Z

) ) ;

) )
) ) ;

print£ ("Average of %g and %g: %g\n"', x, z, average (x,
return 0;

}

double average (double a, double b) /* DEFINITION */

{

return (a + b) / 2;

}

eF3N

 

***************************page_218***************************
Q&A

@

9.3

9.3  Arguments 193

 

Arquments

Let's review the difference between a parameter and an argument. -

 

In C, arguments are passed by value: when a function 1s called, each argument
Is evaluated and its value assigned to the corresponding parameter. Since the
parameter contains a copy of the argument's value. any changes made to the
parameter during the execution of the function don’t affect the argument. In effect,
each parameter behaves like à variable that’s been initialized to the value of the
matching argument.

The fact that arguments are passed by value has both advantages and disad-
vantages. Since a parameter can be modified without affecting the corresponding
argument, we can use parameters as variables within the function, thereby reduc-
ing the number of genuine variables neëded. Consider the following function.
which raises a number x to à power n:

int power (int x, int n)

{

int i, result = 1;

for (i = 1; i <= n; i++)
result = result * x;

return result;

}

Since n 1s a copy of the original exponent, we can modify it inside the l'unction,
thus removing the need for i:

***************************page_219***************************
194 Chapter9 Functions

int power (int x, int n)

{

int result = 1;

while (n-- > O)
result = result * x;

return result:;

}

 

***************************page_220***************************
9.3  Arguments 195

 

 

Array Arguments

Arrays are often used as arguments. When a function parameter is a one-dimen-
e{740 _ sional array, the length of the array can be (and 1s normally) left unspecified:

int f(int a[]) /* no length specified */

{
}

The argument can be any one-dimensional array whose elements are of the proper
type. There’s just one problem: how will £ know how long the array is? Unfortu-
nately, C doesn’t provide any easy way for a function to determine the length of an

array passed Lo it. Instead, we’I] have to supply the length—if the function needs
it—as an additional argument.

***************************page_221***************************
196 Chapter9 Functions

 

Although we can use the sizeof operator to help determine the length of an
array variable, it doesn’t give the correct answer for an array parameter:

int f(int a[])

(

int len = sizeof(a) / sizeof (a [0]) ;
/*** WRONG: not the number of elements in a ***/

}

Section 12.3 explains why.

 

The following function illustrates the use of one-dimensional array arguments.
When given an array a of int values, sum_array returns the sum of the ele-
Ments in à. Since sum_array needs to know the lengih of a, we must supply it
äs a second argument.

int sum array(int a[], int n)

{

int i, sum = O0;

for (i = 0; i < n; i++)
sum += a[i];

return sum;

}

The prototype for sum_array has the following appearance:
int sum _ array(int a[], int n);

ÂS usual. we can omit the parameter names if we wish:

int sum array(int [], int);

When sum_array is called, the first argument will be the name of an array.
and the second will be its length. For example:

#define LEN 100

int main(void)

(
int b[LEN], total;
total = sum array(b, LEN) ;

}

Notice that we don*t put brackets after an array name when passing it to à function:

total = sum array(b[], LEN) ; /*** WRONG **x/

***************************page_222***************************
QaÂ

9.3  Arguments 197

An important point about array arguments: À function has no way to check
that we've passed it the correct array length. We can exploit this fact by telling the
function that the array is smaller than 1t really 1s. Suppose that we’ve only stored
50 numbers in the b array, even though it can hold 100. We can sum just the first
50 elements by writing

total = sum array(b, 50); /* sums first 50 elements */

sum _ array will ignore the other 50 elements. (Indeed, 11 won't know that they
even exist!)

 

Be careful not to tell à function that an array argument 1s /arger than 1t really 1s:
total = sum array(b, 150); /*** WRONG ***/

In this example, sum_array will go past the end of the array. causing undefined
behavior.

 

Another important thing to know is that a function is allowed to change the
elements of an array parameter. and the change 1s reflected in the corresponding
argument. For example. the following function modifies an array by storing zero
into each of its elements:

void store zeros(int a[], int n)

{

int i;

Il
©Êo
H-
A
J
H-
+
+

for (i
a[i] = O;

}
The call

store zeros(b, 100);

will store zero into the first 100 elements of the array b. This ability to modify the
elements of an array argument may seem to contradict the fact that C passes argu-
ments by value. In fact, there’s no contradiction, but ! won’t be able to explain why
until Section 12.3.

If a parameter is a multidimensional array, only the length of the first dimen-
sion may be omitted when the parameter is declared. For example, 1f we revise the
sum_array function so that à is a two-dimensional array, we must specify the
number of columns in a. although we don’t have to indicate the number of rows:

#define LEN 10

int sum two dimensional array(int a[) [LEN], int n)

(

int i, j, sum = O0;

***************************page_223***************************
198

Chaptier9 Functions

arrays of pointers » 13.7

æ

variable-length arrays > 8.3

for (i = 0; i < n; i++)
for (j = 0; j < LEN; j++)
sum += a[i] [(j] ;

return sum;

;

Not being able to pass multidimensional arrays with an arbitrary number of col-
umns can be a nuisance. Fortunately, we can often work around this difficulty by
using arrays of pointers. C99's variable-length array parameters provide an even
better solution to the problem.

Variable-Length Array Parameters

C99 adds several new twists lo array arguments. The first has to do with variable-
length arrays (VLAs), a feature of C99 that allows the length of an array to be
specified using a non-constant expression. Variable-leneth arrays can also be
parameters, as it turns out.

Consider the sum_array function discussed earlier in this section. Here*s
the definition of sum_array, with the body omitted:

int sum array(int a(], int n)

(
}

Âs 1t stands now, there’s no direct link between n and the length of the array a.
Although the function body treats n as a’s length, the actual length of the array
could in fact be larger than n (or smaller, in which case the function won’t work
correctly).

Using a variable-length array parameter, we can explicitly state that a’s length
Is n:

int sum array(int n, int a(n])

{
}

The value of the first parameter (n) specifies the length of the second parameter
(a). Note that the order of the parameters has been switched: order is important
when variable-length array parameters are used.

 

The following version of sum_array is illegal:

int sum array(int af[n], int n) /*** WRONG ***/

(
}

The compiler will issue an error message at int a [n] . because it hasn’t yet seen n.

 

***************************page_224***************************
9.3  Arguments 199

There arc several ways to write the prototype for our new version of
sum _ array. One possibility is to make it look exactly like the function defini-
tion:

int sum array(int n, int aln]); /* Version 1 */
Another possibility is to replace the array length by an asterisk (* ):
int sum array(int n, int a[*]); /* Version 2a */

The rcason for using the * notation 1s that parameter names are optional in func-
tion declarations. If the name of the first parameter is omitted. it wouldn’t be possi-
ble to specify that the length of the array is n, but the * provides a clue that the
length of the array is related to parameters that come earlier in the list:

int sum array(int, int [*]); /* Version 2b */

It’s also legal to leave the brackets empty, as we normally do when declaring an
array parameter:

int sum array(int n, int a[]); /* Version 3a */
int sum array(int, int [(l):; /* Version 3b */

Leaving the brackets empty isn’t a good choice, because it doesn’t expose the rela-
tionship between n and a.

In general, the length of a variable-length array parameter can be any expres-
sion. For example, suppose that we were to write a function that concatenates two
arrays a and b by copying the elements of a, followed by the elements of b, into a
third array named c:

int concatenate (int m, int n, int a[m], int b[n], int c[m+n])

{
}

The length of c is the sum of the lengths of à and b. The expression used to spec-
ify the length of c involves two other parameters, but in general it could refer to
variables outside the function or even call other f'unctions.

Variable-length array parameters with a single dimension—as In all our exam-
ples so far—have limited usefulness. They make à function declaration or defini-
tion more descriptive by stating the desired length of an array argument. However,
no additional error-checking 1s performed: 1t’s still possible for an array argument
to be too long or too short.

[L turns out that variable-leneth array parameters are most useful for multidi-
mensional arrays. Earlier in this section, we tried to write a function that sums the
elements in à two-dimensional array. Our original function was limited to arrays
with a fixed number of columns. Tf we use a variable-length array parameter, we
can generalize the function to any number of columns:

***************************page_225***************************
200

Chapter 9

Functions

int sum_two _ dimensional _ array(int n, int m, int al[n] [m])

{

int i, j, sum = O0;

for (i = 0; i < n; i++)
Éor (j = 0; j < m; j++)
sum += al[il [j] ;

return sum;

}

Prototypes for this function include the following:

int sum _ two dimensional array(int n, int m, int a[n] [m]
int sum two_dimensional _ array(int n, int m, int a[#] [-]
int sum_two dimensional array(int n, int m, int al) [m]) ;
int sum_two dimensional array(int n, int m, int al[] [#])

Using static in Array Parameter Declarations

C99 allows the use of the keyword static in the declaration of array parameters.
(The keyword itself existed before C99. Section 18.2 discusses its traditional uses.)

In the following example, putting static in front of the number 3 indicates
that the length of a is guaranteed to be at least 3:

int sum _ array(int a[static 3], int n)

{
}

Using static in this way has no effect on the behavior of the program. The pres-
ence of static is merely à “hint” that may allow a C compiler to generate faster
instructions for accessing the array. (If the compiler knows that an array will
always have a certain minimum length, it can arrange to “prefetch” these elements
from memory when the function is called, before the elements are actually needed
by statements within the function.)

One last note about static: If an array parameter has more than one dimen-
sion, static can be used only in the first dimension (for example, when specify-
ing the number of rows in a two-dimensional array).

Compound Literals

Let's return to the original sum array function one last time. When
sum_array 1s called, the first argument is usually the name of an array (the one
whose elements are to be summed). For example, we might call sum _array in
the following way:

int b[] = {3, o, 3, 4, 1};
total = sum array(b, 5);

***************************page_226***************************
designated initializers >8. 7

lvalues > 4.2

9.4

return statement

94  The return Statement 201

The only problem with this arrangement 1s that b must be declared as a variable
and then initialized prior to the call. If b isn’t needed for any other purpose, it can
be mildly annoying to create it solely for the purpose of calling sum _ array.

In C99, we can avoid this annoyance by usine a compound liferal: an
unnamed array that’s created ‘“’on the fly” by simply specifying which elements it
contains. The following call of sum _ array has a compound literal (shown in
bold) as its first argument:

total = sum array((int [1){3, 0, 3, 4, 1}, 5);

In this example. the compound literal creates an array containing the five integers
3, O. 3. 4, and 1. We didn’t specify the length of the array, so it’s determined by the
number of elements in the literal. We also have the option of specifying a length
explicitly: (int [4]) {1, 9, 2, 1} is equivalent to (int [1) {1, 9, 2, 1}.

In general. a compound literal consists of à type name within parentheses, fol-
lowed by a set of values enclosed by braces. À compound literal resembles a cast
applied to an initializer. In fact. compound literals and initializers obey the same
rules. À compound literal may contain designators, just like a designated initial-
izer, and it may fail to provide full initialization (in which case any uninitialized
elements default to zero). For example, the literal (int [10]){8, 6} has 10
elements; the first two have the values 8 and 6, and the remaining elements have
the value 0.

Compound literals created inside a function may contain arbitrary expres-
sions, not just constants. For example, we could write

total = sum array((int [1){2 * i, i + j, j #* k}, 3);

where i, j, and k are variables. This aspect of compound literals greatly enhances
their usefulness.

À compound literal 1s an Ivalue, so the values of its elements can be changed.
If desired, a compound literal can be made “read-only” by adding the word const
to its type, as in (const int [1){5, 4}.

The return Statement

À non-void function must use the return statement to specify what value it will
return. The return statement has the form

return expression ;
The expression is often just a constant or variable:

return 0;
return status;

***************************page_227***************************
202

Chapter9 Functions

conditlonal operator > 5.2

9.5

More complex expressions are possible. For example, it’s not unusual to see the
conditional operator used in a return expression:

return n >= 0 ? n : O;

When this statement is executed, the expression n >= 0 ? n : O is evaluated first.
The statement returns the value of n if il's not negative; otherwise, it returns 0.

If the type of the expression in a return statement doesn’t match the func-
tion’s return type, the expression will be implicitly converted to the return type. For
example, if a function is declared to return an int, but the return statement
contains a double expression, the value of the expression is converted to int.

return statements may appear in functions whose return type is void, pro-
vided that no expression is given:

return; /* return in a void function */

Putting an expression in such a return statement will get you a compile-time
error. In the following example, the return statement causes the function to
return immediately when given a negative argument:

void print int(int i)
{
if (i < O)
return;
print£("=d", i);

}

[f{ à is less than O, print_int will return without calling print£.
À return statement may appear at the end of à void function:

void print pun (void)

{

printf("To C, or not to C: that is the question.\n") ;
return; /* OK, but not needed */

}

Using return is unnecessary, though, since the function will return automatically
aîter 1ts last statement has been executed.

If à non-void function reaches the end of its body—that is, it fails to execute
a return statement—the behavior of the program is undefined if it attempts to
use the value returned by the function, Some compilers will issue a warning such
as “control reaches end of non-void function” if they detect the possibility of a
non-void function ‘’falling off” the end of its body.

Program Termination

Since main is a function, it must have a return type. Normally, the return type of
main 1s int, which 1s why the programs we’ve seen so far have defined main in
the following way:

***************************page_228***************************
æ

argc and argv > 13.7

Q&ÂÀ

<stdlib.h>header »26.2

9.5 Program Termination 203

int main(void)

(
;

Older C programs often omit main°s return type, taking advantage of the fact that
it traditionally defaults to int:

main ()

{
}

Omitting the return type of a function isn’t legal in C99, so it’s best to avoid this
practice. Omitting the word void in main’s parameter list remains legal, but—as
a matter of style—it's best to be explicit about the fact that main has no parame-
ters. (We’Il see later that main sometimes does have two parameters, usually
named argc and argv.)

The value returned by main is a status code that—in some operating sys-
tems—can be tested when the program terminates. main should return O 1if the
program terminates normally; to indicate abnormal termination, main should
return a value other than O. (Actually, there’s no rule to prevent us from using the
return value for other purposes.) It’s good practice to make sure that every C pro-
gram returns a status code, even if there are no plans to use it, since someone run-
ning the program later may decide to test it.

The exit Function

Executing a return statement in main 1s one way to terminate a program.
Another is calling the exit function, which belongs to <stdlib.h>. The argu-
ment passed to exit has the same meaning as main°s return value: both indicate
the program’s status at termination. To indicate normal termination, we'd pass 0:

exit (0) ; /* normal termination */

Since O is a bit cryptie, C allows us to pass EXIT_SUCCESS instead (the effect 1s
the same):

exit (EXIT SUCCESS) ; /* normal termination */
Passing EXIT FAILURE indicates abnormal termination:
exit (EXIT _ FAILURE) ; /* abnormal termination */

EXIT SUCCESS and EXIT FAILURE are macros defined in <stdlib.h»>.
The values of EXIT SUCCESS and EXIT _ FAILURE are implementation-
defined; typical values are O and [, respectively.

As methods of terminating a program, return and exit are closely related.
In fact, the statement

return expression ;

***************************page_229***************************
204

Chapter9 Functions

9.6

in maïn 1s equivalent to
exit (expression) ;

The difference between return and exit is that exit causes program termina-
tion regardless of which function calls it. The return statement causes program
termination only when it appears in the main function. Some programmers use
exit exclusively to make it easier to locate all exit points in a program.

Recursion

À fünction 1s recursive if it calls itself. For example, the following function com-
putes n! recursively, using the formula n! = n x (n — 1)!:

int fact (int n)

{
if (n <= 1)
return l;
else

return n * fact(n - 1);

}

Some programming languages rely heavily on recursion, while others don’t even
allow it. C falls somewhere in the middle: it allows recursion, but most C program-
mers don t use 1t that often.

To see how recursion works, let*s trace the execution of the statement

i = fact(3);

Here’s what happens:

fact (3) finds that 3 1s not less than or equal to |. so it calls
£act (2). which finds that 2 is not less than or equal to !, so it calls
fact (1), which finds that ! ;s less than or equal to |, so it returns |, causing
£act (2) to return 2 x | = 2. causing
fact (3) toreturn 3 x2=6.

Notice how the unfinished calls of £act “pile up” until £act is finally passed 1.
Ât that point, the old calls of £fact begin to “unwind” one by one, until the origi-
nal call—fact (3) —finally returns with the answer, 6.

Here’s another example of recursion: a function that computes x" using the
formula "*= xx x"",

int power (int x, int n)

{
if (n == O)
return l;
else

return x * power(x, n - 1);

***************************page_230***************************
96 Recursion 205

The call power (5, 3) would be executed as follows:

power (5, 3) finds that 3 is not equal to O, so it calls
power (5, 2), which finds that 2 is not equal to O, so it calls
power (5, 1), which finds that | is not equal to O. so it calls
power (5, 0), which finds that O às equal to O, so it returns |!. causing
power (5, 1) toreturn5 x | =5, causing
power (5, 2) toreturn 5x 5 = 25, causing
power (5, 3) to retum 5 x 25 = 125.

_

Incidentally, we can condense the power function a bit by putting a conditional
expression in the return statement:

int power (int x, int n)

{

return == 0 ? 1 : x * power(x, n - 1);

}

Both fact and power are careful to test a “termination condition” as soon as
they're called. When £act is called, it immediately checks whether its parameter
is less than or equal to |. When power is called, it first checks whether its second
parameter is equal to O. All recursive functions need some kind of termination con-
dition in order to prevent infinite recursion.

The Quicksort Algorithm

At this point, you may wonder why we're bothering with recursion; after all. nel-
ther fact nor power really needs it. Well, you’ve got a point. Neither function
makes much of a case for recursion, because each calls itself just once. Recursion
is much more helpful for sophisticated algorithms that require a function to call
itself two or more times.

In practice, recursion often arises naturally as a result of an algorithm design
technique known as divide-and-conquer. in which a large problem 1s divided into
smatler pieces that are then tackled by the same algorithm. À classic example of
the divide-and-conquer strategy can be found in the popular sorting algorithm
known as Quicksort. The Quicksort algorithm goes as follows (for simplicity,
we'll assume that the array being sorted is indexed from | to n):

|. Choose an array element e (the “partitioning element”), then rearrange the
array so that elements I. …. à — | are less than or equal to e, element / con-
tains e, and elements / + |, …. n are greater than or equal to e.

. Sort elements 1, …. { — | by using Quicksort recursively.

. Sort elements à + 1. …, n by using Quicksort recursively.

v IN

After step 1, the element e is in its proper location. Since the elements to the left of
e are all less than or equal to it, they’Il be in their proper places once they've been
sorted in step 2; similar reasoning applies to the elements to the right of e.

Step ! of the Quicksort algorithm is obviously critical. There are various
methods to partition an array. some much better than others. We'Il use à technique

***************************page_231***************************
206

Chapter9 Functions

that's casy to understand but not particularly efficient. Hl first describe the parti-
tioning algorithm informally; later, we’Il translate it into C code.

The algorithm relies on two “markers” named /ow and high, which keep track
of positions within the array. Initially, /ow points to the first element of the array
and high points to the last clement. We start by copying the first element (the parti-
tioning element) into a temporary location elsewhere, leaving a “hole” in the array.
Next, we move high across the array from right to left until it points to an element
that’s smaller than the partitioning element. We then copy the element into the hole
that /ow points to, which creates a new hole (pointed to by high). We now move
low from left to right, looking for an element that’s larger than the partitioning ele-
ment. When we find one. we copy it into the hole that high points to. The process
repeats, with /ow and high taking turns, until they meet somewhere in the middle
of the array. Ât that time, both will point to a hole; all we need do is copy the parti-
tioning eclement into the hole. The following diagrams illustrate how Quicksort
would sort an array of integers:

Let’s start with an array contuining seven

elements. low points to the first element; 12 l 3 l S | 18 l 7 Ï15 [ 10

 

 

 

 

high points to the last one. î î
low high
The first element, 12. is the partitioning - '
element. Copying it somewhere else leaves [ 3 | 6 1178| 7 (15 110 p 12
à hole at the beginning of the array. î î
low high
We now compare the element pointed to by { j
high with 12. Since 10 is smaller than 12. 10 | 3 6 181 7 | 15 12
ls on the wrong side of the array. so we î î
move 11 to the hole and shifti /Jow to the [
, low high
right.
low points to the number 3. which is less TS e
than 12 and therefore doesn't nced to be 1013 | 6 118| 7 | 15 12
moved. We shift /ow to the right instead. î î
low high
Since 6 is also less than 12, we shift low ; ;
again. 10 6 |18| 7 |15 1
à 4
| |
low high
low now points to 18, which is larger than
12 and therefore out of position. After 1LOj 3 | 6 7 11518 p 12
moving 18 to the hole, we shift Nigh to the & À

left. | |

***************************page_232***************************
PROGRAM

gsort.c

96 Recursion 207

high points to 15, which is greater than 12 l ' ;
and thus doesn't need to be moved. We 101 3 | 86 15 | 18 p 12
shift Aigl to the left and continue. î î

low high

——

high points to 7, which is out of position. Z
10 3 6 7 15 18 y 12

After moving 7 to the hole, we shift /ow to

the right. î
low, high

low and high are now equal, s0 we move J ; ,

the partitioning element to the hole. 10 | 3 | 6 | 7 |12 | 15 | 18

At this point, we*ve accomplished our objective: all elements to the left of the par-
titioning element are less than or equal to 12, and all elements to the right are
grealer than or equal to 12. Now that the array has been partitioned, we can use
Quicksort recursively to sort the first four elements of the array (10, 3, 6, and 7)
and the last two (15 and 18).

Quicksort

Let’s develop a recursive function named quicksort that uses the Quicksort
algorithm to sort an array of integers. To test the function, we’Il have main read 10
numbers into an array, call quicksort to sort the array, then print the elements
in the array:

Enter 10 numbers to be sorted: 9 16 47 82 4 66 12 3 25 S1
In sorted order: 3 4 9 12 16 25 47 51 66 82

 

Since the code for partitioning the array is a bit lengthy, l’Il put it in a separate
function named split.

/* Sorts an array of integers using Quicksort algorithm */
#finclude <stdio.h>
#define N 10

void quicksort (int a[], int low, int high) ;
int split (int a[], int low, int high) ;

int main(void)

(

int a[N], 1;

printf ("Enter %d numbers to be sorted: ", N);
for (i = 0; i < N; i++)
scanf ("*#d", &a[il);

***************************page_233***************************
208

Chapter9 Functions

quicksort (a, 0, N - 1),

print£("In sorted order: ");
for (1 = 0; i < N; i+<)

printf("%d ", a[ilJ),
printf ("\n") ;

return 0;

}

void quicksort (int a[], int low, int high)

{

int middle;

if (low >= high) return;

middle = split(a, low, high) ;
quicksort (a, low, middle - 1);
quicksort (a, middle + 1, high) ;

}

int split (int a[], int low, int high)

(

int part element = a[low] ;

for (::) {
while (low < high && part_element <= a [high])
high——;
if (low >= high) break;
a[low++] = a[high] ;

while (low < high && a[low] <= part _ element)
low++;

if (low >= high) break;

a [high--] = a[low] ;

;

a[high] = part element ;
return high;

}

Although this version of Quicksort works, it’s not the best. There are numer-
ous ways to improve the program’s performance, including:

= Improving the partitionine algorithm. Our method isn°t the most efficient.
Instead of choosing the first element in the array as the partitioning element,
its better to take the median of the first element, the middie element, and the
last element. The partitioning process itself can also be sped up. In particular,
it’s possible to avoid the 1low < high tests in the two while loops.

u Using à different method to sort small arrays. Instead of using Quicksort
recursively all the way down to arrays with one element, il’s better to use a
simpler method for small arrays (those with fewer than, say, 25 elements).

***************************page_234***************************
default arqument promotions > 9.3

Q & À 209

= Making Quicksort nonrecursive. Although Quicksort is à recursive algorithm
by nature—and is easiest to understand in recursive form—It's actually more
efficient 1f the recursion 1s removed.

For details about improving Quicksort, consult a book on algorithm design, such as
Robert Sedgewick’s Algorithms in C, Parts 1. Fundamentals. Data Structures,
Sorting, Searching, Third Edition (Boston, Mass.: Addison-Wesley, 1998).

Q & À

Some C books appear to use terms other than parameter and argument. Is
there any standard terminology? [p. 184]

As with many other aspects of C, there’s no general agreement on terminology.
although the C89 and C99 standards use parameter and argument. The following
table should help you translate:

This book: Other books:

parameter formal argument, formal parameter
argument actual argument. actual parameter

Keep in mind that—when no confusion would result—I sometimes deliberately
blur the distinction between the two terms. using argiunent to mean either.

l’ve seen programs in which parameter types are specified in separate decla-
rations after the parameter list, as in the following example:

double average(a, b)
double a, b;

{

return (a + b) / 2;

}
Is this practice legal? [p. 188]

This method of defining functions comes from K&R C. so you may encounter it in
older books and programs. C89 and C99 support this style so that older programs
will still compile. l’d avoid using it in new programs, however, for a couple of rea-
sons.

First. functions that are defined in the older way aren’t subject to the same
degree of error-checking. When a function is defined in the older way—and no
prototype is present—the compiler won*t check that the function 1s called with the
right number of arguments, nor will it check that the arguments have the proper
types. Instead, it will perform the default argument promotions.

Second, the C standard says that the older style is ‘“obsolescent,” meaning that
its use is discouraged and that it may be dropped from C eventually.

***************************page_235***************************
210

Chapter9 Functions

Q:

ÂÀ:

:;:Q:

A:

pointers to functions > 17,7

expression statements > 4.5

“Q:

Some programming languages allow procedures and functions to be nested
within cach other. Does C allow function definitions to be nested?

No. C does not permit the definition of one function to appear in the body of
another. Among other things, this restriction simplifies the compiler.

Why does the compiler allow the use of function names that aren°t followed by
parentheses? [p. 189]

We'Il see in a later chapter that the compiler treats à function name not followed by
parentheses as a pointer to the function. Pointers to lunctions have legitimate uses,
so the compiler can*t automatically assume that a function name without parenthe-
ses is an error. The statement

print _ pun;

is legal because the compiler treats print pun as a pointer and therefore an
expression, making this a valid (although pointless) expression statement.

In the function call £(a, b), how does the compiler know whether the
commia is punctuation or whether it°s an operator?

IL turns out that the arguments in a function call can’t be arbitrary expressions.
Instead, they must be “‘assignment expressions,” which can’t contain commas used
às operators unless they're enclosed in parentheses. In other words. in the call
£ (a, b) the comma is punctuation: in the call f ((a, b)) it’s an operator.

Do the names of parameters in a function prototype have to match the names
given later in the function°s definition? [p. 192]

No. Some programmeers take advantage of this fact by giving long names to param-
cters in the prototype, then Using shorter names in the actual definition. Or a
French-speaking programmer might use English names in prototypes, then switch
to more l'amiliar French names in function definitions.

[ still don’t understand why we bother with function prototypes. If we just put
definitions of all the functions before main, we>re covered, right?

Wrong. First, you’re assuming that only main calls the other functions. which is
unrealistic. In practice, some of the functions will call each other. If we put all
l'unction definitions above main, we'Il have to watch their order carefully. Calling
à function that hasn’t been defined yet can lead to big problems.

But that’s not all. Suppose that two functions call each other (which isn’t as
far-fetched as it may sound). No matter which function we define first. it will end
up calling à function that hasn*t been defined yet.

But there’s still more! Once programs reach a certain size, it won’t be feasible
(o put all the functions in one file anymore. When we reach that point, we'll need
prototypes lo tell the compiler about functions in other files.

l’ve seen function declarations that omit all information about parameters:

***************************page_236***************************
> .Q

Q & À 211

double average () ;

Is this practice legal? [p. 192]

Yes. This declaration informs the compiler that average returns a double value
but provides no information about the number and types of its parameters. (Leav-
ing the parentheses empty doesn’t necessarily mean that average has no param-
eters.)

In K&R C, this form of function declaration is the only one allowed: the form
that we’ve been usinge—the function prototype, in which parameter information às
included—was introduced in C89. The older kind of function declaration is now
obsolescent, although still allowed.

Why would a programmer deliberately omit parameter names in a function
prototype? Isn°t it easier to just leave the names? [p. 193]

Omitting parameter names in prototypes is typically done for defensive purposes.
If a macro happens to have the same name as a parameter. the parameter name will
be replaced during preprocessing, thereby damaging the prototype in which t
appears. This isn°t likely to be à problem in a small program written by one person
but can occur in large applications written by many people.

Is it legal to put a function declaration inside the body of another function?
Yes. Here’s an example:

int main(void)

(

double average (double a, double b);

}

This declaration of average is valid only for the body of main: if other func-
tions need to call average, they'll each have to declare it.

The advantage of this practice is that il’s clearer to the reader which functions
call which other functions. (In this example, we see that main will be calling
average.) On the other hand, it can be a nuisance if several functions need to call
the same function. Even worse, trying to add and remove declarations during pro-
oram maintenance can be a real pain. For these reasons, l'Il always put function
declarations outside l'unction bodies.

If several functions have the same return type, can their declarations be com-
bined? For example, since both print _ pun and print count have void
as their return type, is the following declaration legal?

void print pun(void), print _ count (int n) ;

Yes. In fact, C even allows us to combine function declarations with variable decla-
rations:

double x, y, average (double a, double b);

***************************page_237***************************
212

Chapter9 Functions

Combining declarations in this way usually isn't a good idea, though: it can easily
cause confusion.

What happens if I specify a length for a one-dimensional array parameter?
[p. 195]

The compiler ignores it. Consider the following example:
double inner_product (double v[3], double w[3]) ,

Other than documenting that inner _ product's arguments are supposed to be
arrays of length 3, specifying a length doesn’t buy us much. The compiler won't
check that the arguments actually have leneth 3. so there’s no added security. In
fact, the practice is misleading in that it suggests that inner product can only
be passed arrays of length 3. when in fact we can pass arrays of arbitrary length.

Why can the first dimension in an array parameter be left unspecified, but not
the other dimensions? [p. 197]

First. we need to discuss how arrays are passed in C. As Section 12.3 explains,
when an array is passed to à f'unction, the function is given a pointer to the first ele-
ment In the array.

Next, we need to know how the subscripting operator works. Suppose that à is
à one-dimensional array passed to a function. When we write

a[i] = 0O;

the compiler generates instructions that compute the address of a [i ] by multiply-
ing i by the sizc of an array element and adding the result to the address that a rep-
resents (the pointer passed to the function). This calculation doesn't depend on the
length of a, which explains why we can omit it when defining the function.

What about multidimensional arrays? Recall that C stores arrays In row-major
order, with the elements in row O stored first. then the elements in row 1. and so
forth. Suppose that à is à two-dimensional array parameter and we write

a[i]l[j] = 0;

The compiler generates instructions to do the following: (1) multiply i by the size
of à single row of a: (2) add this result to the address that a represents; (3) multiply
j by the size of an array element; and (4) add this result to the address computed in
step 2. To generate these instructions, the compiler must know the size of a row in
the array. which is determined by the number of columns. The bottom line: the pro-
grammer must declare the number of columns in a.

Why do some programmers put parentheses around the expression in a
return statement?

The examples in the first edition of Kernighan and Ritchie's The C Programming
Language always have parentheses in return statements, even though they
aren’t required. Programmers (and authors of subsequent books) picked up the
habit from K&R. 1 don't use these parentheses, since they’re unnecessary and

***************************page_238***************************
Q

>

 

Q & À 213

contribute nothing to readability. (Kernighan and Ritchie apparently agree: the
return statements in the second edition of The C Programmine Language lack
parentheses.)

What happens if a non-void function attempts to execute a return state-
ment that has no expression? [p. 202]

That depends on the version of C. In C89, executing a return statement without
an expression in a non-void function causes undefined behavior (but only 1f the
program attempts to use the value returned by the l'unction). In C99. such a state-
ment 1s illegal and should be detected as an error by the compiler.

How can I test main°s return value to see if a program has terminated nor-
mally? |p. 203]

That depends on your operating system. Many operating systems allow this value
to be tested within a “batch file” or “shell script” that contains commands to run
several programs. For example, the line

if errorlevel 1 command

in a Windows batch file will execute command 1f the last program terminated with
a status code greater than or equal to |.

In UNIX, each shell has its own method for testing the status code. In the
Bourne shell, the variable $? contains the status of the last program run. The C
shell has a similar variable, but its name 1s Sstatus.

Why does my compiler produce a “control reaches end of non-void function”
warning when it compiles main?

The compiler has noticed that ma in, despite having int as its return type, doesn't
have a return statement. Putting the statement

return 0;

at the end of main will keep the compiler happy. Incidentally, this iS good practice
even if your compiler doesn'1 object to the lack of à return statement.

When a program is compiled using a C99 compiler, this warnine shouldn’t
occur. In C99, it’s OK to “‘fall off” the end of main without returning a value; the
standard states that main automatically returns O in this situation.

With regard to the previous question: Why not just define main°s return type
to be void?

Although this practice is fairly common, it’s illegal according to the C89 standard.
Even Iif it weren’tillegal, it wouldn’t be à good 1idea, since 1l presumes that no one
will ever test the program’s status upon termination.

C99 opens the door to legalizing this practice, by allowing main to be
declared ‘“in some other implementation-defined manner” (with a return type other
than int or parameters other than those specified by the standard). HMowever. any
such usage isn’t portable, so it’s best to declare main's return type to be int.

***************************page_239***************************
214 Chapter9 Functions

Section 9.1

Section 9.2

@

Q:
À:

D

e

_Ul

8.

Is it legal for a function £1 to call a function f2, which then calls f1?

Yes. This is just an indirect form of recursion in which one call of f1 leads to
another. (But make sure that either £1 or £2 eventually terminates!)

Exercises

The following l'unction, which computes the area of a triangle. contains two errors. Locate
the errors and show how to fix them. (Hinr: There are no errors in the formula.)

double triangle_area (double base, height)
double product ;

{

product = base * height ;
return product / 2;

}

Write a function check (x, y, n) that returns | if both x and y fall between O and n = 1.
inclusive. The function should return O otherwise. Assume that x, y. and n are all of type
int.

Write a function gcd (m, n) that calculates the greatest common divisor of the integers m
and n. (Programming Projeet 2 in Chapter 6 describes Euclid’s algorithm for computing the
GCD.)

Write à function day_o£ _ year (month, day, year) that returns the day of the year
(an integer between ! and 366) specified by the three arguments.

Write a function num_digits (n) that returns the number of digits in n (a positive inte-
ger). Hint: To determine the number of digits in a number n. divide it by 10 repeatedly.
When n reaches O, the number of divisions indicates how many digits n originally had.

Write a function digit (n, k) that returns the k digit (From the right) in n (a posi-
tive integer). For example, digit (829, 1) returns 9. digit (829, 2) returns 2. and
digit (829, 3) returns &, If K is greater than the number of digits in n, have the func-
tion return 0.

Suppose that the function £ has the following definition:
int f(int a, int b) { … }

Which of the following statements are legal? (Assume that i has type int and x has type
double.)

(a) i = f(83, 12);

(b) x = f(83, 12);

(c) i = f(3.15, 9.28);
(d) x = f(3.15, 9.28);
(e) f(83, 12);

Which of the following would be valid prototypes for à function that returns nothing and has
one double parameter?

(a) void £ (double x) ;

***************************page_240***************************
Section 9.3

Section 9.4

@ 10.

ll.

[ 3.

14

Exercises 215

(b) void £ (double) ;
(c) void £(x) ;
(d) f (double x) ;

What will be the output of the following program?

#include <stdio.h>
void swap(int a, int b);

int main (void)

{

int i = 1, j = 2;

swap(i, j) ;
printf("i = %d, j = %d\n", i, J);
return 0;

}

void swap(int a, int b)

ï

int temp = àa;
a = b;
b = temp;

}

Write functions that return the following values. (Assume that à and n are parameters,
where a is an array of int values and n is the length of the array.)

(a) The largest element in a.
(b) The average of all elements in a.
(c) The number of positive elements in a.

Write the following function:
float compute_GPA(char grades[], int n);

The grades array will contain letter grades (A, B, C. D, or F, either upper-case or lower-
case); n is the length of the array. The funetion should return the average of the grades
(assume that A = 4, B= 3,C=2,D=1,and F =0).

Write the following function:

double inner product (double a[], double b[], int n);
The function should return a [(0] * b [0] +a [[1] #* b{[1] + … +a [n-1] * b[n-1).

Write the following function, which evaluates à chess position:
int evaluate position(char board[8] [8]) ;

board represents à configuration of pieces on a chessboard, where the letters K, Q, R, B, N,
P represent White pieces, and the letters k. q. r, b, n. and p represent Black pieces.
evaluate position should sum the values of the White pieces (Q = 9,R = 5, B = 3,
N = 3, P = |). Lt should also sum the values of the Black pièces (done in a similar way). The
function will return the difference betwcen the two numbers. This value will be positive if
White has an advantage in material and negative if Black has an advantage.

Thc following function is supposed to return true if any element of the array a has the
value 0 and false if all clements are nonzero. Sadly, it contains an error. Find the error and
show how to fix it:

***************************page_241***************************
216 Chapter9  Functions

@ 15.

Section 9.6 16.

@ 17.
18.

(D*10.

bool has_zero(int a[], int n)

{

int i;
Eor (i = O0; i < n; i++)
if (a[i] == O)
return true;
else

return false;

;

The following (rather confusing) function finds the median of three numbers. Rewrite the
function so that it has just one return statement.

double median (double x, double y, double Zz)

{

if (x <= y)
iËf (y <= z) return y;
else if (x <= z) return z;
else return x;

if (z <= y) return y;

if (x <= z) return x;

return z;

}

Condense the fact function in the same way we condensed power.
Rewrite the £act function so that il’s no longer recursive.

Write à recursive version of the gcd function (see Exercise 3). Here's the strategy to use for
computing gcd(m, n): If n is O, return m. Otherwise. call gcd] recursively. passing n as
the first argument and m % n as the second.

Consider the following “mystery” function:

void pb(int n)

{

if (n != 0O) |
pb(n / 2);
putchar ('0' + n % 2);

}
}

Trace the execution of the function by hand. Then write a program that calls the function,
passing it a number entered by the user. What does the function do?

Programming Projects

Write a program that asks the user to enter à scries of integers (which it stores in an array),
then sorts the integers by calling the function selection _sort. When given an array
With 7 elements. selection_sort must do the following:

|. Search the array to find the largest element. then move it to the last position in the array.
2. Call itself recursively to sort the first n — | elements of the array.

***************************page_242***************************
tV

6.

Programming Projects 217

Modify Programming Project 5 from Chapter 5 so that it uses a function to compute the
amount of income tax. When passed an amount of taxable income. the function will return
the tax due.

Modify Programming Project 9 from Chapter 8 so that it includes the following functions:

void generate _ random _walk (char walk [10] [10]) ;
void print array (char walk [10] [10]) ;

main first calls generate _random_walk. which initializes the array to contain ‘ ."
characters and then replaces some of these characters by the letters A through Z, as
described in the original project. main then calls print_array to display the array on
the screen.

Modify Programming Project 16 from Chapter $ so that it includes the following f'unctions:

void read word(int counts [26]) ;
bool equal array(int counts1[(26], int counts2 [26]) ;

main will call read_word twice, once for each of the two words entered by the user. Às 1t
reads a word. read_word will use the lctters in the word to update the counts array, às
described in the original project. (main will declare two arrays. one for cach word. These
arrays are used to track how many limes each letter occeurs in the words.) main will then
call equal _ array, passing it the two arrays. equal_array will return true if the ele-
ments in the two arrays are identical (indicating that the words arc anagrams) and £alse
otherwise.

Modify Programming Project 17 from Chapter 8 so that it includes the following f'unctions:

void create magic_square (int n, char magic_square [n] [n]) ;
void print magic square(int n, char magic_square [n] [n]) ;

After obtaining the number » from the user, main will call create _magic_square.
passing it an n x n array that is declared inside main. create_magic_square will fill
the array with the numbers }, 2, .… n7 as described in the original project. main will then
call print magic_square. which will display the array in the format described in the
original project. Nore: T your compiler doesn*t support variable-length arrays, declare the
array in main to be 99 x 99 instead of n x n and use the following prototypes instead:

void create magic_square(int n, char magic_square [99] [99] ) ;
void print magic square(int n, char magic_square[99] [99] ) ;

Write à function that computes the value of the following polynomial:
34 204-S00- 0047x —6

Write a program that asks the user to enter a value for x, calls the function to compute the
value of thé polynomial, and then displays the value returned by the function.

The power function of Section 9.6 cun be made faster by having it calculate x" in a differ-
ent way. We first notice that if » 1s a power of 2, then x" can be computed by squaring. For
example, x* is the square of , so x* can be computed using only two multiplications instead
of three. As it happens. this technique can be used even when n is not a power of 2. If n is
even. we use the formula x" = (xF 1F n is odd, then x" = x x x"}; Write à recursive func-
tion that computes x". (The recursion ends when n = 0,in which case the function returns |.)
To test your function, write a program that asks the user Lo enter values for x and n, calls

power to compute x”, and then displays the value returned by the function.

Write a program that simulates the game of craps. which is played with two dice. On the
first roll, the player wins if the sum of the dicc is 7 or ! 1. The player loses 1f the sum is 2, 3.

***************************page_243***************************
218

Chapter9 Functions

or 12. Any other roll is called the “point” and the game continues. On each subsequent roll,
the player wins if he or she rolls the point again. The player loses by rolling 7. Any other roll
is Ignored and the game continues. At the end of each game, the program will ask the user
whether or not to play again. When the user enters à response other than y or Y. the program
Will display the number of wins and losses and then terminate.

You rolled: 8
Your point is 8
You rolled: 3
You rolled: 10
You rolled: 8
You win!

Play again? y

You rolled: 6
Your point is 6
You rolled: 5
You rolled: 12
You rolled: 3
You rolled: 7
You lose!

Play again? y

You rolled: 11
You win!

Play again? n
Wins: 2  Losses: 1

Write your program as three functions: main, roll_dice. and play_game. Here are
the prototypes for the latter two functions:

int roll dice (void) ;
bool play game (void) ;

roll _dice should gcnerate two random numbers, each between ! and 6, and return their
sum. play_game should play one craps game (calling ro1l l_dice to determine the out-
come of each dice roll); it will return true if the player wins and fa1 se if the player loses.
play_game is also responsible for displaying messages showing the results of the player's
dice rolls. main will call play _game repeatedly. keeping track of the number of wins and
losses and displaying the “you win” and “you lose” messages. Hint: Use the rand function
to génerate random numbers. See the deal .c program in Section 8.2 for an example of
how to call rand and the related srand function.

***************************page_244***************************
10

10.1

Program Organization

As Will Rogers would have said, “There
is no such thing as a free variable."

Having covered functions in Chapter 9, we*re ready to confront several issues that
arise when a program contains more than one function. The chapter begins with a
discussion of the differences between local variables (Section 10.1) and external
variables (Section 10.2). Section 10.3 then considers blocks (compound statements
containing declarations). Section 10.4 tackles the scope rules that apply to local
names, external names, and names declared in blocks. Finally, Section 10.5 sug-
gests a way to organize function prototypes, f'unction definitions, variable declara-
tions, and the other parts of a C program.

Local Variables

À variable declared in the body of a function is said to be /ocal to the function. In
the following function, sum 1s a local variable:

int sum digits (int n)

{
int sum = O0; /* local variable */
while (n > O) Ç
sum += n % 10;
n /= 10;
}
return sum;
}

219

***************************page_245***************************
220

Chapter 10  Program Organization

Q&ÂÀ

By default, local variables have the following properties:

= Automatic storage duration. The storage duration (or extent) of à variable is
the portion of program execution during which storage l'or the variable exists.
Storage for a local variable is “automatically” allocated when the enclosing
function is called and deallocated when the function returns, so the variable is
said to have automatic storage duration. À local variable doesn’1 retain its
value when its enclosing function returns. When the function is called again,
there's no guarantee that the variable will still have its old value.

u Block scope. The scope of a variable is the portion of the program text in
which the variable can be referenced. A local variable has block scope: it is
visible from its point of declaration to the end of the enclosing function
body. Since the scope of a local variable doesn't extend beyond the function
to which it belongs, other functions can use the same name for other pur-
poses.

Section 18.2 covers these and other related concepts in more detail.

Since C99 doesn°t require variable declarations to come at the beginning of a
function. il’s possible for a local variable to have a very small scope. In the follow-
ing example, the scope of i doesn’t begin until the line on which it’s declared,
which could be near the end of the function body:

void £ (void)

{

int 15°—
— scope of i

 

} —

Static Local Variables

Putting the word static in the declaration of a local variable causes it to have
static storage duration instead of automatic storage duration. À variable with
static storage duration has a permanent storage location, so it retains its value
throughout the execution of the program. Consider the following function:

void f (void)

{

static int i; /* static local variable */

}

Since the local variable i has been declared static. it occupies the same mem-
ory location throughout the execution of the program. When £ returns, i won't
lose its value.

À static local variable still has block scope, so it’s not visible to other func-
tions. In « nutshell, à static variable is a place to hide data from other functions but
retain it for future calls of the same function.

***************************page_246***************************
10.2

10.2  External Variables 221

Parameters

Parameters have the same properttes—automatic storage duration and block
scope—as local variables. In fact, the only real difference between parameters and
local vartables 1s that each parameter 1s inttialized automatically when a function 1s
called (by being assigned the value of the corresponding argument).

 

External Variables

Passine arguments 1s one Way lo transmit information to a function. Functions can
also communicate through exfernal variables—variables that are declared outside
the body of any function.

The properties of external variables (or g/obal variables, as they're sometimes
called) are different from those of local variables:

m Sfatic storage duration. External variables have static storage duration, just
lke local variables that have been declared static. À value stored in an
external variable wirll stay there indeffnitely.

u /ile scope. An external vartable huas file scope: 1t 1s visible from ts point of
declaration to the end of the enclosing file. As à result, an external varrable
can be accessed (and potentially modrfied) by all functions that follow rts dec-
laration.

Example: Using External Variables to Implement a Stack

To illustrate how external variables might be used. let’s look at a data structure
known as a sfack, (Stacks are an abstract concept, not a C feature: they can be
implemented in most programming languages.) À stack, like an array, can store
multiple data 1tems of the same type. However, the operations on à stack are lim-
ited: we can either push an item onto the stack (add it to one end—the ‘““stack top”)
or pop it from the stack (remove 1t from the same end). Examining or modifying an
item that’s not at the top of the stack 1s forbidden.

One way 1o implement à stack in C 1s to store its items in an array. which we'Hl
call contents. À separate integer variable named top marks the position of the
stack top. When the stack is empty. top has the value 0. To push an 1tem on the
stack, we simply store the item in contents al the position indicated by top.
then increment top. Popping an item requires decrementing top, then using it as
an index mnto contents to fetch the rtem that's being popped.

Based on this outline, here's a program fragment (not a complete program)
that declares the contents and top variables for a stack and provides a set of
functions that represent operations on the stack. AIl five functions need access to
the top variable, and two functions need access to contents. so we'll make
contents and top external.

***************************page_247***************************
222

Chapter 10  Program Organization

#include <stdbool .h> /* C99 only */

#define STACK SIZE 100

/* external variables */
int contents [STACK SIZE] ;
int top = 0;

void make empty (void)

{
}

bool is empty (void)

{
}

bool is full (void)

(
}

void push(int i)

{

top = 0;

return top == O0;

return top == STACK SIZE;

if (is full())

stack _ over£low () ;
else

contents [top++] = i;

}

int pop (void)
{
if (is empty())
stack underflow() ;
else
return contents [--top] ;

Pros and Cons of External Variables

External variables are convenient when many functions must share a variable or
when a few functions share a large number of variables. In most cases, however,
itl’s better for functions to communicate through parameters rather than by sharing

variables. Here’s why:

m f we change an external variable during program maintenance (by altering its
type, say), we’ll need to check every function in the same file to see how the

change affects 1t.

***************************page_248***************************
10.2  External Variables 223

u l{f an external variable is assigned an incorrect value. it may be difficult to
identify the guilty function. Is like trying to solve a murder committed at a
crowded party—there’s no easy way to narrow the list of suspects.

w Functions that rely on external variables are hard to reuse in other programs. À
function that depends on external variables isn’t self-contained; to reuse the
function. we'll have to drag along any external variables that it needs.

Many C programmers rely far too much on external variables. One common
abuse: using the same external variable for different purposes in different func-
tions. Suppose that several functions need a variable named i to control a for
statement. Instead of declaring i in each function that uses it, some programmers
declare 1t at the top of the program, thereby making the variable visible to all func-
tions. This practice is poor not only for the reasons listed earlier, but also because
it’s misleading; someone reading the program later may think that the uses of the
variable are related. when in fact they’re not.

When you use external variables. make sure they have meaningful names.
(Local variables don’t always need meaningful names: 1t°s often hard to think of a
better name than i for the control variable in a £or loop.) If you find yourself
using names like 1 and temp for external variables, that’s a clue that perhaps they
should really be local variables.

 

Makine variables external when they should be local can lead to some rather frus-
trating bugs. Consider the following example. which 1s supposed to display a 10 x
10 arrangement of asterisks:

int à;

void print one row(void)

(
for (i = 1; i <= 10; i++)
print£("*") ;
}
void print all _ rows (void)
{
for (i = 1; i <= 10; i++) {
print one _row();
print£ ("\n") ;
}
}

Instead of printing 10 rows. print _ all _rows prints only one row. When
print _one_rovw returns after being called the first time, à will have the value
11. The £for statement in print all rows then increments i and tests
whether it’s less than or equal to 10. It’s not, so the loop terminates and the func-
tion returns.

 

***************************page_249***************************
224 Chapter 10  Program Organization

PROGRAM Guessing a Number

To get more experience with external variables. we'Il write a simple game-playing
program. The program generates a random number between ! and 100, which the
user attempts Lo guess in as few tries as possible. Here’s what the user will see
when the program 1s run:

Guess the secret number between 1 and 100.

A newv number has been chosen.
Enter guess: 55

Too low; try again.

Enter guess: 65

Too high; try again.

Enter guess: 60

Too high; try again.

Enter guess: 58

You won in 4 guesses!

Play again? (Y/N) y

A new number has been chosen.
Enter guess: 78

Too high; try again.

Enter guess: 34

You won in 2 guesses!

Play again? (Y/N) n

This program will need to carry out several different tasks: initializing the ran-
dom number generator. choosing a secret number, and interacting with the user
until the correct number is picked. !f we write a separate function to handle each
task, we might end up with the following program.

quess.c _ /* Asks user to quess a hidden number */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX NUMBER 100

/* external variable */
int secret _number ;

/* prototypes */

void initialize number generator (void) ;
void choose _new secret _number (void) ;
void read guesses (void) ;

int main (void)

{

char command ;

***************************page_250***************************
print£("Guess the secret number between 1 and %d.\n\n",

MAX NUMBER) ;

10.2  External Variables

initialize number generator () ;

do |

choose_new secret _number () ;
printf ("A new number has been chosen.\n") ;

read _guesses () ;
print£ ("Play again?
scanf (" %c",
print£("\n") ;
} while (command ==

&command)
lyl

return 0;

}

(Y/N)

" ;

‘

|| command == 'Y');

225

/********'À‘*********‘k***‘k*****‘k******k***********************

* initialize number generator: Initializes the random

*
+

number generator using
the time of day.

*
*
*

'À'**************—k*—k—k***—k—k****'k‘k****k*****—k********—k**—k******/

void initialize number generator (void)

{

srand ( (unsigned) time (NULL) ) ;

}

/*******—k******‘k*****—k**************“k*‘k*****************‘k**

* choose_new secret _numbe
*

*

r: Randomly selects a number

*

between 1 and MAX NUMBER and *

stores it in secret number.

*

*********—k******—k*****************************************/

void choose _new secret _number (void)

(
}

secret_number = rand() %

MAX NUMBER + 1;

/*‘k‘k‘k**********‘k*****‘k***'k**************‘k***%‘************‘k'k

* read guesses:

+ too high,
* correct,
* quesses a

XX AKAREKXAKERAAKAAEKAEEKKAKAKKK K

void read guesses (void)

{

int guess, num guesses =
£or (::) |
num guesses++;
printf ("Enter guess: "
scanf ("sd", &quess) ;
if (qguess == secret _nu

printf("You won in %d quesses!\n\n", num guesses) ;

return;
} else if (guess < sec

Repeatedly reads user guesses and tells
* the user whether each guess is too low,
or correct. When the guess 1s

prints the total number of
nd returns.

0 ;

) ;

mber) {

ret _number)

*
*
*x
*
*
*

/

***************************page_251***************************
226

Chapter 10  Program Organization

time function »26.3
srand function »26.2

rand function »26.2

guess2.c

print£ ("Too low; try again.\n") ;
else
printf("Too high; try again.\n") ;

For random number generation, the quess. c program rclies on the time,
srand, and rand functions, which we first used in deal .c (Section 8.2). This
time, we're scaling the return value of rand so that it falls between 1 and
MAX NUMBER.

Althoueh guess.c works fine, it relies on an external variable. We made
secret _number external so that both choose _new secret _number and
read_guesses could access it. If we alter choose _ new secret _number
and read_quesses just à little, we should be able to move secret _number
into the main function. We'll modify choose new secret number so
that it returns the new number, and we'll rewriteé read _guesses so that
secret _number can be passed to it as an argument.

Here’s our new program, with changes in bold:

/* Asks user to quess a hidden number */

#include <stdio.h>
#include <stdlib.h>
#Hinclude <time.h>

#define MAX NUMBER 100

/* prototypes */

void initialize number generator (void) ;
int new secret _number (void) ;

void read guesses (int secret number) ;

int main (void)
char command ;
int secret number;

printf ("Guess the secret number between 1 and %$d.\n\n",
MAX _ NUMBER) ;
initialize _number generator () ;
do {
secret number = new secret number () ;
print£f ("A new number has been chosen.\n") ;
read guesses (secret number) ;
printf ("Play again? (Y/N) ");

scan£(" %c", &command) ;
print£ ("\n") ;
} while (command == 'y' || command == 'Y');

return 0;

}

***************************page_252***************************
10.3

10.3  Blocks 221

/************************—k*******'k*‘k*‘k******'k**‘k***********

* initialize number generator: Initializes the random *
* number generator using *
* the time of day. *

**'k************'k*****************************************-k/

void initialize number generator (void)

{

srand ( (unsigned) time (NULL) ) ;

}

/********************-k********************************-k-k*-k*

* new secret number: Returns a randomly chosen number *
* between 1l and MAX NUMBER. *

**********************************************************/

int new secret _ number (void)

{

return rand() % MAX NUMBER + 1;

}

/*'k********************************************************

* read guesses: Repeatedly reads user guesses and tells *
* the user whether each guess is too low, *
* too high, or correct. When the guess is *
* correct, prints the total number of *
* quesses and returns. *

*

%* %* % % % * à * % k à à * * à* % à * * % * À* * à k * % x* * % k* * % * * * * * à* * * à * * % à * + * * * * * * * * X /

void read guesses (int secret number)

{

int guess, num guesses = 0;

£for (;;) |

num_guesses++;

printf ("Enter guess: ") ;

scanf ("$d", &quess) ;

if (quess == secret number) {
printf("You won in %d quesses!\n\n", num guesses) ;
return;

} else if (guess < secret number)
print£f ("Too low; try again.\n") ;

else
print£ ("Too high; try agaiïn.\n") ;

l

Blocks

In Section 5.2, we encountered compound statements of the form

{ statements }

***************************page_253***************************
228

Chapter 10 Program Organization

block

10.4

It turns out that C allows compound statements to contain declarations as well:

{ declarations statements }

JIl use the term bloek to describe such a compound statement. Here’s an example
of a block:

i£ (i > j) |
/* swap values of i and ; */
int temp = i;
L = j;
j = temp;

}

By default, the storage duration of a variable declared in à block 1s automatic: stor-
age for the variable 1s allocated when the block 1s entered and deallocated when the
block 1s exited. The vartable has block scope; it can't be referenced outside the
block. À variable that belongs to a block can be declared static to give 1t static
storage duration.

The body of a function is a block, Blocks are also useful inside à function
body when we need variables for temporary use. In our last example, we needed a
vartable temporarily so that we could swap the values of à and . Putting tempo-
rary variables in blocks has two advantages: (1) It avoids cluttering the declara-
Lions at the beginning of the function body with variables that are used only briefly.
(2) It reduces name conflicts. In our example, the name temp can be used else-
where in the same function for different purposes—the temp variable is strictly
local to the block n which it’s declared.

C99 allows variables to be declared anywhere within a block, just as it allows
variables to be declared anywhere within a function.

Scope

[n a C program, the same identifier may have several different meanings. C’s scope
rules enable the programmer (and the compiler) to determine which meaning 1s
relevant at a given point in the program.

Here's the most important scope rule: When a declaration inside a block
names an identifier that's already visible (because it has file scope or because it’s
declared in an enclosing block). the new declaration temporarily ‘“hides” the old
one, and the identifier takes on a new meaning. At the end of the block, the identi-
fier regains its old meaning.

Consider the (somewhat extreme) example at the top of the next page, in
which the identifier i has Four different meanings:

m In Declaration |, à is à variable with static storage duration and file scope.

***************************page_254***************************
10.5  Organizing a C Program 229

; /* Declaration 1 */

   

void f(int£î}) /* Declaration 2 */

{_/

1 = l;
}
void g(void)
{
int£ï)= 2 ; /* Declaration 3 */
À

  

int@; /* Declaration 4 */

 

In Declaration 2, i 1s a parameter with block scope.
In Declaration 3, i is an automatic variable with block scope.
In Declaration 4, i is also automatic and has block scope.

i is used five times. C’s scope rules allow us to determine the meaning of i in each
case:

The i = 1 assignment refers to the parameter in Declaration 2, not the variable
in Declaration |. since Declaration 2 hides Declaration 1.

The i > O test refers to the variable in Declaration 3, since Declaration 3 hides
Declaration ! and Declaration 2 is out of scope.

The i = 3 assignment refers to the variable in Declaration 4, which hides Dec-
laration 3.

The i = 4 assignment refers to the variable in Declaration 3. It can’t refer to
Declaration 4, which is out of scope.

The i = 5 assignment refers to the variable in Declaration |.

10.5 Organizing a C Program

Now that we’ve seen the major elements that make up a C program, it’s time Lo
develop a strategy for their arrangement. For now, we'll assume that a program

***************************page_255***************************
230

Chapter 10 Program Organization

PROGRAM

always fits into a single file. Chapter 15 shows how to organize a program that’s
split over several files.
So far, we’ve seen that a program may contain the following:

Preprocessing directives such as #include and #define
Type definitions

Declarations of external variables

Function prototypes

Function definitions

Ç imposes only a few rules on the order of these items: A preprocessing directive
cloesn’t take effect until the line on which it appears. À type name can’t be used
until it’s been defined. À variable can°t be used until it’s declared. Although C isn’t
as picky about functions, I strongly recommend that every function be defined or
declared prior to its first call. (C99 makes this a requirement anyway.)

There are several ways to organize a program so that these rules are obeyed.
Here’s one possible ordering:

#include directives

#define directives

Type definitions

Declarations of external variables
Prototypes for functions other than main
Definition of main

Definitions of other functions

It makes sense to put #include directives first, since they bring in information
that will likely be needed in several places within the program. #define direc-
tives create macros, which are generally used throughout the program. Putting type
definitions above the declarations of external variables is logical, since the declara-
tions of these variables may refer to the type names just defined. Declaring exter-
nal variables next makes them available to all the functions that follow. Declaring
all functions except for main avoids the problems that arise when à function is
called before the compiler has seen its prototype. This practice also makes it possi-
ble to arrange the function definitions in any order whatsoever: alphabetically by
function name or with related functions grouped together, for example. Defining
main before the other functions makes it easier for a reader to locate the pro-
gram'’s starting point.

À final suggestion: Precede each function definition by a boxed comment that
gives the name of the function, explains its purpose, discusses the meaning of each
parameter, describes its return value (if any), and lists any side effects it has (such
as modifying external variables).

Classifying a Poker Hand

To show how a C program might be organized. let’s attempt a program that's a lit-
tle more complex than our previous examples. The program will read and classify

***************************page_256***************************
10.5  Organizing a C Program 231

a poker hand. Each card in the hand will have both à su (clubs. diamonds, hearts,
or spades) and a rank (two. three. four, five, six, seven, eight, nine, ten, jack, queen.
king, or ace). We won'1 allow the use of jokers. and we’ll assume that aces are
high. The program will read a hand of five cards. then classify the hand into one of
the following categories (listed in order from best to worst):

straight flush (both à straight and a flush)
four-of-a-kind (four cards of the same rank)
fuil house (a three-of-a-kind and a pair)

flush (five cards of the same suit)

straight (five cards with consecutive ranks)
three-of-a-kind (three cards of the same rank)
LwoO pairs

pair ({wo cards of the same rank)

high card (any other hand)

If a hand falls into two or more categories, the program will choose the best onc.
For input purposes, we'Il abbreviate ranks and suits as follows (letters may be
either upper- or lower-case):

Ranks: 2 3 45 6789t7gka
Suits: c d h s

If the user enters an illegal card or tries to enter the same card twice, the program
will ignore the card, issue an error message, and then request another card. Enter-
ing the number 0 instead of à card will cause the program to terminate.

À session with the program will have the following appearance:

Enter a card: 2s
Enter a card: Ss
Enter a card: 4s
Enter a card: 3s
Enter a card: 6s

Straight É£lus

Enter a card: 8c

Enter a card: as

Enter a card: 8c
Duplicate card; ignored.
Enter a card: 7c

Enter a card: ad

Enter a card: 3h

Pair

 

Enter a card: 6s
Enter a card: d2
Bad card; ignored.
Enter a card: 2d
Enter a card: Sc
Enter a card: àh
Enter a card: ts

***************************page_257***************************
232

Chapter 10  Program Organization

High card

Enter a card: O

From this description of the program, we see that it has three tasks:

Read a hand of five cards.
Analyze the hand for pairs, straights, and so forth.
Print the classification of the hand.

We'1l divide the program into three functions—read _cards, analyze hand,
and print _result—that perform these three tasks. main does nothing but call
these functions inside an endless loop. The functions will need to share a fairly
large amount of information, so we’ll have them communicate through external
variables. read_cards will store information about the hand into several exter-
nal variables. analyze_hand will then examine these variables. storing its find-
ings into other external variables for the benefit of print result.

Based on this preliminary design, we can begin to sketch an outline of the pro-
gram:

/* finclude directives go here */
/* #define directives go here */
/* declarations of external variables go here */

/* prototypes */

void read _ cards (void) ;
void analyze _hand (void) ;
void print result (void) ;

/*'k'k***************—k********************‘f:***'k*‘k‘k‘k**‘k*******

* main: Calls read cards, analyze hand, and print result *
* repeatedly. *
**********************************************************/

int main(void)

for (;:) {
read_cards () ;
analyze _hand () ;
print _result () ;
/*********-k*—k******—#*************—k—k**‘k*'ä:*******************
* read cards:  Reads the cards into external variables; *
* checks for bad cards and duplicate cards. *

**‘k*****************‘k*******‘:‘:*****************************/

void read_cards (void)

{
}

***************************page_258***************************
poker.c

10.5 Organizing a C Program 233

/'k**-k********************‘k**'k**1‘r*‘********1‘:*****************

* analyze hand: Determines whether the hand contains a *
x straight, a flush, four-of-a-kind, *
* and/or three-of-a-kind; determines the *
* number of pairs; stores the results into *
* external variables. +
‘k*‘k***********‘k************************************—k******/

void analyze hand (void)

{

/***********‘k*******‘k******‘k******************—h—k***—k******—k
* print result: Notifies the user of the result, using *
* the external variables set by *
* analyze _hand. *

****k*-k*****************‘k*****—k*************—k**-k——k*****—k—k*—k*/

void print result (void)

(
}

The most pressing question that remains 1s how to represent the hand of cards.
Let’s see what operations read_cards and analyze_hand will perform on
the hand. During the analysis of the hand, analyze _ hand vwill need to know
how many cards are in cach rank and each suit. This suggests that we use two
arrays, num_in rank and num_in _ suit. The value of num_in rank[r]
Will be the number of cards with rank r, and the value of num_in suit [s] will
be the number of cards with suit s. (We'II encode ranks as numbers between O and
|2. and suits as numbers between O and 3.) We’ll also need a third array,
card _ exists, so that read _cards can detect duplicate cards. Each time
read_cards reads a card with rank r and suit s, it checks whether the value of
card _exists [r] [s] is true. If so. the card was previously entered; if not,
read _cards assigns true tocard exists[r] [s|.

Both the read_cards function and the analyze_hand function will need
access to the num_in rank and num _ in _suit arrays. so l'Il make them exter-
nal variables. The card_exists array is used only by read_cards. so it can
be local to that l'unction. Às a rule. variables should be made external only 1f neces-
sary.

Having decided on the major data structures, we can now finish the program:

/* Classifies a poker hand */

#include <stdbool.h> /* C99 only */
#include <stdio.h>
#include <stdlib.h>

#define NUM RANKS 13
#define NUM SUITS 4
#define NUM _ CARDS S

***************************page_259***************************
234

Chapter 10  Program Organization

/* external variables */

int num in rank [NUM RANKS] ;

int num in suit [NUM SUITS] ;

bool straight, flush, four, three;
int pairs; /* can be 0, 1, or 2 */

/* prototypes */

void read _ cards (void) ;
void analyze hand (void) ;
void print result (void) ;

/**********************************************************

* main: Calls read cards, analyze hand, and print result *
* repeatedly. *
***'k**********‘k‘k******‘k**‘k*****************************‘k**/

int main(void)
(
£or (:;) {
read _cards () ;
analyze_hand () ;
print result () ;

}
}

/*******‘k************À‘**‘k****‘k*********‘k*******‘k‘k**'k*‘k*'k****

* read cards: Reads the cards into the external *
* variables num in rank and num in suit; *
* checks for bad cards and duplicate cards. *

*****************‘*****************‘*********'À'****‘k*********/

void read cards (void)

{

bool card exists [NUM RANKS] ([NUM _ SUITS] ;
char ch, rank ch, suit _ch;

int rank, suit;

bool bad card;

int cards read = 0;

for (rank = 0; rank < NUM RANKS; rank++) Ç{

num_in rank ({rank] = 0;
for (suit = 0; suit < NUM SUITS; suit++)
card_exists (rank] [suit] = false;

}

for (suit = O0; suit < NUM SUITS; suit++)
num_in suit [suit] = O0;

while (cards read < NUM CARDS) {
bad _card = false;

print£ ("Enter a card: ");

rank ch = getchar () ;
switch (rank ch) {

***************************page_260***************************
10.5  Organizing a C Program

235

case '0': exit (EXIT SUCCESS) ;
case '2': rank = 0; break;
case !3': rank = 1; break;
case '4': rank = 2; break;
case '!5': rank = 3; break;
case '6': rank = 4; break;
case '7': rank = 5; break;
case '8': rank = 6; break;
case '!S': rank = 7; break;
case ‘'t': case 'T': rank = 8;, break;
case 'j': case 'J': rank = 9; break;
case 'q': case 'Q': rank = 10; break,;
case 'k': case 'K': rank = 11; break:;
case 'a': case 'A': rank = 12; break;
default : bad_card = true;

}

suit_ch = getchar () ;

switch (suit ch) (
case 'c': case 'C': suit = O; break;
case 'd': case 'D': suit = 1;, break;
case 'h': case 'H': suit = 2; break;
case 's': case 'S': suit = 3; break;
default : bad _card = true;

}

while ((ch = getchar()) != '\n')
if (ch != ' !) bad card = true;

if (bad _ card)
printf ("Bad card; ignored.\n") ;

else if (card exists [rank] [suit])
print£ ("Duplicate card; ignored.\n") ;

else {
num_in_rank [rank] ++ ;
num_in _ suit [suit]++;
card_exists [rank] [suit] =
cards read++;

true;

}
}
}

/'À"k'k‘k‘A“k*****‘k***‘k*‘k**'k‘k*'k**********************************

* analyze _hand:
* straight,

Determines whether the hand contains a
a flush, four-of-a-kind,

* and/or three-of-a-kind; determines the
* number of pairs;

* the external variables straight, flush,
* four, three, and pairs.

*
*
*
stores the results into *
*
*
*

KKKKKKKAKKXARAREKRAERAAARRARAARKAAA R A A A A R A K A À X À X À K K À /

void analyze _hand (void)

(

int num consec = 0;
int rank, suit;

***************************page_261***************************
236

Chapter 10  Program Organization

}

straight = false;
Élush = false;
four = false;
three = false:;
pairs = 0;

/* check for £lush */
for (suit = 0; suit < NUM SUITS; suit++)
if (num in suit[suit] == NUM CARDS)
£flush = true;

/* check for straight */

rank = 0;

while (num in rank[rank] == 0O) rank++;

for (; rank < NUM RANKS && num in _ rank [rank] > 0; rank++)
num_consec++;

if (num consec == NUM CARDS) {
straight = true;
return;

}

/* check for 4-of-a-kind, 3-of-a-kind, and pairs */
for (rank = 0; rank < NUM RANKS; rank++) {

if (num _ in rank[rank] == 4) four = true;

if (num in rank [rank] 3) three = true;
1i£ (num in _ rank [rank] 2) pairs++;

}

/—k*-k******‘k*****‘k*****‘k*****‘k‘k‘k*—k**************************

* print_result: Prints the classification of the hand, *
* based on the values of the external *
* variables straight, flush, four, three, *
* and pairs. *

****************************‘k*******************'ﬁ:*********/

void print result (void)

{

1f (straight && flush) print£f("Straight flush") ;

else if (four) printf ("Four of a kind") ;
else if (three &&
pairs == 1) printf ("Full house") ;
else if (flush) print£f ("Flush") ;
else if (straight) printf ("Straight") ;
else 1f (three) printf ("Three of a kind") ;
else if (pairs == 2) print£ ("Two pairs") ;
else if (pairs == 1) printf ("Pair") ;
else print£ ("High card") ;

print£ ("\n\n") ;

Notice the use of the exit function in read_cards (in case ' O" of the first

switch statement). exit 1s convenient for this program because of its ability to
terminate execution from anywhere in the program.

***************************page_262***************************
Section 10.4

O

Q & À 237

Q & À

What impact do local variables with static storage duration have on recursive
functions? [p. 220]

When a function is called recursively, fresh copies are made of its automatic vari-
ables for each call. This doesn*t occur for static variables, though. Instead, all calls
of the function share the same static variables.

In the following example, j is initialized to the same value as i, but there are
two variables named i:

int 1 = 1l;

void f (void)

int à ;
int i = 2;

n

Is this code legal? If so, what is j°s initial value, l or 2?

The code is indeed legal. The scope of a local variable doesn't begin until its decla-
ration. Therefore, the declaration of j refers to the external variable named i. The
initial value of j will be 1.

Exercises

The following program outline shows only function definitions and variable declarations.
int a;

void f (int b)

{
}

void g(void)

{

int C;

int d;

{

int e;
}
}

int main(void)

{
}

int Ëf;

***************************page_263***************************
238

Chapter 10  Program Organization

For cach of the following scopes, list all variable and parameter names visible in that scope:
(a) The £ function

(b) The g function

(c) The block in which @ is declared

(d) The main function

The following program outline shows only function definitions and variable declarations.

int b, C:

void £ (void)

{
}

void g(int a)

(

int C;

(

}
}

int main(void)

{

int c, d;
}

For cach of the following scopes, list all variable and parameter names visible in that scope.
If there’s more than one variable or parameter with the same name, indicate which one is
visible.

int b, d;

int a, d;

(a) The £ function

(b) The g function

(c) The block in which a and d are declared
(d) The main function

Suppose that a program has only one function (main). How many different variables named
i could this program contain?

Programming Projects

MoJify the stack example of Section 10.2 so that it stores characters instead of integers.
Next, add a main function that asks the user to enter a series of parentheses and/or braces.
then indicates whether or not they’re properly nested:

Enter parentheses and/or braces: ((){}{()})
Parentheses/braces are nested properly

 

Hint;: Âs the program reads characters. have it push each left parenthesis or left brace. When
it reads a right parenthesis or brace, have it pop the stack and check that the item popped is a
matching parenthesis or brace. (If not, the parentheses/braces aren*t nested properly.) When
the program reads the new-line character. have it check whether the stack is empty: if so, the
parentheses/braces are matched. IF the stack isn'rempty (or il stack_underflovw is ever

***************************page_264***************************
Programming Projecis 239

called), the parentheses/braces aren't matched. If stack_overflow is called, have the
program print the message Stack overflow and terminate immediately.

Modify the poker.c prograin of Section 10.5 by moving the num_in_rank and
num _ in suit arrays into main, which will pass them as arguments to read_cards
and analyze hand.

Remove the num in _ rank, num_in suit, and card _ exists arrays from the
poker.c program of Section 10.5. Have the program store the cards in a 5 x 2 array
instead. Each row of the array will represent a card. For example, if the array is named
hand, then hand [0] [0] will store the rank of the first card and hand [0] [1] will store
the suit of the first card.

Modify the poker. c program of Section 10.5 by having it recognize an additional cate-
gory, “royal flush” (ace, king. queen, jack, ten of the same suit). À royal flush ranks higher
than all other hands.

Modify the poker .c program of Section 10.5 by allowing ‘“ace-low” straights (acc, two,
three, four, five).

Some calculators (notably those from Hewlett-Packard) use a system of writing mathemati-
cal expressions known as Reverse Polish Notation (RPN). In this notation, operators are
placed afer their operands instead of berween their operands. For example, | + 2 would bc
written ! 2 + in RPN, and ! + 2 * 3 would be written ! 2 3 # + RPN expressions can easily
be evaluated using a stack. The algorithm involves reading the operators and operands in an
expression from left to right, performing the following actions:

When an operand is encountered, push it onto the stack.

When an operator is encountered, pop its operands from the stack. perform the opera-
tion on those operands, and then push the result onto the stack.

Write a program that evaluates RPN expressions. The operands will be single-digit integers.
Thc operators are +, — *, /. and =. The = operator causes the top stack item to be displayed;
afterwards, the stack is cleared and the user is prompted to enter another expression. Thce
process continues until the user enters à character that is not an operator or opcrand:

Enter an RPN expression: 1 2 3 #* + =
Value of expression: 7

Enter an RPN expression: 5 8 * 4 9 - / =
Value of expression: -8

Enter an RPN expression: q

 

 

If the stack overflows, the program will display the message Expression is too com-
plex and terminate. If the stack underflows (because of an expression such as | 2 + +), the
program will display the message Not enough operands in expression and termi-
nate. Hints: Incorporate the stack code from Section 10.2 into your program. Use
scanf (" %c", &ch) to read the operators and operands.

Write a program that prompts the user for a number and then displays the number, using
characters to simulate the effect of a seven-segment display:

Enter a number: 491-9014

L ILE LUEN UU
p HUN ON 1

Characters other than digits should be ignored. Write the program so that the maximum
number of digits is controlled by a macro named MAX_DIGITS. which has the value 10. Tf

***************************page_265***************************
240

Chapter 10 Program Organization

the number contains more than this number of digits. the extra digits are ignored. Hints: Usce
two external arrays. One is the segments array (see Exercise 6 in Chapter 8), which stores
data representing the correspondence between digits and segments. The other array. dig-
its, will be an array of characters with 4 rows (since each segmented digit is four charac-
ters high) and MAX DIGITS * 4 columns (digits are three characters wide, but a space 1s
needed between digits for readability). Write your program as four functions: main,
clear _digits array. process _ digit, and print digits array. Here are
the prototypes for the latter three functions:

void clear digits _array (void) ;
void process digit (int digit, int position) ;
void print digits _ array (void) ;

clear_digits array vwill store blank characters into all elements of the digits
array, process digit will store the seven-segment representation of digit into a
specified position in the digits array (positions range from O to MAX DIGITS — |).
print_digits _array will display the rows of the digits array. each on a single line,
producing output such as that shown in the example.

***************************page_266***************************
11

11.1

Pointers

The 11th commandment was “Thou Shalt Compute”
or “Thou Shalt Not Compute"—I| forget which.

Pointers are one of C’s most important—and most often misunderstood—features.
Because of their importance, we*II devote three chapters to pointers. In this chap-
ter. we*]] concentrate on the basics; Chapters 12 and 17 cover more advanced uses
of pointers.

We’1l start with a discussion of memory addresses and their relationship to
pointer variables (Section 11.1). Section 1 1.2 then introduces the address and indi-
rection operators. Section 11.3 covers pointer assignment. Section | 1.4 explains
how to pass pointers to functions, while Section 11.5 discusses returning pointers
from functions.

Pointer Variables

The first step in understanding pointers is visualizing what they represent at the
machine level. In most modern computers, main memory is divided into bytes,
with each byte capable of storing eight bits of information:

 

 

Each byte has a unique address to distinguish it from the other bytes in memory. If
there are n bytes in memory. we can think of addresses as numbers that range from
O to n — 1 (see the figure at the top of the next page).

An executable program consists of both code (machine instructions corre-
sponding to statements in the original C program) and data (variables in the origi-
nal program). Each variable in the program occupies one or more bytes of memory;

241

***************************page_267***************************
242

Chapter 11

QaÂ

Pointers

Address … Contents

 

0 01010011
l 01110161_
2 01110011
3 01100001
â IOllOlllû
n-l 01000011

 

 

the address of the first byte is said to be the address of the variable. In the following
figure, the variable i occupies the bytes at addresses 2000 and 2001. so i*s address
1s 2000:

2000

2001

 

 

Here's where pointers come in. Although addresses are represented by num-
bers, their range of values may differ from that of integers, so we can’! necessarily
store them in ordinary integer variables. We can, however, store them in special
pointer variables. When we store the address of a variable i in the pointer variable
p. we say that p “points to” i. In other words, a pointer is nothing more than an
address, and a pointer variable is just a variable that can store an address.

Instead of showing addresses as numbers in our examples, l’Il use a simpler
notation. To indicate that a pointer variable p stores the address of a variable i, PIl
show the contents of p as an arrow directed toward i:

OO

Declaring Pointer Variables

 

À pointer variable is declared in much the same way as an ordinary variable. The
only difference is that the name of à pointer variable must be preceded by an aster-
isk:

int *p;

***************************page_268***************************
abstract objects > 19.7

pointers to pointers » 17.6

11.2

Ivalues > 4.2

11.2  The Address and Indirection Operators 243

This dectaration states that p is a pointer variable capable of pointing to objects of
type int. m using the term object instead of variable since—as we'll sec in
Chapter 17—p might point to an area of memory that doesnt belong to a variable.
(Be aware that “object” will have a different meaning when we discuss program
design in Chapter 19.)

Pointer variables can appear in declarations along with other variables:

 

int i, j, a[10)], b[20], *p., *q;

In this example, i and j are ordinary integer variables, à and b are arrays of Inte-
gers, and p and q are pointers to integer objects.

C requires that every pointer variable point only to objects of a particular type
(the referenced type):

int *p; /* points only to integers */
double *qg; /* points only to doubles */
char *r; /* points only to characters */

There are no restrictions on what the referenced type may be. In fact. a pointer
variable can even point to another pointer.

The Address and Indirection Operators

C provides a pair of operators designed specifically for use with pointers. To find
the address of a variable, we use the & (address) operator. If x is a variable. then
&x is the address of x in memory. To gain access to the object that a pointer points
to, we use the * (indirection) operator. If p is a pointer, then *p represents the
object to which p currently points.

The Address Operator

Declaring a pointer variable sets aside space for a pointer but doesn’t make it point
to an object:

int *p; /* points nowhere in particular */

Its crucial to initialize p before we use it. One way to initialize a pointer variable
is to assign it the address of some variable—or, more generally, |value—using the
& operator:

int i, *p;
p = &i;

By assigning the address of i to the variable p. this statement makes p point to i:

GO

***************************page_269***************************
244

Chapter 11

QaA

Pointers

Il's also possible to initialize a pointer variable at the time we declare ît
int i;
int *p = &i;
We can even combine the declaration of i with the declaration of P. provided that
i 1s declared first:

int i, *p = &i;

The Indirection Operator

Once a pointer variable points to an object, we can use the * (indirection) operator
to access what’s stored in the object. If p points to i, for example, we can print the
value of i as follows:

print£ ("sd\n", *p);

print£ will display the value of i, not the address of i.

The mathematically inclined reader may wish to think of * as the inverse of &.
Applying & to a variable produces a pointer to the variable; applying * to the
pointer takes us back to the original variable:

j = *&i, /* same as j = i; */

Âs long as p points to i, *p is an alias for i. Not only does *p have the same
value as i, but changing the value of *p also changes the value of i. (*p is an
lvalue, so assignment to it is legal.) The following example illustrates the equiva-
lence of *p and i; diagrams show the values of p and i at various points in the
computation.

p = &i;

 

_

print£("%d\n"', i), /* prints 1 */
print£ ("%d\n", *p),; /* prints 1 #/

*p - 2;
p! '—l— —>{ 2 li

print£f("%d\n", i); /* prints 2 */
print£ ("*d\n", *p); /* prints 2 */

 

***************************page_270***************************
11.3

11.3 Pointer Assignment = 245

 

Never apply the indirection operator to an uninitialized pointer variable. IT a
pointer variable p hasn’t been initialized, attempting to use the value of p in any
way causes undefined behavior. In the following example. the call of print£ may
print garbage, cause the program to crash. or have some other effect:

int *p;
printf("%d", *p) ; /*** WRONG ***/

Assigning a value to *p is particularly dangerous. If p happens to contain a valid
memory address, the following assignment will attempt to modify the data stored
at that address:

int *p;
*p = 1l; /*** WRONG ***/

If the location modified by this assignment belongs to the program, it may behave
erratically: if it belongs to the operating system, the program will most likely
crash. Your compiler may issue a warning that p is uninitialized. so pay close
attention to any warning messages you gel.

 

Pointer Assignment

C allows the use of the assignment operator to copy pointers, provided that they
have the same type. Suppose that i. j. p. and q have been declared as follows:

int i, j, *Pp,. *Gg;
The statement
p = &i;

is an example of pointer assignment; the acdress of à is copied into p. Here's
another example of pointer assignment:

q = Ps

This statement copies the contents of p (the address of i) into q, in effect making
q point to the same place as p:

.\\
| D j
_J? i
N
_:l

Both p and q now point to i, so we can change i by assigning a new value Lo
either #p or *q

 

q

***************************page_271***************************
246 Chapter 11  Pointers

*p = l;
p\î:l
1 i
//
q «
*q = 2;

 

 

Any number of pointer variables may point to the same object.
Be careful not to confuse

q = P/
with
*q = *P;

The first statement is a pointer assignment; the second isnt, as the followine
example shows:

 

 

p = &i;
q =€&j;
i = 1;
00

GO
[H

The assignment *q = *p copies the value that p points to (the value of i) into the
object that q points to (the variable ).

 

 

***************************page_272***************************
11.4

11.4  Pointers as Arguments 247

Pointers as Arguments

So far, we’ve managed to avoid a rather important question: What are pointers
good for? There’s no single answer to that question, since pointers have several
distinct uses in C. In this section. we’I] see how a pointer to a variable can be use-
ful as a function argument. We'I1 discover other uses for pointers in Section | 1.5
and in Chapters 12 and 17.

We saw in Section 9.3 that a variable supplied as an argument in a function
call is protected against change, because C passes arguments by value. This prop-
erty of C can be a nuisance if we want the function to be able to modify the vari-
able. In Section 9.3, we tied—and failed—to write a decompose function that
could modify two of its arguments.

Pointers offer a solution to this problem: instead of passing a variable x as the
argument to a function, we’I] supply &x, a pointer to x. We'll declare the corre-
sponding parameter p to be a pointer. When the function is called, p will have the
value &x. hence *p (the object that p points to) will be an alias for x. Each appear-
ance of *p in the body of the function wil] be an indirect reference to x, allowing
the function both to read x and to modify it.

To see this technique in action, let’s modify the decompose function by
declaring the parameters int _ part and frac_part to be pointers. The defini-
tion of decompose will now look like this:

void decompose (double x, long *int part, double *frac _part)

*int part = (long) x;
*frac _ part = x - *int part;

}

The prototype for decompose could be either
void decompose (double x, long *int part, double *frac part);
or
void decompose (double, long *, double *);
We'1l call decompose in the following way:
decompose (3.14159, &i, &d);

Because of the & operator in front of à and d. the arguments lo0 decompose are
pointers to i and d, not the valres of i and d. When decompose is called, the
value 3.14159 is copied into x, a pointer to i is stored in int part, and a
pointer to d is stored in frac_part:

***************************page_273***************************
 

248 Chapter 11  Pointers

 

x | 3.14159 l
int _ part ——I—— ? l i
frac part *—l——* ? ld

The first assignment in the body of decompose converts the value of x to type
long and stores it in the object pointed to by int _part. Since int part
points to i, the assignment puts the value 3 in i:

x | 3.14159 I
int_part °—l—' 3 I i
frac _part j—> ? |d

The second assignment fetches the value that int part points to (the value of
i), which 1s 3. This value is converted to type double and subtracted from x, giv-
ing .14159, which 1s then stored in the object that frac_part points to:

x | 3.14159 l
int part 3—* 3 Ii
frac_part 3—* ,.14159 ld

When decompose returns. i and d will have the values 3 and .14159, just as we
originally wanted.

Using pointers as arguments to functions 1s actually nothine new; we’ve been
doing it in calls of scan£ since Chapter 2. Consider the following example:

 

 

 

 

 

 

int i;
scanf ("$d", &i) ;

We must put the & operator in front of à so that scantf 1s given a pointer to i; that
pointer tells scan£ where to put the value that it reads. Without the & scanf
would be supplied with the value of i.

Although scan£'s arguments must be pointers, il’s not always true that every
aregument needs the & operator. In the following example, scanf is passed a
pointer variable:

***************************page_274***************************
PROGRAM

11.4  Pointers as Arguments 249
int i, *p;

p = &i;
scan£ ("zd", p);

Since p contains the address of i. scan£ will read an integer and store it in i.
Using the & operator in the call would be wrong:

scanf ("zsd", &p); /*** WRONG ***/

scan£ would rcad an integer and store it in p instead of in i.

 

Failine to pass a pointer to a function when one is expected can have disastrous

results. Suppose that we call decompose without the & operator in front of i and
d:

decompose (3.14159, i, d);

decompose is expecting pointers as its second and third arguments, but it’s been
given the values of i and d instead. decompose has no way to tell the difference,
so it will use the values of i and d as though they were pointers. When decom-
pose stores values in *int part and *frac_part, it will attempt to change
unknown memory locations instead of modifying i and d.

If we’ve provided a prototype for decompose (as we should always do. of
course), the compiler will let us know that we're attempling to pass arguments of
the wrong type. In the case of scan£, however. failing to pass pointers often goes
undetected by the compiler, making scan£ an especially error-prone function.

 

Finding the Largest and Smallest Elements in an Array

To illustrate how pointers are passed to functions, lel’s look at a function named
max_min that finds the largest and smallest elements in an array. When we call
max min, we’ll pass it pointers to two variables: max_min will then store its
answers in these variables. max_min has the following prototype:

void max min(int a[], int n, int *max, int *min) ;
A call of max_min might have the following appearance:
max_min(b, N, &big, &small) ;

b is an array of integers; N is the number of elements in b. big and small are
ordinary integer variables. When max_min finds the largest element in b, it stores
the value in big by assigning it to *max. (Since max points to big. an assign-
ment to *max wil] modify the value of big.) max _min stores the smallest ele-
ment of b in small by assigning it to *min.

To test max_min. we'll write a program that reads 10 numbers into an array,
passes the array to max_min, and prints the results:

***************************page_275***************************
250 Chapter 11  Pointers

Enter 10 numbers: 34 82 49 102 7 94 23 11 50 31
Largest: 102
Smallest: 7

Here’s the complete program:
maxmin.c _ /* Finds the largest and smallest elements in an array */
#include <stdio.h>
#define N 10
void max_min(int a([], int n, int *max, int *min) ;

int main(void)

{

int b[N], i, big, small;

print£f ("Enter %d numbers: ", N);
for (i = O0; i < N; i++)
scan£ ("=d", &b[il]);

max_min(b, N, &big, &small) ;

print£f ("Largest: %d\n", big) ;
print£("Smallest: %“d\n", small) ;

return O0;

}

void max min(int a[], int n, int *max, int *min)

{

int i;

*max = *min = a[0}];
for (i = 1; i < n; i++) {
Lif (a[i] > *max)
*max = a[il];
else if (a[i] < *min)
*min = a[i}];

Using const to Protect Arguments

When we call a function and pass it a pointer to à variable, we normally assume
that the function will modify the variable (otherwise, why would the function
require a pointer?). For example. if we see a statement like

Ë (&X) ;

***************************page_276***************************
eF3

11.5

11.5 _ Pointers as Return Values 251

in a program, we’d probably expect £ to change the value of x. Its possible,
though, that £ merely needs to examine the value of x, not change it. The reason
for the pointer might be efficiency: passing the value of a variable can waste time
and space if the variable requires a large amount of storage. (Section 12.3 covers
this point in more detail.)

We can use the word const to document that a function won’t change an
object whose address is passed to the function. const goes in the parameter’s
declaration, just before the specification of its type:

void f (const int *p)

{

*p = 0; /*** WRONG #***/

This use of const indicates that p is a pointer to a “constant integer”” Attempting
to modify #p is an error that the compiler will detect.

Pointers as Return Values

We can not only pass pointers to functions but also write functions that return
pointers. Such functions are relatively common; we’Il encounter several in Chapter
13.

The following function, when given pointers to two integers, returns a pointer
to whichever integer 1s larger:

int *max(int *a, int *b)

{
if (*a > *b)
return a;
else
return b;

}

When we call max, we’Il pass pointers to two int variables and store the result in
a pointer variable:

int *p, i, j;
p = max(&i, &j) ;

During the call of max, *a is an alias for i, while *b is an alias for j. If i has a
larger value than j, max returns the address of i; otherwise, it returns the address
of j. After the call, p points to either i or j.

Although the max function returns one of the pointers passed to it as an argu-
ment, that’s not the only possibility. À function could also return a pointer to an
external variable or to a local variable that’s been declared static.

***************************page_277***************************
252

Chapter 11

/

Pointers

 

Never return a pointer to an automatic local variable:

int *f£ (void)

{

int i;

return £&i;

}

The variable i doesn’t exist once £ returns, so the pointer to it will be invalid.
Some compilers issue a warning such as “function returns address of local vari-
able” in this situation.

 

Pointers can point to array elements, not just ordinary variables. If à is an
array, then &a [i] is a pointer to element i of a. When a function has an array
argument. it’s sometimes useful for the function to return a pointer to one of the
elements in the array. For example, the following function returns a pointer to the
middle element of the array a, assuming that a has n elements:

int *find middle(int a[], int n) (
return &a [n/2] ;
}

Chapter 12 explores the relationship between pointers and arrays in considerable
detail.

Q & À

Is a pointer always the same as an address? [p. 242]

Usually, but not always. Consider a computer whose main memory is divided into
words rather than bytes. À word might contain 36 bits, 60 bits, or some other
number of bits. If we assume 36-bit words, memory will have the following
appearance:

 

 

 

 

 

 

 

Address Contents
0 001010011001010011001010011001010011
1 001110101001110101001110101001110101
2 001110011001110011001110011001110011
3 001100001001100001001100001001100001
4 001101110001101110001101110001101110
n-1 |001000011001000011001000011001000011

 

 

***************************page_278***************************
Q & À 253

When memory 1s divided into words, each word has an address. An integer
usually occupies one word, so a pointer to an integer can just be an address. How-
ever, a word can store more than one character. For example. a 36-bit word might
store six 6-bit characters:

 

 

l010011 ‘110101' 210011 100001l 101110l 000011

or four 9-bit characters:

0010130011 l001110101 |001110011 |001100001

For this reason, a pointer to a character may need to be stored in à différent form
than other pointers. À pointer to a character might consist of an address (the word
in which the character 1s stored) plus à small integer (the position of the character
within the word).

On some computers, pointers may be ‘offsets” rather than complete
addresses. For example, CPUs in the Intel x86 family (used in many personal com-
puters) can execute programs In several modes. The oldest of these, which dates
back to the 8086 processor of 1978, is called real mode. In this mode, addresses
are sometimes represented by a single 16-bit number (an of/fset) and sometimes by
two 16-bit numbers (a segment:offset pair). An offset isn’t a true memory address:
the CPU must combine 1t with a segment value stored in a special register. To sup-
port real mode, older C compilers often provide two kinds of pointers: near point-
ers (16-bit offsets) and far pointers (32-bit segment:offset pairs). These compilers
usually reserve the words near and far as nonstandard keywords that can be
used to declare pointer variables.

If a pointer can point to data in a program, is it possible to have a pointer to
program code?

Yes. We'1l cover pointers to functions in Section 17.7.

It seems to me that there’s an inconsistency between the declaration

int *p = &i;

and the statement

p = &i;

Why isn’t p preceded by a * symbol in the statement, as it is in the declara-
tion? [p. 244]

The source of the confusion is the fact that the * symbol can have different mean-
ings in C, depending on the context in which 1t’s used. In the declaration

int *p = &i;

the * symbol 1s not the indirection operator. Instead, it helps specify the type of p,
informing the compiler that p is a pointerto an int. When it appears In a statement,

***************************page_279***************************
254

Chapter 11

> &

Pointers

however, the # symbol performs indirection (when used as a unary operator). The
statement

*p = &i; /*** WRONG ***/

would be wrong, because it assigns the address of i to the object that p points to.
not to p itself.

[s there some way to print the address of a variable? [p. 244]

Any pointer. including the address of a variable, can be displayed by calling the
print£ function and using p as the conversion specification. See Section 22.3
for details.

The following declaration is confusing:

void f(const int *p);

Does this say that £ can’t modifyv p? [p. 251]

No. Ît says that £ can’t change the integer that p points to; it doesn’t prevent f
from changing p itself.

void f(const int *p)

{

int ;;
*p = 0; /*** WRONG ***/
p = &j; /* legal */

}

Since arguments are passed by value, assigning p a new value—by making it point
somewhere else—won’t have any effect outside the f'unction.

When declaring a parameter of a pointer type, is it legal to put the word
const in front of the parameter’s name, as in the following example?

void f (int * const p);

Yes, although the effect isn’t the same as if const precedes p's type. We saw in
Section 11.4 that putting const before p’s type protects the object that p points
to. Putting const after p’s type protects p itself:

void f(int * const p)

(

int ;;

*p = 0; /* legal */
p = &j; /*** WRONG ***/

This feature isn’t used very often. Since p is merely a copy of another pointer (the
argument when the function 1s called), there’s rarely any reason to proteet it.

An even greater rarity 1s the need to protect both p and the object it points to.
which can be done by putting const both before and after p’s type:

***************************page_280***************************
Section 11.2

Section 11.3

Section 11.4

@ 2.
3.
@ 4
5.
® 6

Exercises 255

void f (const int * const p)

{

int j;

*p = 0; /*** WRONG ***/
p = &j; /*** WRONG ***/

Exercises

If à is a variable and p points to i, which of the following expressions are aliases for i ?

(a) *p (c) *&p (e) #i (g) *&i
(b) &p (d) &*p (f) &i (h) &*i

If à is an int variable and p and q are pointers to int, which of the following assignments
are legal?

(a) p = i; (d) p = &g; (g) p = *q;
(b) *p = &i; (e) p = *&g; (h) *p = ;
(c) & = ; (f) p = q: (1) *p = *g;

The following function supposedly computes the sum and average of the numbers in the
array a. which has length n. avg and sum point to variables that the function should mod-
ify. Unfortunately, the function contains several errors; find and correct them.

void avg_sum(double a[], int n, double *avg, double *sum)

(

int i;

sum = 0.0;

for (i = O0; i < n; i++)

sum += a[i];

avg = sum / n;
Write the following function:
void swap(int *p, int *g);
When passed the addresses of two variables, swap should exchange the values of the vari-
ables:

swap(&i, &]) ; /* exchanges values of i and ; */

Write the following function:
void split time(long total _ sec, int *hr, int *min, int *sec);

total_sec is a time represented as the number of seconds since midnight. hr, min, and
sec are pointers to variables in which the function will store the equivalent time in hours
(0-23), minutes (0-59). and seconds (0-59), respectively.

Write the following function:

void find _ two _largest (int a[], int n, int *largest,
int *second largest) ;

***************************page_281***************************
256 Chapter 11

Section 11.5

S.

tJ

e

Pointers

When passed an array a of length n. the function will search a for its largest and second-
largest elements, storing them in the variables pointed to by largest and
second _largest, respectively.

Write the following function:

void split date(int day _ of year, int year,
int *month, int *day) ;

day_of year is an integer between ! and 366, specifying a particular day within the year
designated by year. month and day point to variables in which the function will store the
equivalent month (1—12) and day within that month (1=31).

Write the following function:
int *find _ largest (int a[], int n);

When passed an array a of length n. the function will return à pointer to the array’s largest
element.

Programming Projects

Modify Programming Project 7 from Chapter 2 so that it includes the following function:

void pay_amount (int dollars, int *twenties, int *tens,
int *fives, int *ones) ;

The function determines the smallest number of $20, $10. $5, and $1 bills necessary to pay
the amount represented by the dollars parameter. The twenties parameter points to à
variable in which the function will store the number of S20 bills required. The tens,
fives. and ones parameters are similar.

Modify Programming Project 8 from Chapter 5 so that it includes the following function:

void find closest flight (int desired time,
int *departure time,
int *arrival time) ;

This function will find the flight whose departure time is closest to desired _time
(expressed in minutes since midnight). Ît will store the departure and arrival times of this
flight (also expressed in minutes since midnight) in the variables pointed to by
departure _ time andarrival time, respectively.

Modify Programming Project 3 from Chapter 6 so that it includes the following function:

void reduce (int numerator, int denominator,
int *reduced _ numerator,
int *reduced _denominator) ;

numerator and denominator areë the numerator and denominator of a fraction.
reduced_numerator and reduced_denominator are pointers to variables in
which the function will store the numerator and denominator of the fraction once it has been
reduced to lowest terms.

Modify the poker .c program of Section 10.5 by moving all external variables into main
and modifying functions so that they communicate by passing arguments. The
analyze_hand function nécds to change the straight, flush, four, three, and
pairs variables, so it will have to be passed pointers to those variables.

***************************page_282***************************
12

12.1

Pointers and Arrays

Optimization hinders evolution.

Chapter 11 introduced pointers and showed how they’re used as function aregu-
ments and as values returned by functions. This chapter covers another application
for pointers. When pointers point to array elements, C allows us to perform arith-
metic—addition and subtraction—on the pointers, which leads to an alternative
way of processing arrays in which pointers take the place of array subseripts.

The relationship between pointers and arrays in C 1s a close one, as we'll soon
see. We'll exploit this relationship in subsequent chapters, including Chapter 13
(Strings) and Chapter 17 (Advanced Uses of Pointers). Understanding the connec-
tion between pointers and arrays 1s critical for mastering C: it will give you insight
into how C was designed and help you understand existing programs. Be aware,
however, that one of the primary reasons for using pointers to process arrays—effi-
clency—Is no longer as important as it once was, thanks to improved compilers.

Section 12.1 discusses pointer arithmetic and shows how pointers can be com-
pared using the relational and equality operators. Section 12.2 then demonstrates
how we can use pointer arithmetic for processing array clements. Section 12.3
reveals a key fact about arrays—an array name can serve as a pointer to the array's
first element—and uses 1t Lo show how array arguments really work. Section 12.4
shows how the topics of the first three sections apply to multidimensional arrays.
Section 12.5 wraps up the chapter by exploring the relationship between pointers
and variable-length arrays, a C99 feature.

 

Pointer Arithmetic

We saw in Section 11.535 that pointers can point to array elements. For example,
suppose that a and p have been declared as follows:

257

***************************page_283***************************
258

Chapter 12  Pointers and Arrays

Q&AÀ

int a[10], *p;
We can make p point to a [0] by writing
p = &a[0];

Graphically, here’s what we’ve just done:

+
- CT TT

0 1 à 3 4 5 6 7 8 9

 

 

 

 

 

 

 

 

 

We can now access a [0] through p; for example, we can store the value 5 in
a [0] by writing

*p=5;

Here’s our picture now:

 

 

 

Making a pointer p point to an element of an array a isn*t particularly excit-
ing. However. by performing pointer arithmetic (or address arithmetic) on p, we
can access the other elements of a. C supports three (and only three) forms of
pointer arithmetic:

Adding an integer to a pointer
Subtracting an integer from a pointer
Subtracting one pointer from another

Let’s take a close look at each of these operations. Our examples assume that the
following declarations are in effect:

int a[10], *p, *g, i;

Adding an Integer to a Pointer

Adding an integer j to a pointer p yields a pointer to the clement 3 places after the
one that p points to. More precisely, if p points to the array element a [i], then
p + j points to a [i+] ] (provided, of course, that a [i+j] exists).

The following example illustrates pointer addition; diagrams show the values
of p and q at various points in the computation.

***************************page_284***************************
12.1  Pointer Arithmetic 259

p = &a[2]; pŒ

a

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

e
_
tV
U
U
G
J

 

 

 

 

p

Subtracting an Integer from a Pointer

If p points to the array element a [i]. then p - j points to a [i-j] . For example:

p = &a[8]; pï_l

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

O
#3
I
u
—
UI
C

—
…
.

Subtracting One Pointer from Another

When one pointer is subtracted from another, the result is the distance (measured
in array elements) between the pointers. Thus, if p points to a [i] and q points to
a [j1.then p - q is equal to i - j. For example:

***************************page_285***************************
260

Chapter 12  Pointers and Arrays

æ

compound literals »9,3

12.2

c1 } -.L)

 

 

 

i = p - q; /* i is 4 */
i = q - p; /* i is -4 */

 

Performing arithmetic on a pointer that doesn’t point to an array element causes
undefined behavior. Furthermore, the effect of subtracting one pointer from
another 1s undefined unless both point to elements of the same array.

 

Comparing Pointers

We can compare pointers using the relational operators (<, <=, >, >=) and the
equality operators (== and ! =). Using the relational operators to compare two
pointers is meaningful onty when both point to elements of the same array. The
outcome of the comparison depends on the relative positions of the two elements
in the array. For example, after the assi gnments

p = &a[5] ;
q = &a[1];

the value of p <= q is 0 and the value oOf p >= gis |.

Pointers to Compound Literals

It's legal for a pointer to point to an element within an array created by a com-
pound literal. A compound literal, you may recall, is a C99 feature that can be used
(O create an array with no name.

Consider the following example:

int *p = (int [1){3, o, 3, 4, 1},

p points to the first element of a five-element array containing the integers 3, O, 3,
4, and 1. Using a compound literal saves us the trouble of first declaring an array
variable and then making p point to the first clement of that array:

int all = {31 0, 3, 4, l};
int *p = &a[0];

Using Pointers for Array Processing

Pointer arithmetic allows us to visit the elements of an array by repeatedly incre-
menting a pointer variable. The following program fragment, which sums the ele-
ments of an array a, illustrates the technique. In this example, the pointer variable

***************************page_286***************************
Qa&A

122  Using Pointers for Array Processing 261

p initially points to a [0]. Each time through the loop, p is incremented: as a
result, it points to a [1], then a [2], and so forth. The loop terminates when p
steps past the last element of a.

#define N 10
int a[N], sum, *p;
sum = O

for (p &a[0]; p < &a[N] ; p++)
sum += *p;

|I w.

The following figures show the contents of a, sum, and p at the end of the first
three loop iterations (before p has been incremented).

prmeeeet-225

At the end of the first iteration:

 

 

 

 

 

 

 

 

 

 

 

 

”1]
[
a | 11 | 34 | B2 7 6—1'98 47 | 18 1 79 | 20
0 1 2 3 4 S ô 7 8 9
sum 11

 

 

 

At the end of the second iteration:

 

 

 

 

mjw]w[z]

 

 

 

 

 

 

 

 

 

 

 

 

gum â5
Àt the end of the third itération: 14
; à d Ç ;
a| 1l l 34 | 82 7 6+ l 98 | 47 l 18 | 79 | 20

 

 

 

0 1 2 3 4 5 6 7 B 9

 

seum 127

 

 

 

The condition p < &a [N] in the £or slatement deserves special mention.
Strange as il may seem, it’s legal to apply the address operator to a [N] , even
though this element doesn’t exist (a is indexed from O to N — 1). Using a [N] in
this fashion is perfectly safe, since the loop doesn°t attempt to examine its value.
The body of the loop will be executed with p equal to &a[0], &a[1], …
&a [N-1]. but when p is equal to &a [N] , the loop terminates.

We could just as easily have written the loop without pointers, of course, using
subscripting instead. The argument most often cited in support of pointer arithmetic
is that it can save execution time. However, that depends on the implementation—
some C compilers actually produce better code for loops that rely on subscripting.

***************************page_287***************************
262

Chapter 12 _ Pointers and Arrays

Combining the * and ++ Operators

C programmers often combine the * (indirection) and ++ operators in statements
that process array elements. Consider the simple case of storing a value into an
array eclement and then advancing to the next element. Using array subscripting,
we might write

ali++] = j;
If p is pointing to an array element, the corresponding statement would be
*p++ = J;

Because the postfix version of ++ takes precedence over *, the compiler sees this
as

* (p++) = J;

The value of p++ 1s p. (Since we’re using the postfix version of ++, p won’t be
incremented until after the expression has been evaluated.) Thus, the value of
* (p++) will be *p—the object to which p is pointing.

Of course, *p++ isn°t the only legal combination of * and ++. We could write
(*D) ++, for example, which returns the value of the object that p points to, and
then increments that object (p itself is unchanged). If you find this confusing, the
following table may help:

Expression Meaning
*p++ Or * (p++) Valuc of expression is *p before increment; increment p later
(*p)++ Value of expression is *p before increment; increment *p later
*++p or * (++p) Increment p first; valuc of expression is *p after increment
++*por ++(*p) Increment *p first: value of expression is *p after increment

All four combinations appear in programs, although some are far more common
than others. The one we’ll see most frequently is *p++, which is handy in loops.
Instead of writing

£or (p = &a[0]); p < &a[N] ; p++)
sum += *p;

to sum the elements of the array a, we could write

p = &a[0];
while (p < &a[N])
SUM += *D++;

The * and - - operators miXx in the same way as * and ++. For an application
that combines * and - -, let’s return to the stack example of Section 10.2. The orig-
inal version of the stack relied on an integer variable named top to keep track of
the “top-of-stack” position in the contents array. Let's replace top by a pointer
variable that points initially to element O of the contents array:

int *top ptr = &contents [0] ;

***************************page_288***************************
12.3

12.3  Using an Array Name as a Pointer 263

Here are the new push and pop functions (updating the other stack functions is
left as an exercise):

void push(int i)

{

if (is full())
stack over£low () ;
else
*top ptr++ = i;

int pop(void)

{
if (is empty())
stack_underflow () ;
else
return *--top ptr;

}

Note that l’ve written *--top_ptr, not *top _ ptr--, since | want pop to dec-
rement top_ptr before fetching the value to which it points.

Using an Array Name as a Pointer

Pomter arithmetic is one way in which arrays and pointers are related, but it’s not

the only connection between the two. Here’s another key relationship: The name of

an array can be used as a pointer to the first element in the array. This relationship

simplifies pointer arithmetic and makes both arrays and pointers more versatile.
For example, suppose that à is declared as follows:

int a(10];

Using a as a pointer to the first element in the array, we can modify a [0] :
*a = 7; /* stores 7 in a[o0]) */

We can modify a [1] through the pointer à + 1:

*(a+1l) = 12, /* stores 12 in a[1] */

In general, à + i 1s the same as &a [i] (both represent a pointer to element i of a)
and * (a+i) 1s equivalent to a [i] (both represent element i itself). In other
words, array subscripting can be viewed as a Fform of pointer arithmetic.

The fact that an array name can serve as a pointer makes il easier to write
loops that step through an array. Consider the following loop from Section 12.2:

for (p = &a[0]; p < &a[N] ; p++)
SUM += *p;

***************************page_289***************************
264 Chapter 12  Pointers and Arrays

idiom

/

PROGRAM

reverse3.c

To simplify the loop, we can replace &a [0] by a and &a [N] by à + N:

for (p = a; p < a + N; p++)
sum += *p;

 

Although an array name can be used as a pointer, it’s not possible to assign it a new
value. Attempting to make it point elsewhere is an error:

while (*a != O)
a++; /*** WRONG ***/

This is no great loss: we can always copy a into a pointer variable, then change the
pointer variable:

p = ài
while (*p != O)
p++;

 

Reversing a Series of Numbers (Revisited)

The reverse. c program of Section 8.1 reads 10 numbers, then writes the num-
bers in reverse order. As the program reads the numbers, it stores them in an array.
Once all the numbers are read, the program steps through the array backwards as it
prints the numbers.

The original program used subscripting to access elements of the array. Here's
a new version in which l’ve replaced subscripting with pointer arithmetic.

/* Reverses a series of numbers (pointer version) */
#include <stdio.h>
#define N 10

int main(void)

(

int a[N], *p;

printË ("Enter %d numbers: ", N);
for (p = a; p < a + N; p++)
scanf ("%*d", p);

printf ("In reverse order:") ;

for (p = a + N - 1; p >= a; p--)
printf£(" %d", *p) ;

print£("\n") ;

return 0;

In the original program, an integer variable i kept track of the current position
within the array. The new version replaces i with p, à pointer variable. The num-

***************************page_290***************************
12.3  Using an Array Name as a Pointer 265

bers are still stored in an array: we°re simply using a different technique to keep
track of where we are in the array.

Note that the second argument to scan£ 1s p, not &p. Since p points to an
array element, it’s a satisfactory argument for scanf; &p, on the other hand,
would be a pointer to a pointer to an array element.

Array Arguments (Revisited)

When passed to a function. an array name is always treated as a pointer. Consider
the following function, which returns the largest element in an array of integers:

int find _ largest (int a[], int n)

{

int i, max;

max = a[0];
for (i = 1; i < n; i++)
if (a[i] > max)
max = a[i);
return max;

}
Suppose that we call find _ largest as follows:
largest = find largest (b, N);

This call causes a pointer to the first element of b to be assigned to a: the array
itself isn’t copied.

The fact that an array argument is treated as a pointer has some important con-
sequences:

u When an ordinary variable 1s passed to a function, its value is copied; any
changes to the corresponding parameter don’t affect the variable. In contrast.
an array used as an argument isn’t protected against change, since no copy 1s
made of the array itself. For example, the following function (which we first
saw in Section 9.3) modifies an array by storing zero into each of its elements:

void store _zeros(int al[], int n)

{
int ;
for (i = 0; i < n; i++)
a[li] = O0;
}

To indicate that an array parameter won't be changed, we can include the word
const in its declaration:

int f£find largest (const int a[), int n)

{
}

***************************page_291***************************
266

Chapter 12  Pointers and Arrays

QeÀ

>

If const 1s present, the compiler will check that no assignment to an element
of a appears in the body of f£ind _ largest.

u The time required to pass an array to a function doesn’t depend on the size of
the array. Therc’s no penalty for passing a large array, since no copy of the
array 1s made.

w An array parameter can be declared as a pointer if desired. For example,
£find largest could be defined as follows:

int find _ largest (int *a, int n)

{
}

Declaring a to be a pointer 1s equivalent to declaring it to be an array; the
compiler treats the declarations as though they were identical.

 

Although declaring a parameter to be an array is the same as declaring it to be a
pointer, the same isn’t true for a variable. The declaration

int a[(10];
causes the compiler to set aside space for 10 integers. In contrast, the declaration
int *a;

causes the compiler to allocate space for a pointer variable. In the latter case, à 1s
not an array; attempting to use it as an array can have disastrous results. For exam-
ple, the assignment

*a = 0; /*** WRONG ***/

will store O where a 1s pointing. Since we don’t know where a is pointing, the
effect on the program 1s undefined.

 

 

u À function with an array parameter can be passed an array ‘“slice”—a sequence
of consecutive elements. Suppose that we want £ind_largest to locate the
largest element in some portion of an array b, say elements b [5], …. b[14].
When we call find_largest, we'll pass it the address of b [5] and the
number 10, indicating that we want find _ largest to examine 10 array
elements, starting at b [5] :

largest = find largest (&b[5], 10);

Using a Pointer as an Array Name

If we can use an array name as a pointer, will C allow us to subscript a pointer as
though it were an array name? By now, you’d probably expect the answer to be
yes, and you’d be right. Here’s an example:

***************************page_292***************************
12.4

12.4  Pointers and Multidimensional Arrays 267

#define N 10
int a[N], i, sum = O, *p = a;

for (i = 0; i < N; i++)
sum += plil;

The compiler treats p [i] as * (p+i), which 1s a perfectly legal use of pointer
arithmetic. Although the ability to subscript a pointer may seem to be little more
than a curiosity, we’Il see in Section 17.3 that it’s actually quite useful.

Pointers and Multidimensional Arrays

Just as pointers can point to elements of one-dimensional arrays. they can also
point to elements of multidimensional arrays. In this section, we’I1 explore com-
mon techniques for using pointers to process the elements of multidimensional
arrays. For simplicity, l’Il stick to two-dimensional arrays, but everything we'Il do
applies equally to higher-dimensional arrays.

Processing the Elements of a Multidimensional Array

We saw in Section 8.2 that C stores two-dimensional arrays in row-major order; in
other words, the elements of row O come first, followed by the elements of row |,
and so forth. An array with r rows would have the following appearance:

row 0 row | rowr—1

 

 

We can take advantage of this layout when working with pointers. M we make a
pointer p point to the first element in a two-dimensional array (the element in row
O, column 0), we can visit every element in the array by incrementing p repeatedly.
Às an example, let’s look at the problem of initializing all elements of a two-
dimensional array to zero. Suppose that the array has been declared as follows:

int a [NUM ROWS] [NUM COLS] ;

The obvious technique would be to use nested £or loops:
int row, col;

Éor (row = 0; row < NUM ROWS; row++)

for (col = 0; col < NUM COLS; col++)
a [row] [(co1] = 0;

***************************page_293***************************
268

Chapter 12  Pointers and Arrays

QaÂÀ

But if we view a as a one-dimensional array of integers (which 1s how 1t’s stored).
we can replace the pair of loops by a single loop:

int *p;

for (p
*p —

&a[0] [0] ; p <= &a [NUM ROWS-1] [NUM COLS-1] ; p++)

!

Ol

The loop begins with p pointing to a [0] [0]. Successive increments of p make
it point to a[0] [1]. a[0] [2]. a[0] [3], and so on. When p reaches
a [0] [NUM COLS-1] (the last element in row O), incrementing it again makes
p point to a [1] [0], the first element in row !. The process continues until p
goes past a [NUM ROWS-1] [NUM _ COLS-1]. the last element in the array.

Although treating a two-dimensional array as one-dimensional may seem like
cheating, it works with most C compilers. Whether it’s a good idea to do so is
another matter. Techniques like this one definitely hurt program readability, but—
at least with some older compilers—produce a compensating iIncrease in effi-
ciency. With many modern compilers, though, there’s often little or no speed
advantage.

Processing the Rows of a Multidimensional Array

What about processing the elements in just one row of a two-dimensional array?
Again, we have the option of using a pointer variable p. To visit the elements of
row i, we'd'initialize p Lo point to element 0 in row i in the array a:

p = &al[i] [0] ;
Or we could simply write
p = alil;

since, for any two-dimensional array a, the expression a [i] is a pointer to the
first element in row i. To see why this works, recall the magic formula that relates
array subscripting to pointer arithmetic: for any array a, the expression a [i] is
equivalent to * (à + i). Thus, &a [i] [0] is the same as &(* (a[i] + O)).
which 1s equivalent to &*a [i], which is the same as a [i]. since the & and *
operators cancel. We'1l use this simplification in the following loop, which clears
row i of the array a:

int a [NUM ROWS] [NUM COLS], *p, i;

a[i]; p < ali] + NUM COLS; p++)

Since a [i] 1s a pointer to row i of the array a, we can pass a [i] toa
function that’s expecting a one-dimensional array as its argument. In other words,
a function that’s designed to work with one-dimensional arrays will also work
with a row belonging to a two-dimensional array. Às a result. functions such as

***************************page_294***************************
124  Pointers and Multidimensional Arrays 269

find largest and store _zeros are more versatile than you might expect.
Consider find_largest, which we originally designed to find the largest ele-
ment of a one-dimensional array. We can just as easily use find_largest to
determine the largest element in row i of the two-dimensional array a:

largest = find largest (a[i], NUM COLS) ;

Processing the Columns of a Multidimensional Array

Processing the elements in a column of a two-dimensional array isn’t as easy,
because arrays are stored by row, not by column. Here’s a loop that clears column
i of the array a:

int a [NUM ROWS] [NUM_COLS] , (*p) [NUM COLS], i;

Eor (p = &a[0]; p < &a [NUM ROWS] ; p++)
(*p) [i] = 0;

l've declared p to be à pointer to an array of length NUM_COLS whose elements
are integers. The parentheses around *p in (*p) [NUM COLS] are required;
without them, the compiler would treat p as an array of pointers instead of a
pointer to an array. The expression p++ advances p to the beginning of the next
row. In the expression (*p) [i], *p represents an entire row of a, so (*p) [i]
selects the element in column i of that row. The parentheses in (*p) [i] are
essential, because the compiler would interpret *p [i] as * (p[il).

Using the Name of a Multidimensional Array as a Pointer

Just as the name of a one-dimensional array can be used as a pointer, so can the
name of any array, regardless of how many dimensions it has. Some care is
required, though. Consider the following array:

int a[NUM ROWS] [NUM _ COLS] ;

a is not à pointer to a [0] [0] ; instead, it’s a pointer to a [0] . This makes more
sense if we look at it from the standpoint of C, which regards a not as a two-
dimensional array but as a one-dimensional array whose elements are one-
dimensional arrays. When used as a pointer, à has type int (*) [NUM COLS)]
(pointer to an integer array of length NUM_COLS).

Knowing that a points to a [0] is useful for simplifying loops that process the
elements of à two-dimensional array. For example, instead of writing

for (p = &al[0]; p < &a [NUM ROWS] ; p++)
(*p) [i] = 0;

to clear column i of the array a, we can write

for (p = a; p < a + NUM ROWS; p++)
(*p) [i] = 0;

***************************page_295***************************
2170

Chapter 12  Pointers and Arrays

eF3 1

12.5

variable-length arrays > 8.3

Another situation in which this knowledge comes in handy is when we want
to “trick” a function into thinking that a multidimensional array is really one-
dimensional. For example, consider how we might use find_largest to find
the largest element in a. As the first argument to find largest, let’s try
passing a (the address of the array); as the second, we’ll pass NUM ROWS *
NUM_COLS (the total number of elements in a):

largest = find largest (a, NUM ROWS * NUM COLS) ; /* WRONG */

Unfortunately, the compiler will object to this statement, because the type of a is
int (#) [NUM COLS] but £ind largest is expecting an argument of type
int *. The correct call 1s

largest = find _ largest (a[0], NUM ROWS * NUM COLS) ;

a [0] points to element 0 in row O, and it has type int * (after conversion by the
compiler), so the latter call will work correctly.

Pointers and Variable-Length Arrays (C99)

Pointers are allowed to point to elements of variable-length arrays (VLAs), a fea-
ture of C99. An ordinary pointer variable would be used to point to an element of à
one-dimensional VLA:

void f (int n)

{

int a[n], *p;
p =a;

When the VLA has more than one dimension, the type of the pointer de-
pends on the length of each dimension except for the first. Let’s look at the two-
dimensional case:

void f(int m, int n)

{

int a(m] ([n], (*p) [n] ;
p = a;

}

Since the type of p depends on n, which isn’t constant, p is said to have a variably
modified type. Note that the validity of an assignment such as p = a can’t always
be determined by the compiler. For example, the following code will compile but is
correct only if m and n are equal:

int a[m] [n], (*p) [m] ;
p = a;

***************************page_296***************************
e

Q & À 271

If m# n. any subsequent use of p will cause undefined bchavior.

Variably modified types are subject to certain restrictions, just as variable-
leneth arrays are. The most important restriction is that the declaration of a vari-
ably modified type must be inside the body of a function or in a function proto-
type.

Pointer arithmetic works with VLAs just as it does for ordinary arrays.
Returning to the example of Section 12.4 that clears a single column of a Lwo-
dimensional array a, let's declare à as a VLA this time:

int a[m] [n] ;
À pointer capable of pointing to a row of a would be declared as follows:
int (*p) [n] ;

The loop that clears column i is almost identical to the one we used in Section
12.4:

£or (p à ;
(*p) [i] =

p < a-+m; p++)
0 ;

Q & À

[ don’t understand pointer arithmetic. If a pointer is an address, does that
mean that an expression like p + j adds j to the address stored in p? [p. 255]

No. Integers used in pointer arithmetic are scaled depending on the type of the
pointer, If p is of type int *, for example, then p + j Lypically adds 4 X j Lo p,
assuming that int values are stored using 4 bytes. But if p has type double *,
then p + j will probably add 8 x ; to p, since double values are usually & bytes
long.

When writing a loop to process an array, is it better to use array subscripting
or pointer arithmetic? [p. 261]

There’s no easy answer to this question, since it depends on the machine you're
using and the compiler itself. In the early days of C on the PDP-11, pointer arith-
metic yielded a faster program. On today's machines, using today's compilers,
array subscripting is often just as good, and sometimes even better. The bottom
line: Learn both ways and then use whichever is more natural for the kind of pro-
gram you're writing.

I read somewhere that i [a] is the same as a [i]. Is this true?

Yes, it is, oddly enough. The compiler treats i [a] as * (i + a), which is the same
as * (a + i). (Pointer addition, like ordinary addition, is commutative.) But
* (a + i) is equivalent to a [i]. Q.E.D. But please don’t use i [a] in programs
unless you're planning to enter the next Obfuscated C contest.

***************************page_297***************************
272

Chapter 12  Pointers and Arrays

Q:
À:

>.

Why is *a the same as a [] in a parameter declaration? [p. 266]

Both indicate that the argument is expected to be a pointer. The same operations on
a are possible in both cases (pointer arithmetic and array subscripting, in particu-
lar). And, in both cases, à itself can be assigned a new value within the function.
(Although C allows us to use the name of an array variable only as a “constant
pointer,” there’s no such restriction on the name of an array parameter.)

Is it better style to declare an array parameter as *a or a [] ?

That’s a tough one. From one standpoint. à [] is the obvious choice, since *a is
ambiguous (does the function want an array of objects or a pointer to a single
object?). On the other hand, many programmers argue that declaring the parameter
as *a is more accurate, since it reminds us that only a pointer is passed, not a copy
of the array. Others switch betwcen *a and a [] . depending on whether the func-
tilon uses pointer arithmetic or subscripting to access the elements of the array.
(That’s the approach l’Il use.) In practice, *a is more common than a [] . so you’d
better get used to it. For what it’s worth, Dennis Ritchie now refers to the a []
notation as “a living fossil” that “serves as much to confuse the learner as to alert
the reader.”

We”ve seen that arrays and pointers are closely related in C. Would it be accu-
rate to say that they’re interchangeable?

No. It's true that array parameters are interchangeable with pointer parameters, but
array variables aren’t the same as pointer variables. Technically. the name of an
array isn’t à pointer; rather, the C compiler converts it to a pointer when necessary.
To see this difference more clearly, consider what happens when we apply the
sizeof operalor to an array a. The value of sizeof (a) is the total number of
bytes in the array—the size of each element multiplied by the number of elements.
But if p is à pointer variable, sizeoëË (p) is the number of bytes required to store
a pointer value.

You said that treating a two-dimensional array as one-dimensional works
with ‘‘“most’”’ C compilers. Doesn*1 it work with all compilers? [p. 268]

No. Some modern “bounds-checking” compilers track not only the type of a
pointer, but—when it points to an array—also the length of the array. For example,
suppose that p is assigned a pointer to a [0] [0]. Technically, p points to the first
clement of a [0], a one-dimensional array. lf we increment p repeatedly in an
effort lo visit all the elements of a, we'I! go out of bounds once p goes past the last
element of a [0]. À compiler that performs bounds-checking may insert code to
check that p is used only to access elements in the array pointed to by a [0] : an
attempt to increment p past the end of this array would be detected as an error.

 

If a is a two-dimensional array, why can we pass a [0] —but not a itself—to
find_largest? Don°t both a and a [0] point to the same place (the begin-
ning of the array)? [p. 270]

They do, as a matter of fact—both point to element a [0] [0]. The problem is that

***************************page_298***************************
Section 12.1

Section 12.2

Section 12.3

l

3.

5.

Exercises 2173

a has the wrong type. When used as an argument, it’s a pointer to an array, but
find largest is expecting a pointer to an integer. However, a [0] has type
int *, so il’s an acceptable argument for £ind_largest. This concern about
types is actually good: if C weren*t so picky, we could make all kinds of horrible
pointer mistakes without the compiler noticing.

Exercises

Suppose that the following declarations are in effect:

int a[] = {5, 15, 34, 54, 14, 2, 52, 72};
int *p = &a[1], *q = &a[5];

(a) Whalt is the value of * (p+3) ?

(b) What is the value of * (g-3) ?

(c) What is the value of q - p?

(d) 1s the condition p < q true or false?
(e) Is the condition *p < *q true or false?

Suppose that high. 1low, and middle are all pointer variables of the same type, and that
low and high point to elements of an array. Why is the following statement illegal, and
how could it be fixed?

middle = (low + high) / 2:;

What will be the contents of the à array after the following statements are exccuted?

#define N 10

int a[N] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int *p = &a[0], *q = &a[N-1], temp;

while (p < q) (

temp = *p;
*p++ = *G;
*q-- = temp;

Rewrite the make_empty, is_empty. and is_f£ull functions of Section 10.2 to use the
pointer variable top_ptr instead of the integer variable top.

Suppose that à is a onc-dimensional array and p is a pointer variable. Assuming that the
assignment p = a has just been performed. which of the following expressions are illegal
because of mismatched types? Of the remaining expressions, which are true (have à nonzero
value)?

(a) p == a[o]
(b) p == &a[0]
(c) *p == alo]
(d) p[0] == a[o]

Rewrite the following function to use pointer arithmetic instead of array subscripting. (In
other words, eliminate the variable i and all uses of the [] operator.) Make as few changes
as possible.

***************************page_299***************************
274 Chapter 12  Pointers and Arrays

10.

}.

12.

Section 12.4 @ 13.

int sum _ array(const int a[], int n)

(

int i, sum;

sum = O0;
for (i = 0; i < n; i++)
sum += a[i];

return sum;

}

Write the following function:
bool search(const int a[], int n, int key);

à is an array to be searched, n is the number of elements in the array, and key is the search
key. search should return true if key matches some element of a. and false if it
doesn’t. Use pointer arithmetic—not subscriptinge—to visit array elements.

Rewrite the following function to use pointer arithmetic instead of array subscripting. (In
other words, eliminate the variable i and all uses of the [] operator.) Make as few chanees
as possible.

void store zeros(int a[], int n)

{

int i;

H
O
H.
A
D
H-
+
+

for (i
a[li] = O0;

}

Write the following function:

double inner product (const double #a, const double *b,
int n);

a and b both point to arrays of length n. The function should return a [0] * b[0] +
a[1] * b[1] + … + a[n-1] # b[n-1]. Use pointer arithmetic—not subscripting—to
visit array clements.

Modify the £ind_middle function of Section 11.5 so that it uses pointer arithmetic to
calculate the return value.

Modify the find_largest function so that it uses pointer arithmetic—not subscript-
Ing—Hlo visit array clements.

Write the following function:

void find _ two largest (const int *a, int n, int *largest,
int *second largest) ;

à points to an array of length n. The function searches the array for its largest and second-
largest elements, storing them in the variables pointed to by largest and
second_largest, respectively. Use pointer arithmetic—not subseripting—to visit array
elements.

Section 8.2 had a program fragment in which two nested £or loops initialized the array
ident for use as an identity matrix. Rewrite this code, using a single pointer to step
through the array one element at a time. Hint: Since we won't be using row and col index
varlables, it won't be easy to tell where to store I. Instead. we can use the fact that the first
element of the array should be !. the next N elements should be O, the next element should

***************************page_300***************************
l4.

17.

|8.

Programming Projects 275

be !. and so forth. Use a variable to keep track of how many consecutive Os have been
stored: when the count reaches N, it’s time to storc |.

Assume that the following array contains à wcek's worth of hourly temperature readings,
with cach row containing the readings for one day:

int temperatures [7] [24] ;

Write a statement that uses the search function (see Exercise 7) to search the entire
temperatures array for the value 32.

Write a loop that prints all temperature readings stored in row i of the temperatures
array (see Exercise 14). Usc à pointer to visit each element of the row.

Write a loop that prints the highest temperature in the temperatures array (see Exercise
14) for each day of the week. The loop body should call the £ind_largest function,
passing it one row of the array at a time.

Rewrite the following function to use pointer arithmetic instead of array subscripting. (In
other words. eliminate the variables i and ÿ and all uses of the [] operator.) Use a single
loop instead of nested loops.

int sum two _ dimensional array(const int a[] (LEN], int n)

{

int i, j, sum = O0;

for (i = O0; i < n; i++)
for (j = 0; j < LEN; j++)
sum += al[il (5)] ;

return sum;

}

Write the evaluate position function described in Exercise 13 of Chapter 9. Use
pointer arithmetic—not subscripling—to visit array elements. Use a single loop instead of
nested loops.

Programming Projects

(a) Write a program that reads a message, then prints the reversal of the message:

Enter a message: Don't get mad, get even.
Reversal is: .neve teg ,dam teg t'noD

 

Hint: Read the message one character at a time (using getchar) and store the characters in
an array. Stop reading when the array is full or the character read is " \n'.

(b) Revise the program to use a pointer instead of an integer to keep track of the current
position in the array.
(a) Write à program that reads a message. then checks whether it’s a palindrome (the letters

in the message are the same from left to right as from right to left):

Enter a message: He lived as a devil, eh?
Palindrome

 

Enter a message: Madam, I am Adam.
Not a palindrome

 

***************************page_301***************************
216

Chapter 12  Pointers and Arrays

_Ul

Ignorc all characters that aren’t letters. Use integer variables to keep track of positions in the
array.

(b) Revise the program to use pointers instead of integers to kcep track of positions in the
array.

Simplify Programming Project 1(b) by taking advantage of the fact that an array name can
be used as a pointer.

Simplify Programming Project 2(b) by taking advantage of the fact that an airay name can
be used as a pointer.

Modify Programming Project 14 from Chapter 8 so that it uses a pointer instead of an inte-
ger to keep track of the current position in the array that contains the sentence.

Modify the gsort . c program of Section 9.6 so that 1ow, high, and middle are pointers
lo array clements rather than integers. The split function will need to return a pointer. not
an integer.

Modify the maxmin.c program of Section 11.4 so that the max_min function uses a
pointer instead of an integer to keep track of the current position in the array.

***************************page_302***************************
13

13.1

Strings

It's difficult to extract sense from strings, but
they're the only communication coin we can count on.

Although we've used char variables and arrays of char values in previous chap-
ters, we still lack any convenient way to process a series of characters (a string, In
C terminology). We’Il remedy that defect in this chapter, which covers both string
constants (or literals, as they're called in the C standard) and string variables,
which can change during the execution of a program.

Section 13.1 explains the rules that govern string literals. including the rules
for embedding escape sequences in string literals and for breaking long string liter-
als. Section 13.2 then shows how to declare string variables, which are simply
arrays of characters in which a special character—the null character—marks the
end of a string. Section 13.3 describes ways to read and write strings. Section 13.4
shows how to write functions that process strings, and Section 13.5 covers some of
the string-handling functions in the C library. Section 13.6 presents idioms that are
often used when working with strings. Finally. Section 13.7 describes how to set
up arrays whose elements are pointers to strings of different lengths. This section
also explains how C uses such an array to supply command-line information to
programs.

String Literals

A string literal is a sequence of characters enclosed within double quotes:
"When you come to a fork in the road, take it."

We first encountered string literals in Chapter 2; they often appear as format
strings in calls of print£ and scanf£.

217

***************************page_303***************************
218

Chapter 13  Strings

escape sequences » 7.3

Escape Sequences in String Literals

String literals may contain the same escape sequences as character constants.
We've used character escapes in print£ and scanf format strings for some
time. For example, we’ve seen that each \n character in the string

"Candy\nIs dandy\nBut liquor\nIs quicker.\n --Ogden Nash\n"
causes the cursor to advance to the next line:

Candy

Is dandy

But liquor

Is quicker.
--Ogden Nash

Although octal and hexadecimal escapes are also legal in string literals, they*re not
às common as character escapes.

 

Be careful when using actal and hexadecimal escape sequences in string literals.
An octal escape ends after three digits or with the first non-octal character. For
example, the string "\1234" contains two characters (\123 and 4), and the
string "\189" contains three characters (\1, 8, and 9). A hexadecimal escape, on
the other hand, isn°t limited to three digits; it doesn't end until the first non-hex
character. Consider what happens if a string contains the escape \x£fc. which rep-
resents the character ÿ in the Latin! character set, a common extension of ASCH.
The string "Z\xfcrich" (“Zürich”) has six characters (Z. \x£c, r, i, c, and
h), but the string "\xfcber" (a failed attempt at “über”) has only two (\xfcbe
and r). Most compilers will object to the latter string, since hex escapes are usually
limited to the range \x0—\x£f.

 

Continuing a String Literal

I{ we find that a string literal is too long to fit conveniently on a single line, C
allows us to continue it on the next line, provided that we end the first line with a
backslash character (\). No other characters may follow \ on the same line, other
than the (invisible) new-line character at the end:

print£ ("When you come to a fork in the road, take it. \
--Yogi Berra") ;

In general, the \ character can be used to join two or more lines of à program into
à single line (a process that the C standard refers to as “splicing”). We*Il see more
examples of splicing in Section 14.3.

The \ technique has one drawback: the string must continue at the beginning
of the next line. thereby wrecking the program’s indented structure. There’s a bet-
ler way to deal with long string literals, thanks to the following rule: when two or
more string literals are adjacent (separated only by white space), the compiler will

***************************page_304***************************
13.1  String Literals 279

join them into a single string. This rule allows us to split a string literal over two or
more lines:

printf ("When you come to a fork in the road, take it. "
"--Yogi Berra") ;

How String Literals Are Stored

We've used string literals often in calls of print£ and scan£. But when we call
print£ and supply a string literal as an argument, what are we actually passing?
To answer this question, we need to know how string literals are stored.

In essence, C treats string literals as character arrays. When a C compliler
encounters à string literal of length n in a program, it sets aside n + 1 bytes of
memory for the string. This area of memory will contain the characters in the
string, plus one extra character—the null character—to mark the end of the string.
The null character is a byte whose bits are all zero, so it’s represented by the \ 0
escape sequence.

 

Don*t confuse the null character (" \0 " ) with the zero character (* O" ). The null
character has the code 0; the zero character has a different code (48 in ASCID.

 

For example, the string literal "abc" is stored as an array of four characters
(a, b, c, and \ 0):

 

Strine literals may be empty: the string " " is stored as a single null character:
& - > &

|
Since a string literal is stored as an array, the compiler treats it as a pointer of

type char *. Both print£ and scan£. for example. expect a value of type
char * as their first argument. Consider the following example:

print£ ("abc") ;

When printF is called, it’s passed the address of "albc" (a pointer to where the
letter a is stored in memory).

Operations on String Literals

In general, we can use a string literal wherever C allows a char * pointer. For
example, à string literal can appear on the right side of an assignment:

***************************page_305***************************
280

Chapter 13  Strings

QaÂ

char *p;
p = "abc",;

This assignment doesn’t copy the characters in "abc": it merely makes p point to
the first character of the string.
Ç allows pointers to be subscripted, so we can subscript string literals:

char ch;
ch = "abc" [1] ;

The new value of ch will be the letter b. The other possible subscripts are O (which
would select the letter a), 2 (the letter c). and 3 (the null character). This property
of string literals isn°t used that much, but occasionally it's handy. Consider the fol-
lowing function, which converts a number between O and 15 into a character that
represents the equivalent hex digit:

char digit _ to hex char(int digit)

{
}

return "0123456789ABCDEF" [digit] ;

 

Attempting to modify à string literal causes undefined behavior:
char *p = "abc";
*p = 'd'; /*** WRONG **>*/

À program that tries to change à string literal may crash or behave erratically.

 

String Literals versus Character Constants

À string literal containing a single character isn’t the same as a character constant.
The string literal "a" is represented by a pointer to a memory location that con-
tarns the character a (followed by à null character). The character constant 'a' is
represented by an integer (the numerical code for the character).

 

Don't ever use à character when a string is required (or vice versa). The call
printf ("\n") ;

is legal, because print£ expects a pointer as its first argument. The followins
call isn’t legal, however:

printf('\n'); - /##** WRONG *+#x/

 

***************************page_306***************************
13.2

idiom

13.2  String Variables 281

String Variables

Some programming languages provide a special string type for declaring string
variables. C takes a different tack: any one-dimensional array of characters can be
used to store a string, with the understanding that the string is terminated by à null
character. This approach is simple. but has significant difficulties. It’s sometimes
hard to tell whether an array of characters is being used as a string. lf we write our
own string-handling functions, we’ve got to be careful that they deal properly with
the null character. Also, there’s no faster way to determine the length of a string
than a character-by-character search for the null character.

Let’s say that we need a variable capable of storing a string of up to 80 charac-
ters. Since the string will need à null character at the end, we’Il declare the variable
to be an array of 81 characters:

#define STR LEN 80
char str[STR LEN+1] ;

We defined STR_LEN to be 80 rather than 81. thus emphasizing the fact that str
can store strings of no more than $0 characters. and then added | to STR_LEN in
the declaration of str. This a common practice among C programmers.

 

When declaring an array of characters that will be used to hold à string, always
make the array one character longer than the string, because of the C convention
that every string is terminated by a null character. Failing to leave room for the nutl
character may cause unpredictable results when the program is executed, since
functions in the C library assume that strings are null-terminated.

 

Declaring a character array to have length STR_LEN + | doesn’t mean that it
will always contain a string of STR _LEN characters. The length of a string
depends on the position of the terminating null character, not on the length of the
array in which the string is stored. An array of STR _LEN + | characters can hold
strings of various lengths, ranging from the empty string to strings of length
STR LEN.

Initializing a String Variable
À string variable can be initialized at the same time it’s declared:

char datel[8] = "June 14";

***************************page_307***************************
282

Chapter 13  Strings

array initializers > 8. ?

The compiler will put the characters from "June 14" in the datel array, then
add a null character so that datel can be used as a string. Here’s what date1
will look like:

 

Although "June 14" appears to be a string literal, it’s not. Instead, C views it as
an abbreviation for an array initializer. In fact, we could have written

char dât€l[8] — {‘J|, nu|' 'D', '€', ! I, '1", |4|' r\on};

1 think you’Il agree that the original version is casier to read.
What 1f the initializer is too short to fill the string variable? In that case, the
compiler adds extra null characters. Thus, after the declaration

char date2[9] = "June 14",;

date2 will have the following appearance:

date2

 

This behavior is consistent with C’s treatment of array initializers in general. When
an array initializer is shorter than the array itself, the remaining elements are ini-
tialized to zero. By initializing the leftover elements of à character array to \ O, the
compiler is followmng the same rule.

What if the initializer is longer than the string variable? That’s illegal for
strings. just as it’s illegal for other arrays. However, C does allow the initializer
(not counting the null character) to have exactly the same length as the variable:

char date3[7] = "June 14";

There’s no room for the null character. so the compiler makes no attempt to store
one:

date3

 

 

If you're planning to initialize a character array to contain a string, be sure that the
length of the array is longer than the length of the initializer. Otherwise, the com-
piler will quietly omit the null character, making the array unusable as a string.

 

The declaration of à string variable may omit its length, in which case the
compiler computes it:

char date4 [] = "June 14";

***************************page_308***************************
dynamically allocated strings » 77.2

13.2  String Variables 283

The compiler sets aside eight characters for date4, enough to store the characters
in "June 14" plus à null character. (The fact that the length of date4 isn’t spec-
ified doesn’t mean that the array*s length can be changed later. Once the program
is compiled, the length of date4 is fixed at eieht.) Omitting the length of a string
variable is especially useful if the initializer 1s long, since computing the length by
hand is error-prone.

Character Arrays versus Character Pointers
Let’s compare the declaration

char date[] = "June 14";

which declares date to be an array, with the similar-looking
char *date = "June 14";

which declares date to be a pointer. Thanks to the close relationship between
arrays and pointers, we can use either version of date as a string. In particular,
any function expecting to be passed a character array or character pointer will
accept either version of date as an argument.

However. we must be careful not to make the mistake of thinking that the two
versions of date are interchangcable. There are significant differences bctween
the two:

m In the array version, the characters stored in date can be modified, like the
elements of any array. In the pointer version, date points to a string literal,
and we saw in Section 13.!1 that string literals shouldn’t be modified.

u In the array version, date is an array name. In the pointer version, date 1s a
variable that can be made to point to other strings during program execution.

If we need a string that can be modified, it’s our responsibility to set up an
array of characters in which to store the string; declaring a pointer variable isn°l
cnough. The declaration

char *p;

causes the compiler to set aside enough memory for a pointer variable; unfortu-
nately, it doesn*t allocate space for a string. (And how could it? We haven’t indi-
cated how long the string would be.) Before we can use p as a string, it must point
to an array of characters. One possibility is to make p point to à string variable:

char str[STR LEN+1], *p;
p = str;

p now points to the first character of str. so we can use p as a string. Another
possibility is to make p point to a dynamically allocated string.

***************************page_309***************************
284

Chapter 13  Strings

/

13.3

 

Using an uninitialized pointer variable as a string is a serious error. Consider the
lollowing example, which attempts to build the string "abc":

char *p;

p[0] = 'a'; /*** WRONG ***/
p[1] = 'b'; /*** NRONG *+**/
p[2] = 'e'; /*** WRONG ***/
p[3] = '\o0'; /*** WRONG *+**/

Since p hasn’t been initialized, we don’t know where it’s pointing. Using the
pointer to write the characters a, b, c, and \0O into memory causes undefined
behavior.

 

Reading and Writing Strings

Writing à string is easy using either the print£ or puts functions. Reading a
string is à bit harder, primarily because of the possibility that the input string may
be longer than the string variable into which it’s being stored. To read a string in a
single step, we can use either scan£ or gets. As an alternative, we can read
strings one character at a time.

Writing Strings Using print£ and puts

The %s conversion specification allows print£ to write a string. Consider the
following example:

char str[] = "Are we having fun yet?";

print£f("%s\n"', str),;
The output will be
Are we having fun yet?

print£ writes the characters in a string one by one until it encounters a null char-
acter. (If the null character is missing, print£ continues past the end of the string
until—eventually—it finds a null character somewhere in memory.)

To print just part of a string, we can use the conversion specification
where p is the number of characters to be displayed. The statement

O

$ .ps,

print£("%.6s\n", str) ;
will print

Are we

***************************page_310***************************
whilte-space characters » 3.2

13.3  Reading and Writing Strings 285

A strins, like a number, can be printed within a field. The $/ns conversion will
display a string in a field of size m. (A string with more than m characters will be
printed in full, not truncated.) If the string has fewer than mm characters, it will be
right-justified within the field. To force left justification instead, we can put a
minus sign in front of m. The n and p values can be used in combination: a conver-
sion specification of the form %,n .ps causes the first » characters of a string to be
displayed in a field of size m.

printf£ isn’t the only function that can write strings. The C library also pro-
vides puts, which 1s used in the following way:

puts (str) ;

puts has only one argument (the string to be printed). After writing the string,
puts always writes an additional new-line character, thus advancing to the begin-
ning of the next output line.

Reading Strings Using scan£ and gets

The %s conversion specification allows scan£ to read a string into a character
array:

scanf ("%s", str) ;

There’s no need to put the & operator in front of str in the call of scan£: like any
array name, str 1s treated as a pointer when passed to a function.

When scanf£ 1s called, it skips white space, then reads characters and stores
them in str until it encounters a white-space character. scan£ always stores a
null character at the end of the string.

À string read using scanf will never contain white space. Consequently,
scanf won’t usually read a full line of input; a new-line character will cause
scanf to stop reading, but so will a space or tab character. To read an entire line
of input at a time, we can use gets. Like scanf, the gets function reads input
characters into an array, then stores a null character. In other respects, however,
gets is somewhat different from scan£:

= gets doesn’t skip white space before starting to read the string (scan£
does).

u gets reads until it finds à new-line character (scan£ stops at any white-
space character). Incidentally, gets discards the new-line character instead of
storing it in the array; the null character takes its place.

To see the difference between scan£ and gets. consider the following pro-
gram f[ragment:

char sentence [SENT LEN+1] ;

print£ ("Enter a sentence:\n") ;
scanf ("%s", sentence) ;

***************************page_311***************************
286

Chapter 13  Strings

AN

Égets function » 22.5

Suppose thal after the prompt
Enter a sentence :
the user enters the line
To C, or not to C: that is the question.

scan£ vwill store the string "To" in sentence. The next call of scanf will
resume reading the line at the space after the word To.
Now suppose that we replace scanf by gets:

gets (sentence) ;
When the user enters the same input as before, gets will store the string
K To C, or not to C: that is the question. "

In sentence.

 

Âs they read characters into an array, scanf and gets have no way to detect
when it’s full. Consequently, they may store characters past the end of the array.
causing undefined behavior. scanf can bc made safer by using the conversion
specification %ns instead of %s, where n is an integer indicating the maximum
number of characters to be stored. gets, unfortunately, is inherently unsafe:
fÊgets is a much better alternative,

 

Reading Strings Character by Character

Since both scanf and gets are risky and insufficiently flexible for many appli-
cations, C programmers often write their own input functions. By reading strines
one character at a time, these functions provide a greater degree of control than the
standard input functions.

IF we decide to design our own input function, we’!! need to consider the fol-
lowing issues:

#s Should the function skip white space before beginning to store the string?

=s What character causes the function to stop reading: a new-line character, any
white-space character, or some other character? Is this character stored in the
string or discarded?

u What should the function do 1f the input string is too long to store: discard the
extra characters or leave them for the next input operation?

Suppose we need a function that doesn’t skip white-space characters. stops
reading at the first new-line character (which isn’t stored in the string), and dis-
cards extra characters. The function might have the following prototype:

int read _line(char str[], int n);

***************************page_312***************************
getchar function » 7.3

Q&ÂÀ

13.4

13.4  Accessing the Characters ina String — 287

str represents the array into which we'1l store the input, and n 1s the maximum
number of characters to be read. If the input line contains more than n characters,
read _line will discard the additional characters. We'll have read_line
return the number of characters it actually stores in str (a number anywhere from
0 to n). We may not always need read_line's return value, but it doesn’t hurt to
have it available.

read_line consists primarily of à loop that calls getchar to read a char-
acter and then stores the character in str. provided that there’s room left. The loop
terminates when the new-line character is read. (Strictly speaking, we should also
have the loop terminate if getchar should fail to read a character, but we’ll
ignore that complication for now.) Here's the complete definition of read_line:

int read line(char str{(], int n)

{
int ch, i = O0;
while ((ch = getchar()) != '\n')
if (i < n)
str[i++] = ch;
str[i] = '\0'; /* terminates string */
return i; /* number of characters stored */

}

Note that ch has int type rather than char type, because getchar returns the
character that it reads as an int value.

Before returning, read _ line puts a null character at the end of the string.
Standard functions such as scanf and gets automatically put a null character at
the end of an input string; if we're writing our own input function, however, we
must take on that responsibility.

Accessing the Characters in a String

Since strings are stored as arrays, we can use subscripting to access the characters
in a string. To process every character in a string s, for example, we can set up a
loop that increments a counter i and selects characters via the expression s [i ] .

Suppose thal we need a function that counts the number of spaces in a string.
Using array subscripting, we might write the function in the following way:

int count spaces(const char s[])

{

int count = O, i;
for (i = O; s[i] != '"\O'; i++)
i£f (s[i] == ‘ ‘)
count++;

return count;

}

***************************page_313***************************
288

Chapter 13  Strings

l’ve included const in the declaration of s to indicate that count spaces
doesn't change the array that s represents. If s were not a string, the function
would need a second argument specifying the length of the array. Since s is a
string, however, count spaces can determine where it ends by testing for the
null character.

Many C programmers wouldn’t write count spaces as we have. Instead,
they'd use a pointer to keep track of the current position within the string. As we
saw in Section 12.2, this technique 1s always available for processing arrays, but it
proves to be especially convenient for working with strines.

Let’s rewrite the count _spaces function using pointer arithmetie instead
of array subscripting. We’Il eliminate the variable i and use s itself to keep track
of our position in the string. By incrementing s repeatedly, count spaces can
step through each character in the string. Here’s our new version of the function:

int count spaces (const char *s)

int count = O0;
for (; *s != '\O'; sS++)
if (*s == " ")
count++;
return count;

Note that const doesn t prevent count spaces from modifying s; it’s there to
prevent the function from modifying what s points to. And since s is a copy of the
pointer that’s passed to count spaces, incrementing s doesn’t affect the origi-
nal pointer.

The count _spaces example raises some questions about how to write
string functions:

m /s it better to use array operations or pointer operations to access the char-
acters in a string? We're free to use whichever is more convenient: we can
even mix the two. In the second version of count spaces. treating s as à
pointer simplifies the function slightly by removing the need for the variable
i. Traditionally, C programmers lean toward using pointer operations for pro-
Cessing strings.

# Should a string parameter be declared as an array or as a pointer? The two
versions of count_spaces illustrate the options: the first version declares s
to be an array; the second declares s to be a pointer. Actually, there’s no dif-
ference between the two declarations—recall from Section 12.3 that the com-
piler treats an array parameter as though it had been declared as a pointer.

m Docs the form of the parameter (s [] or *s) affect what can be supplied as
an argument? No. When count _spaces is called, the argument could be
an array name, a pointer variable, or a string litera—count _spaces can't
tell the difference.

***************************page_314***************************
13.5

<string.h>header »23.6

13.5  Using the C String Library — 289

Using the C String Library

Some programming languages provide operators that can copy strings, compare
strings, concatenate strings, select substrings, and the like. C’s operators. in con-
trast. are essentially useless for working with strings. Strings are treated as arrays
in C. so they're restricted in the same ways as arrays—in particular, they can’t be
copied or compared using operators.

 

Direct attempts to copy or compare strings will fail. For example, suppose that
str1 and str2 have been declared as follows:

char str1(10], str2[10] ;
Copying a string into a character array using the = operator 1s not possible:

stril = "abc"; /*** WRONG ***/
str2 = str]l; /*** WRONG ***/

We saw in Section 12.3 that usins an array name as the left operand of = 1s illegal.
D &
Initializing à character array using = 1s legal, though:

char str1[(10] = "abc";

In the context of a declaration, = 1s not the assignment operator.
Attempting to compare strings using a relational or equality operator 1s legal
but won’t produce the desired result:

if (stril == str2) … /*** WRONG ***/

This statement compares str1 and str2 as pointers; it doesn't compare the con-
tents of the two arrays. Since str1 and str2 have different addresses. the
expression str1 == str2 must have the value 0.

 

Fortunately, all is not lost: the C library provides a rich set of functions for
performing operations on strings. Prototypes for these functions reside in the
<string.h> header, so programs that need string operations should contain the
following line:

#include <string.h>

Most of the functions declared in <string. h> require at least one string as
an argument. String parameters are declared to have type char *, allowing the
argument to be a character array, à variable of type char *, or a string literal—all
are suitable as strings. Watch out for string parameters that aren’t declared const,
however. Such a parameter may be modified when the function is called, so the
corresponding argument shouldn’t be a string literal.

 

***************************page_315***************************
290

Chapter 13  Strings

/

strncpy lunction »>23.6

There are many functions in <string.h>; l'Il cover a few of the most basic.

In subsequent examples, assume that str1 and str2 are character arrays used as
strings.

The strcpy (String Copy) Function
The strcopy function has the following prototype in <string.h>:
char *strcpy (char *s1, const char *s2);

strcpy copies the string s2 into the string s1. (To be precise, we should say
“strcpy copies the string pointed to by s2 into the array pointed to by s1.”)
That is, strcpy copies characters from s2 to s1 up to (and including) the first
null character in s2. strcopy returns s1 (a pointer to the destination string). The
String pointed to by s2 isn’t modified, so it’s declared const.

The existence of strcpy compensates for the fact that we can’t use the
assignment operator to copy strings. For example, suppose that we want to store
the string "abcd" in str2. We can’t use the assignment

str2 = "abcd"; /*** WRONG ***/

because str2 1s an array name and can’t appear on the left side of an assignment.
Instead, we can call strcopy:

stropy (str2, "abcd") ; /* str2 now contains "abecd" */
Similarly, we can’t assign str2 to str1 directly, but we can call strepy:
stropy(stri1, str2); /* str1 now contains "abed" */

Most of the time, we'll discard the value that stropy returns. On occasion,
though, it can be useful to call stropy as part of a larger expression in order to
use its return value. For example, we could chain together a series of sLrepy
calls:

strcpy(str1, strcopy(str2, "abced")) ;
/* both str1 and str2 now contain "abcd" */

 

In the call stropy(str1, str2). strcopy has no way to check that the string
pointed to by str2 will actually fit in the array pointed to by str1. Suppose that
str1 points to an array of length ». If the string that str2 points to has no more
than n — | characters, then the copy will succeed. But if str2 points to a longer
string, undefined behavior occurs. (Since strcopy always copies up to the first null
character, it will continue copying past the end of the array that str1 points to.)

 

Calling the strnopy function is a safer, albeit slower, way to copy a string.
strncopy is similar to stropy but has a third argument that limits the number of
characters that will be copied. To copy str2 into str1, we could use the follow-
ing call of strncepy:

***************************page_316***************************
size t type »7.6

135  Using the C String Library — 291

strnocpy(str1, str2, sizeof(str1)) ;

Âs long as str1 1s large enough to hold the string stored in str2 (including the
null character), the copy will be done correetly. strnepy 1tself isn*t without dan-
ger, though. For one thing, it will leave the string in str1 without a terminating
null character if the length of the strine stored in str2 is greater than or equal to
the size of the str1 array. Here's à safer way to use strncpy:

strnopy(str1I, str2, sizeof(str1) - 1);
strl (sizeof (str1i1)-1] = '\0';

The second statement guarantees that str1 1s always null-terminated, even if
strncopy fails to copy a null character from str2.

The strlen (String Length) Function
The strlen function has the following prototype:
size t strlen(const char *s) ;

size t. which is defined in the C library, is a typede£ name that represents
one of C's unsigned integer types. Unless we’re dealing with extremely long
strings, this technicality need not concern us—we can simply treat the return value
of strlen as an integer.

strlen returns the lengih of à string s: the number of characters in s up lo.
but not including, the first null character, Here are a few examples:

int len;

len = strlen ("abc") ; /* len is now 3 */
len = strlen("") ; /* len is now 0 */
stropy(str1, "abc”) ;

len = strlen(strl) ; /* len is now 3 */

The last example illustrates an important point. When given an array as its argu-
ment, strlen doesn't measure the length of the array itself; instead, it returns the
length of the string stored in the array.

The strcat (String Concatenation) Function
The strcat function has the following prototype:
char *strcat (char *sl, const char *s2) ;

strcat appends the contents of the string s2 to the end of the string s1; 1l
returns sl (a pointer to the resulting string).
Here are some examples of strcat in action:

strcopy (str1, "abc") ;
strcat (stri, "def") ; /* strl now contains "abcdef" */

***************************page_317***************************
292

Chapter 13  Strings

strncat function » 23.6

QaA

strcpy(stri, "abc") ;
strocpy(str2, "def") ;
strcat (stri, str2); /* str1 now contains "abcdef" */

Âs with strcpy, the value returned by strcat is normally discarded. The
following example shows how the return value might be used:

stropy(str1i, "abc”") ;
strepy(str2, "def") ;
strcat(str1I, strcat (str2, "ghi")) ;
/* strl now contains "abcdefghi"; str2 contains "defghi" */

 

The effect of the call strcat (str1, str2) is undefined if the array pointed to
by str1 isn’t long enough to accommodate the additional characters from str2.
Consider the following example:

char str1(6] = "abc";

strcat(stri, "def") ; /*** WRONG ***+/

strcat will attempt to add the characters d. e, £, and \O to the end of the string
already stored in str1. Unfortunately, str1 1s limited to six characters. causing
strcat to write past the end of the array.

 

The strncat function is a safer but slower version of strcat. Like
strnopy, it has a third argument that limits the number of characters it will copy.
Here’s what a call might look like:

strncat ((str1i, str2, sizeof(str1) - strlen(stri1) - 1);

strncat will terminate str1 with a null character. which isn’t included in the
third argument (the number of characters to be copied). In the example, the third
argument calculates the amount of space remaining in str1 (given by the expres-
sion sizeof (str1) - strlen(str1)) and then subtracts ! to ensure that
there will be room for the null character.

The strcmp (String Comparison) Function
The stromp function has the following prototype:
int streomp (const char *s1, const char *s2);

strcmp compares the strings s1 and s2, returning a value less than, equal to, or
greater than O, depending on whether s1 is less than. equal to. or greater than s2.
For example, to see 1f str1 is less than str2, we'd write

if (stromp(str1i, str2) < O) /* is str1 < str2? */

***************************page_318***************************
ASCII character set » Appendix E

PROGRAM

135  Using the C String Library — 293

To test whether str1 1s less than or equal to str2. we'’d write

if (stromp(str1, str2)

<= 0) /* is str1 <= str2? */

By choosing the proper relational operator (<, <=, >, >=) or equality operator (==,
! =), we can test any possible relationship between str1 and str2.

stremp compares strings based on their lexicographic ordering, which re-
sembles the way words are arranged in a dictionary. More precisely, stremp con-
siders s1 lo be less than s2 if either one of the following conditions 1s satisfied:

u The first / characters of s1 and s2 match, but the (/+1)st character of s1 is
less than the (/+1)st character of s2. For example, "abc" is less than "bced",
and "abd" is less than "abe*.

u Al| characters of s1 match s2. but s1 1s shorter than s2. For example,
"abc" 1s less than "abecd".

Âs it compares characters from two strings. stremp looks at the numerical
codes that represent the characters. Some knowledge of the underlying character
set 1s helpful in order to predict what stremp will do. For example, here are a few
important properties of the ASCII character set:

e The characters in each of the sequences A—Z, a-z, and 0-9 have consecutive
codes.

u All upper-case letters are less than all lower-case letters. (In ASCII, codes
between 65 and 90 represent upper-case letters; codes between 97 and 122
represent lower-case letters.)

e Dicits are less than letters. (Codes between 48 and 57 represent digits.)

w Spaces are less than all printing characters. (The space character has the value

32 in ASCIL.)

Printing a One-Month Reminder List

To illustrate the use of the C string library. we’11 now develop a program that prints
a one-month list of daily reminders. The user will enter à series of reminders, with
each prefixed by a day of the month. When the user enters O instead of a valid day.
the program will print a list of all reminders entered, sorted by day. Here’s what a
session with the program will look like:

Enter
Enter
Enter
Enter
Enter
Enter
Enter
Enter

day
day
day
day
day
day
day
day

and
and
and
and
and
and
and
and

reminder :
reminder :
reminder :
reminder :
reminder :
reminder :
reminder :
reminder :

24 Susan's birthday
5 6:00 - Dinner with Marge and Russ

 

 

 

 

26 Movie - "Chinatown"
7 10:30 - Dental appointment
12 Movie - "Dazed and Confused"

 

5 Saturday class
12 Saturday class
0

 

 

***************************page_319***************************
294

Chapter 13  Strings

sprint£ function »22.8

remind.c

Day Reminder
5 Saturday class
5 6:00 - Dinner with Marge and Russ
7 10:30 - Dental appointment
12 Saturday class

12 Movie - "Dazed and Confused'"
24 Susan's birthday
26 Movie - "Chinatown"

The overall strategy isn’t very complicated: we’ll have the program read a
series of day-and-reminder combinations, storing them in order (sorted by day).
and then display them. To read the days, we’ll usce scanf; to read the reminders,
we'll use the read_line function of Section !3.3.

We'll store the strings in a two-dimensional array of characters, with each row
of the array containing one string. After the program reads a day and its associated
reminder, it will search the array to determine where the day belongs. using
streomp lo do comparisons. It will then use stropy to move all strings below
that point down one position. Finally, the program will copy the day into the array
and call strcat to append the reminder to the day. (The day and the reminder
have been kept separate up to this point.).

Of course, there are always a few minor complications. For example, we want
the days to be right-justified in a two-character field, so that their ones digits will
line up. There are many ways to handle the problem. l’ve chosen to have the pro-
gram use scanf£ to read the day into an integer variable, then call sprint£ to
convert the day back into string form. sprintf 1s a library function that’s similar
to print£, except that 11 writes output into a string. The call

sprintf (day _str, "%2d", day) ;

writes the value of day into day_str. Since sprint£ automatically adds a null
character when it's through writing, day_str will contain a properly null-termi-
nated string.

Another complication 1s making sure that the user doesn’t enter more than two
digits. We’Il use the following call of scan£ for this purpose:

scanf ("$2d", &day) ;

The number 2 between % and d tells scan£ to stop reading after Lwo digits, even
if the input has more digits.
With those details out of the way, here’s the program:

/* Prints a one-month reminder list */

#include <stdio.h>
finclude <string.h>

#define MAX REMIND 50 /* maximum number of reminders */
#define MSG LEN 60 /* max length of reminder message */

***************************page_320***************************
13.5  Using the C String Library 295

int read line(char str[], int n);

int main (void)

{
char reminders [MAX _ REMIND] [MSG_LEN+3] ;
char day _ str[3], msg_str [MSG_LEN+1] ;
int day, i, j, num remind = 0;

for (;;) |
i£ (num remind == MAX REMIND) {
printf("-- No space left --\n") ;
break;

}

printf ("Enter day and reminder: ") ;
scanf ("%2d", &day) ;
if (day == O)

break ;
sprint£ (day_str, "%2d", day) ;
read_line (msg_str, MSG_LEN) ;

for (i = 0; i < num remind; i++)
if (stromp(day_str, reminders[i]) < O)
break;
for (j = num remind; j > i; ])--)

strcopy (reminders[j], reminders [j-1)] ) ;

strcpy (reminders (i], day_str) ;
strcat (reminders {(i], msg _str) ;

num_remind++ ;

}

printf ("\nDay Reminder\n") ;
for (i = 0; i < num remind; i++)
printf(" %s\n", reminders [i] ) ;

return 0;

}

int read _line(char str[], int n)

{

int ch, i = 0;

while ((ch = getchar()) != '\n')
if (i < n)
str[i++] = ch;
str[i] = '\0';
return ;

Although remind. c 1s useful for demonstrating the stropy. strcat, and
stremp functions, it lacks something as a practical reminder program. There are

***************************page_321***************************
296

Chapter 13  Strings

13.6

obviously a number of improvements needed, ranging from minor tweaks to major
enhancements (such as saving the reminders in a file when the program termi-
nates). We'1l discuss several improvements in the programming projects at the end
of this chapter and in later chapters.

String Idioms

Functions that manipulate strings are a particularly rich source of idioms. In this
section, we'll explore some of the most famous idioms by using them to write the
strlen and strcat functions. You’I] never have to write these functions. of
course, since they’re part of the standard library. but you may have to write fune-
tions that are similar.

The concise style l’Il use in this section is popular with many C programmers.
You should master this style even if you don’t plan to use it in your own programs,
since you're likely to encounter it in code written by others.

One last note before we get started. If you want to try out any of the versions
of strlen and strcat in this section. be sure to alter the name of the function
(changing strlen to my_strlen, for example). As Section 21.1 explains.
we're not allowed to write a function that has the same name as a standard library
function, even when we don’t include the header to which the function belongs. In
fact, all names that begin with str and a lower-case letter are reserved (to allow
functions to be added to the <string. h> header in future versions of the C stan-
dard).

Searching for the End of a String

Many string operations require searching for the end of a string. The strlen
function is a prime example. The following version of strlen searches its string
argument to find the end. using a variable to keep track of the string’s length:

size t strlen(const char *s)

{

size t n;

for (n = 0; *s != '\O'; s++)
n++;
return n;

}

Às the pointer s moves across the string from left to right, the variable n keeps
track of how many characters have been seen so far. When s finally points to a null
character, n contains the length of the strine.

Let’s see if we can condense the function. First, we'll move the initialization
of n to its declaration:

***************************page_322***************************
136 String Idioms 297

size t strlen(const char #s)

size t n = 0;
for (; *s != '\O'; Ss++)
n++;
return n;
Next. we notice that the condition *s != '\O' is the same as *s != O, because

the integer value of the null character is O. But testing *s ! = O is the same as test-
ing *s; both are true if *s isn’t equal to 0. These observations lead to our next ver-
sion of strlen:

size t strlen(const char *s)

size t n = 0;

for (; *s; s++)
n++,;

return n;

But, as we saw in Section 12.2, it’s possible to increment s and test *s in the same
expression:

size t strlen(const char *s)

size t n = 0;

for (; *s++;)
n++;

return n;

Replacins the for statement with a while statement, we arrive at the following
version of strlen:

size t strlen(const char *s)

{
size t n = Q0;
while (*s++)
n++ ;
rveturn n;
}

Although we’ve condensed strlen quite a bit, it’s likely that we haven*t in-
creased its speed. Here”s a version that does run faster. at least with some compilers:

size t strlen(const char *s)

{

const char *p = s;

***************************page_323***************************
298 Chapter 13  Strings

while (*s)
S++;
return s - p;

}

This version of strlen computes the length of the string by locating the position
of the null character, then subtracting from it the position of the first character in
the string. The improvement in speed comes from not having to increment n inside
the while loop. Note the appearance of the word const in the declaration of p.
by the way; without it, the compiler would notice that assigning s to p places the
string that s points to at risk.

The statement

idiom  while (*s)
S++;

and the related

idlom = while (*s++)

ë

are idioms meaning ‘“‘search for the null character at the end of a string.” The first
version leaves s pointing to the null character. The second version is more concise,
but leaves s pointing just past the null character.

Copying a String

Copying a string is another common operation. To introduce C’s “string copy”
idtom, we'll develop two versions of the strcat function. Let's start with a
straightforward but somewhat lengthy version:

char *strcat (char *s1, const char *s2)

{

char *p = sl;

while (*p != '\0')
pD++i

while (*s2 != '\0') Ç{
*p = *s2;
p++i
s2++;

*p: |\Ol;
return sl;

}

This version of strcat uses a two-step algorithm: (1) Locate the null character at
the end of the string s1 and make p point to it. (2) Copy characters one by one
from s2 to where p 1s pointing.

The first while statement in the function implements step (1). p is set to
point to the first character in the s1 string. Assuming that s1 points to the string
"abc". we have the following picture:

***************************page_324***************************
13.6  String |dioms 299

“I
N

p |c|vwo| | |

C

 

 

 

a

p 1s then incremented as long as it doesn’t point to a null character. When the loop
terminates, p must be pointing to the null character:

Y. _

w |

b C

Q

 

 

 

The second while stalement implements step (2). The loop body copies one
character from where s2 points to where p points, then increments both p and s2.
If s2 originally points to the string "def", here’s what the strings will look like
after the first loop iteration:

81[Î_| ‘°Î%J sp.[__{:|

a

 

 

 

 

 

 

 

The loop terminates when s2 points to the null character:

|w|ca[e]e] [a [ î1‘îﬁ

After putting à null character where p is pointing, strcat returns.
By a process similar to the one we used for strlen, we can condense the
definition of strcat, arriving at the following version:

 

 

 

char *strcat (char *s1, const char *s2)

{

char *p = sl;

while (*p)
p++;
while (*p++ = #*s2++)

return sl;

***************************page_325***************************
300

Chapter 13  Strings

idiom

13.7

The heart of our streamlined strcat function is the “strine copv” idiom:
& COp

while (*p++ = *s2++)

’

If we ignore the two ++ operators, the expression inside the parentheses simplifies
to an ordinary assignment:

*p = *s2

This expression copies a character from where s2 points to where p points. After
the assignment, both p and s2 are incremented, thanks to the ++ operators.
Repeatedly executing this expression has the effect of copying a series of charac-
ters from where s2 points to where p points.

But what causes the loop to terminate? Since the primary operator inside the
parentheses is assignment, the while statement tests the value of the assign-
ment—the character that was copied. All characters except the null character test
true, so the loop won’t terminate until the null character has been copied. And
since the loop terminates affer the assignment, we don’t need a separate statement
to put a null character at the end of the new strine.

Arrays of Strings

Let's now turn to a question that we’1l often encounter: what’s the best way to store
an array of strings? The obvious solution is to create a two-dimensional array of
characters, then store the strings in the array, one per row. Consider the following
example:

char planets[{] [8] = {"Mercury", "Venus", "Earth",
"Mars", "Jupiter", "Saturn",
"Uranus", "Neptune", "Pluto"};

(In 2006, the International Astronomical Union demoted Pluto from “planet” to
“dwarf planet,” but l’ve left it in the planets array for old times’ sake.) Note that
we’re allowed to omit the number of rows in the planets array—since that's
obvious from the number of elements in the initializer—but C requires that we
specify the number of columns.

The figure at the top of the next page shows what the planets array will
look like. Not all our strings were long enough to fil] an entire row of the array, so
C padded them with null characters. There’s a bit of wasted space in this array,
since only three planets have names long enough to require eight characters
(including the terminating null character). The remind. c program (Section 13.5)
IS a glaring example of this kind of waste. It stores reminders in rows of a two-
dimensional character array, with 60 characters set aside for each reminder. In our
example, the reminders ranged from 18 to 37 characters in length, so the amount of
wasted space was considerable.

***************************page_326***************************
13.7  Arrays of Strings 301

 

 

 

 

 

 

 

 

 

 

_i 1 2 ; 5 6 7
Oj M | e |r u |r | y |\o l
11V|e |n s |\0 |\0 | \0 l
21E / a r h |\0 | \6 | \0
3/ #% |a |r \0 | \0 | \0 | \O
4| J u |Pp t 2 r |\o
5| S |a |ct r |n |\0 | \0
6] U | r | a u | 8 |\0 | \0O
7|N|# |Pp u |n |e \0
81 P |1 | u o |\0j\0 |\0

 

 

 

 

 

 

 

 

 

 

The inefficiency that’s apparent in these examples is common when working
with strines, since most collections of strings will have à mixture of long strings
and short strines. What we need is a ragged array: à two-dimensional array whose
rows can have different lengths. C doesn’t provide a ‘’ragged array type,” but it
does give us the tools to simulate one. The secret is to create an array whose ele-

ments are pointers t Strings.

Here’s the planets array again. this time as an array of pointers to strings:

char *planets{] = {"Mercury",
l|Mars l ‘

"Uranus",

"Venus",
"Jupiter",
"Neptune”",

"Earth",

"Saturn",

"pluto"};

Not much of a change, eh? We simply removed one pair of brackets and put an aster-
isk in front of planet s. The effect on how planets is stored is dramatic, though:

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

nplanets

0 -—'——*{M e|r|ec Ul rl Yl\0
— .

1| » ——w{V e|n|u|s l\0l

2| >—t-—- E l|alrl|e|h [\0]

3 -———*{M a|r s]\E]

3| <-#- " J_ u|p|i|tjejr \0l

5 _Î:.-—+ S|a|t|u|r|n \0]

61 —l—U|r aﬂÎn u |s \ol

71 ——N ]|e|p|t|u|n e-Î;5]

8 -;:]__… P|1|u|t|o|\o

Each element of planets is a pointer to a null-terminated string. There are no
longer any wasted characters in the strings, although we’ve had to allocate space
for the pointers in the planets array.

To access one of the planet names, all we need do 1s subscript the planets
array. Because of the relationship between pointers and arrays, accessing a charac-
ter in a planet name is done in the same way as accessing an element of a two-

***************************page_327***************************
302

Chapter 13  Strings

e 7.70

QaÂ

null pointers » 17.71

dimensional array. To search the planets array for strings beginning with the
letter M, for example, we could use the following loop:

for (i = 0; i < 9; i++)
if (planets[i] [0] == ‘'M')
printf ("%s begins with M\n", planets [i] ) ;

Command-Line Arguments

When we run a program, we’Il often need to supply it with information—a file
name, perhaps, or a switch that modifies the program”s behavior. Consider the
UNIX 1s command. If we run 1s by typing

ls

at the command line, it will display the names of the files in the current directory.
But if we instead type

1s -l

then 1s will display a “long” (detailed) listing of files, showing the size of each file,
the file's owner, the date and time the file was last modified, and so forth. To modify
the behavior of 1s further, we can specify that it show details for just one file:

ls -1 remind.c

1s will display detailed information about the file named remind. c.

Command-line information is available to all programs, not just operating sys-
tem commands. To obtain access to these command-line arguments (called pro-
gram parameters in the C standard). we must define main as a function with two
parameters, which are customarily named argc and argv:

int main(int argc, char *argv[])

(
}

argc (‘argument count”) is the number of command-line arguments (including
the name of the program itself). argv (“argument vector”) is an array of pointers
to the command-line arguments, which are stored in string form. argv [0] points
to the name of the program, while argv [1] through argv [argc-1] point to
the remaining command-line arguments.

argv has one additional element, argv [argec], which is always a null
pointer—a special pointer that points to nothing. We*I! discuss null pointers in a
later chapter; For now, all we need to know is that the macro NULL represents a null
pointer.

If the user enters the command line

ls -l remind.c

then argc will be 3, argv [0] will point to a string containing the program

***************************page_328***************************
PROGRAM

13.7  Arrays of Strings 303

name, argv [1] will point to the string "-1", argv [2] will point to the string
"remind.c", and argv [3] will be a null pointer:

argv

——> program name

 

 

" - [1 |\o

 

——>

 

 

 

m |i |n }d l.l cl\0î

    

 

 

This figure doesn’t show the program name in detail, since it may include a path or
other information that depends on the operating system. If the program name isn°t
available, argv [0] points to an empty string.

Since arqv is an array of pointers. accessing command-line areuments is
easy. Typically, a program that expects command-line arguments will set up a loop
that examines each argument in turn. One way to write such a loop is to use an
integer variable as an index into the argv array. For example, the following loop
prints the command-line arguments, one per line:

int i;

for (i = 1; i < argc; i++)
print£("%s\n"', argv[il);

Another technique 1s to set up a pointer to argv [1], then increment the pointer
repeatedly to step through the rest of the array. Since the last element of argv 1s al-
ways a null pointer, the loop can terminate when it finds à null pointer in the array:

char **p;

for (p = &argv[1]; *p != NULL; p++)
print£f("%s\n", *p) ;

Since p 1s à pointer to à pointer 10 a character, we’ve got to use it carefully. Setting
p equal to &argv [1] makes sense; argv [1] is a pointer to a character, so
&argv [1] will be a pointer to a pointer. The test *p != NULL is OK, since *p
and NULL are both pointers. Incrementing p looks good; p points to an array ele-
ment, so incrementing it will advance it to the next element. Printing *p is fine,
since *p points to the first character in a string.

Checking Planet Names

Our next program, planet . c, illustrates how to access command-line argu-
ments. The program 1s designed to check a series of strings to see which ones are
names of planets. When the program is run. the user will put the strings to be tested
on the command line:

planet Jupiter venus Earth f£red

***************************page_329***************************
304

Chapter 13  Strings

planet.c

The program will indicate whether or not each string is a planet name; if it is, the
program will also display the planet's number (with planet ! being the one closest
to the Sun):

Jupiter is planet 5
venus is not a planet
Earth is planet 3
Éred is not a planet

Notice that the program doesn’t recognize a string as a planet name unless its first
letter 1s upper-case and its remaining letters are lower-case.

/* Checks planet names */

#finclude <stdio.h>
Hinclude <string.h>

#define NUM PLANETS 9

int main(int argc, char *argv[])

{
char *planets[] = {"Mercury", "Venus", "Earth",
"Mars", "Jupiter", "Saturn",
"Uranus", "Neptune", "Pluto"};
int i, j;
for (i = 1; i < argc; i++) (
for (j = 0; j < NUM PLANETS; j++)
if (stromp(argv[i], planets[j]) == 0) (
printf("%s is planet %d\n", argv[i], j + 1);
break ;
}
if (j == NUM PLANETS)
print£("%s is not a planet\n", arqgv [i]) ;
}
return 0;
}

The program visits each command-line argument in turn, comparing it with
the strings in the planets array until it finds a match or reaches the end of
the array. The most interesting part of the program is the call of stromp, in
which the arguments are argv [i] (a pointer to a command-line argument) and
planets [y] (a pointer to a planet name).

Q & À

How long can a string literal be?
According to the C89 standard, compilers must allow string literals to be at least

***************************page_330***************************
>.

> ©

Q & À 305

509 characters lons. (Yes, you read that right—509. Don’t ask.) C99 increases the
minimum to 4095 characters.

Wlhy aren°t string literals called ‘“‘string constants’”?

Because they‘re not necessarily constant. Since string literals are accessed through
pointers. there’s nothing to prevent a program from attempting to modify the char-
acters In a string literal.

How do we write a string literal that represents ‘“über” if "\xfcber" doesn°t
work? [p. 278]

The secret is to write two adjacent string literals and let the compiler join them into
one. In this example, writing "\xfc" "ber" will give us à string literal that rep-
resents the word ‘“iiber.”

Modifying a string literal seems harmless enough. Why does it cause unde-
fined behavior? [p. 280]

Some compilers try to reduce memory requirements by storing single copies of
identical string literals. Consider the following example:

char *p = "8bC", *q — ”âbC",‘

À compiler might choose to store "abc" just once, making both p and q point to
it. If we were to change "abc*" through the pointer p, the string that q points to
would also be affected. Needless to say, this could lead to some annoying bugs.
Another potential problem is that string literals might be stored in a “read-only”
area of memory; a program that attempts to modify such a literal will simply crash.

Should every array of characters include room for a null character?

Not necessarily, since not every array of characters 1s used as a string. Including
room for the null character (and actually putting one into the array) is necessary
only if you’re planning to pass it to a function that requires a null-terminated
string.

You do not need a null character if you’I! only be performing operations on
individual characters. For example, a program might have an array of characters
that it will use to translate from one character set to another:

char translation _table (128] ;

The only operation that the program will perform on this array is subscripting.
(The value of translation table [ch] will be the translated version of the
character ch.) We would not consider translation table to be a string: it
need not contain a null character, and no string operations will be performed on it.

If printf and scan£ expect their first argument to have type char *, does
that mean that the argument can be a string variable instead of a string lit-
eral?

***************************page_331***************************
306

Chapter 13  Strings

Â:

:;:Qz

A:

EOF macro > 22,4

Yes, as the following example shows:

char fmt[] = "Zd\n";
int i;

print£ (fmt, i);

This ability opens the door to some intriguing possibilites—reading a format
string as input, for example.

If l want print£ to write a string str, can°t I just supply str as the format
string, as in the following example?

print£ (str) ;

Yes, but i£'s risky. If str contains the % character. you won't get the desired result.
since print£ will assume its the beginning of a conversion specification.

How can read_line detect whether getchar has failed to read a charac-
ter? [p. 287]

If it can’t read a character, either because of an error or because of end-of-file,
getchar returns the value EOF, which has type int. Here’s a revised version of
read_line that tests whether the return value of getchar is EOF. Changes are
marked in bold:

int read line(char str[], int n)

{

int ch, i = O0;

while ((ch = getchar()) != '\n' && ch != EOF)

L1£ (i < n)
str[i++] = ch;
str[i] = '\0';
return i;

}

Why does stremp return a number that’s less than, equal to, or greater than
zero? Also, does the exact return value have any significance? [p. 292]

stremp's return value probably stems from the way the function is traditionally
written. Consider the version in Kernighan and Ritchie’s The C Programming Lan-

guage:

int stromp(char *s, char *t)
{ ° °
int 1;
for (i = O; s[i] == t[i]; i++)
1f (s[i] == '\O')
return 0;
return s[i)] - tli];

}

***************************page_332***************************
Q & À 307

The return value 1s the difference between the first “’mismatched” characters in the
s and t strings, which will be negative if s points to a “smaller” string than t and
positive if s points lo a ‘“larger” string. There’s no guarantee that stremp 1s actu-
ally written this way, though, so it’s best not to assume that the magnitude of its
return value has any particular meaning.

My compiler issues a warning when I try to compile the while statement in
the strcat function:

while (#*p++ = *s2++)

/

What am L doing wrong?

Nothing. Many compilers—but not all. by any means—issue à warning 1f you use
= where == is normally expected. This warning 1s valid at least 95% of the time,
and it will save you a lot of debugging if you heed it. Unfortunately, the warning
isn’t relevant in this particular example; we actually do mean to usc =, not ==. To
get rid of the warning, rewrite the while loop as follows:

while ((#*p++ = *s2++) != O)

4

Since the while statement normally tests whether *p++ = *s2++ is not 0, we
haven’t changed the meaning of the statement. The warning goes away, however,
because the statement now tests a condition, not an assignment. With the GCC
compiler, putting a pair of parentheses around the assignment is another way to
avoid a warning:

while ((*p++ = *s2++))

‘

Are the strlen and strcat functions actually written as shown in Section
13.6?

Possibly, although it’s common practice for compiler vendors to write these func-
tions—and many other string functions—in assembly language instead of C. The
string functions need to be as fast as possible, since they’re used often and have to
deal with strings of arbitrary length. Writing these functions in assembly language
makes it possible to achieve great efficiency by taking advantage of any special
string-handling instructions that the CPU may provide.

Why does the C standard use the term ‘“program parameters’” instead of
“command-line arguments”? [p. 302]

Programs aren’t always run from a command line. In à typical graphical user inter-
face, for example, programs are launched with a mouse click. In such an environ-
ment, there’s no traditional command line, although there may be other ways of
passing information to a program; the term “program parameters” leaves the door
open for these alternatives.

***************************page_333***************************
308 Chapter 13  Strings

OQ:
À:

dynamic storage allocation » 17.7

Section 13.3 l.
M 2

#3

M 4

isspace function »23.5

Do I have to use the names argc and argv for main’s parameters? [p. 302]

No. Using the names argc and argv is merely a convention, not a language
requirement.

l’ve seen argv declared as **argv instead of *argv []. Is this legal?
Certainly. When declaring a parameter, writing *a is always the same as writing
a [) . regardless of the type of a’s elements.

We”ve seen how to set up an array whose elements are pointers to string liter-
als. Are there any other applications for arrays of pointers?

Yes. Although we've focused on arrays of pointers to character strings. that’s not
the only application of arrays of pointers. We could just as easily have an array
whose elements point to any type of data, whether in array form or not. Arrays of
pointers are particularly useful in conjunction with dynamic storage allocation.

Exercises

The following function calls supposedly write a single new-line character. but some are
incorrect. Identify which calls don’t work and explain why.

(a) printf("%c", '\n'), (g) putchar ('\n') ;
(b) print£("%c", "\n") , (h) putchar ("\n") ;
(c) printf("%s", '\n'); (1) puts('\n') ;

(d) print£f("ss", "\n") ; ÿ) puts("\n") ;

(e) print£('\n'); (k) puts("") ;

() printf ("\n") ;

Suppose that p has been declared as follows:
char *p = "abc";

Which of the following function calls are legal? Show the output produced by each legal
call. and explain why the others are illegal.

(a) putchar (p) ;

(b) putchar (*p) ;

(c) puts (p) ;

(d) puts(*p) ;

Suppose that we call scan£ as follows:

scanf ("%d%s%d", &i, s, &j);

If the user enters 12abc34 56def£78, what will be the values of i, s, and j after the
call? (Assume that i and j are int variables and s is an array of characters.)

Modify the read_line function in each of the following ways:

(a) Have it skip white space before beginning to store input characters.

(b) Have it stop reading at the first white-space character. Hint: To determine whether or
not a character is white space, call the isspace function.

***************************page_334***************************
 

 

Section 13.4

toupper function »23.5

Section 13.5

S.

® 6.
T.
©
0.

|l

12.

Exercises 309

(c) Have it stop reading at the first new-line character. then store the new-line character in
the string.
(d) Have it leave behind characters that it doesn t have room lo store.

(a) Write a function named capitalize that capitalizes all letters in its argument. The
argument will be a null-terminated string containing arbitrary characters. not just letters.
Use array subscripting to access the characters in the string. Hinz: Use the toupper func-
tion to convert each character to upper-case.

(b) Rewrite the capitalize function, this time using pointer arithmetic to access the
characters in the string.

Write a function named censor that modifies a string by replacing every occurrence of
foo by xxx. For example, the string "food £oo1" would become "xxxd xxx1 ". Make
the function as short as possible without sacrificing clarity.

Suppose that str is an array of characters. Which one of the l'ollowing statements is not
equivalent to the other three?

(a) *str = 0;

(b) str[0] = '\O';
(c) stroepy(str, "") ;
(d) strcat(str, "") ;

What will be the value of the strine str after the following statements have been executed?

strcpy(str, "tire-bouchon") ;
stropy(&str[4], "d-or-wi") ;
strcat (str, "red?") ;

What will be the value of the string s1 after the following statements have been executed?

stropy(s1, "computer") ;

strecpy(s2, "science") ;

if (stromp(s1, s2) < O)
strcat(s1, s2);

else
strcat (s2, s1l);
sl (strlen(s1)-6] = '\0';

The following function supposedly creates an identical copy of à string. What's wrong with
the function?

char *duplicate (const char *p)

{

char *q;

strepy(q, Pp) ;
return q;

}

The Q&A section at the end of this chapter shows how the stremp function might be writ-
ten using array subscripting. Modify the function to use pointer arithmetic instead.

Write the following function:

void get extension (const char *file name, char *extension) ;

***************************page_335***************************
310 Chapter 13  Strings

Section 13.6

13.

#14,

©Is.

1'7.

file_name points to a string containing a file name. The function should store the exten-
sion on the file name in the string pointed to by extension. For example, if the file name
is"memo.txt"ﬂheﬁnæﬁm1th…me"txt"h1…esumgpomuﬂtobyextensionﬂf
the file name doesn’t have an extension, the function should store an empty string (a single
null character) in the string pointed to by extension. Keep the function as simple as pos-
sible by having it use the strlen and strcepy functions.

Write the following function:
void build_index url (const char *domain, char *index _url) ;

domain points to a string containing an Internet domain, such as "knking.com". The
function should add "http://www." to the beginning of this string and "/
index.html" to the end of the string, storing the result in the string pointed to by
index_url. (In this example, the result will be "http://www.knking. com/
index.html".) You may assume that index ur1l points to a variable that is long
enought to hold the resulting string. Keep the function as simple as possible by having it use
the strcat and strcpy functions.

What does the following program print?

#include <stdio.hs>

int main(void)

{

char s[] = "Hsjodi", *p;

for (p = s; *p; p++)
_._*p;

puts(s) ;

return 0;

}

Let £ be the following function:

int f(char *s, char *t)

(

char *p1, *p2;
for (p1 = s; *pl; pl++) |

for (p2 = t; *p2; p2++)
if (*p1 == *p2) break;
if (*p2 == '\0') break;

}

return pl - s;

(a) What is the value of £ ("abcd", "babc") ?
(b) What is the value of £ ("abcd", "bca") ?
(c) In general, what value does f return when passed two strings s and t?

Use the techniques of Section 13.6 to condense the count_spaces function of Section
13.4. In particular, replace the £or statement by a while loop.
Write the following function:

bool test_extension(const char *file name,
const char *extension}) ;

***************************page_336***************************
toupper lunction >23.5

16.

Programming Projects 311

file name points to a string containing à file name. The function should return true if
the file‘s extension matches the string pointed to by extension. ignoring the case of let-
ters. For example. the call test_extension ("memo.txt", "TXT") would return
true. Incorporate the ‘search for the end of à string” idiom into your function. Hint: Use
the toupper function to convert characters to upper-case before comparing them.

Write the following function:
void remove filename (char *url) ;

ur1 points to à string containing a URIL (Uniform Resource Locator) that ends with a file
name (such as "http://www.knking.com/index.html "), The function should
modify the string by removing the file name and the preceding slash. (In this example, the
result will be "http: //www.knking.com".) Incorporate the “search for the end of a
string” idiom into your function. Hint: Have the function replace the last slash in the string
by a null character.

Programming Projects

Write a program that finds the “smallest” and “largest” in à series of words. After the user
enters the words, the program will determine which words would come first and last if the
words were listed in dictionary order. The program must stop accepting input when the user
enters à four-letter word. Assume that no word is more than 20 letters long. An interactive
session with the program might look like this:

Enter word: dog
Enter word: zebra
Enter word: rabbit
Enter word: catfish
Enter word: walrus
Enter word: cat
Enter word: fish

 

Smallest word: cat
Largest word: zebra

Hint: Use two strings named smallest_word and largest_word to keep track of the
“smallest” and “largest” words enterèd so far. Each time the user enters a new word, use
streomp to compare it with smallest_word; if the new word is “smaller” use strcpy
to save it in smallest word. Do a similar comparison with 1largest_word. Use
strlen to determine when the user has entered a f'our-letter word.

Improve the remind. c program of Section 13.5 in the following ways:

(a) Have the program print an error message and ignore a reminder if the corresponding
day is negative or larger than 3t. Hint: Use the continue statement.

(b) Allow the user to enter à day. a 24-hour time. and a reminder. The printed reminder list
should be sorted first by day, then by time. (The original program allows the user to
enter a time. but il’s treated as part of the reminder.)

(c) Have the program print a one-year reminder list. Require the user to enter days in the
form monrh/dax.

Modify the deal .c program of Scction 8.2 so that it prints the full names of the cards it
deals:

***************************page_337***************************
312

Chapter 13  Strings

'_J|

atoi function > 26.2

® 6.

10.

[.

Enter number of cards in hand: 5
Your hand:

Seven of clubs

Two of spades

Five of diamonds

Ace of spades

Two of hearts

Hint: Replace rank_code and suit_code by arrays containing pointers to strings.
Write a program named reverse.c that echoes its command-line arguments in reverse
order. Running the program by typing

reverse void and null

should produce the following output:

null and void

Write a program named sum.c that adds up its command-line arguments, which are
assumed to be integers. Running the program by typing

sum 8 24 62

should produce the following output:

Total: 94

Fint: Use the atoi function to convert each command-line argument from string form to

integer form.

Improve the planet . c program of Section 13.7 by having it ignore case when comparing
command-line arguments with strings in the planets array.

Modify Programming Project 11 from Chapter 5 so that it uses arrays containing pointers to
strings instead of switch statements. For example. instead of using a switch statement
to print the word for the first digit. use the digit as an index into an array that contains the
strings "twenty", "thirty". and so forth.

Modify Programming Project 5 from Chapter 7 so that it includes the following funetion:
int compute _scrabble value (const char *word) ;

The function returns the SCRABBLE value of the string pointed to by word.

Modify Programming Project 10 from Chapter 7 so that it includes the following function:
int compute _ vowel count (const char *sentence) ;

The function returns the number of vowels in the string pointed to by the sentence
parameter.

Modify Programming Project 11 from Chapter 7 so that it includes the following function:
void reverse_name (char *name) ;

The function expects name to point to a string containing à first name followed by a last
name. Ît modifies the string so that the last name comes first, followed by a comma. a space.
the first mitial, and à period. The original string may contain extra spaces before the first
name, between the first and tast names, and after the last name.

Modify Programming Project 13 from Chapter 7 so that it includes the following function:
double compute_average_word _ length(const char *sentence) ;

The function returns the average length of the words in the string pointed to by sentence.

***************************page_338***************************
14.

15.

16.

|7.

|8.

Programming Projects 313

Modify Programming Project 14 from Chapter 8 so that it stores the words In à (wo-
dimensional char array as it reads the sentence, with cach row of the array storing à sin-
gle word. Assume that the sentence contains no more than 30 words and no word is more
than 20 characters long. Be sure to store a null character at the end of each word so that il
can be treated as a string.

Modify Programming Project 15 from Chapter 8 so that it includes the following function:
void encrypt (char *message, int shi£ft);

The function expects message to point to a string containing the message to be encrypted;
shift represents the amount by which each letter in the message 1s to be shifted.

Modify Programming Projeet 16 from Chapter 8 so that it includes the following function:
bool are anagrams (const char *wordl, const char *word2) ;

The function returns true if the strings pointed to by word1 and word2 are anagrams.

Modify Programming Project 6 from Chapter 10 so that it includes the following funetion:
int evaluate RPN expression(const char *expression) ;

The function returns the value of thè RPN expression pointed to by expression.

Modify Programming Project ! from Chapter 12 so that it includes the following function:
void reverse (char *message) ;

The function reverses the string pointed to by message. Hint: Use two pointers, one ini-
tially pointine to the first character of the string and the other initially pointing to the last
character. Have the function reverse these characters and then move the pointers toward
each other, repeating the process until the pointers meet.

Modify Programming Projeet 2 from Chapter 12 so that it includes the following l'unction:
bool is palindrome (const char *message) ;

The function returns true if the string pointed to by message is à palindrome.

Write à program that accepts à date from the user in the form nwn/dd/yvyy and then dis-
plays it in the form monrh dd, yvyy. where month is the name of the month:

Enter a date (mm/dd/yvyyy) : 2/17/2011
You entered the date February 17, 2011

Store the month names in an array that contains pointers to strings.

***************************page_339***************************

***************************page_340***************************
14

141

The Preprocessor

There will always be things we wish to say in our programs
that in all known languages can only be said poorly.

In previous chapters. l’ve used the #define and #include directives without
going into detail about what they do. These directives—and others that we haven’t
yet covered—are handled by the preprocessor, à piece of software that edits C pro-
grams just prior to compilation. Its reliance on a preprocessor makes C (along with
C++) unique among major programming languages.

The preprocessor is a powerful tool, but it also can be a source of hard-to-find
bugs. Moreover, the preprocessor can easily be misused to create programs that are
almost impossible to understand. Although some C programmers depend heavily
on the preprocessor, l recommend that it—like so many other things in life—be
used in moderation. ‘

This chapter begins by describing how the preprocessor works (Section 14.1)
and giving some general rules that affect all preprocessing directives (Section
14.2). Sections 14.3 and 14.4 cover two of the preprocessor’s major capabilities:
macro definition and conditional compilation. (Il defer detailed coverage of file
inclusion, the other major capability, until Chapter 15.) Section 14.5 discusses the
preprocessor’s lesser-used directives: #error, #line, and #pragma.

How the Preprocessor Works

The behavior of the preprocessor is controlled by preprocessing directives: com-
mands that begin with a # character. We’ve encountered two of these directives,
#define and #include, in previous chapters.

The #define directive defines a macro—a name that represents something
else, such as à constant or frequently used expression. The preprocessor responds to
a HdeFfine directive by storing the name of the macro together with its definition.

315

***************************page_341***************************
316

Chapter 14  The Preprocessor

When the macro is used later in the program, the preprocessor “expands” the
macro, replacing it by its defined value.

The #include directive tells the preprocessor to open a particular file and
“Include” its contents as part of the file being compiled. For example, the line

#include <stdio.h>

instructs the preprocessor to open the file named stdio.h and bring its contents
into the program. (Among other things, stdio.h contains prototypes for C's
standard input/output functions.)

The following diagram shows the preprocessor’s role in the compilation pro-
Cess:

C program
|

Y

Preprocessor

v
Modified C program

Y

Compiler

Y
Object code

The input to the preprocessor is a C program. possibly containing directives. The
preprocessor executes these directives, removing them in the process. The output
of the preprocessor is another C program: an edited version of the original pro-
gram, containing no directives. The preprocessor’s output goes directly into the
compiler. which checks the program for errors and translates it to object code
(machine instructions).

To see what the preprocessor does, let’s apply it to the celsius. c program
of Section 2.6. Here’”s the original program:

/* Converts a Fahrenheit temperature to Celsius */

#Hinclude <stdio.h>

#define FREEZING PT 32.0f
#define SCALE FACTOR (5.0f / 9.0£)

int main(void)
{

float fahrenheit, celsius;

print£ ("Enter Fahrenheit temperature: ");
scanf ("5£", &fahrenheit) ;

celsius = (fahrenheit - FREEZING_PT) * SCALE FACTOR;

***************************page_342***************************
14.1  Howthe Preprocessor Works 317

print£f("Celsius equivalent is: %.1f\n", celsius) ;

return 0;

;

After preprocessing. the program will have the following appearance:

Blank line

Blank line

Lines brought in from stdio.h
Blank line

Blank line

Blank line

Blank line

int main(void)

{ float fahrenheit, celsius;
print£ ("Enter Fahrenheit temperature: ") ;
scanf ("%f", &fahrenheit) ;
celsius = (fahrenheit - 32.0£) * (5.0£ / 9.0f);
printf("Celsius equivalent is: %.1f\n", celsius) ;
} return 0;

The preprocessor responded to the #include directive by bringing in the con-
tents of stdio.h. The preprocessor also removed the #define directives and
replaced FREEZING PT and SCALE FACTOR wherever they appeared later in
the file. Notice that the preprocessor doesn't remove lines containing directives:
instead, 1t ssmply makes them empty.

As this example shows, the preprocessor does a bit more than just execute
directives. In particular, it replaces each comment with a single space character.
Some preprocessors go further and remove unnecessary white-space characters,
including spaces and tabs at the beginning of indented lines.

In the early days of C. the preprocessor was a separate program that fed 1ts
output into the compiler. Nowadays, the preprocessor is often part of the compiler.
and some of its output may not necessarily be C code. (For example, including a
standard header such as <stdio .h> may have the cffect of making its functions
available to the program without necessarily copying the contents of the header
into the program’s source code.) Sull, it’s useful to think of the preprocessor as
separate from the compiler. In fact, most C compilers provide a way to view the
output of the preprocessor. Some compilers generate preprocessor output when a
certain option is specified (GCC will do so when the -E option is used). Others
come with a separate program that behaves like the integrated preprocessor. Check
your compiler’s documentation for more information.

A word of caution: The preprocessor has only a limited knowledge of C. Às
a result, it’s quite capable of creating illegal programs as 1t executes directives.
Often the original program looks fine, making errors harder to find. In complicated

***************************page_343***************************
318

Chapter 14  The Preprocessor

programs, examining the output of the preprocessor may prove useful for locating
this kind of error.

14.2 Preprocessing Directives

Most preprocessing directives fall into one of three categories:

n Macro definition. The fdefine directive defines a macro; the #undef
directive removes a macro definition.

u File inclusion. The #include directive causes the contents of a specified
file to be included in a program.

n Conditional compilation. The #if, #ifde£, #ifndeË, #elif, #else.
and #endi£f directives allow blocks of text to be either included in or
excluded from a program, depending on conditions that can be tested by the
preprocessor.

 

The remaining directives—#error, #line, and #pragma—are more special-
ized and therefore used Iess often. We’11 devote the rest of this chapter to an in-
depth examination of preprocessing directives. The only directive we won't dis-
cuss in detail is Hinclude, since it’s covered in Section 15.2.

Betore we go further, let’s look at a few rules that apply to all directives:

m Directives always begin with the # symbol, The # symbol need not be at the be-
ginning of a line, as long as only white space precedes it. After the # comes the
name of the directive, followed by any other information the directive requires.

m Any number of spaces and horizontal tab characters may separate the
tokens in a directive. For example, the following directive is legal:

# define N 100

m Directives always end at the first new-line character, unless explicitly con-
tinued. To continue a directive to the next line, we must end the current line
with a \ character. For example, the following directive defines a macro that
represents the capacity of a hard disk, measured in bytes:

#define DISK CAPACITY (SIDES * \
TRACKS PER SIDE * \
SECTORS PER TRACK * \
BYTES PER SECTOR)

u Directives can appear anywhere in a program. Although we usually put
#de£fine and finclude directives at the beginning of a file, other directives
are more likely to show up later, even in the middle of function definitions.

= Comments may appear on the same line as a directive. In fact, it’s good prac-
tice to put a comment at the end of a macro definition to explain the meaning
of the macro:

#define FREEZING PT 32.0Ë /* freezing point of water */

***************************page_344***************************
14.3

#define directive
(simple macro)

eF3N

14.3  Macro Definitions 319

Macro Definitions

The macros that we’ve been using since Chapter 2 are known as simple macros,
because they have no parameters. The preprocessor also supports parameterized
macros. We’ll look first at simple macros, then at parameterized macros. After
covering them separately, we’ll examine properties shared by both.

Simple Macros

The definition of a simple mnacro (or object-like macro, as Vs called in the C stan-
dard) has the form

H+define identifier replacement-list

replacement-list is any sequence of preprocessing tokens, which are similar to the
tokens discussed in Section 2.8. Whenever we use the term “token” in this chapter,
it means ‘““preprocessing token.”

A macro’s replacement list may include identifiers, keywords, numeric con-
stants, character constants, string literals. operators, and punctuation. When it
encounters a macro definition, the preprocessor makes a note that identifier repre-
sents replacement-list, wherever identifier appears later in the file, the preproces-
sor substitutes replacement-list.

 

Don’t put any extra symbols in a macro definition—they'll become part of the
replacement list. Putting the = symbol in a macro definition is a common error:

#define N 100 /*** WRONG ***/

int a (N] ; /* becomes int a([= 100] ; */

In this example, we’ve (incorrectly) defined N to be à pair of tokens (= and 100).
Ending a macro definition with a semicolon is another popular mistake:

#define N 100; _ /*** WRONG ***/
int a[N] ; /* becomes int a[100;]; */

Here N 1s defined to be the tokens 100 and ;.

The compiler will detect most errors caused by extra symbols in a macro defi-
nition. Unfortunately, the compiler will flag each use of the macro as incorrect,
rather than identifying the actual culprit—the macro’s definition—which will have
been removed by the preprocessor.

 

Simple macros are primarily used for defining what Kernighan and Ritchie
call “manifest constants.” Using macros, we can give names to numeric, character,
and string values:

***************************page_345***************************
320

Chapter 14  The Preprocessor

#define STR _LEN 80

#define TRUE l
#define FALSE O
#define PI 3.14159
#*define CR t\r'
#define EOS t 0"

fdefine MEM _ ERR "Error: not enough memory"
Using #define to create names for constants has several significant advantages:

u /t makes programs easier to read. The name of the macro—if well-chosen—
helps the reader understand the meaning of the constant. The alternative 1s à
program full of “’Magic numbers” that can easily mystify the reader.

u Îf makes programs easier to modify. We can change the value of a constant
throughout à program by modifying à single macro definition. “Hard-coded”
constants are morc difficult to change, especially since they sometimes appear
in a slightly altered form. (For example, a program with an array of length 100
may have à loop that goes from 0 to 99. If we merely try to locate occurrences
of 100 in the program, we*ll miss the 99.)

u Ît helps avoid inconsistencies and typographical errors. 1Ë a numerical con-
stant like 3.14159 appears many times in a program, chances are 1l will
occasionally be written 3.1416 or 3.14195 by accident.

Although simple macros are most often used to define names for constants.
they do have other applications:

u Makine minor changes to the syntax of C. We can—in cffect—alter the syn-
tax of C by defining macros that serve as alternate names for C symbols. For
example. programmers who prefer Pascal’s begin and end to C’s { and }
can define the following macros:

#define BEGIN ({
#define END }

We could go so far as to invent our own language. For example, we might cre-
ate a LOOP ‘statement” that establishes an infinite loop:

#define LOOP for (;;)
Changing the syntax of C usually isn’t a good idea, though, since it can make

programs harder for others to understand.
u Renaming types. In Section 5.2. we created a Boolean type by renaming int:

#define BOOL ant

type definillons » 7.5 Although some programmers use macros for this purpose, type definitions are
a superior way to define type names.

u Controlling conditional compilation. Macros play an important role in con-
trolling conditional compilation. as we’1l see in Section 14.4. For example, the
presence of the following line in a program might indicate that 1t’s to be com-

***************************page_346***************************
#de£ine directive
(parameterized macro)

/

14.3  Macro Definitions 321

piled in “debugging mode,’ with extra statements included to produce debug-
ging output:

#define DEBUG

Incidentally. it’s legal for a macro’s replacement list to be empty, as this exam-
ple shows.

When macros are used as constants, C programmers customarily capitalize all
letters in their names. However, there’s no consensus as to how to capitalize mac-
ros used for other purposes. Since macros (especially parameterized macros) can
be a source of bugs. some programmers like to draw attention to them by using all
upper-case letters in their names. Others prefer lower-case names, following the
style of Kernighan and Ritchie’s 7he C Programming Language.

Parameterized Macros

The definition of a parameterized macro (also known as a function-like macro)
has the form

tdefine identifier( x , X , … , X ) replacement-list
| 2 N

where x,, Æ, …, X, are identifiers (the macro’s parameters). The parameters may
appear as many times as desired in the replacement list.

 

There must be »o space between the macro name and the left parenthesis. If space
is left, the preprocessor will assume that we*re defining a simple macro; it will

treat (x;, X, , X,) as part of the replacement list.

 

When the preprocessor encounters the definition of a parameterized macro, it
stores the definition away for later use. Wherever a macro invocation of the form
identifier (y;, Va, 1 V,) appears later in the program (where v,. y,. ... }, are
sequences of tokens). the preprocessor replaces it with rep/acement-list. substitut-
ing y, for X,. y, for x,, and so forth.

For example. suppose that we've defined the following macros:

>

#define MAX (x, y) ) > (
) =2

( y) ? (x) : (y))
Hdefine IS EVEN(n) ( ==

(The number of parentheses in these macros may seem excessive, but there’s a rea-
son. as we'll see later in this section.) Now suppose that we invoke the two macros
in the following way:

i = MAX(j+k, m-n) ;
if (IS EVEN(i)) i++;

***************************page_347***************************
322

Chapter 14  The Preprocessor

<ctype .h> header » 23.5

æ

inline functions > 78.6

The preprocessor will replace these lines by

i = ((j+Kk)>(m-n)?(j+k) : (m-n) ) ;
if (((i)%2==0)) i++;

Âs this example shows, parameterized macros oflen serve as simple functions. MAX

behaves like a function that computes the larger of two values. IS_EVEN behaves

like a function that returns | if its argument is an even number and 0 otherwise.
Here's à more complicated macro that behaves like a function:

#define TOUPPER (c) ('a'<=(c)&&(c)<='z'?(c)-'a'+'A':(c))

This macro tests whether the character c is between 'a' and 'z'. IF so, 1t pro-
duces the upper-case version of c by subtracting 'a' and adding 'A'. If not, it
leaves c unchanged. (The <ctype .h> header provides a similar function named
toupper that’s more portable.)

À parameterized macro may have an empty parameter list. Here’s an example:

#define getchar() getc(stdin)

The empty parameter list isn’t really needed, but it makes getchar resemble a
function. (‘Yes, this is the same getchar that belongs to <stdio.h>. We’ll sec
in Section 22.4 that getchar 1s usually implemented as a macro as well as a
function.)

Using a parameterized macro instead of a true function has a couple of advan-
tages:

u The program may be slightly faster. À function call usually requires some
overhead during program execution—context information must be saved,
arguments copied, and so forth. À macro invocation, on the other hand,
requires no run-time overhead. (Note, however, that C99’s inline functions
provide a way to avoid this overhead without the use of macros.)

m Macros are “generie.” Macro parameters, unlike function parameters, have
no particular type. Às à result, a macro can accept arguments of any type, pro-
vided that the resulting program—after preprocessine—is valid. For example.
we could use the MAX macro to find the larger of two values of type int.
long, float, double, and so forth.

But parameterized macros also have disadvantages:

u The compiled code will often be larger. Each macro invocation causes the
insertion of the macro’s replacement list, thereby increasing the size of the
source program (and hence the compiled code). The more often the macro 1s
used, the more pronounced this effect is. The problem is compounded when
macro invocations are nested. Consider what happens when we use MAX to
find the largest of three numbers:

n = MAX(i, MAX(], kK));
Here’s the same statement after preprocessing:

n = ((3)>(((5)>(k)?(5) : (K))) ? (1) : (((9) > (K) ? (5) : (k) ) } ) ;;

***************************page_348***************************
14.3  Macro Definitions 323

m Arguments aren’t type-checked. When a function 1s called, the compiler

checks each argument to see if it has the appropriate type. If not, either the
argument Is converted to the proper type or the compiler produces an error
message. Macro arguments aren't checked by the preprocessor, nor are they
converted.

u Ît’s not possible to have a pointer to a macro. As we'll see in Section 17.7, C

allows pointers to functions, a concept thal’s quite useful in certain program-
ming situations. Macros are removed during preprocessing, so there’s no cor-
responding notion of “pointer to à macro”; as a result, macros can’t be used in
these situations.

u À macro may evaluate its arguments more than once. À function evaluates

its arguments only once; a macro may evaluate its arguments two or more
times. Evaluating an argument more than once can cause unexpected behavior
if the argument has side effects. Consider what happens if one of MAX’s argu-
ments has a side effect:

n = MAX(i++, j) ;
Here’s the same line after preprocessineg:
n = ((à++)>(3)?(i++):(9));

If à 1s larger than j, then i will be (incorrectly) incremented twice and n will
be assigned an unexpected value.

 

Errors caused by cvaluatine a macro argument more than once can be difficult to
find, because a macro invocation looks the same as a function call. To make mat-
ters worse, a macro may work properly most of the time, failing only for certain
arguments that have side effects. For self-protection, it’s a good idea to avoid side
effects in arguments.

 

Parameterized macros are good for more than just simulating functions. In

particular, they’re often used as patterns for segments of code that we find our-
selves repeating. Suppose that we grow tired of writing

print£f ("$d\n", i);

every time we need to print an integer i. We might define the following macro,
which makes 1t easier to display integers:

#define PRINT INT(n) printf("%d\n", n)

Once PRINT_INT has been defined, the preprocessor will turn the line

PRINT INT(i/j) ;

into

print£ ("*d\n", i/j);

***************************page_349***************************
324

Chapiter 14  The Preprocessor

Qa&A

The # Operator

Macro definitions may contain two special operators, # and ##. Neither operator is
recognized by the compiler: instead, they’re executed during preprocessing.

The # operator converts a macro argument into a string literal; it can appear
only in the replacement list of à parameterized macro. (The operation performed
by # Is known as “stringization” a term that m sure you won°{ find in the dictio-
nary.)

There are a number of uses for #; let’s consider just one. Suppose that we
decide to use the PRINT INT macro during debugging as a convenient way to
print the values of integer variables and expressions. The # operator makes it pos-
sible for PRINT INT to label each value that it prints. Here’s our new version of
PRINT INT:

f#idefine PRINT INT(n) printf (#n " = %d\n", n)

The # operator in front of n instructs the preprocessor to create a string literal from
PRINT INT ‘s argument. Thus, the invocation

PRINT _ INT(i/j) ;
will become
printf("i/j" "— %d\ﬁ", i/j)î

We saw in Section 13.1 that the compiler automatically joins adjacent string liter-
als, so this statement is equivalent to

print£f("i/j = %d\n", i/j);

When the program is executed. print£ will display both the expression i /j and
its value. If à is 11 and ; is 2, for example, the output will be

i/j = 5

The ## Operator

The ## operator can “paste” two tokens (identifiers, for example) together to form
a single token. (Not surprisingly. the ## operation is known as “token-pasting.”) If
one of the operands is a macro parameter, pasting occurs after the parameter has
been replaced by the corresponding argument. Consider the following macro:

#define MK ID(n) i##n

When MK_ID is invoked (as MK_ID(1). say), the preprocessor first replaces the
parameter n by the argument (1 In this case). Next, the preprocessor joins i and 1
to make a single token (i1). The following declaration uses MK_ ID to create three
identifiers:

int MK _ ID(1), MK ID({2), MK ID(3);

***************************page_350***************************
14.3  Macro Definitions 325

After preprocessing, this declaration becomes
int il, i2, i3;

The ## operator isn’t one of the most frequently used features of the prepro-
cessor; in fact, it’s hard to think of many'situations that require it. To find a realistic
apptication of ##, let's reconsider the MAX macro described earlier in this section.
As we observed then. MAX doesn’t behave properly 1f its arguments have side
effects. The alternative to using the MAX macro is to write a max function. Unfor-
tunately. one max function usually isn’t enough: we may need a max function
whose arguments are int values, one whose arguments are float values, and so
on. All these versions of max would be identical except for the types of the argu-
ments and the return type, so it seems a shame to define each one from scratch.

The solution is to write a macro that expands into the definition of a max func-
tion. The macro will have a single parameter, type. which represents the type of
the arguments and the return value. There's just one snag: 1f we use the macro to
create more than one max function, the program won't compile. (C doesn’t allow
two functions to have the same name 1f both are defined in the same file.) To solve
this problem, we’1l use the ## operator to create a different name for each version
of max. Here’s what the macro will look like:

#define GENERIC MAX (type) \
type typet# max(type x, type y) \
{ \

return x > y ? x : y; \
}

Notice how type is joined with _max to form the name of the function.
Suppose that we happen to need a max function that works with £loat val-
ues. Here’s how we’d use GENERIC MAX lo define the function:

GENERIC MAX (float)
The preprocessor expands this line into the following code:

float float max(float x, £loat y) { return x > y ? x : y: }

General Properties of Macros

Now that we’ve discussed both simple and parameterized macros. let’s look at
some rules that apply to both:

m À macro’s replacement list may contain invocations of other macros. For
example. we could define the macro TWO_ PI in terms of the macro PI:

#define PI 3.14159
#define TWO _ PI (2*PI)

When it encounters TWO_PI later in the program, the preprocessor replaces t
by (2*PI). The preprocessor then rescans the replacement list to see 1if 11

***************************page_351***************************
326

Chapter 14  The Preprocessor

QaA

#undef£ directive

contains invocations of other macros (PI. in this case). The preprocessor will
rescan the replacement list as many times as necessary to eliminate all macro
names.

The preprocessor replaces only entire tokens, not portions of tokens. Às a
result, the preprocessor ignores macro names that are embedded in identifiers,
character constants, and string literals. For example, suppose that a program
contains the following lines:

#define SIZE 256
int BUFFER SIZE;

if (BUFFER SIZE > SIZE)
puts ("Error: SIZE exceeded") ;

After preprocessing, these lines will have the following appearance:
int BUFFER SIZE;

if (BUFFER SIZE > 256)
puts ("Error: SIZE exceeded") ;

The identifier BUFFER_SIZE and the string "Error: SIZE exceeded"
weren't affected by preprocessing, even though both contain the word SIZE.

u À macro definition normally remains in effect until the end of the file in

which it appears. Since macros are handled by the preprocessor. they don”
obey normal scope rules. À macro defined inside the body of a function isn't
local to that function: 1t remains defined until the end of the file.

u À 7nacro may not be defined twice unless the new definition is identical to

the old one. Differences in spacing are allowed, but the tokens in the macro’s
replacement list (and the parameters, 1f any) must be the same.

u Macros may be “undefined” by the Funde£ directive. The funde£ direc-

tive has the form

Hunde£ identifier

where identifier is a macro name. For example, the directive

#undef N

removes the current definition of the macro N. (If N hasn’t been defined as a
macro, the #undef directive has no effect.) One use of #undef 1s to remove
the existing definition of a macro so that it can be given a new definition.

Parentheses in Macro Definitions

The replacement lists in our macro definitions have been full of parentheses. Is it
really necessary to have so many? The answer is an emphatic yes; 1f we use fewer

***************************page_352***************************
14.3  Macro Definitions 327

parentheses, the macros will sometimes give unexpected—and undesirable—
results.

There are two rules to follow when deciding where to put parentheses in a
macro definition. First, if the macro’s replacement list contains an operator. always
enclose the replacement list in parentheses:

#define TWO PI (2#*3.14159)

Second, if the macro has parameters, put parentheses around each parameter every
time it appears in the replacement list:

#define SCALE(x) ((x)*10)

Without the parentheses, we can*t guarantee that the compiler will treat replace-
ment lists and arguments as whole expressions. The compiler may apply the rules
of operator precedence and associativity in ways that we didn’t anticipate.

To illustrate the importance of putting parentheses around a macro’s replace-
ment list, consider the following macro definition, in which the parentheses are
missing:

#define TWO PI 2*3.14159
/* needs parentheses around replacement list */

During preprocessing, the statement
conversion factor = 360/TWO_PI;
becomes

conversion factor = 360/2*3.14159;

The division will be performed before the multiplication, yielding à result different
from the one intended.

Putting parentheses around the replacement list isn’t enough 1f the macro has
parameters—each occurrence of a parameter needs parentheses as well. For exam-
ple, suppose that SCALE 1s defined as follows:

#+define SCALE(x) (x*10) /* needs parentheses around x */
During preprocessing, the statement

j = SCALE(1i+1) ;

becomes

} = (i+1*10);

Since multiplication takes precedence over addition, this statement is equivalent to
j = i+10;

Of course, what we wanted was

j = (i+1)#*10;

***************************page_353***************************
328

Chapter 14  The Preprocessor

/N

 

À shortage of parentheses in a macro definition can cause some of C's most frus-
trating errors. The program will usually compile and the macro will appear to
work, failing only at the least convenient times.

 

Creating Longer Macros

The comma operator can be useful for creating more sophisticated macros by
allowing us to make the replacement list a series of expressions. For example, the
following macro will read a string and then print it:

#define ECHO(s) (gets(s), puts(s))

Calls of gets and puts are expressions, so it’s perfectly legal to combine them
using the comma operator. We can invoke ECHO as though it were à function:

ECHO (str) ; /* becomes (gets(str), puts(str)); */

Instead of using the comma operator in the definition of ECHO. we could have
enclosed the calls of gets and puts in braces to form a compound statement:

#define ECHO(s) { gets(s); puts(s); }

Unfortunately, this method doesnt work as well. Suppose that we use ECHO in an
i £ statement:

if (echo £lag)
ECHO (str) ;
else
gets (str) ;

Replacing ECHO gives the following result:

if (echo flag)

{ gets(str) ; puts(str); };
else

gets (str) ;

The compiler treats the first two lines as a complete 1 £ statement:

if (echo flag)
{ gets(str); puts(str) ; }

[t treats the semicolon that follows as a null statement and produces an error mes-
sage for the else clause, since it doesn’t belong to any i f. We could solve the
problem by remembering not to put a semicolon after each invocation of ECHO,
but then the program would look odd.

The comma operator solves this problem for ECHO, but not for all macros.
Suppose that à macro needs to contain a series of statements, not just à series of
expressions. The comma operator is of no help: it can glue together expressions.

***************************page_354***************************
Table 14.1
Predefined Macros

14.3  Macro Definitions 329

but not statements. The solution 1s to wrap the statements in a do loop whose con-
dition is false (and which therefore will be executed just once):

do { … } while (o)

Notice that the do statement isn°{ complete—it needs a semicolon at the end. To
see this trick (ahem, technique) in action, let’s incorporate it into our ECHO macro:

#define ECHO(s) \
do { \
gets(s); \
puts(s); \

} while (0)

When ECHO is used, it must be followed by a semicolon. which completes the do
statement:

ECHO (str) ;
/* becomes do { gets(str); puts(str); } while (0); */

Predetfined Macros

C has several predefined macros. Each macro represents an integer constant or
string literal. As Table 14.1 shows, these macros provide information about the
current compilation or about the compiler itself.

 

 

 

 

Name Description
__ LINE _ Line number of file being compiled
__ FILE . — Name of file being compiled
__DATE__  Date of compilation (in the form "Mmm dd yyyy")
__TIME _ Time of compilation (in the form "hh:mm:ss")
__STDC___ 1 if the compiler conforms to the C standard (C89 or C99)

 

The _DATE _and_ TIME _ macros identify when a program was com-
piled. For example, suppose that a program begins with the following statements:

print£ ("Wacky Windows (c) 2010 Wacky Software, Inc.\n") ;
printf ("Compiled on %s at %s\n"', __DATE__, __ TIME _ } ;

Each time it begins to cxecute, the program will print two lines of the form

Wacky Windows (c) 2010 Wacky Software, Inc.
Compiled on Dec 23 2010 at 22:18:48

This information can be helpful for distinguishing among different versions of the
same program.

We can use the C LINE = and__ FILE — macros to help locate errors.
Consider the problem of detecting the location of a division by zero. When a C
program terminates prematurely because it divided by zero, there’s usually no indi-
cation of which division caused the problem. The following macro can help us pin-
point the source of the error:

***************************page_355***************************
330 Chapter 14

assert macro >24.,1

æ

Table 14.2
Additional Predefined
Macros in C99

complex types > 27.3

QaÂ

The Preprocessor

#define CHECK ZERO(divisor) \
Lif (divisor == O) \
print£f("*** Attempt to divide by zero on line %d " \
"of file %s ***\n"', _ LINE , _ FILE }

The CHECK _ZERO macro would be invoked prior to à division:

CHECK _ZERO(j) ;
k = i / j;

If j happens to be zero, à message of the following lform will be printed:
x** Attempt to divide by zero on line 9 of file foo.c ***

Error-detecting macros like this one are quite useful. In fact, the C library has a
general-purpose error-detecting macro named assert.

The _ STDC _ macro exists and has the value ! 1f the compiler conforms to
the C standard (either C89 or C99). By having the preprocessor test this macro, a
program can adapt to a compiler that predates the C89 standard (see Section 14.4
[or an example).

Additional Predefined Macros in C99
C99 provides a few additional predefined macros (Table 14.2).

 

 

Name Description

__STDC __HOSTED _ | 1F thris 1s a hosted implementation; O 1f it is
freestanding

__STDC __VERSION _ Version of C standard supported

__STDC IEC 559 | if IEC 60559 floating-point arithmetic is
supported

_ _STDC IEC 559 COMPLEX ‘ 1 if IEC 60559 complex arithmetic is supported

__STDC _ ISO 1064 6__* yyyymmiL if wchar t values match the ISO

 

10646 standard of the specified year and month

 

‘Conditionally defined

To understand the meaning of __ STDC__HOSTED__, we need some new
vocabulary. An implementation of C consists of the compiler plus other software
necessary to execute C programs. C99 divides implementations into two catego-
ries: hosted and freestanding. À hosted implementation must accept any program
that conforms to the C99 standard. whereas a freestanding ünplementation
doesn't have to compile programs that use complex types or standard headers
beyond a few of the most basic. (In particular, a freestanding implementation
doesn’t have to support the <stdio.h> header.) The _ STDC __HOSTED _
macro represents the constant 1 if the compiler 1s a hosted implementation: other-
wise, the macro has the value 0.

The __ STDC__VERSION _ macro provides a way to check which version
of the C standard is recognized by the compiler. This macro first appeared in
Amendment ! to the C&9 standard, where its value was specified to be the lons

 

***************************page_356***************************
IEEE floating-point standard > 7.2

wchar_t type »25.2
ISO/IEC 10646 standard »25.2

æ

14.3  Macro Definitions 331

integer constant 199409L (representing the year and month of the amendment). If
a compiler conforms to the C99 standard, the value is 199901L. For each subse-
quent version of the standard (and each amendment to the standard), this macro
will have a different value.

A C99 compiler may (or may not) define three additional macros. Each macro
is defined only 1f the compiler meets à certain requirement:

u — STDC IEC 559 __ is defined (and has the value !) if the compiler per-
forms floating-point arithmetic according to the IEC 60559 standard (another
name for the IEEE 754 standard).

=s — STDC IEC 559 COMPLEX __ is defined (and has the value 1) if the

compiler performs complex arithmetic according to the IEC 60559 standard.
n STDC _ ISO 10646 __ is defined as an integer constant of the form

y_ÎyymmL (for example, 199712L) 1f values of type wchar _ t are repre-
sented by the codes in the ISO/IEC 10646 standard (with revisions as of the

specified year and month).

 

 

Empty Macro Arguments

C99 allows any or all of the arguments in a macro call to be empty. Such a call will
contain the same number of commas as a normal call, however. (That way, 1t's easy
to sce which arguments have been omitted.)

In most cases, the effect of an empty argument is clear. Wherever the corre-
sponding parameter name appears in the replacement list. il’s replaced by noth-
ing—it simply disappears from the replacement list. Herc’s an example:

#define ADD(x,y) (x+y)
After preprocessing, the statement
i = ADD(j,k);

becomes

i = (j+k);

whereas the statement

i = ADD(,k);

becomes

i = (+k);

When an empty argument is an operand of the # or ## operators, special rules
apply. If an empty argument is “stringized” by the # operator. the result 1s "" (the
empty string):

#define MK STR(x) #x

char empty _string[] = MK _STR() ;

***************************page_357***************************
332

Chapter 14  The Preprocessor

æ

variable-lengih argument lists
»-26.1

After preprocessing, the declaration will have the following appearance:
char empty_string[] = "";

If one of the arguments of the ## operator is empty. it’s replaced by an invisi-
ble “placemarker” token. Concatenating an ordinary token with a placemarker
token yields the original token (the placemarker disappears). If two placemarker
tokens are concatenated, the result is a single placemarker. Once macro expansion
has been completed, placemarker tokens disappear from the program. Consider the
following example:

fdefine JOIN(x,y,z) x#iyHkz

int JOIN(a,b,c), JOIN(a,b,), JOIN(a,,c), JOIN(,,c);
After preprocessing, the declaration will have the following appearance:
int abc, ab, ac, C;

The missing arguments were replaced by placemarker tokens, which then disap-
peared when concatenated with any nonempty arguments. AIl three arguments to
the JOIN macro could even be missing, which would yield an empty result.

Macros with a Variable Number of Arguments

In C89, a macro must have a fixed number of arguments, if it has any at all. C99
loosens things up a bit, allowing macros that take an unlimited number of areu-
ments. This feature has long been available for functions, so it’s not surprising that
macros were finally put on an equal footing.

The primary reason for having a macro with a variable number of arguments is
that it can pass these arguments to a f'unction that accepts a variable number of
arguments. such as print£ or scan£. Here’s an example:

#define TEST(condition, ...) ((condition)? \
print£ ("Passed test: %s\n"', #condition): \
print£f(_ _ VA ARGS___))

The . . . token, known as ellipsis, goes at the end of a macro’s parameter list, pre-
ceded by ordinary parameters, if there are any.__ VA ARGS __ is a special identi-
fier that can appear only tn the replacement list of a macro with a variable number
of arguments; il represents all the arguments that correspond to the ellipsis. (There
must be at least one argument that corresponds to the ellipsis, although that argu-
ment may be empty.) The TEST macro requires at leust two arguments. The first
argument matches the condition parameter: the remaining arguments match
the ellipsis.
Here's an example that shows how the TEST macro might be used:

TEST (voltage <= max voltage,
"Voltage %d exceeds %d\n", voltage, max voltage) ;

The preprocessor will produce the following output (reformatted for readability):

***************************page_358***************************
14.4

14.4  Conditional Compilation 333

((voltage <= max voltage)?
printf ("Passed test: %s\n", "voltage <= max voltage") :
printf ("Voltage %d exceeds %d\n", voltage, max _ voltage)) ;

When the program is executed, the program will display the message
Passed test: voltage <= max voltage

if voltage is no more than max_voltage. Otherwise, it will display the values
of voltage and max_voltage:

Voltage 125 exceeds 120

The —func  Identifier

Another new feature of C99 is the __ _func___ identifier. _ func__ has nothing
to do with the preprocessor, so it actually doesn’t belong in this chapter. However,
like many preprocessor features, it’s useful for debugging, so l've chosen to dis-
cuss it here.

Every function has access to the __ func __ identifier, which behaves like a
string variable that stores the name of the currently executing function. The effect
is the same as if each function contains the following declaration at the beginning
of its body:

 

static const char _ func_ [] = "function-name" ;

where function-name is the name of the function. The existence of this identifier
makes it possible to write debugging macros such as the following:

#define FUNCTION CALLED() print£f("%s called\n", __fune__);
#define FUNCTION RETURNS() print£f("%s returns\n", __func_ );

Calls of these macros can then be placed inside functions to trace their calls:

void f (void)

{

FUNCTION CALLED () ; /* displays "£ called" */

FUNCTION RETURNS(); /* displays "f returns" */

}

Another use of _ func _ : it can be passed to a function to let it know the name
of the function that called it.

Conditional Compilation

The C preprocessor recognizes a number of directives that support condifional
compilation—the inclusion or exclusion of a section of program text depending on
the outcome of a test performed by the preprocessor.

***************************page_359***************************
334

Chapter 14  The Preprocessor

#i £ directive

#endi £ directive

The #i f and #endi £ Directives

Suppose we're in the process of debugging a program. We'd like the program to
print the values of certain variables, so we put calls of print£ in critical parts of
the program. Once we've located the bugs, it's often a good idea to let the print f
calls remain, just in casc we need them later. Conditional compilation allows us to
leave the calls in place, but have the compiler ignore them.

Here’s how we'Il proceed. We'll first define a macro and give it a nonzero
value:

#define DEBUG 1

The name of the macro doesn't matter. Next. we'll surround cach group of
print£ calls by an #i f-#endi£ pair:

#Hif DEBUG

print£ ("Value of i: %$d\n", i),;
print£ ("Value o£f j: %d\n", j);
tendif

During preprocessing. the #i£ directive will test the value of DEBUG. Since its
value isn’t zero. the preprocessor will leave the two calls of print£ in the pro-
gram (the #i£ and #endi£ lines will disappear. though). If we change the value
of DEBUG to zero and recompile the program, the preprocessor will remove all
four lines from the program. The compiler won°t see the calls of printf. so they
won't occupy uny space in the object code and won't cost any time when the pro-
gram is run. We can leave the #i f-#endi£ blocks in the final program, allowing
diagnostic information to be produced later (by recompiling with DEBUG set to |)
if any problems turn up.
In general, the #1 £ directive has the form

HI£ constant-expression

The #endi£ directive is even simpler:

#endif

When the preprocessor encounters thé #i£ directive, it evaluates the constant
expression. [[ the value of the expression is zero, the lines between #if and
tendif will be removed from the program during preprocessing. Otherwise, the
lines between #i £ and #endi£ will remain in the program to be processed by the
compiler—the #i£ and tendif will have had no effect on the program.

It's worth noting that the #i £ directive treats undefined identifiers as macros
that have the value O. Thus, 1f we neglect to define DEBUG, the test

#1i£ DEBUG

***************************page_360***************************
#i fdef directive

QaÂ

144  Conditional Compilation 335

will fail (but not generate an error message). while the test
#i£f !DEBUG

will succeed.

The defined Operator

We encountered the # and ## operators in Section 14.3. There’s just one other
operator. def ined. that’s specific to the preprocessor. When applied to an identi-
fier, def ined produces the value | if the identifier is a currently defined macro; it
produces O otherwise. The de£fined operator is normally used in conjunction
with the #i £ directive; it allows us to write

Hif defined (DEBUG)
#endif

The lines between the #i f and #endi £ directives will be included in the program
only if DEBUG is defined as a macro. The parentheses around DEBUG aren (
required; we could simply write

#if defined DEBUG

Since defined tests only whether DEBUG is defined or not, it’‘s not neces-
sary to give DEBUG a value:

Hdefine DEBUG

The #i fdef and #i fnde£f Directives

The #i fdef directive tests whether an identifier is currently defined as a macro:
#i fdef identifier

Using #i fde£ is similar to using #iÉ:

#ifde£ identifier
Lines to be included if identifier is defined as a macro
tendif

Strictly speaking, there’s no need for #ifdef, since we can combine the #if
directive with the def ined operator to get the same effect. In other words, the
directive

#ifde£ identifier
is equivalent to

#if£f defined (identifier)

***************************page_361***************************
336 Chapter 14  The Preprocessor

#i fndef directive

#elif directive

#else directive

The #i fnde£ directive is similar to #ifdef, but tests whether an identifier
1S HOf defined as a macro:

#ifnde£ identifier

Writing
Hifnde£ identifier
is the same as writing

#Hi£ !defined (identifier)

The #eli f and #e1se Directives

#if, #ifde£, and #ifndef blocks can be nested just like ordinary i £ state-
ments. When nesting occurs, it’s a good idea to use an increasing amount of inden-
tation as the level of nesting grows. Some programmers put a comment on each
closing #endi£ to indicate what condition the matching #i f tests:

#if DEBUG

#endif /* DEBUG */

This technique makes it easier for the reader Lo find the beginning of the #i £ block.
For additional convenience, the preprocessor supports the #e1 i £ and #else
directives:

Helif constant-expression

#else

#elif and #else can be used in conjunction with #i f, #i Fde£, or #ifnaef
to test a series of conditions:

#i£ expr!

Lines 10 be included if exprl is nonzero

Heli£ expr2

Lines to be included if exprl is zero but expr2 is nonzero
#else

Lines to be included otherwise

tendif

Although the #Hi£ directive is shown above, an #ifdef or #ifndef directive
can be used instead. Any number of #el i £ directives—but at most one #e1 se—
may appear between #i f and #endif.

***************************page_362***************************
144  Conditional Compilation 337

Uses of Conditional Compilation

Conditional compilation is certainly handy for debugging, but its uses don't stop
there. Here are a few other common applications:

= Writing programs that are portable to several machines or operating sys-
tems. The following example includes one of three groups of lines depending
on whether WIN32, MAC_OS, or LINUX is defined as a macro:

#if£f defined (WIN32)
gelif defined (MAC_OS)
Âelif defined (LINUX)
%endif

A program might contain many of these #i£ blocks. Ât the beginning of the
program, one (and only one) of the macros will be defined, thereby sclecting a
particular operating system. For example, defining the LINUX macro might
indicate that the program is to run under the Linux operating system.

= Writing programs that can be compiled with different compilers. Different
compilers often recognize somewhat different versions of C. Some accept a
standard version of C. some don’t. Somé provide machine-specific language
extensions: some don’t. or provide a different set of extensions. Conditional
compilation can allow a program to adjust to different compilers. Consider the
problem of writing à program that might have to be compiled using an older,
nonstandard compiler. The __ STDC __ macro allows the preprocessor to
detect whether a compiler conforms to the standard (either C89 or C99): 1f 1t
doesn‘t, we may need to change certain aspects of the program. In particular,
we may have to use old-style function declarations (discussed in the Q&A at
the end of Chapter 9) instead of function prototypes. At each point where
functions are declared. we can put the following lines:

#i£ _ STDC _

Function prototypes

#else

Old-style function declarations
Hendif

= Providing a default definition for a macro. Conditional compilation allows
us to check whether a macro is currently defined and, if not, give it a default
definition. For example, the following lines will define the macro
BUFFER SIZE if it wasn’t previously defined:

#ifndef BUFFER SIZE
#define BUFFER SIZE 256
#endif

***************************page_363***************************
338

Chapter 14  The Preprocessor

Qaâ

14.5

#error directive

IT_MAX macro >23.2

= lemporarily disabling code that contains comments. We can‘tuse a / *.* /
comment to “comment out” code that already contains /*...*/ comments.
Instead. we can use an #i f directive:

#Hif£ O
Lines containine comments
tendif

Disabling code in this way is often called ‘“conditioning out.”

Section 15.2 discusses another common use of conditional compilation: pro-
tecting header files against multiple inclusion.

Miscellaneous Directives

To end the chapter, we'Il take a brief look at the #error, #1 ine, and #pragma
directives. These directives are more specialized than the ones we’ve already
examined, and they’re used much less frequently.

The #error Directive

The #error directive has the form

Herror message

where message is any sequence of tokens. If the preprocessor encounters an
#error directive, it prints an error message which must include message. The
exact form of the error message can vary from one compiler to another; it might be
somethinge like

Error directive: nmiexsage
or perhaps just
#error message

Encountering an #error directive indicates a serious flaw in the program; some
compilers immediately terminate compilation without attempting to find other
errors.

terror directives are frequently used in conjunction with conditional com-
pilation to check for situations that shouldn’t arise during a normal compilation.
For example, suppose that we want lo ensure that a program can*t be compiled on
a machine whose int type isn’t capable of storing numbers up to 100,000. The
largest possible int value is represented by the INT_MAX macro, so all we need
do 1s invoke an #error directive if INT MAX 1sn’t at least 100,000:

***************************page_364***************************
#1ine directive
(form 1)

œ

#l1ine directive
(form 2)

14.5  Miscellaneous Directives 339

#if INT MAX < 100000
#error int type is too small
#endif

Attempting to compile the program on a machine whose integers are stored in I6
bits will produce a message such as

Error directive: int type is too small

The #error directive is often found in the #else part of an #if-#eli£-
#else series:

Hif defined (WIN32)

telif defined (MAC OS)

#elif defined (LINUX)

#else

#error No operating system specified
#endif

The #1 ine Directive

The #1 ine directive is used to alter the way program lines are numbered. (Lines
are usually numbered |, 2. 3, as you'd expect.) We can also use this directive Lo
make the compiler think that it’s reading the program from a file with a different
name.

The #1 ine directive has two forms. In one form, we specify a line number:

#line n

n must be a sequence of digits representing an integer between | and 32767
(2147483647 in C99). This directive causes subsequent lines in the program to be
numbered n, n + 1, n + 2, and so forth.

In the second form of the #1 ine directive, both a line number and a file name
are specified:

#line n "file"

The lîines that follow this directive are assumed to come from file, with line num-
bers starting at n. The values of n and/or the file string can be specified using mac-
ros.

One effect of the #l ine directive is to change the value ofthe __ LINE —
macro (and possibly the __ FILE _ macro). More importantly. most compilers
will use the information from the #1 ine directive when generating error messages.

***************************page_365***************************
340 Chapter 14  The Preprocessor

#pragma directive

For example. suppose that the following directive appears at the beginning of the
file foo. c:

#line 10 "bar.c"

Let's say that the compiler detects an error on line 5 of foo. c. The error message
will refer to line 13 of file bar . c, not line 5 of file foo.c. (Why line 13? The
directive occupies line ! of £oo. c, so the renumbering of Foo. c begins at line 2,
which is treated as line 10 of bar .c.)

A1 first glance, the #l1ine directive is mystifying. Why would we want error
messages to refer to a different line and possibly a different file? Wouldn*t this
make programs harder to debug?

In fact, the #1ine directive isn’t used very often by programmers. Instead,
1l's used primarily by programs that generate C code as output. The most famous
example of such a program is yacc (Yet Another Compiler-Compiler). a UNIX
utility that automatically generates part of a compiler. (The GNU version of yacc
Is named bison.) Before using yacc, the programmer prepares a file that con-
tains information for yacc as well as fragments of C code. From this file. yacc
generates a C program, y . tab. c, that incorporates the code supplied by the pro-
grammer. The programmer then compiles y . tab. c in the usual way. By inserting
#line directives in y.tab.c, yacc tricks the compiler into believing that the
code comes from the original file—the one written by the programmer. As a result,
any error messages produced during the compilation of y.tab.c will refer to
lines in the original file, not lines in y.tab.c. This makes debugging easier,
because error messages refer to the file written by the programmer, not the (more
complicated) file generated by yacc.

The #pragma Directive

The #pragma directive provides a way to request special behavior from the com-
piler. This directive is most useful for programs that arc unusually large or that
need to take advantage of the capabilities of à particular compiler.

The #pragma directive has the form

#pragma tokens

where /okens are arbitrary tokens. #pragma directives can be very simple (a sin-
gle token) or they can be much more elaborate:

tpragma data(heap_size => 1000, stack size => 2000)

Not surprisingly, the set of commands that can appear in #pragma directives
is different for each compiler; you’Il have to consult the documentation for your
compiler to see which commands it allows and what those commands do. Inciden-
tally, the preprocessor must ignore any #pragma directive that contains an unrec-
ognized command: it’s not permitted to give an error message.

***************************page_366***************************
æ

æ

_Pragma expression

145  Miscellaneous Directives 341

In C89, there are no standard pragmas—they're all implementation-defined.
C99 has three standard pragmas, all of which use STDC as the first token following
#pragma. These pragmas are FP CONTRACT (covered in Section 23.4),
CX _ LIMITED RANGE (Section 27.4), and FENV ACCESS (Section 27.6).

The Pragma Operator

C99 introduces the _Pragma operator, which is used in conjunction with the
#pragma directive. À _ Pragma expression has the form

_Pragma ( srring-literal )

When it encounters such an expression, the preprocessor “destringizes” the string
literal (yes, that’s the term used in the C99 standard!) by removing the double
quotes around the string and replacing the escape sequences \" and \\ by the
characters " and \, respectively. The result is a series of tokens, which are then
treated as though they appear in a #pragma directive. For example, writing

_ Pragma ("data (heap_size => 1000, stack _size => 2000)")
is the same as writing
tpragma data(heap size => 1000, stack size => 2000)

The _Pragma operator lets us work around a limitation of the preprocessor:
the fact that a preprocessing directive can‘t generate another directive. _Pragma.
however, is an operator, not a directive, and can therefore appear in a macro defini-
tion. This makes it possible for a macro expansion to leave behind a #pragma
directive.

Let’s look at an example from the GCC manual. The following macro uses the
_Pragma operator:

#define DO PRAGMA(x) _Pragma (#x)
The macro would be invoked as follows:

DO PRAGMA (GCC dependency "parse.y")
After expansion, the result will bc

#pragma GCC dependency "parse.y"

which is one of the pragmas supported by GCC. (It issues a warning if the date of
the specified fFle—parse. y in this example—is more recent than the date of the
current file—the one being compiled.) Note that the argument to the call of
DO _PRAGMA is à series of tokens. The # operator in the definition of DO_PRAGMA
causes the tokens to be stringized into "GCC dependency \"parse.y\"":
this string is then passed to the _Pragma operator, which destringizes it, produc-
ing à #pragma directive containing the original tokens.

***************************page_367***************************
342

Chapter 14  The Preprocessor

> ©

Q & À

Pve scen programs that contain a # on a line by itself. Is this legal?

Yes. This 1s the null directive; it has no cffect. Some programmers use null direc-
tives for spacing within conditional compilation blocks:

#if INT MAX < 100000
#

terror int type is too small

#
tendif

Blank lines would also work, of course, but the # helps the reader see the extent of
the block.

l’m not sure which constants in a program need to be defined as macros. Are
there any guidelines to follow? [p. 319]

One rule of thumb says that every numeric constant, other than O or }, should be a
macro. Character and string constants are problematic, since replacing a character
or string constant by a macro doesn’t always improve readability. 1 recommend
using a macro instead of a character constant or string literal provided that (1) the
constant is used more than once and (2) the possibility exists that the constant
might someday be modified. Because of rule (2). I don’t use macros such as

#+define NUL '\0!'

although some programmers do.

What does the # operator do if the argument that it’s supposed to ““stringize”
contains a " or \ character? [p. 324]

It converts " to \" and \ to \\. Consider the following macro:
#define STRINGIZE(x) #x

The preprocessor will replace STRINGIZE ("£oo") by "\"£oo\"".

I can°t get the following macro to work properly:
#define CONCAT (x,y) x##vy

CONCAT (a,b) gives ab, as expected, but CONCAT (a, CONCAT (b, c ) ) gives
an odd result. What’s going on?

Thanks to rules that Kernighan and Ritchie call “bizarre;’ macros whose replace-
ment lists depend on ## usually can’t be called in a nested fashion. The problem is
that CONCAT (a, CONCAT (b, c) ) isn'{ expanded in a ‘normal” fashion, with
CONCAT (b, C) yielding bc, then CONCAT (a, bc) giving abc. Macro parame-
ters that are preceded or followed by ## in à replacement list aren°t expanded at

***************************page_368***************************
saqrt function »23.3

Q & À 343

the time of substitution. As a result. CONCAT (a, CONCAT (b, c) ) expands to
aCONCAT (b, c). which can’t be expanded further, since there’s no macro named
acoONCAT.

There’s a way to solve the problem, but it’s not pretty. The trick is to define a
second macro that simply calls the first one:

#define CONCAT2(x,y) CONCAT (x,y)

Writing CONCAT2 (a, CONCAT2 (b, c) ) now yields the desired result. As the
preprocessor expands the outer call of CONCAT2, it will expand CONCAT2 (b, C)
as well: the difference is that CONCAT2’s replacement list doesn't contain ##. If
none of this makes any sense, don‘t worry; it’s not a problem that arises often.

The # operator has a similar difficulty, by the way. If #x appears in a replace-
ment list, where x is a macro parameter, the corresponding argument is not
expanded. Thus, if N is a macro representing 10, and STR (x) has the replacement
list #x, expanding STR(N) yields "N", not "10". The solution is similar to the
one we used with CONCAT: defining a second macro whose job 1s to call STR.

Suppose that the preprocessor encounters the original macro name during
rescanning, as in the following example:

#define N (2*M)
#define M (N+1)

i = N; /* infinite 1oop? */

The preprocessor will replace N by (2*M), then replace M by (N+1). Will the
preprocessor replace N again, thus going into an infinite loop? [p. 326]

Some old preprocessors will indeed go into an infinite loop, but newer ones
shouldn*t. According to the C standard, if the original macro name reappears dur-
ing the expansion of a macro, the name is not replaced again. Here’s how the
assignment to i will look after preprocessing:

i = (2*(N+1));

Some enterprising programmers take advantage of this behavior by writing
macros whose names match reserved words or functions in the standard library.
Consider the sqrt library function. sqrt computes the square root of its argu-
ment, returning an implementation-defined value if the argument is negative. Per-
haps we would prefer that sqrt return O if its argument is negative. Since sqrt£ is
part of the standard library. we can°t easily change it. We can, however, define a
sart macro that evaluates to 0 when given a negative argument:

fundef£ sqrt
#define sqrt (x) ((x)>=0?sgrt (x) :0)

ÀA later call of sqrt will be intercepted by the preprocessor, which expands 1t into
the conditional expression shown here. The call of sqrt inside the conditional
expression won't be replaced during rescanning, so it will remain for the compiler

***************************page_369***************************
344

Chapter 14  The Preprocessor

to handle. (Note the use of #unde£ 10 undefine sqrt before defining the sqrt
macro. Às we'Il see in Section 21.1, the standard library is allowed to have both a
macro and a function with the same name. Undefining sqrt before defining our
own sqrt macro is a defensive measure, in case the library has already defined
sqrt as a macro.)

1 get an error when I try to use predefined macros suchas _ LINE — and
__FILE , Is there a special header that I need to include?

No. These macros are recognized automatically by the preprocessor. Make sure that
you have Mwo underscores at the beginning and end of each macro name, not one.

What’s the purpose of distinguishing between a ‘“hosted implementation” and
à ““freestanding implementation”? If a freestanding implementation doesn°t
even support the <stdio.h> header, what use is it? [p. 330]

À hosted implementation is needed for most programs (including the ones in this
book), which rely on the underlying operating system for input/output and other
essential services. À freestanding implementation of C would be used for pro-
grams that require no operating system (or only a minimal operating system). For
example, a freestanding implementation would be needed for writing the kernel of
an operating system (which requires no traditional input/output and therefore
doesn’t need <stdio.h> anyway). Freestanding implementations are also useful
for writinge software for embedded systems.

I thought the preprocessor was just an editor. How can it evaluate constant
expressions? [p. 334]

The preprocessor is more sophisticated than you might expect; it knows enough
about C to be able to evaluate constant expressions, although it doesn’t do so in
quite the same way as the compiler. (For one thing, the preprocessor treats any
undefined name as having the value 0. The other differences are too esoteric to go
into here.) In practice, the operands in a preprocessor constant expression are usu-
ally constants, macros that represent constants. and applications of the defined
operator.

Why does C provide the #i £de£ and #i fnde£ directives, since we can get
the same effect using the #i £ directive and the defined operator? [p. 335]

The #i fde£ and #i fndef directives have been a part of C since the 1970s. The
defined operator, on the other hand, was added to C in the 1980s during stan-
dardization. So the real question is: Why was defined added to the language?
The answer is that de£fined adds flexibility. Instead of just being able to test the
existence of a single macro using #ifde£ or #ifndef, we can now test any
number of macros using #i£ together with defined. For example. the following
directive checks whether FOO and BAR are defined but BAZ is not defined:

#if defined(FOO) && defined(BAR) && !defined(BAZ)

***************************page_370***************************
Section 14.3

l.

e

© »5.

Exercises 345

I wanted to compile a program that [ hadn*t finished writing, so I ‘“condi-
tioned out” the unfinished part:

Hif O
#endif

When I compiled the program, I got an error message referring to one of the
lines between #if and #endi£. Doesn’t the preprocessor just ignore these
lines? [p. 338]

No, the lines aren’t completely ignored. Comments are processed before prepro-
cessing directives are executed, and the source code is divided into preprocessing
tokens. Thus, an unterminated comment between #if and #endi £ may cause an
error message. Also, an unpaired single quote or double quote character may cause
undefined behavior.

Exercises

Write parameterized macros that compute the following values.

(a) The cube of x.
(b) The remainder when n 1s divided by 4.
(c) 1 if the produet of x and y is less than 100, À otherwise.

Do your macros always work? If not, describe what arguments would make them fail.

Write a macro NELEMS (a) that computes the number of elements in a one-dimensional
array a. Hint: See the discussion of the sizeof operator in Section 5.1.

Let DOUBLE be the following macro:
#define DOUBLE(x) 2*x

(a) What is the value of DOUBLE (1+2) ?
(b) What 1s the value of 4/DOUBLE (2) ?
(c) Fix the definition of DOUBLE.

For each of the following macros, give an example that illustrates à problem with the macro

and show how to fix it.

(a) #define AVG(x,y) (x-y)/2
(b) #define AREA(x,y) (x)*(y)

Let TOUPPER be the following macro:
#define TOUPPER(c) ('a'<=(c)&&(c)<='z'?(c)-'a'+'A':(c))

Let s be a string and let i be an int variable. Show the output produced by each of the fol-
lowing program fragments.

(a) strocpy(s, "abcd") ;
i = 0;
putchar (TOUPPER(s[++i] ) ) ;

***************************page_371***************************
346 Chapter 14  The Preprocessor

10.

l1.

Éprint£ function >22.3

stderr stream > 221

Section 14.4

@ 12

(b) strepy(s, "0123") ;
i = 0;
putchar (TOUPPER (s [++i] ) ) ;

(a) Write a macro DISP (£,x) that expands into u call of print£ that displays the value
of the function £ when called with argument x. For example.

DISP(sgrt, 3.0);
should expand into
print£("sqgrt(%g) = %g\n"', 3.0, sqrt(3.0));

(b) Write a macro DISP2 (£,x, y) that’s similar to DISP but works for functions with
tlWo arguments.

Let GENERIC _MAX be the following macro:

#define GENERIC MAX (type)
type typeH# _ max(type x, type y)

{

return x > y ? x : y;
}

(a) Show the preprocessor’s expansion of GENERIC MAX (long).
(b) Explain why GENERIC MAX doesn’t work for basic types such as unsigned loncg.

(c) Describe a technique that would allow us to use GENERIC _MAX with basic types such
as unsigned long. Hint: Don't change the definition of GENERIC MAX.

0800 SO 6C

Suppose we want a macro that expands into a string containing the current line number and
file name. In other words, we"d like to write

const char *str = LINE FILE;
and have it expand into
const char *str = "Line 10 of file foo.c";

where foo. c 1s the file containing the program and 10 is the line on which the invocation
of LINE FILE appears. Warning: This exercise is for experts only. Be sure to read the
Q& À section carefully before attempting!

Write the following parameterized macros.

(a) CHECK(x, y,n) — Has the value ! if both x and y fall between O and n — 1. inclusive.
(b) MEDIAN (x, y, z) — Finds the median of x. y. and z.
(c) POLYNOMIAL (x) —- Computes the polynomial 3x* + 24* — 5" —- 2 + 7x —6.

Functions can often—but not always—be written as parameterized macros. Discuss what
characteristics of a f'unction would make it unsuitable as à macro.

(C99) C programmers often use the Éprint£ function to write error messages:

Eprint£ (stderr, "Range error: index = %d\n", index) ;

stderr is C's “standard error” stream; the remaining arguments are the same as those for
print£, starting with the format string. Write a macro named ERROR that generates the
call of Eprint£ shown above when given a format string and the items to be displayed:

ERROR ("Range error: index = %d\n", index) ;

Suppose that the macro M has been defined as follows:
#define M 10

***************************page_372***************************
Exercises 347

Which of the following tests will fail?

(u) Hi£f M

(b) #ifde£ M

(c) #ifndef M

(d) #if defined (M)
(c) #i£ !defined (M)

(a) Show what the following program will look like after preprocessing. You may ignore
any lines added to the program as a result of including the <stdio.h> header.

#include <stdio.h>

#define N 100
void f (void) ;

int main(void)
{

Ë() ;
#ifdef N
#undef N
#endif

return 0;

}

void f (void)
{
#if defined (N)

print£("N is %d\n", N);
#telse

printf("N is undefined\n") ;
tendif

}

(b) What will be the output of this program?

Show what the following program will look like after preprocessing. Some lines of the pro-
sgram may cause compilation errors: find all such errors.

#define N = 10

#define INC(x) x+1

#define SUB (x,y) x-y
#define SOR(x) ((x)*(x))
#define CUBE(x) (SOR(x) * (x) )
tdefine M1(x,y) x#i#y
#define M2(x,y) #x #y

int main (void)

{

int a[(N], i, j, k, Mm;

#ifdef N
l = j;
#else
}j = à:
#endif

ji = 10 * INC(3);

***************************page_373***************************
348 Chapter 14  The Preprocessor

i = SUB(j, kK);
i = SQOR(SQR(j)) ;
i = CUBE() ;

i = M1(3j, kK);
puts (M2 (i, j)) ;

Hundef SOR

i = SOR(j) ;
#define SOR

i = SOR(j) ;

return 0;

}

[5.  Suppose that a program necds to display messages in either English. French, or Spanish.
Using conditional compilation, write à program fragment that displays one of the following
three messages, depending on whether or not the specified macro is defined:

Insert Disk 1 ( f ENGLISH 1s defined)
Inserez Le Disque 1 (if FRENCH 1s defined)
Inserte El Disco 1 — (if SPANISH 1s defined)

Section 14.5 *16.  (C99) Assume that the following macro definitions arc in effect:

#define IDENT(x) PRAGMA (ident #x)
#define PRAGMA(x) _Pragma (#x)

What will the following line look like after macro expansion?
IDENT (foo)

***************************page_374***************************
15.1

stacks > 10.2

Writing Large Programs

Around computers it is difficult to find the correct unit
of time to measure progress. Some cathedrals took a
century to complete. Can you imagine the grandeur
and scope of a program that would take as long?

Although some C programs are small enough to be put in a single file, most aren°t.
Programs that consist of more than one file are the rule rather than the exception. In
this chapter, we'Il see that a typical program consists of several source files and
usually some header files as well. Source files contain definitions of functions and
external variables: header files contain information to be shared among source files.
Section 15.1 discusses source files, while Section 15.2 covers header files. Section
15.3 describes how to divide a program into source files and header files. Section
15.4 then shows how to “build” (compile and link) a program that consists of more
than one file, and how to “rebuild”’ à program after part of it has been changed.

Source Files

Up to this point, we’ve assumed that a C program consists of à single file. In fact, à
program may be divided among any number of source files. By convention, source
files have the extension .c. Each source file contains part of the program, prima-
rily definitions of functions and variables. One source file must contain a function
named main. which serves as the starting point for the program.

For example, suppose that we want to write a simple calculator program that
evaluates integer expressions entéred in Reverse Polish notation (RPN), mn which
operators follow operands. If the user enters an expression such as

305 - 7*

we want the program to print its value (175. in this case). Evaluating an RPN
expression is easy if we have the program read the operands and operators, one by
one, using a stack to keep track of intermediate results. If the program reads a

349

***************************page_375***************************
350

Chapter 15 Writing Large Programs

number, we*1l have it push the number onto the stack. If it reads an operator, we'll
have it pop two numbers from the stack, perform the operation, and then push the
result back onto the stack. When the program reaches the end of the user’s input,
the value of the expression will be on the stack. For example, the program will
evaluate the expression 30 5 - 7 * in the following way:

|. Push 30 onto the stack.

2. Push 5 onto the stack.

3. Pop the top two numbers from the stack, subtract 5 from 30, giving 25, and
then push the result back onto the stack.

4. Push 7 onto the stack.

5. Pop the top two numbers from the stack. multiply them. and then push the
result back onto the stack.

After these steps, the stack will contain the value of the expression (175).
Turning this strategy into a program isn’t hard. The program’s main function
will contain a loop that performs the following actions:

Read a ‘“token” (a number or an operator).

[f the token is a number, push it onto the stack.

If the token is an operator, pop its operands from the stack, perform the opera-
tion, and then push the result back onto the stack.

When dividing a program like this one into files, it makes sense to put related func-
tions and variables into the same file. The function that reads tokens could go into
one source file (token. c, say), together with any functions that have to do with
tokens. Stack-related functions such as push, pop, make _ empty, is_empty.
and is full could go into a different file, stack.c. The variables that repre-
sent the stack would also go into stack. c. The main function would go into yet
another file, calc.c.
Splitting a program into multiple source Îfiles has significant advantages:

=s Grouping related functions and variables into a single file helps clarify the
structure of the program.

m Each source file can be compiled separately—a great time-saver if the pro-
gram is large and must be changed frequently (which is common during pro-
gram development).

u Functions are more easily reused in other programs when grouped in separate
source files. In our example, splitting off stack.c and token. c from the
main function makes it simpler to reuse the stack functions and token func-
tions in the future.

15.2 Header Files

When we divide a program into several source files, problems arise: How can a
function in one file call a function that’s defined in another file? How can a func-

***************************page_376***************************
#include directive
(form 1)

#include directive
(form 2)

QaAÀ

15.2  Header Files 351

tion access an external variable in another file? How can two files share the same
macro definition or type definition? The answer lies with the #include directive.
which makes 1l possible to sharce information—function prototypes. macro defini-
ions, type definitions. and more—among any number of source files.

The #include directive tells the preprocessor to open a specified file and
insert its contents into the current file. Thus. 1l we want several source files to have
access to the same information. we'Il put that information in a file and then use
#include to bring the file's contents into each of the source files. Files that are
included in this fashion are called Reader files (or sometimes include files); Il
discuss them in more detail later in this section. By convention. header files have
the extension .h.

Note: The C standard uses the term ‘“source file” to refer to all files written by
the programmer, including both .c and .h files. l’Il use “source file” to refer to
.c files only.

 

The #include Directive

The #include directive has two primary forms. The first form 1s used for header
files that belong to Cs own library:

finclude «</ilename>

The second form is used for all other header files. including any that we write:

#finclude "/ilename"

œ

The difference between the two is a subtle one having to do with how the com-
piler locates the header file. Here are the rules that most compilers follow:

= finclude </ilename>: Search the directory (or directories) in which system
header files reside. (On UNIX systems. for example. system header files are
usually kept in the directory /usr/include.)

#s finclude "filenaume"; Search the current directory, then search the direc-
tory (or directories) in which system header files reside.

The places to be searched for header files can usually be altered, often by a com-
mand-line option such as - Ipath.

 

Don't use brackets when including header files that you have written:

#include <myheader.h> /*** WRONG **+*/

The preprocessor will probably look for myheader .h where the system header
files are kept (and. of course. won'1 find it).

 

***************************page_377***************************
352 Chapter 15 Writing Large Programs

portability tip

#include directive
(form 3)

preprocessing tokens » 14.37

The File name in an finclude directive may include information that helps
locate the file. such as a directory path or drive specifier:

rinclude "c:\cprogs\utils.h" /* Windows path */
#include "/cprogs/utils.h" /* UNIX path */

Although the quotation marks in the #include directive make file names look
like string hitcrals. the preprocessor doesn't treat them that way. (That's fortunate.
since \c and \u—which appear in the Windows example—would be treated as
escape sequences In à strimg literal.)

Is usually best not to include path or drive information in Hinclude
directives. Such information makes it difficult to compile a program when
its transported to another machine or, worse, another operating system.

For example, the following Windows #include directives specify drive and/or
path information that may not always be valid:

finclude "d:utils.h"
#include "\cprogs\include\utils.h"
finclude "d:\cprogs\include\utils.h"

The followine directives are better: they don’t mention specific drives, and paths
are relative rather than absolute:

finclude "utils.h"
#include ". .\include\utils.h"

The Hinclude directive has third Formn that's used less often than the other
two:

#include tokens

where fokens 1s any sequence of preprocessine tokens. The preprocessor will scan
the tokens and replace any macros that it finds. Affer macro replacement, the
resulune directive must match one of the other forms of #include. The advan-
tage of the third kind of Finclude 1s that the file name can be defined by a macro
rather than being ‘hard-coded” into the directive itsclf, as the following example
shows:

#if defined(IA32)

tdefine CPU FILE "ia32.h"
#elif defined (IA64)

#define CPU FILE "ia64.h"
Heli£f defined (AMD64 )

tdefine CPU FILE "amd64.h"
#endif

#include CPU FILE

***************************page_378***************************
15.2  Header Files 353

Sharing Macro Definitions and Type Definitions

Most large programs contain macro definitions and type definitions that need to be
shared by several source files (or, in the most extreme casc. by al! source files).
These definitions should go into header files.

For example. suppose that we're writing à program that uses macros named
BOOL., TRUE, and FALSE. (There’s no need for these in C99, of course. because
the <stdboo!l .h> header defines similar macros.) Instead of repeating the defi-
nitions of these macros in each source file that needs them. it makes more sense to
put the definitions in à header file with a name like boolean.h:

Jdefine BOOL int
#define TRUE 1
Fdefine FALSE O

Any source file that requires these macros will simply contaimn the line
#include "boolean.h"

[In the following figure. two files include boolean.h:

 

'#defîne BOOL int
#define TRUE 1
#define FALSE O

 

/ boolean.h

+ . 4

rinclude "boçlean.h" #include "boolean.h"

  

Type definitions are also common in header files. For example. instead of
defining a BOOL macro. we might use typedeË to create a Bool type. If we do,
the boolean.h file will have the following appearance:

#define TRUE 1
#define FALSE C
typedef int Bool;

Putting definitions of macros and types in header files has some clear advan-
tages. First, we save time by not having to copy the definitions into the source files
where they're needed. Second, the program becomes casier to modify. Changine
the definition of a macro or type requires only that we edit a sinele header file: we
don’t have to modify the many source files in which the macro or type 1s used.
Third, we don't have to worry about inconsistencies caused by source files contain-
ing different definitions of the same macro or type.

***************************page_379***************************
354 Chapter 15  Writing Large Programs

dofault argument promotions » 93

/\

Sharing Function Prototypes

Suppose that a source file contains a call of a function £ that’s defined in another
file. Éoo.c. Calling £ without declaring 1t first 1S risky. Without a prototype to
rely on, the compiler is forced to assume that £°s return type is int and that the
number of parameters matches the number of arguments In the call of £. The argu-
ments themselves are converted automatically to a kind of “standard form” by the
default argument promotions, The compiler's assumptions may well be wrong, but
it has no way to check them, since it compiles only one file at a time. If the
assumptions are incorrect. the program probably won't work. and there won't be
any clues as to why it doesn't. (For this reason, C99 prohibits calline a function for
which the compiler has not yet seen a declaration or definition.)

 

When calling à function £ that's defined in another file. always make sure that the
compiler has seen à prototype for f prior to the call.

 

Our first impulse 1s to declare £ in the file where it’s called. That solves the
problem but can create a maintenance nightmare. Suppose that the function 1s
called in fifty different source files. How can we ensure that £'s prototypes are the
same In all the files? How can we guarantee that they match the definition of £ in
foo.c” If £ should change later. how can we find all the files where 1t's used?

The solution is obvious: put £'s prototype in a header file, then include the
header file in all the places where £ 1s called. Since £ 1s defined in £oo. c. let's
name the header file £oo.h. In addition to including foo .h in the source files
where £ 1s called, we’ll need to include it in £oo.c. enabling the compliler to
check that £°s prototype In foo .h matches 1ts definition in foo.c.

 

Always include the header file declaring a function £ in the source file that con-
tains £ s definition. Failure to do so can cause hard-to-find bugs. since calls of f
elsewhere In the program may not match £*s definition.

 

If foo.c contains other functions. most of them should be declared in the
same header file as £. After all. the other functions in foo.c arè presumably
related to £; any file that contains a call of £ probably needs some of the other
functions in foo.c. Functions that are intended for use only within foo.c
shouldn’t be declared in a header file. however: to do so would be misleadine.

To 1llustrate the use of function prototypes in header files, let's return to the
RPN calculator of Section 15.1. The stack. c file will contain definitions of the
make empty. is empty.is f£ull. push. and pop functions. The followimng
prototypes for these functions should go in the stack. h header file:

void make _ empty (void) ;
int is _ empty (void) ;

 

***************************page_380***************************
external varnables > 70.2

15.2  Header Files 355

int is _ full (void) ;
void push(int i);
int pop (void) ;

(To avoid complicating the example. is_ empty and is _ f£full will return int
values instead of Boolean values.) We'll include stack.h in calc. c to allow
the compiler to check any calls of stack functions that appear in the latter file.
We'll also include stack .h in stack. c so the compiler can verify that the pro-
totypes in stack.h match the definitions in stack.c. The following figure
shows stack.h, stack.c, and calc.c:

 

r

| void make_empty (void) ;
int is _ empty (void) ;

| int is £ull (void) ;
void push(int i);

lint pop (void) ;

 

 

 

stack.h
4 A
finclude "stack.h" | Hinclude "stack.h"

int main (void) lint contents [100] ;
{ int ton = O0;

make _empty () ;

void make empty(void)

{ —

int is empty (void)

{ . )

int is £ull (void)

(— }

void push(int 1)

}

int pop(void)

 

 

 

 

stack.c

Sharing Variable Declarations

External variables can be shared among files in much the same way functions are.
To share a function. we put its definition in one source file. then put declarations in
other files that need to call the function. Sharing an external variable is donc in
much the same way.

Up to this point, we haven't needed to distinguish between a variable's decla-
ration and its definition. To declare a variable i, we've written

int i; /* declares i and defines it as well */

***************************page_381***************************
356

Chapter 15 Writing Large Programs

extern keyword » /8.2

e 7.41

which not only declares ù to be à variable of type int. but defines i as well. by
causing the compiler to set aside space for à. To declare à without defining it, we
must put the keyword extern at the beginning of its declaration:

extern int i; /* declares i without defining it */

extern informs the compiler that à 1s defined elsewhere in the program (most
likely in à different source file). so there’s no need to allocate space for 1t.

extern works with variables of all types. When we usc it in the declaration
of an array, we can omit the length of the array:

extern int a[];

Since the compiler doesn’t allocate space for a at this time, there’s no need for it to
know a's length.

To share a variable i among several source files, we first put à definition of i
in one file:

int 1;

IF à needs to be initialized, the initializer would go here. When this file is com-
piled, the compiler will allocate storage for i. The other files will contain declara-
tions of i:

extern int i;

By declaring 1 in each file. it becomes possible to access and/or modify i within
those files. Because of the word extern. however, the compiler doesn't allocate
additional storage for i each time one of the files is compiled.

When a variable is shared among files, we'll face a challenge similar to one
that we had with shared functions: ensuring that all declarations of a variable agree
with the definition of the variable.

 

When declarations of the same variable appear in different files, the compiler can't
check that the declarations match the variable’s definition. For example. one file
may contain the definition

int 1;
while another file contains the declaration

extern long 1;

Àn error of this kind can cause the program to behave unpredictably.

 

To avoid inconsistency. declarations of shared variables are usually put in
header files. À source file that needs access to a particular variable can then
include the appropriate header file. In addition. each header file that contains à

***************************page_382***************************
15.2  Header Files 357

variable declaration 1s included in the source file that contains the variable's defini-
tion. enablinge the compiler to check that the two match.

Although sharing variables among files is a long-standing practice in the C
world, it has significant disadvantages, In Section 19.2, we'll see what the prob-
lems are and learn how to design programs that don't need shared variables.

Nested Includes

À header file may itself contain # include directives. Although this practice may
seem u bit odd, 1t can be quite useful in practice. Consider the stack.h file.
which contains the following prototypes:

int is empty (void) ;
int is full (void) ;

Since these f'unctions return only Ô or |. it's a good idea to declare their return type
to be Bool instead of int, where Bool 1s the type that we defined earlier in this
section:

Bool is empty (void) ;
Bool is full (void) ;

Of course. we’ll need to include the boolean. h file in stack. h so that the def-
inition of Bool is available when stack.h 1s compiled. (In C99, we’d include
<stdbool .h> instead of boolean.h and declare the return types of the two
functions to be boo1 rather than Bool.)

Traditionally. C programmers shun nested includes. (Early versions of C
didn’t allow them at all.) However, the bias against nested includes has largely
faded away, in part because nestedl includes are common practice in C++.

Protecting Header Files

If a source file includes the same header file twice. compilation errors may result.
This problem is common when header files include other header files. For exam-
ple. suppose that filel .h includes file3.h, file2.h includes file3.h.
and prog. c includes both filei .h and file2.h (see the figure at the top of
the next page). When prog. c is compiled. file3 .h will be compiled twice.

Including the same header file twice doesn’t always cause a compilation error.
If the file contains only macro definitions. function prototypes, and/or variable
declarations. there won°t be any difficulty. If the file contains a type definition.
however. we'Il get a compilation error.

Just to bc safe. itl's probably a good idea to protect all header files against mul-
tiple inclusion: that way. we can add type definitions to a file later without the risk
that we might forget to protect the file. In addition, we might save some time dur-
ing program development by avoidine unnecessary recompilation of the same
header file.

***************************page_383***************************
358

Chapter 15

#error directives > 74.5

Writing Large Programs

 

 

 

A file3.h \

° ° - 4 « . - Pd E )
finclude "file3s.n" winclude "file3.h"

 

 

filel.h \ file2.n
\ 1
& #include "filel.h"

finclude "file2 .h"

 

prog.c

To protect à header file, we’Il enclose the contents of the file in an #i fndef-
tendi£ pair. For example, the boolean. h file could be protected in the follow-
ing Way:

iti£ndef BOOLEAN H
#define BOOLEAN H

#define TRUE i
#define FALSE O
typedef int Bool;

#endif

When this file is included the first time, the BOOLEAN H macro won't be defined,
so the preprocessor will allow the lines between #i fnde£ and #endif to stay.
But 1f the file should be included a second time. the preprocessor will remove the
lines between #i £nde£ and #endi£.

The name of the macro (BOOLEAN _ H) doesn't really matter. However. mak-
ing it resemble the name of the header file is a good way to avoid conflicts with
other macros. Since we can‘{ name the macro BOOLEAN .H (identifiers can*t con-
tain periods). a name such as BOOLEAN H is a g00d alternative.

#error Directives in Header Files

Herror dircctives are often put in hcader files to check for conditions under
which the header file shouldn’t bc included. For example. suppose that a header

 

 

***************************page_384***************************
__STDC___ macro » 14.3

15.3

PROGRAM

15.3  Dividing a Program into Files 359

file uses a feuture that didn’t exist prior to the original C89 standard. To prevent the
header file from being used with older, nonstandard compilers, 1t could contain an
#i Ende£ directive that tests for the existence of the___STDC __ Macro:

tifndef __STDC __
ferror This header requires a Standard C compiler
#endiF

Dividing a Program into Files

Let's now use what we know about header files and source files to develop a sim-
ple technique for dividing a program into files. We'1l concentrate on functions, but
the same principles apply to external variables as well. We Il assume that the pro-
gram has already been designed; that is. we've decided what functions the program
will need and how to arrange the functions into logically related groups. (We"ll dis-
cuss progrum design in Chapter 19.)

Here's how we'Il procced. Each set of functions will go into a separate source
file (letUs use the name Éoo. c for one such file). In addition, we'1l create a header
file with the same name as the source file, but with the extension .h (foo.h. in
our case). Into £oo.h. we'I] put prototypes for the funclions defined in foo.c.
(Functions that are designed for use only within foo.c need not—and should
not—be declared in £oo .h. The read char function in our next program 1s an
example.) We'Il include £oo .h in each source file that needs to call a function
defined in foo .c. Moreover. we'Îl include £foo.h in £oo. c so that the compiler
can check that the function prototypes in £oo .h are consistent with the definitions
in foo.c.

The main function will go in a file whose name matches the name of the pro-
eram—if we want the program to be known as bar. then main should be in the
file bar.c. It's possible that there are other functions in the same file as main, so
long as they're not called from other files in the program.

 

Text Formatting

To illustrate the technique that we've just discussed., let's apply it to à small text-
formatting program named justi£fy. Às sample Input to justi£y, we Il use a
file named quote that contains the following (poorly formatted) quotation from
“The development of the C programming language” by Dennis M. Ritchie (in His-
tory of Programmine Languages 11, edited by T. J. Bergin, Jr…. und R, G. Gibson.
Jr.. Addison-Wesley. Reading, Mass., 1996, pages 67 1-687):

C is quirky,  Élawed, and an
enormous SuUCCcess. Although accidents oË history
surely helped, it evidently satisfied a need

for a system implementation language efficient

***************************page_385***************************
360

Chapter 15 _ Writing Large Programs

Input redirection » 22. 1

output redirection >22.1 …

enough to displace assembly language,
yet sufficiently abstract and fluent to describe
algorithms and interactions in a wide variety
of environments.
-- Dennis M. Ritchie

To run the program from a UNIX or Windows prompt. we'd enter the com-
mand

justify <quote

The < symbol informs the operating system that justi£fy will read from the file
quote instecad of accepting input from the keyboard. This feature, supported by
UNIX, Windows, and other operating systems, 1s called inrpuft redirection. When
given the quote file as input, the justi£y program will produce the following
output:

C is quirky, flawed, and an enormous success. Although
accidents of history surely helped, it evidently satisfied a
need for a system implementation language efficient  enough
to displace assembly language, yetu sufficiently abstract and
fluent to describe algorithms and interactions in a wide
variety of environments. -- Dennis M. Ritchie

The output of justi£y will normally appear on the screen, but we can save 1t in à
file by using output redirection:

justify <quote >newquote

The output of justi£y will go into the file newquote.

In gencral, justi£y's output should be identical to its input. except that
extra spaces and blank lines are deleted, and lines are filled and justified. “Filling”
a line means adding words until one more word would cause the line to overflow.
“Justifying” a line means adding extra spaces berween words so that each line has
exactly the same lensth (60 characters). Justification must be done so that the
space between words in a line is equal (or as nearly equal as possible). The last line
of the output won't be justified.

We"lt assume that no word is longer than 20 characters. (A punctuation mark
is considered part of the word to which it is adjacent.) That’s a bit restrictive, of
course. but once the program is written and debugged we can easily increase this
limit to the point that it would virtually never be exceeded. IF the program encoun-
ters a longer word, it must ignore all characters after the first 20. replacing them
with a single asterisk. For example. the word

antidisestablishmentarianism
would be printed as

antidisestablishment *

***************************page_386***************************
word.h

15.3  Dividing a Program into Files 361

Now that we understand what the program should do. 1ts time to think about à
design. We*1]] start by observing that the program can*t write the words one by one
as thev're read. Instead. 11 will have to store them in a ‘“Îine buffer” unul there are
cnough to fill à line. After further reflection, we decide that the heart of the pro-
gram will be a loop that goes something like this:

for (;;) {
read word ;
if (can't read word) |
write contents of line buffer without justification ;
terminate program ;

}

if£ (word doesn't fit in line buffer) |
write contents of line buffer with justification ;
clear line huffer ;

}

add word ta line bufjer;

}

Since we* need functions that deal with words and functions that deal with the
tine buffer. let's split the program into three source files, putting all functions
related to words in one file (word. c) and all functions related to the line buffer in
another file (line. c). À third file (justi£fy. c) will contain thé main function.
In addition to these files. we'Il need two header files, word.h and line.h. The
vord.h file will contain prototypes for the functions in word.c: line.h will
play a similar role for 1ine.c.

By examining the main loop. we see that the only word-related function
that we"1l neëd iS a read _ word function. (1f read_word can'{ read a word
because itl’s reached the end of the input file. we*ll have it signal the main Ioop
by prétending to read an “empty” word.) Consequently. the word.h file is a
small one:

#ifndef WORD H
idefine WORD_H

/*****************‘k*‘x****‘.«'r**“k**'k*‘k****************‘k****9r—k**

* read word: Reads the next word from the input and *
* stores it in word. Makes word empty iËÉ no *
* word could be read because of end-of-file. *
* Truncates the word if its length exceeds *
* len. *

*

AN RR A RR A ÀX A H /

void read word(char *word, int len);
fendif

Notice how thé WORD_H macro protects word .h from being included more than
once. Although word.h doesn’t really need it. itl’s good practice to protect all
header files in this Wav.

***************************page_387***************************
362

Chapter 15  Writing Large Programs

line.h

-

The line.h file won't be as short as word.h. Our outline of the main loop
reveals the need for functions that perform the following operations:

Write contents of line buffer without justification
Determinc how many characters are left in line buffer
Write contents of line buffer with justification

Clear line buffer

Add word to line buffer

Woe'Il call these functions £lush line. space remaining, write line.
clear line, and add_word. Here’s what the 1ine.h hcader file will look
like:

Hifnde£f LINE H
#define LINE H

/‘k‘k******‘k************‘k****************—k**—k**********—k**—k**

* clear line: Clears the current line. *
'k***********‘k****‘k***‘k******‘k**-fc****v‘:**********'î:****:&?‘:****/

void clear line (void) ;

/******"Â'***********'ä'*******'k‘k**'k*********'À'**k****'k*****%“k’k*’ä’

* add word: Adds word to the end of the current line. #
* If this is not the first word on the line, *
* puts one space before word. *

*****—k******************i*******—k******—k**********‘k*******/

void add word(const char *word}) ;

/**'k********‘k****‘k********'À’*******'ä'************************

* space _remaining: Returns the number of characters left *

+ in the current line. *
****************%‘$*‘k'k‘k*:Æ‘k*****i<**+:**—k********—k********k*****/

int space remaining (void) ;

/‘k*******************************—k-k***—k***********k****Ÿ:*‘k**
* write line: Writes the current line with *
* jJustification. *
*******‘k*********:‘:*k****‘k‘k****—k************k*i'**7':***‘k****'k*'k/

void write line (void) ;

/*********‘k******‘k**********'k***************%‘**‘k*‘k‘k*****'ä"ä'*

* flush line: Writes the current line without *
* justification. I£ the line is empty, does *
* nothing. *

*‘À'************'.ë**+:—k*'k***'k***'À'***‘k**'k*'}\‘*******Ÿ:************/

void flush _ line (void) ;
#endif

Before we write the word.c and line.c files. we can use the functions
declared in word.h and 1ine.hto write justify. c, the main program. Writ-
ing this file 1s mostly à matter of translating our original loop design into C.

***************************page_388***************************
justify.c

word.c

15.3  Dividing a Program into Files 363

/* Formats a £ile of text */

#include <string.h>
Hinclude "line.h"
jinclude "word.h"

#define MAX WORD LEN 20

int main(void)
char word [MAX WORD LEN+2)] ;
int word _len;

clear line() ;

for (;;) |
read_word(word, MAX WORD LEN+1) ;
word _len = strlen (word) ;

if (word len == O) |
flush_line() ;
return 0;

)

if (word len > MAX WORD _ LEN)
word [MAX WORD LEN] = '*';

if (word len + 1 > space remaining()) {
write line();
clear line();

}

add_word (word) ;

}
}

Including both 1ine.h and word.h gives the compiler access to the function
prototypes in both files as it compiles justi£fy.c.

main uses a trick to handlce words that exceed 20 characters. When 1t calls
read_word. main tells it to truncate any word that exceeds 21 characters. After
read_word returns, main checks whether word contains a string that's longer
than 20 characters. If so. the word that was read must have been at least 21 charac-
ters long (before truncation), so main replaces the word's 21st character by an
asterisk.

Now it’s time to write word. c. Although the word .h header file has à pro-
totype for only one l'unction. read_word, we can put additional functions in
word. c if we nced to. Às it turns out, read_word 1s easier to write 1f we add a
small “helper” function, read_char. We'll assigen read_char the task of read-
ing à single character and, if ils a new-line character or tab, converting 1t to a
space. Having read _ word call read _ char instead of getchar solves the
problem of treating new-line characters and tabs as spaces.

Here s the word. c file:

#include <stdio.h>
Finclude "word.h"

***************************page_389***************************
364

Chapter 15

TOF macro » 22,4

line.c

Writing Large Programs

int read _char (void)

{

int ch

getchar () ;

if (ch == '\n' || ch == '\t')
return ' ‘;
return ch;

}

void read word(char *word, int len)

{

int ch, pos = OD;
while ((ch = read char()) == ' *)

while (ch != ! " && ch != EOF) |
if (pos < len)
word {pos++] = ch;
ch = read _char();

}

word[pos] = '\0';

}

Before we discuss read_word. a couple of comments are in order concern-
Ing the use of getchar in the read_char function. First, getchar returns an
int value instead of a char valne; that'< why the variable ch in read_char is
declared to have type int and why the return type of read_char is int. Also,
getchar returns the value EOF when it‘s unable to continue reading (usually
because it has reached the end of the input file).

read_word consists of two loops. The first loop skips over spaces. stopping
at the first nonblank character. (EOF isn°t a blank, so the loop stops if it reaches the
end of the input file.) The second loop reads characters until encountering a space
or EOF. The body of the loop stores the characters in word until reaching the len
limit. After that, the loop continues reading characters but doesn°t store them. The
final statement in read_word ends the word with a null character, thereby mak-
ing it à string. I read_word encounters EOF before finding a nonblank charac-
ter, pos will be 0 at the end. making word an empty strine.

The only file left is 1line.c, which supplies definitions of the functions
declared in the 1ine .h file. 1ine. c will also need variables to kcep track of the
state of the line buffer. One variable. 1ine. will store the characters in the current
linc. Strictly speakine. Line is the only variable we need. For speed and conve-
nience. however, we’]l use two other variables: line len (the number of char-
acters in the current line) and num_words (the number of words in the current
linc).

Here’s the 1ine. c file:
finclude <stdio.h>

finclude <string.h>
finclude "line.h"

***************************page_390***************************
15.3  Dividing a Program into Files

#define MAX LINE LEN 60

char line [MAX LINE LEN+1] ;
int line len = O0;
int num words = 0;

void clear line (void)

{

line (0] = '\0';
line len = 0;
num words = 0;

}

void add word(const char *word)

{

if (num words > O) |
line[linre len] = " ;
line [line len+1] = '\0';
line len++;

}

strcat (line, word) ;

line _len += strlen(word) ;

num_words++;

}

int space _remaining (void)

{
}

void write _line (void)

(

return MAX LINE LEN - line len;

int extra spaces, spaces to insert, i, J;
extra _ spaces = MAX LINE LEN - line len;
for (i = 0; i < line len; i++) |
if (line(i] != * ")
putchar (line [i] ) ;
else (
spaces_to_insert = extra_spaces /
for (j = 1; j <= spaces to insert + 1; j++)
putchar(' ');
extra spaces -= Spaces to insert;

num words--;

}
}

putchar ('\n') ;

}

void flush _line (void)

(

if (line len > O)
puts (line) ;

(num words - 1);

365

***************************page_391***************************
366

Chapter 15 _ Writing Large Programs

15.4

Most of the functions in line.c are casy to write. The only tricky one is
write_line, which writes a line with justification. write line writes the
characters in Line one by one, pausing at the space between each pair of words to
write additional spaces rf needed. The number of additional spaces is stored in
spaces_to_insert. which has the value extra _spaces / (num words
- 1). where extra _spaces 1s initially the difference between the maximum
line length and the uctual line length. Since extra_spaces und num_words
change after cach word is printed, spaces to insert will change as well. If
extra_spaces is 10 initially and num _ words 1s 5, then the first word will be
followed by 2 extra spaces, the second by 2. the third by 3, and the fourth by 3.

Building a Multiple-File Program

In Section 2.1, we examined the process of compiling and linking a program that
fits into a single file. Let’s expand thal discussion to cover multiple-file programs.
Building a large program requires the same basic steps as building a small one:

u Compiling. Each source file in the program must be compiled separatelv.
(Heacder files don’t need to be compiled: the contents of à header file are auto-
matically compiled whenever à source file that includes it is compiled.) For
each source file, the compiler generates a file containing object code. These
FNles—known as object files—huave the extension .o in UNIX and .obj in
Windows.

 

# Linking. The linker combines the object files created in the previous step—
along with code for library functions—to produce an executable file. Among
other duties, the linker 1s responsible for resolving external references lefi
bchind by the compiler. (An external reference occurs when a function in one
file calls à function defined in another file or accesses a variable defined in
another file.)

Most compilers allow us to build a program in a singlé step. With the GCC
compiler, For example. we'd use the following command to build the justi£y
program of Section 15.3:

qcc -o justify justify.c line.c word.c

The three source files are first compiled into object code. The object files are then
automatically passed to the linker, which combines theim into à single file. The -o
option specifies that we want the executable file to be named justi Éy.

Makefiles

Putting the names of all the source files on the command lîine quickly gets tedious.
Worse still. we could waste a lot of time when rebuilding a program if we recom-
pile all source files, not just the ones that were affected by our most recent changes.

***************************page_392***************************
QaÂ

15.4  Building a Multiple-File Program 367

To make it easier to build large programs. UNIX originatec the concept of the
makefile, à file containing the information necessary to build à program. À make-
file not only lists the files that are part of the program, but also describes depen-
dencies amonsg the files. Suppose that the file £oo. c includes the file bar .h. We
say that foo .c “depends” on bar .h, because à change to bar .h will require us
to recompile £oo.c.

Here's a UNIX makefile for the justiE£y program. The makefile uses GCC
lor compilation and linking:

justify: justify.o word.o line.o
gcc -o justify justify.o word.o line.o

justify.o: justify.c word.h line.h
gcc -c justiËÉy.c

word.o: word.c word.h
gcc -c word.c

line.o: line.c line.h
gcc -c line.c

Therc are four groups of lines: each group is known as a rule, The first line in cach
rule sives a farget file. followed by the files on which it depends. The second line
is a command to be executed if the target should need to be rebuilt because of a
change to one of its dependent files. Let’s look at the first two rules; the last two
are similar.

In the first rule, justi £y (the exccutable file) ts the target:

justify: justi£fy.o word.o line.o
gcc -o justi£fy justify.o word.o line.o

The first line states that justify depends on the files justi£y.o, word.0o,
and line.o: if any one of these three files has changed since the program was
last built, then justify needs to be rebuilt. The command on the following line
shows how the rebuilding is to be done (by using the gcc command to link the
three object files).

In the second rule, justify. 0 is the target:

justi£fy.o: justify.c word.h line.h
gcc -c justify.c

The first line indicates that justi£y.o needs to be rebuilt if there's been à
change to justify.c, word.h, or line.h. (The reason for mentioning
word.h and line.his that justi£y. c includes both these files. so it's poten-
tially affected by a change to either one.) The next line shows how to update
justify.o (by recompiling justi£y.c). The -c option tells the compiler to
compile justi£y. c into an object file but not attempt to link 1t.

Once we've created a makefile for a program, we can use the make utility to
build (or rebuild) the program. By checking the time and date associated with cach

***************************page_393***************************
368 Chapter 15 Writing Large Programs

file in the program. make cun determine which files are out of date. Tt then invokes
the commands necessary to rebuild the program.
If you want to give make a trv. here are u few details you’Il nced to know:

u Eachcommand in à makefile must be preceded by à tab character. not a series
of spaces. (In our example. the commands appear to be indented eight spaces,
but 10s actually à single tab character.)

u À makelile is normally stored in a lile named Makefile (or makefile).
When the make utility is used, it automatically checks the current directory
for « file with one of these names,

w To invoke make, use the command
make rargel

wherc rarger is one of the targets listed in the makefile. To build the justi £y
execulible using our makefile. we would use the command

make justi£y

u |f no target is specificd when make is invoked. it will build the target of the
first rule. For example. the command

make

will build the justi£y exccutable. since justi Ey is the first tareet in our
makefile. Except for this special property of the first rule. the order of rules in
a makefile ts arbitrary.

make 1s complicated enough that entire books have been written about it, so
we won't attempt to delve further into its intricacies. Let’s just say that real make-
files aren’t usually as casy to understand as our example. There are numerous
techniques that reduce the amount of redundancy in makefiles and make them cas-
ler to modify: at the same time. though. these techniques greatly reduce their read-
ability.

Not everyone uses makefiles, by the way. Other program maintenance tools |
arc also popular. including the “project files” supported by some integrated devel-
opment environments.

Errors During Linking

Some errors that can’t be detected during compilation will be found during linkine.
In particular, 1f the definition of a function or variable is missineg from a program.
the linker will be unable to resolve external reférences to it, causing à message
such as “undefined svmbol” or “undefined reference.”

Errors detected by the linker are usually easy to fix. Here arc some of the most ‘
common causes:

= Misspellings. T the name of a variable or function is misspelled. the linker
will report it as missing. For example. if the function read_char is defined

 

À

***************************page_394***************************
15.4  Building a Multiple-File Program 369

in the program but called as read_cahr, the linker will report that
read _cahr is missing.

# Missing files. 1f the linker can‘t find the functions that are in file £oo.c, it
may not know about the file. Check the makefile or project file to make surc
that foo. c 1s listed therc.

# Missing libraries. The linker may not be able to find all library functions used
in the program. À classic example oceurs in UNIX programs that use the
<math.h> header. Simply including the header in à program may not be
enough: many versions of UNIX require that the -1m option be specified
wlhen the program is linked, causing the linker to search a system file that con-
tains compiled versions of the <math. h> functions. Failing to use this option
may cause “undefined reference” messages during linking.

Rebuilding a Program

During the development of a program. it’s rare that we'Il need to compile all its
files. Most of the time, we'Il test the program, make a change, then build the pro-
gram again. To save time, the rebuilding process should recompile only thosc files
that might be affected by the latest change.

Let's assume that wc‘ve designed our program in the way outlined in Section
|5.3. with a header file for each source file. To see how many files will need to be
recompiled after a change, we need to consider two possibilities.

The first possibility is that the change affects a single source file. In that case,
only that file must be recompiled. (After that. the entire program will need to be
relinked. of course.) Consider the justify program. Suppose that we decide to
condense the read_char function in word. c (changes are marked in bold):

int read _ char (void)

(

int ch = getchar();

return (ch == '\n' || ch == '\t') ? !" " : Ch;

}

This modification doesn’t affect word.h. so we need only recompile word.c
and relink the program.

The second possibility is that the change affects a header file. In that case, we
should recompile all files that include the hcader file. since they could potentially
be affected by the change. (Some of them might not be, but it pays to be conserva-
tive.)

As an example, consider the read_word function in the just i f£y program.
Notice that main calls strlen immediately after calling reaà_word. in order
to determine the length of the word that was just read. Since read_word already
knows the leneth of the word (read_word's pos variable keeps track of the
length). it seems silly to use strlen. Modifying read_word to rcturn the
word’s length is easy. First, we change the prototype of read_word in word.h:

***************************page_395***************************
370 Chapter 15 _ Writing Large Programs

/*********'ä:*'ﬂ:*********'À‘*ir‘k**************‘k*‘k******k'k********i‘

* read _ word: Reads the next word from the input and *
* stores it in word. Makes word empty if no *
* word could be read because of end-of-file. *
* Truncates the word if its length exceeds +
* len. Returns the number of characters *
* stored. +
*****'À"k**‘k*********‘k*****‘k‘k*'k*******7‘r*‘k'ﬁ'******—k***********/

int read_word(char *word, int len}) ;

Of course, wc're careful to change the comment that accompanies read _ word.
Next, we change the definition of read_word in word. c:

int read word(char *word, int len)

{
int ch, pos = 0;
while ((ch = read char()) == " ")
while (ch != ! " && ch != EoF) {
f (pos < len)
word [pos++] = ch;

ch = read _ char();
}
word{pos] = '\0';
return pos;

}

Finally, we modify just ify.c by removing the include of <string.h> and
changing main as follows:

int main (void)
char word [MAX WORD LEN+2] ;
int word len;

clear line () ;
for (::) {
word _ len = read word(word, MAX WORD LEN+1]) ;
if (word _ len == O) |
Elush line();
return 0;
}
if (word _ len > MAX _ WORD LEN)
word [MAX WORD LEN] = '#*!;
if (word_len + 1 > space remaining()) |
write _ line();
clear line() ;

}

add_word (word) ;

***************************page_396***************************
predefined macros > 14.3

15,4  Building a Multiple-File Program 371

Once we've made these changes. we'll rebuild the just ify program by recom-
piling word. c and justi£y. c and then relinking. There's no necd to recompile
line.c, which doesn’t include word.h and therefore won'{ be affected by
changes to it. With the GCC compiler. we could use the following command Lo
rebuild the program:

gcc -o justify justi£fy.c word.c line.o

Note the mention of 1ine.o instcad of line. c.

Onc of the advantages of using makefiles is that rebuilding 1s handled auto-
matically. By examining the date of cach file, the make utility can determine
which files have changed since the program was last built. Tt then recompiles
thesc files. together with all files that depend on them, either directly or indirect-
ly. For example, if we make the indicated changes to word.h, word. c, and
justi£y.c and then rebuild thé justify program. make will perform the
following actions:

|. Build justi£y. 0 by compiling justi£fy.c (because justi£fy.c and
word.h were changed).

D

. Build word.o by compiling word.c (because word.c and word.h
were changed).

3. Build justify by linkinge justify.o, word.o, and line.o
(because justi£fy.o and word.o werc changed).

Defining Macros Outside a Program

C compilers usually provide some method of specifying the value of a macro at the
time à program is compiled. This ability makes it easy to change the value of a
macro without editing any of the program's files. ls especially valuable when pro-
grams are built automatically using makefiles.

Most compilers (including GCC) support the -D option. which allows the
value of a macro to be specified on the command line:

gcc -DDEBUG=1 foo.c

In this example, the DEBUG macro is defined to have the value 1 in the program
foo. c, just as 1f the line

#Hdefine DEBUG 1

appeared at the beginning of foo.c. If the -D option names a macro wilhout
specifying its value. the value 1s taken to be |.

Many compilers also support the -U option. which ‘’undefines” a macro as if
by using fundef. We can use -U to undefine a predefined macro or onc that was
defined carlier in the command line using -D.

***************************page_397***************************
372

Chapter 15 Writing Large Programs

>.

Q & À

You don’t have any examples that use the #include directive to include a
source file. What would happen if we were to do this?

That's not a good practice. although it's not illegal. Here’s an example of the kind
of trouble you can gct into. Suppose that foo. c defines a function f that we'Il
necd in bar . c and baz. c. so we put the directive

#Hinclude "foo.c"

In both bar.c and baz. c. Each of these files will compile nicely. The problem
comes later. when the linker discovers two copies of the object code for £. Of
course. we would have gotten away with includinge foo.c if only bar.c had
Included it, not baz.c as well. To avoid problems. it’s best to use #include
only with header files, not source files.

What are the exact search rules for the #include directive” [p. 351]

-

That depends on your compiler. The C standard is delibcrately vague in its descrip-
tion of #include. If the file name is enclosed in brackets, the preprocessor looks
in a "sequence of implementation-defined places.” as the standard obliquely puts
it. If the file name is enclosed in quotation marks. the file “is scarched for in an
implementation-defined manner” and. if not found. then searched as if its name
had been enclosed in brackets. The reason for this waff ling is simple: not all oper-
ating systems have hicrarchical (tree-like) file systems,

To make matters even more interestine. the standard doesn”t require that
names enclosed in brackets be file names at all. lcaving open the possibility that
#include directives using <> are handled entircly within the compiler.

! don’t understand why cach source file needs its own header file. Why not
have one big header file containing macro definitions, type definitions, and
function prototypes? By including this file, each source file would have access
to all the shared information it needs. [p. 354]

The “once big header file” approach certainly works; à number of programmers use
IL. And it does have an advantage: with only one header file, there are fewer files to
manage. For large programs. however, the disadvantages of this approach tend to
outweigh its advantages.

Using a single header file provides no useful information to someone reading
the program later. With multiple header files. the reader can quickly see what other
parts of the program are used by à particular source file.

But that’s not all. Since each source file depends on the big header file, chang-
Ing it will cause all source files to be recompiled—a significant drawback in à large
program. To make matters worse, the header file will probably change frequently
because of the large amount of information it contains.

***************************page_398***************************
Exercises 373

Q: The chapter says that a shared array should be declared as follows:
extern int al];
Since arrays and pointers are closely related, would it be legal to write
extern int *a;

instead? [p. 356]

A: No. When used in expressions, arrays “decay” into pointers. (We've noticed this
behavior when an array name is used as an argument in a function call.) In variable
declarations. however, arrays and pointers are distinct types.

Q: Does it hurt if a source file includes headers that it doesn’t really need?

A: Not unless the header has à declaration or definition that conflicts with one in the
source file. Otherwise, the worst that can happen is à minor increase in the time it
takes to compile the source file.

Q: 1 needed to call a function in the file foo.c, so ! included the matching
header file, foo.h. My program compiled, but it won°t link. Why?

“A: Compilation and linking are completely separate in C. Header files exist to provide
information to the compiler. not the linker. IF you want to call à function in foo . c,
then you have to make sure that Foo.c is compiled and that the linker is aware
that it must search the abject file for foo.c to find the function. Usually this
means naming foo. c in the program's makefile or project file.

Q: If my program calls a function in <stdio .h>, docs that mean that all funce-
tions in <stdio.h> will be linked with the program?

A: No. Including <stdio.h> (orany other header) has no effect on linking. In any
event. most linkers will link only functions that your program actually needs.

Q: Where can I get the make utility? [p. 367]
Â

make is a standard UNIX utility. The GNU version. known as GNU Make, 1s
included in most Linux distributions. lt's also available directly from the Free Soft-
ware Foundation (Guwu:gniorg/software/make/).

Exercises

Section 15.1 |.  Section 5.1 listed several advantages of dividing à program into multiple souree files.
(a) Describe several other advantages.
(b) Describe some disadvantages.

Section 15.2 @ 2 Which of the following should not be put in a header file? Why not?
(a) Function prototypes
(b) Function definitions

***************************page_399***************************
374 Chapter 15 Writing Large Programs

Section 15.4

6.

(c) Macro definitions
(d) Type definitions

We saw that writing #include <file> instead of #include "file" may not work if file is
onc that we've written. Would there be any problem with writing finclude "file" instead
of tinclude <file> if file is a system header?

Assume that debug. h is a header file with the following contents:

Hi£def DEBUG

#define PRINT DEBUG(n) print£ ("Value of " #n ": %d\n", n)
#else

#define PRINT DEBUG(n)

xendif

Let testdebug. c be the following source file:

#include <stdio.hs>

#Hdefine DEBUG
finclude "debug.h"

int main(void)

-À

int i = 1, j = 2, k = 3;

iifdef DEBUG

print£ ("Output if DEBUG is defined:\n") ;
#else

print£f("Output if DEBUG is not defined:\n") ;
#endif

PRINT DEBUG(i) ;
PRINT DEBUG(j) ;
PRINT DEBUG (k) ;
PRINT DEBUG(i + j);
PRINT _ DEBUG(2 * i + j - k);

return 0;

}

(a) Whatis the output when the program is exccuted?

(b) What is the output if the #de£ine directive is removed from testdebug.c’

(c) Explain why the output is different in parts (a) and (b).

(d) Is it necessary for the DEBUG macro to be defincd before debug . h is included in order
for PRINT_DEBUG to have the desired effect? Justify vour answer.

Suppose that à program consists of three source files—main.c. f1.c, and f2. c—plus
two header files. £1 .h and £2 .h. AIl three source files include f1 . h, but only f1.c and
£2 .c include £2.h. Write à makefile for this program, assuming that the compiler is gcc
und that the executable file is to be named demo.

The following questions refer to the program described in Exercise 5.

(a) Which files need to be compiled when the program is built for the first time?

(b) If£1.C is changed after the program has bcen built, wvhich files need to be recompiled?
(c) If £1.his changed after the program has been built, which files need to be recompiled”
(d) Il £2 .h is changed after the program has bcen built, which files need to be recompiled”

***************************page_400***************************
tV

_U\

Programming Projects 375

Programming Projects

The justi£y program of Section 15.3 justifies lines by inserting extra spaces between
words. The way the write line function currently works, the words closer to the end of
à line tend to have slightly wider gaps between them than the words at the beginning. (For
example. the words closer to the end might have three spaces between them. while the
words closer to the béginning might be separated by only two spaces.) Improve the program
by having write_line alternate between putting the larger gaps at the end of the line and
putting them at the beginning of the line.

Modify the justi£y program of Section 15.3 by having the read_word function
(instead of ma in) store the * character at the end of à word that’s been truncated.

Modify the gsort.c program of Section 9.6 so that the quicksort and split func-
tions are in a separate file named quicksort.c. Create a header file named quick-
sort.h that contains prototypes for the two functions and have both gsort .c and
quicksort .c include this file.

Modify the remind. c program of Section 13.5 so that the read_line function Is In à
scparate file named readline. c. Create a header fîle named readline.h that contains
a prototype for the function and have both remind.c and readline.c include this file.

Modify Programming Project 6 from Chapter 1O so that it has separate stack.h and
stack. c files. as described in Section 15.2.

***************************page_401***************************

***************************page_402***************************
16

16.1

Structures, Unions, and
Enumerations

Functions delay binding: data structures induce binding.
Moral: Structure data late in the programming process.

This chapter introduces three new types: structures, unions. and enumerations. À
structure is à collection of values (members). possibly of different types. À union
is similar to à structure. except that its members share the same storage: as à result,
à union can storc one member at a time. but not all members simultancously. An
enumeration is an intéger type whose values are named by the programmer.

Of these threc types. structures are by far the most important, so l'IL devote
most of the chapter to them. Section 16.1 shows how to declare structure variables
and perform basic operations on them. Section 16.2 then explains how to define
structure types. which—among other things—allow us to write functions that
accept structure arguments or retum structures. Section 16.3 explores how arrays
and structures can be nested. The last two sections are devoted to unions (Section
16.4) and enumerations (Section 16.5).

 

Structure Variables

The only data structure wc*ve covered so far is the array. Arrays have two impor-
tant properties. First, all elements of an array have the same type. Second, to select
an array clement. we specify its position (as an integer subscript).

The properties of à structure are quite different from those of an array. The
elements of à structure (its members. in C parlance) aren’t required to have the
sume type. Furthermore. the members of à structure have names: to select à partic-
ular member, we specify its name, not its position.

Structures may sound familiar, since most programming languages provide a
similar feature. In some languages. structures are called records, and members arc
known as fields.

377

***************************page_403***************************
378

Chapter 16  Structures, Unions, and Enumerations

Declaring Structure Variables

When we need to store a collection of related data items, a structure is a logical
choice. For example. suppose that we need to keep track of parts in a warehouse.
The information that we'Il need to store for each part might include a part number
(an integer), a part name (a string of characters). and the number of parts on hand
(an integer). To create variables that can store all three items of data. we might use
a declaration such as the following:

struct |
int number;
char name [NAME_LEN+1] ;
int on hand;

} part1, part2;

Each structure variable has three members: number (the part number), name (the
name of the part). and on_hand (the quantity on hand). Notice that this declara-
tion has the same form as other variable declarations in C: struct Ç … } specifies
à type, while part1 and part2 arc variables of that type.

The members of à structure are stored in memory in the order in which they're
declared. In order to show what the part1 variable looks like in memory, let's
assume that (1) part1 is located at address 2000, (2) integers occupy four bytes.
(3) NAME_LEN has the value 25, and (4) there are no gaps between the members.
With these assumptions, part1i will have the following appearance:

2000

2001
>number
2002
2003
2004

p name
2029
2030
2031
>on _hand

2032

2033

 

 

 

 

***************************page_404***************************
16.1  Structure Variables 379

Usually it’s not necessary to draw structures in such detail. l'Il normally show
them more abstractly, as a series of boxes:

number
naine

on_hand

] may sometimes draw the boxes horizontally instead of vertically:

001

number s/ name on hand

 

Member values will go in the boxes later; for now, l’ve left them emply.

Each structure represents à new scope: any names declared in that scope won t
conflict with other names in a program. (In C terminology. we say that cach struc-
ture has à separate name space for its members.) For example, the following decla-
rations can appear in the same program:

struct |
int number;
char name [NAME LEN+1] ;
int on hand;

} partl, part2:;

struct (
char name [NAME LEN+1] ;
int number;
char sex;

} employeel, employee2;

The number and name members in the part1 and part2 structures don't con-
flict with the number and name members in employeel and employee2.

Initializing Structure Variables

Like an array, à structure variable may be initialized at the time it’s declared. To
initialize à structure, we prepare a list of valucs to be stored in the structure and
enclose 11 in braces:

struct {
int number ;
char name [NAME _ LEN+1}] ;
int on hand;
} part1 = {528, "Disk drive"”, 10},
part2 = {914, "Printer cable", 5};

***************************page_405***************************
 

380

Chapter 16

Structures, Unions, and Enumerations

The values in the initializer must appear in the same order as the members of the
structure. In our example, the number member of part1 will be 528, the name
member will be "Disk drive*". and so on. Here’s how part1 will look after
initälization:

number 528

 

 

name Daisk drive

—

on _ hand 10

 

Structure initializers follow rules similar to those for array initializers. Expres-
sions used in a structure initializer must be constant: for example. we couldn’t have
used a variable to initialize partl's on hand member. (This restriction is re-
laxed in C99., as we’I1 scc in Section 18.5.) An initializer can have fewer members
than the structure it's initializing: as with atays, any “leftover” members are given
O as their initial value. In particular, the bytes in a leftover character array will be
zero, making it represent the emply string.

Designated Initializers

C99's designated initializers, which were discussed in Section 8.1 in the context of
arrays, can also be used with structures. Consider the initializer for part1 shown
in the previous example:

{528, "Disk drive", 10}

À designated initializer would look similar, but with each value labeled by the
name of the member that it initializes:

{.number = 528, .name = "Disk drive", .on_hand = 10}

The combination of the pertod and the member name is called à designator. (Des-
ignators for array elements have à different form.)

Designated initializers have several advantages. For one, they're easier to read
and check for correctness. because the reader can clearly see the correspondence
between the members of the structure and the values listed in the initializer.
Another is that the values in the initializer don’t have to be placed in the same
order that the members are listed in the structure. Our example imitializer could be
written as follows:

{.on hand = 10, .name = "Disk drive", .number = 528}

Since the order doesn't matter. the programmer doesn’t have to remember the
order in which the members were originally declared. Morcover. the order of
the members can be changed in the future without affecting designated initializ-
ers.

***************************page_406***************************
Ivalues > 4.2

table of operators > Appandix À

16.1  Structure Variables 381

Not all values listed in a designated initializer need be prefixed by a designa-
tor. (This is true for arrays as well. as we saw 1n Section 8.1.) Consider the follow-
ing example:

{.number = 528, "Disk drive", .on _ hand = 10}

The value "Disk drive" doesn't have a designator, so the compiler assumes
that it initializes the member that follows number in the structure. Any members
that the initializer fails to account for arce set lo Zero.

Operations on Structures

Since the most common array operation is subscripting—selecting an element by
position—it's not surprising that the most common opération on a structure is
selecting one of its members. Structure members are accessed by name, though.
not by position.

To access a member within a structure. we write the name of the structure first,
then a period, then the name of the member. For example, the following statements
will display the values of part1's members:

print£("Part number: %“d\n", part1.number) ;
print£("Part name: %s\n", partl.name) ;
printf ("Quantity on hand: *d\n", partl1.on hand) ;

The members of a structure are [values, so they can appear on the left side of
an assignment or as the operand in an increment or decrement expression:

parti.number = 258; /* changes partl's part number */
part1.on _ hand++; /* increments partl's quantity on hand */

The period that we use to access à structure member ts actually a C operator. l
has the same precedence as the postfix ++ and - - operators. so it takes precedence
over nearly all other operators. Consider the following example:

scanf ("*d", &partl.on hand) ;

The expression &part1l.on hand contains two operators (& and .). The
operator takes precedence over the & operator, so & computes the address of
part1.on hand. as we wished.

The other major structure operation 1S assignment:

part2 = parcl;

The cffect of this statement is to copy part1.number into part2.number,
partl .name into part2 .name, and so on.

Since arrays can‘t be copied using the = operator, it comes as something of a
surprise to discover that structures can. ll's even more surprisine when you con-
sider that an array embedded within à structure is copied when the enclosing struc-
ture is copied. Some programmers exploit Uhis property by creating “’dummy”
structures to enclose arrays that will be copied later:

***************************page_407***************************
382

Chapter 16

QaÂ

16.2

e 770

type definitions » 7.5

Structures, Unions, and Enumerations

struct { int a[10]; } al, a2;

al = a2; /* legal, since al and a2 are structures */

The = opérator can be used only with structures of compatible types. Two
structures declared at the same time (as part1 and part2 were) are compatible.
Âs wc'1l see in the next section. structures declared using the same “structure tag”
or the same type name are also compatible.

Other than assignment, C provides no operations on entire structures. In par-
licular, we can’t use the == and != operators to test whether two structures are
equal or not equal.

Structure Types

Although the previous section showed how to declare structure vartables, it failed
to discuss an important issue: naming structure /vpes. Suppose that a program
needs to declare several structure variables with identical members. If all the vari-
ables can be declared at one time. there’s no problem. But if we need to declare the
vartables at different points in the program, then life becomes more difficult. IF we
write

struct (
int number;
char name [NAME LEN+1] ;
int on hand;

} part1;

in one place and

struct (
int number ;
char name [NAME _LEN+1] ;
int on hand;

} part2;

in another, we'Il quickly run into problems. Repeating the structure information
will bloat the program. Changing the program later will be risky. since we can'l
easily guarantee that the declarations will remain consistent.

But those aren't the biggest problems. According to the rules of C. parti
and part2 don't have compatible types. As a result, part1 can*t be assigned to
part2, and vice versa. Also, since wc don't have a name for the type of part1or
part2, we can't use them as arguments in function calls.

To avoid these difficulties. we need to be able to define a name that represents
a fype oË structure. not a particular structure variable. As it turns out, C provides
iwo ways to name structures: we can either declare a ‘’structure tag” or use
typede£ to definc a type name.

 

***************************page_408***************************
16.2 Structure Types 383

Declaring a Structure Tag

A structure tag is « name used to identify a particular kind of structure. The fol-
lowing example declares a structure tag named part:

struct part |
int number ;
char name [NAME LEN+1] ;
int on hand;

}7

Notice the semicolon that follows the right brace—it must be present to terminate
the declaration.

 

Accidentally omitting the semicolon at the end of a structure declaration can cause
surprising errors. Consider the following example:

struct part |
int number;
char name (NAME LEN+1] ;
int on hand;

} /*** WRONG: semicolon missing ***/
f (void)
(

return 0; /* error detected at this line */
}

The programmer failed to specify the return type of the function £ (a bit of sloppy
programming). Since the preceding structure declaration wasn't terminaled prop-
erly, the compiler assumes that £ returns a value of type struct part. The error
won't be detected until the compiler reuches the first return statement in the
function. The result: a cryptic error message.

 

Once we've created the part tag, we can use it to declare variables:
struct part partl, part2;
Unfortunately. we can’t abbreviate this declaration by dropping the word struct:
part partl, part2; /*** WRONG ***/

part isn’t a type name: without the word struct, 1t 1s meaningless.

Since structure tags aren‘t recognized unless preceded by the word struct.
they don’t confliet with other names used in a program. It would be perfectly legal
(although more than a little confusing) to have a variable named part.

Incidentally. the declaration of a structure rag can be combined with the decla-
ration of structure variables:

***************************page_409***************************
384

Chapter 16  Structures, Unions, and Enumerations

linked lists » 775

struct part {
int number;
char name [NAME LEN+1] ;
int on hand;

} part1l, part2;

Here, we ve declared a structure tag named part (making 1t possible to use part
later to declare more variables) as well as variables named part1 and part2.

AIl structures declared to have type struct part are compatible with one
another:

struct part partl = {528, "Disk drive", 10};
struct part part2;

part2 = partl; /* legal; both parts have the same type */

Defining a Structure Type

Às an alternative to declaring à structure tag. we can use typede£ to define a
genuine type name. For example. we could define a type named Part 1n the fol-
lowing way:

typedef struct {
int number;
char name [NAME LEN+1] ;
int on hand;

} Part;

Note that the name of the type. Part. must come at the end. not after the word
struct.

We can use Part in the same way as the built-in types. For example. we
mieht use it to declare variables:

Part partl, part2;

Since Part 1s à typedef name. we're not allowed to write struct Part. AIl
Part variables. regardless of where thev‘re declared, are compatible.

When it comes time to name a structure, we can usually choose cither to
declare a structure tag Or Lo use typedef. However. as we'Il sec later, declaring à
structure tag is mandatory when the structure 1s to be used in a linked list. PIl use
structure tags rather than typede£ names In most of my examples.

Structures as Arguments and Return Values

Functions may have structures as arguments and return values. Let’s look at two
examples. Our first function. when given a part structure as its argument. prints
the structure’s members:

void print part (struct part p)

(

printf ("Part number: %d\n", p.number) ;

***************************page_410***************************
FILE type > 22.17

16.2  Structure Types 385

print£("Part name: %s\n", p.name) ;
print£ ("Quantity on hand: %d\n", p.on hand}) ;

Here's how print _part might be called:
print part (part1l) ;
Our second function returns a part structure that it constructs from its arguments:

struct part build part (int number, const char *name,
int on hand)

struct part p;

p.number = number;
strcopy(p.name, name) ;
p.on hand = on hand;
return p;

!

Notice that it’s legal for build _part's parameters to have names that match the
members of the part structure, since the structure has its own name space. Here's
how build_part might be called:

parti = build part (528, "Disk drive", 10);

Passing a structure to à function and returning à structure from a Function both
require making a copy of all members in the structure. Às à result. these operations
impose à fair amount of overhead on a program, especially 1f the structure 1s large.
To avoid this overhead. it’s sometimes advisable to pass à pointer to à structure
instead of passing the structure itself. Similarly, we might have a function return a
pointer to a structure instead of returning an actual structure. Section 17.5 gives
examples of functions that have a pointer to a structure as an areument and/or
leturn à pointer to à structure.

There are other reasons to avoid copying structures besides efficiency. For
example, the <stdio .h> header defines à type named FILE. which 1s typically a
structure. Each FILE structure stores information about the state of an open file
and therefore must be unique in a program. Every function in <stdio.h> that
opens a file returns a pointer to a FILE structure, and every function that performs
an opcration on an open file requires a FILE pointer as an argument.

On occasion, we may want to initialize a structure variable inside à function to
match another structure, possibly supplied as a parameter to the function. In the
following example, the initializer for part2 is the parameter passed to the £ func-
tion:

void f(struct part partl)

(

struct part part2 = partl;

***************************page_411***************************
386 Chapter 16 Structures, Unions, and Enumerations

automatic storage duration > 70.7

æ

16.3

C permits initializers of this kind, provided that the structure we’re initializing
(part2, in this case) has automatic storage duration (itl's local to à function and
hasn’t been declared static). The initializer can be any expression of the proper
type, including a function call that retums a structure.

Compound Literals

Section 9.3 introduced the C99 feature known as the compound literal, In that sec-
tion, compound literals were used to create unnamed arrays, usually for the pur-
pose of passing the array to a function. À compound literal can also be uscd to
create a structure “on the fly.” without first storing it In à variable. The resulting
structure can be passed as a parameter, returned by a function. or assigned to à
variable. Let's look at a couple of examples.

First, we can use a compound literal to create a structure that will be passed to
à function. For example, we could call the print part function as follows:

print part ((struct part) {528, "Disk drive", 10}) ;

The compound literal (Shown in bold) creates a part structure containing the
members 528, "Disk drive*", and 10. in that order. This structure 1s then passed
to print part, which displays 1t.

Here’s how a compound literal might be assigned to a variable:

parti = (sLrucL pazl) ({(528, "Disk drive", 10};

This statement resembles a declaration containing an initializer. but 1tl’s not the
same—initializers can appear only in declarations, not in statements such as this
one.

In general. a compound literal consists of a type name within parentheses, fol-
lowed by a set of values enclosed by braces. In the case of a compound literal that
represents a structure, the type name can be a structure tag preceded by the word

struct—as In our examples—or a typedef namè. À compound literal may —

contain designators, just like a designated initializer:

print part ((struct part) {.on _ hand = 10,
.name = "Disk drive",
.number = 528});

À compound literal may fail to provide full initialization, in which case any unini-
tialized members default to zero.

Nested Arrays and Structures

Structures and arrays can be combined without restriction. Arrays may have struc-
tures as their elements, and structures may contain arrays and structures as mem-
bers. Wc've already seen an example of an array nested inside a structure (the

 

 
   

***************************page_412***************************
16.3  Nested Arrays and Structures 387

name member of the part structure). Let's explore the other possibilities: struc-
tures whose members are structures and arrays whose elements are structures.

Nested Structures

Nesting one kind of structure inside another is often useful. For example, suppose
that we’ve declared the following structure, which can store a person's first name,
middle initial, and last name:

struct person_name {
char first [FIRST NAME _LEN+1] ;
char middle initaial;
char last [LAST NAME LEN+1] ;

} ;
We can use the person _name structure as part of a larger structure:

struct student {
struct person _name name ;
int id, age;
char sex;

} student1l, student2;

Accessing student1's first name, middle initial, or last name requires two appli-
cations of the . operator:

stropy (studentl.name.first, "Fred") ;

One advantage of making name a structure (instead of having first.
middle initial, and last be members of the student structure) is that
we can more casily treat names as units of data. For example, if we were lo
write a function that displays a name. we could pass it just one argument—a
person _name structure—instead of three arguments:

display _ name (studentl.name) ;

Likewise, copying the information from a person_name structure to the name
member of a student structure would take one assignment instead of three:

Struct person_name new_name ;

studentl.name = new name;

Arrays of Structures

Onc of the most common combinations of arrays and structures is an array whose
elements are structures. An array of this kind can serve as a simple database. For
example, the following array of part structures 1s capable of storing information
about 100 parts:

struct part inventory [100] ;

***************************page_413***************************
388

Chapter 16  Structures, Unions, and Enumerations

To access onc of the parts in the array, we’d use subscripting. To print the part
stored in position i, for example, we could write

print part (inventory [i] ) ;

Accessing à member within a part structure requires a combination of sub-
scripting and member selection. To assign 883 to the number member of
inventory [i]. we could write

inventory [i] .number = 883;

Accessing a single character in a part name requires subscripting (to select a par-
ticular part), followed by selection (to select the name member). followed by sub-
scripting (to select a character within the part name). To change the name stored in
inventory [i] to an empty string, we could write

inventory [i] .name [(0] = '\0';

Initializing an Array of Structures

Initializing an array of structures is done in much the same way as initializing a
multidimensional array. Each structure has its own brace-enclosed initializer; the
initalizer for the array simply wraps another set of braces around the structure ini-
tializers.

One reason for initializing an array of structures is that we‘re planning to treat
it as a database of information that won't change during program execution. For
example. suppose that we're working on a program that will need access to the
country codes used when making international telephonc calls. First. we*Il set up a
structure that can store the name of a country along with its code:

struct dialing code {
char *country;
int code;

} z

Note that country 1s a pointer, not an array of characters. That could be a prob-
lem if we were planning to use dialing_code structures as variables. but we're
not. When we initialize a dialing _ code structure, country will end up
pointing to a string literal.

Next, wc'Il declare an array of these structures and initialize it to contain the
codes for some of the world’s most populous nations:

const struct dialing_code country codes[] =

{{'Argentina", 54}, {"Bangladesh", 880},
{"Brazil", 55}, {"Burma (Myanmar)", 95},
{"China", 86}, {"Colombia", 57},
{"Congo, Dem. Rep. of", 243}, {"Egypt", 20},
{"Ethiopia", 251}, {"France", 33},
{"Germany", 49}, {"India", 91},

***************************page_414***************************
PROGRAM

16.3  Nested Arrays and Structures 389

{"Indonesia", 62}, {"Iran", 98},
{"Italy", 39}, {"Japan", 81},
( Mexico!, 52}, {"Nigeria", 234},
{"Pakistan", 92}, {"Philippines", 63},
{"Poland", 48}, ("Russia", 7},
{"South Africa", 27}, {"South Korea", 82},
e 34}/ (vsudant, 249).
{"Thailand", 66}, {("Turkey", 90},
{"Ukraine", 380}, {"United Kingdom", . 44},
{"United States", 1}, {"Vietnam", 84}} ;

The inner braces around each structure value are optional. As a matter of style.
however, | prefer not to omit them.

Because arrays of structures (and structures containing arrays) are so com-
mon, C99's designated mnitializers allow an item to have morc than one designator.
Suppose that we want to imitalize the inventory array to contain a single part.
The part number 1s 528 and the quantity on hand is 10, but the name is to be left
empty for now:

struct part inventory [100] =
{ [0] .number = 528, [0] .on hand = 10, [0] .name[0] = '\o'};

The first two 1tems in the list use two designators (one to select array element O—
a part structure—and one to select a member within the structure). The last item
uses three designators: one to select an array element, one to select the name
member within that element. and one to select element 0 of name.

Maintaining a Parts Database

To illustrate how nested arrays and structures are used in practice. we'll now
develop a fairly long program that maintains a database of information about parts
stored in a warehouse. The program 1s built around an array of structures, with
each structure containing information—part number, name, and quantity—about
one part, Our program will support the following operations:

u Adda new part number, part name, and initial quantity on hand. The pro-
gram must print an ecrror message 1f the part 1s already in the database or 1f the
database 1s fuil.

# Given a part number, print the name of the part and the current quantity on
hand. The program must print an error message 1f the part number isn’tin the
database.

u Given à part number, change the quantity on hand. The program must print
an error message 1f the part number isn°t in the database.

u Print a table showing all information in the database. Parts must be dis-
played in the order in which they were entered.

u Terminate program execution.

***************************page_415***************************
390 Chapter 16 Structures, Unions, and Enumerations

We'll use the codes i (insert). s (search), u (update). p (print). and q (quit) to rep-
resent thesc operations. À session with the program might look like this:

Enter onperation code: i
Enter part number: 528
Enter part name: Disk drive
Enter quantity on hand: 10

 

Enter operation code: s
Enter part number: 528
Part name: Disk drive
Quantity on hand: 10

Enter operation code: s
Enter part number: 914
Part not É£ouna.

Enter operation code: i
Enter part number: 914

Enter part name: Printer cable
Enter quantity on hand: S

 

 

Enter operation code: u

Enter part number: 528

Enter change in quantity on hand: -2
Enter operation code: s

Enter part number: 528

Part name: Disk drive

Quantity on hand: 8

Enter operation code: p

Part Number

528
914

Part NamË
Disk drive
Printer cable

Quantity on Hand
8
5

Enter operation code: q

The program will store information about cach part in à structure. We"ll limit
the size of tfhe database to 100 parts. making it possible to store the structures in an
array, which l’Il call inventory. (If this limit proves to be too small, we can
always change it latér.) To kcep track of the number of parts currently stored In the
array, we ll use à vartable named num parts.

Since this program is menu-driven, it’s fairly casy to sketch the main loop:

Eor (;;) |

prompt user to enter operation code ;

read code ;

switch (code) |
case ‘i': perform insert operation; break;
case ‘'s': perform search operation; break;
case ‘'u': perform update operation; break;
case ‘p': perform print operation; break;

***************************page_416***************************
inventory.c

16.3  Nested Arrays and Structures 391

case 'q': ferminate program ;
default:  print error message ;

It will be convenient to have separate functions perform the insert, search.
update, and print operations. Since these functions will all need access to
inventory and num _ parts, we might want to make these variables external.
Âs an alternative, we could declare the variables inside main, and then pass them
to the functions as arguments. From à design standpoint, it’s usually better to make
variables local to à function rather than making them external (see Section 10.2 if
you’ve forgotten why). In this program, however, putting inventory and
num _parts Inside main would merely complicate matters.

For reasons that TIl explain later, ’ve decided to split the program into three
files: inventory.c. which contains the bulk of the program: readline.h,
which contains the prototype for the read_line function; and readline. c,
which contains the definition of read_line. We'll discuss the latter two files
later 1n this section. For now, let’s concentrate on inventory. c.

/* Maintains a parts database (array version) */

#include <stdio.h>
#include "readline.h"

#define NAME LEN 25
#define MAX PARTS 100

struct part |
int number ;
char name [NAME LEN+1] ;
int on hand;

} inventory [MAX PARTS] ;

int num parts = 0; /* number of parts currently stored */

int find part (int number) ;
void insert (void) ;

void search (void) ;

void update (void) ;

void print (void) ;

/********************************—k*************************

* main: Prompts the user to enter an operation code, *
* then calls a function to perform the requested *
* action. Repeats until the user enters the *
* command 'q'. Prints an error message if the user *
x enters an illegal code. *
*****—k—k—k*—k—k*********—k***********—k*************************/

int main(void)

(

char code ;

***************************page_417***************************
392 Chapter 16  Structures, Unions, and Enumerations

for (;;) |
print£f ("Enter operation code: ");
scan£f (" %c", &code) ;
while (getchar() != '\n') /* skips to end of line */

’

switch (code) (

case 'i': insert ();
break;
case 's': search() ;
break ;
case 'u': update();
break ;
case ‘'p': print();
break;

case 'q': return D);
default: printf("I1llegal code\n") ;

;

print£("\n") ;
}
}

/******—k************************—k****—k***—k******—k**—ki—***—k**

* £Find part: Looks up a parct number in the inventory *
* array. Returns the array index if the part *
* number is found; otherwise, returns -1. *

***'À'***'k****—k************'ä"ä:************+**Ë+*******‘k**'.‘.“k**/

int find_part(int number )

(

int i;
for (i = 0; i < num parts; i++)
if (inventory [i] .number == number)
return i;

return -;

}

/‘k*******-k*'k'k*****'k********:‘r*****************************#$:

* insert: Prompts the user for information about a new *
* part and then inserts the part into the *
* database. Prints an error message and returns *
* prematurelyv if the part already exists or the *
* database is full. *
*****‘k'æ\‘*‘k‘*‘k**‘k***‘k*+*‘P‘k********‘k‘:‘\‘****************‘k********/

void insert (void)

{

int part number;

if (num parts == MAX PARTS) {
print£ ("Database is full; can't add more parts.\n") ;
return;

}

print£ ("Enter part number: ") ;
scan£("%d", &part number) ;

***************************page_418***************************
16.3  Nested Arrays and Structures 393

if (find part (part_number) >= 0) |
print£f("Part already exists.\n") ;
return;

}

inventory [num _ parts|] .number = part _number ;
print£f ("Enter part name: ") ;

read_line (inventory [num_parts] .name, NAME _ LEN) ;
print£ ("Enter quantity on hand: ") ;

scanf£f ("%d", &inventory [num _ parts] .on _ hand) ;

num _parts++;

}

/*'k*******************‘k*****************************‘k**‘k***

* search: Prompts the user to enter a part number, then *

* looks up the part in the database. I£ the part *
* exists, prints the name and quantity on hand; *
* if not, prints an error message. *

***********-k****'k***‘k***%‘****************************‘k****/

void search(void)

{

int i, number;

printf ("Enter part number: ") ;
scanf ("%d", &number) ;
i = find part (number) ;
if (i >= O) (
printf ("Part name: %s\n", inventory [1] .name) ;
print£ ("Quantity on hand: %d\n", inventory [i] .on _ hand) ;
} else
print£f ("Part not found.\n") ;

}

/—k***—k***********‘à‘****************************************‘k

* update: Prompts the user to enter a part number.

* Prints an error message if the part doesn't *
* exist; otherwise, prompts the user to enter *
* change in quantity on hand and updates the *
* database. *
* *

XKX KXKKXKXKKKEKKKXRKKKRKNKAKKEKKAAAAAXAAKKERAKKARKRKKXKXK /

void update (void)

{

int i, number, change;

printf ("Enter part number: ") ;
scanf ("%d", &number) ;
i = find part (number) ;
if (i >= 0O) {
print£ ("Enter change in quantity on hand: ") ;
scanf ("$d", &change) ;
inventory [i] .on hand += change;
} else
print£f ("Part not found.\n") ;

***************************page_419***************************
394 Chapter 16  Strucitures, Unions, and Enumerations

/******‘k‘***‘k**‘k*******'k**‘k****‘k**'k***'k***‘k‘k****'ﬁ"Â'*‘k‘k******'ﬂ.‘

* print: Prints a listing of all parts in the database, *

* showing the part number, part name, and *
* quantity on hand. Parts are printed in the *
* order in which they were entered into the *
* database. *

**‘k****—k*—k**k*****k******'k'k****-k*—k***'k***+******—k******—k—k—k**/

void print (void)

{

int 1;

print£f ("Part Number Part Name !"
"Quantity on Hand\n") ;
for (i = 0; i < num parts; i++)
printf("%7d %-25s%11d\n", inventory [i]l .number,
inventory [i] .name, inventory [i] .on_hand) ;

In the main function, the format string " %c" allows scanf to skip over
white space before reading the operation code. The space in the format string 1s
crucial; without it, scan£f would sometimes read the new-line character that ter-
minated a previous line of input.

The program contains one function, find part. that isn'{ called from
main. This “helper” function helps us avoid redundant code and simplify the
more important functions. By calling find _ part. the insert. search. and
update functions can locate a part in the database (or simply determine 1f the
part exists).

There’s just one detail left: the read_line function. which the program uses
to read the part name. Section 13.3 discussed the issues that are involved in writing
such à function. Unfortunately. the version of read _line in that section won !
work properly in the current program. Consider what happens when the user
inserts a part:

Enter part number: 528
Enter part name: Disk drive

 

 

Fhe user presses the Enter key after entering the part number and again after enter-
Ing the part name. each time leaving an invisible new-line character that the pro-
gram must read. For the sake of discussion, let's pretend that these characters are
visible:

Enter part number: 528F
Enter part name: Disk drive©

 

 

When we call scan£ (o read the part number. it consumes the 5. 2, and 8. but
leaves the 9 character unread. If we try to read the part name using our original
read _line function, it will encounter the © character immediately and stop
reading. This problem is common when numerical input is followed by character
input. Our solution will be to write a version of read_line that skips white-

***************************page_420***************************
readline.h

readline.c

isspace lunction > 23.5

16.3  Nested Arrays and Structures 395

space characters before 11 begins storing characters. Not only will this solve the
new-line problem, but it also allows us to avoid storing any blanks that precede the
part name.

Since read_line is unrelated to the other functions in inventory. c, and
since il’s potentially reusable in other programs, l’ve decided to separate it from
inventory.c. The prototype for read_line will go in the readline.h
header file:

#ifndef READLINE H
iidefine READLINE H

/*k****‘k*k'k‘k%‘**‘k*k****‘k*‘k****‘k‘k***+******‘k‘**************—k-k*—k**

* read _ line: Skips leading white-space characters, then

* reads the remainder of the input line and *
# stores it in str. Truncates the line if its *
* length exceeds n. Returns the number of *
* characters stored. *
KKKN RERRARARAA RR AARR K

/

int read line(char str[(], int n);
tendif
We'Il put the definition of read_line in the readline. c file:

#finclude <ctype.h>
#include <stdio.h>
#include "readline.h"

int read line(char str{[], int nP)

{

int ch, à = O0;

while (isspace(ch = getchar()))

'

while (ch != '\n' && ch != EOF) {
if (i < n)
str[i++] = ch;
ch = getchar () ;
}
str[i)] = '\0*;
return i;

}
The expression
isspace (ch = getchar())

controis the first while statement. This expression calls getchar to read a char-
acter, stores the character into ch, and then uses the isspace function to test
whether ch is a white-space character. If not, the loop terminates with ch contain-
ing à character that's not white space. Section 15.35 explains why ch has type int
Instead of char and why it°s good to test for EOF.

***************************page_421***************************
396

Chapter 16 _ Structures, Unions, and Enumerations

16.4 Unions

À union, like a structure. consists of one or more members. possibly of different
types. However, the compiler allocates only enough space for the largest of the
members, which overlay each other within this space. As a result. assigning a new
value to one member alters the values of the other members as well.

To illustrate the basic propertics of unions, let’s declare a union variable, u.
with two members:

union {
int i;
double d;
} u;

Notice how the declaration of à union closely resembles a structure declaration:

struct {
int i;
double d;
} s:

In fact, the structure s and the union u differ in just onc way: the members of s are
stored at d'ifferent addresses in memory. while the members of u are stored at the

same address. Here's what s and u will look like in memory (assuming that int
values require four bytes and double values take cight bytes):

Structure Union
q [ f }

 

ps-
rrN
Ï

 

 

 

 

 

 

 

 

 

 

***************************page_422***************************
16.4 Unions 397

In the s structure, i and d occupy different memory locations: the total size of s is
12 bytes. In the u union, i and d overlap (i 1s really the first four bytes of d), so u
occupies only eight bytes. Also, à and d have the same address.

Members of a union are accessed in the same way as members of a structure.
To store the number 82 in the à member of u. we would write

u.i = 82;
To store the value 74.8 in the d member. we would write
u.d = "74.B;

Since the compiler overlays storage for the members of a union, changing one
member alters any value previously stored in any of the other members. Thus, if
we store a value in u. d. any value previously stored in u. i will be lost. (IF we
examine the value of u. i. it will appear to be meaningless.) Similarly, changing
u. i corrupts u . d. Because of this property, we can think of u as a place to store
cither i or d. not both. (The structure s allows us to store i and d.)

The properties of unions arc almost identical to the properties of structures.
We can declare union tags and union types in the same way we declare structure
tags and types. Like structures. unions can be copied using the = operator. passed
to functions, and returned by functions.

Unions can even be initialized in a manner similar to structures. However.
only the first member of à union can be given an initial value. For example, we can
initialize the i member of u to O in the following way:

union {
int i;
double d;
} u = {0};

Notice the presence of the braces. which are required. The expression inside the
braces must be constant. (The rules arc slightly different in C99. as wc'Il see In
Section 18.5.)

Designated initializers, a C99 feature that we’ve previously discussed in the
context of arrays and structures. can also be used with unions. À designated initial-
izer allows us to specify which member of à union should be initialized. For exam-
ple, we can initialize the d member of u as follows:

union (
int i;
double d;
} u = {.d = 10.0};

Only one member can be initialized. but it doesn't have to be the first one.

There are several applications for unions. We'Il discuss two of thesc now.
Another application—viewing storage in different ways—is highly machine-
dependent, so Il postpone it until Section 20.3.

***************************page_423***************************
398

Chapter 16  Structures, Unions, and Enumerations

Using Unions to Save Space

We 1l often use unions as a way to save space in structures. Suppose that we're
designing a structure that will contain information about an item that’s sold
through a gift catalog. The catalog carries only three kinds of merchandise: books,
mugs, and shirts. Each i1tem has à stock number and a price, as well as other infor-
mation that depends on the type of the item:

Books: Title, author, number of pages
Mugs: Design

Shirts: Design, colors available, sizes available

Our first design attempt might result in the following structure:

struct catalog item {
int stock _number;
double price;
int item type;
char title [TITLE LEN+1] ;
char author [AUTHOR LEN+1] ;
int num pages;
char design [DESIGN LEN+1] ;
int colors;
int sizes;

} ;

The 1item _type member would have onc of the values BOOK. MUG. or SHIRT.
The colors and sizes members would store encoded combinations of colors
and sizes.

Although this structure is perfectly usable, it wastes space. since only part of
the information in the structure is common to all items in the catalog. If an item is
a book, for example. there’s no necd to store design. colors, and sizes. By
putting a union inside the catalog_item structure, we can reduce the space
required by the structure. The members of the union will be structures, each con-
taining the data that’s necdcd for a particular kind of catalog item:

struct catalog item {
int stock number;
double price;
int item type;
union {
struct |
char title [TITLE LEN+1] ;
char author [AUTHOR LEN+1] ;
int num pages;
} book;
struct {
char design [DESIGN LEN+1] ;

} mug;

***************************page_424***************************
164  Unions 399

struct |{
char design [DESIGN LEN+1] ;
int colors;
int sizes;
} shirt;
} item;

} z

Notice that the union (named item) is a member of the catalog item
structure, and the book. mug. and shirt structures are members of item. If C is
a catalog_item structure that represents a book. we can print the book's title in
the following way:

o

print£("%s", c.item.book.title) ;

As this example shows, accessing a union that's nested inside a structure can be
awkward: to locate a book title, wc had to specify the name of a structure (c). the
name of the union member of the structure (i tem), the name of a structure mem-
ber of thé union (book). and then the name of a member of that structure (title).

We can use the catalog_item structure to illustrate an interesting aspect of
unions. Normally. it's not a good idca to store a value into one member of a union
and then access the data through a different member. because assigning to one
member of a union causes the values of the other members to be undefined. How-
ever, the C standard mentions a special case: two or more of the members of the
union are structures, and the structures begin with onc or more matching members.
(These members need to be in the same order and have compatible types, but need
not have the same name.) If onc of the structures is currently valid, then the match-
ing members in the other structures will also be valid.

Consider the union embedded in the catalog_item structure. IL contains
three structures as members. two of which (mug and shirt) begin with à match-
ing member (design). Now, suppose that we assign a value to one of the
design members:

stropy (c.item.mug.design, "Cats*") ;
The design member in the other structure will be defined and have the same value:

print£f("%s", c.item.shirt.design}) ; /* prints "Cats" */

Using Unions to Build Mixed Data Structures

Unions have another important application: creating data structures that contain «
mixture of data of different types. Let's say that we need an array whose elements
are a mixture of int and double values. Since the elements of an array must be
of the same type, it seems impossible to create such an array. Using unions,
though. its relatively easy. First. we define a union type whose members represent
the different kinds of data to be stored in the array:

***************************page_425***************************
400

Chapter 16  Structures, Unions, and Enumerations

typedef union {
int i;
double d;

} Number;

Next, we cercate an array whose elements are Number values:
Number number array [1000] ;

Each element of number array is a Number union. À Number union can
store either an int value or a double value, making it possible to store a mixture
of int and double values in number array. For example, suppose that we
want element 0 of number_array to store 5, while clement ! stores 8.395. The
following assignments will have the desired effect:

number array{[0].i = 5;
number array{[1] .d = 8.395;

Adding a ‘“Tag Field””’ to a Union

Unions suffer from à major problem: there’s no easy way to tell which member of
a union was last changed and therefore contains a meaningful value. Consider the
problem of writing a function that displays the value currently stored in a Number
union. This function might have the following outline:

void print _number (Number n)

{

Lf (n contains an integer)
print£("%d", n.i);
else
print£f ("%g"', n.d);

}

Unfortunately, there's no way for print_number to determine whether n con-
tains an integer or a floating-point number.

In order to keep track of this information, we can embed the union within à
structure that has one other member: à “tag field” or “discriminant’ whose pur-
pose 1s to remind us what's currently stored in the union. In the catalog item
Structure discussed earlier in this section, item _type served this purpose.

Let's convert the Number type into a structure with an embedded union:

#define INT KIND O
#define DOUBLE KIND 1

typedef struct (|
int kind; /* tag field */
union {
int i;
double d;
} u;
} Number ;

 

 

***************************page_426***************************
16.5

16.55 Enumerations 401

Number has two members. kind and u. The value of kind will be either
INT _ KIND or DOUBLE KIND.

Each time we assign a value to a member of u, we'Il also change kind to
remind us which member of u we modified. For example, if n is a Number vari-
able, an assignment to the i member of u would have the following appearance:

n.kind = INT KIND;
n.u.i = 82;

Notice that assigning to à requires that we first select the u member of n, then the
i member of u.

When we nced to retrieve the number stored in a Number variable, kind will
tell us which member of the union was the last to be assigned a value. The
print number function can take advantage of this capability:

void print _ number (Number n)
{
if (n.kind == INT _KIND)
printf("%d", n.u.i);
else
printf ("%$g", n.u.d);

 

Tts the program’s responsibility to change the tag field each time an assignment 1s
made to a member of the union.

 

Enumerations

In many programs, we’11 need variables that have only a small set of meaningful
values. À Boolean variable. for example, should have only two possible values:
“true” and ‘“false.” À variable that stores the suit of a playing card should have only
four potential values: “clubs)” “diamonds,” “hearts,” and “’spades.” The obvious
way to deal with such a variable is to declare it as an integer and have a set of codes

that represent the possible values of the variable:

int s; /* s will store a suit */

s = 2; /* 2 represents "hearts" */

Although this technique works, it leaves much to be desired. Someone reading the
program can°t tell that s has only four possible values, and the significance of 2
isn’t immediately apparent.

Using macros to define à suit “type” and names for the various suits is à step
in the right direction:

***************************page_427***************************
402

Chapter 16  Structures, Unions, and Enumerations

#define SUIT int
#define CLUBS 0
#define DIAMONDS 1
#define HEARTS 2
#define SPADES 3

Our previous example now becomes easier to read:

SUIT s;
s = HEARTS;

This technique is an improvement, but it’s still not the best solution. There’s no
indication to someone reading the program that the macros represent values of the
same ‘“type.” If the number of possible values is more than a few, defining a sepa-
rate macro for each will be tedious. Moreover, the names we*ve defined—CLUBS,
DIAMONDS, HEARTS, and SPADES—will be removed by the preprocessor, so
they won’t be available during debugging.

C provides à special kind of type designed specifically for variables that have
a small number of possible values. An enuwmnerated type 1s a type whose values are
listed (“enumerated”) by the programmer, who must create a name (an enumera-
tion constant) for each of the values. The following example enumerates the val-
ues (CLUBS, DIAMONDS, HEARTS, and SPADES) that can be assigned to the
variables s1 and s2:

enum {CLUBS, DIAMONDS, HEARTS, SPADES} s1, s2;

Although enumerations have little in common with structures and unions, they’re
declared in a similar way. Unlike the members of a structure or union, however, the
names of enumeration constants must be different from other identifiers declared
in the enclosing scope.

Enumeration constants are similar to constants created with the #define
directive, but they‘re not equivalent. For one thing, enumeration constants are sub-
Ject to C’s scope rules: if an enumeration is declared inside a function, its constants
won°t be visible outside the function.

Enumeration Tags and Type Names

We'1l often need to create names for enumerations, for the same reasons that we
name structures and unions. Às with structures and unions, there are two ways to
name an enumeration: by declaring a tag or by using typede£ to create a genuine
type name.

Enumeration tags resemble structure and union tags. To define the tag suit,
for example, we could write

enum suit {CLUBS, DIAMONDS, HEARTS, SPADES } ;
suit variables would be declared in the following way:

enum suit sl, s2;

***************************page_428***************************
16.55  Enumerations 403

Às an alternative, we could use typede£ to make Suit a type name:

typedef enum (CLUBS, DIAMONDS, HEARTS, SPADES} Suit;
Suit sl, s2;

In C89, using typedef to name an enumeration 1s an excellent way to create
a Boolean type:

typedef enum {FALSE, TRUE} Bool;

C99 has a built-in Boolean type, of course. so there’s no need for a C99 program-
mer to define a Bool type in this way.

Enumerations as Integers

Behind the scenes, C treats enumeration variables and constants as integers. By
default, the compiler assigns the integers O, |, 2, … to the constants in a particular
enumeration. In our suit enumeration, for example, CLUBS, DIAMONDS,
HEARTS, and SPADES represent O, !, 2, and 3, respectively.

We’re free to choose different values for enumeration constants if we like.
Let’s say that we want CLUBS, DIAMONDS, HEARTS, and SPADES to stand for |,
2, 3, and 4. We can specify these numbers when declaring the enumeration:

enum suit (CLUBS = 1, DIAMONDS = 2, HEARTS = 3, SPADES = 4};

The values of enumeration constants may be arbitrary integers, listed in no particu-

lar order:

enum dept {RESEARCH = 20, PRODUCTION = 10, SALES = 25};

It’s even legal for two or more enumeration constants to have the same value.
When no value is specified for an enumeration constant, its value is one

greater than the value of the previous constant. (The first enumeration constant has

the value O by default.) In the following enumeration, BLACK has the value O,
LT GRAY is 7,DK _ GRAY 1s 8, and WHITE is |5:

enum EGA colors {BLACK, LT _ GRAY = 7, DK GRAY, WHITE = 15};

Since enumeration values are nothing but thinly disguised integers, C allows
us to mix them with ordinary integers:

int 1;
enum (CLUBS, DIAMONDS, HEARTS, SPADES} s;

i = DIAMONDS; /* i is now 1 */
s = 0; /* s is now O (CLUBS) */
s++; /* s is now 1 (DIAMONDS) */
i = Ss + 2; /* i is now 3 */

The compiler treats s as à variable of some integer type: CLUBS, DIAMONDS,
HEARTS, and SPADES arc just names for the integers O, 1, 2, and 3.

***************************page_429***************************
404

Chapter 16  Structures, Unions, and Enumerations

/\

 

Although il’s convenient to be able to use an enumeration value as an integer, it’s
dangerous to use an integer as an enumeration value. For example, we might acci-
dentally store the number 4—which doesn‘t correspond to any suit—into s.

 

Using Enumerations to Declare ‘“Tag Fields”

Enumerations are perfect for solving a problem that we encountered in Section
16.4: determining which member of a union was the last to be assigned a value. In
the Number siructure, for example, we can make the kind member an enumera-
tion instead of an int:

typedef struct {
enum {INT KIND, DOUBLE KIND} kind;
union {
int i;
double d;
} u;
} Number ;

The new structure is used in exactly the same way as the old one. The advantages
are that we've done away with the INT KIND and DOUBLE KIND macros
(they’re now enumeration constants), and we’ve clarified the meaning of kind—
it?'s now obvious that kind has only two possible values: INT _ KIND and
DOUBLE _ KIND.

Q & À

When I tried using the sizeof operator to determine the number of bytes in
a structure, l got a number that was larger than the sizes of the members
added together. How can this be?

Let's look at an example:

struct |
char a;
int b;
} s;

If char values occupy one byte and int values occupy four bytes. how large 1s
s The obvious answer—five bytes—may not be the correct one. Some computers
require that the address of certain data items be a multiple of some number of bytes
(typically two, four, or eight, depending on the item's type). To satisfy this require-
ment, a compiler will “align’” the members of a structure by leaving “holes”
(unused bytes) between adjacent members. lf we assume that data items must

***************************page_430***************************
>.

 

Q & À 405

begin on a multiple of four bytes, the a member of the s structure will be followed
by a three-byte hole. Às à result. sizeo£ (s) will be 8.

By the way, à structure can have a hole at the end, as well as holes between
members. For example. the structure

struct |
int a;
char b;
} s;

might have à three-byte hole after the b member.

Can there be a ‘‘hole” at the beginning of a structure?

No. The C standard specifies that holes are allowed only berveen members or afier
the last member. One consequence 1s that a pointer to the first member of a struc-
ture is guaranteed to be the same as a pointer to the entire structure. (Note, how-
ever, that the Lwo pointers won’t have the same type.)

Why isn’t it legal to use the == operator to test whether two structures are
equal? [p. 382]

This operation was left out of C because therc’s no way to implement it that would
be consistent with the language's philosophy. Comparing structure members one
by one would be too inefficient. Comparing all bytes in the structures would be
better (many computers have special instructions that can perform such a compari-
son rapidly). If the structures contain holes, however, comparing bytes could yreld
an incorrect answer; even 1f corresponding members have 1dentical values. leftover
data stored in the holes might be different. The problem could be solved by having
the compiler ensure that holes always contain the same value (zero. say). Initializ-
ing holes would impose a performance penalty on all programs that use structures,
however, so it’s not feasible.

Why does C provide two ways to name structure types (tags and typedeËf
names)? [p. 382]

C originally lacked typedef, so tags were the only technique available for nam-
ing structure types. When typede£ was added. it was too late to remove lags.
Besides. a tag 1s still necessary when a member of a structure points to a structure
of the same type (see the node structure of Section 17.5).

Can a structure have both a tag and a typede£ name? [p. 384]

Yes. In fact, the tag and the typedef name can even be the same, although that’s
not required:

typedef struct part {
int number;
char name [NAME LEN+1] ;
int on hand;

} part;

***************************page_431***************************
406

Chapter 16  Structures, Unions, and Enumerations

Q:
A.

protecting header files » 75.2

> .Q

-8-

Q»

How can I share a structure type among several files in a program?

Put a declaration of the structure tag (or a typedeË. if you prefer) in a header file.
then include the header file where the structure is needed. To share the part struc-
ture, for example, we’d put the following lines in a header file:

struct part {
int number;
char name [NAME LEN+1] ;
int on hand;

} ;

Notice that we’re declaring only the structure /ag, not variables of this type.

Incidentally, à header file that contains a declaration of a structure tag or struc-
ture type may need protection against multiple inclusion. Declaring a tag or
typedef name twice in the same file is an error. Similar remarks apply to unions
and enumerations.

If I include the declaration of thé part structure into two different files, will
part variables in one file be of the same type as part variables in the other
ile?

Technically. no. However, the C standard says that the part variables in one file
have à type that’s compatible with the type of the part variables in the other file.
Variables with compatible types can be assigned to each other, so there’s little
practical difference betwcen types being ‘“compatible” and being “the same”

The rules for structure compatibility in C89 and C99 are slightly different. In
C89, structures defined in different files are compatible if their members have the
same names ancl appear in the same order, with corresponding members having
compatible types. C99 goes one step further: it requires that either both structures
have the same tag or neither has a tag.

Similar compatibility rules apply to unions and enumerations (with the same
difference between C89 and C99).

Is it legal to have a pointer to a compound literal?

Yes. Consider the print part function of Section 16.2. Currently, thè parame-
ter to this function is a part structure. The function would be more efficient 1f 1t
were modified to accept a pointer to à part structure instead. Using the function
to print a compound literal would then be done by prefixing the argument with the
& (address) operator:

print part (&(struct part) {528, "Disk drive", 10});

Allowing a pointer to a compound literal would seem to make it possible to
modify the literal. Is that the case?

Yes. Compound literals are Ivalues that can be modified, although doing so is rare.

I saw a program in which the last constant in an enumeration was followed by
a comma, like this:

***************************page_432***************************
Section 16.1

O- » À

l

Exercises 407

enum gray_values {
BLACK = O,
DARK GRAY = 64,
GRAY = 128,
LIGHT_GRAY = 192,

Is this practice legal?
This practice is indced legal in C99 (and is supported by some pre-C99 compilers as
well). Allowing a “trailing comma” makes enumerations easier to modify, because

we can add a constant to the end of an enumeration without changing existing lines
of code. For example. we might want to add WHITE Lo our enumeration:

enum gray_values ({
BLACK = O,
DARK GRAY = 64,
GRAY = 128,
LIGHT GRAY = 192,
WHITE = 255,

}7

The comma after the definition of LIGHT GRAY makes it easy to add WHITE to
the end of the list.

One reason for this change is that C89 allows trailing commas in initializers,
so it seemed inconsistent not to allow the same flexibility in enumerations. Inci-
dentally, C99 also allows trailing commas in compound literals.

Can the values of an enumerated type be used as subscripts?

Yes, iIndeed. They are integers and have—by default—values that start at 0 and
count upward, so they make great subscripts. In C99, morcover, enumeration con-
stants can be used as subscripts in designated initializers. Here’s an example:

enum weekdays {MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY} ;

const char *daily specials[] = {
[MONDAY] = "Beef ravioli",
[TUESDAY] = "BLTs",
[WEDNESDAY] = "Pizza",
[THURSDAY] = "Chicken Fajitas",
[FRIDAY] = "Macaroni and cheese"
}
Exercises

In the following declarations, the x and y structures have members named x and y:

struct { int x, y; } x;
struct { int x, y; } y;

Are these declarations legal on an individual basis? Could both declarations appear as
shown in a program? Justify your answer.

***************************page_433***************************
408 Chapter 16  Structures, Unions, and Enumerations

Section 16.2

®

2.

6.

(a) Declare structure variables named c1. c2, and c3, each having members real and
imaginary of type double.

(b) Modify the declaration in part (a) so that cL's members initially have the values 0.0 and
1.0, while c2's members are 1.0 and 0.0 initially. (c3 is not initialized.)

(c) Write statements that copy the members of c2 into c1. Can this be done in one state-
ment, or does it require two?

(d) Write statements that add the corresponding members of c1 and c2, storing the result
in C3.

(a) Show how to declare a tag named complex for a structure with t(wo members. real
and imaginary, of type double.

(b) Use the complex tag to declare variables named c1. c2, and c3.

(c) Write a function named make _ complex that stores its two arguments (both of type
double) in a complex structure, then returns the structure.

(d) Write à function named add_complex that adds the corresponding members of its
arguments (both complex structures), then returns the result (another complex structure).

Repeat Exercise 3, but this time using a rype named Complex.

Write the following functions, assuming that the date structure contains three members:
month. day. and year (all of type int).

(a) int day_of year(struct date d);
Returns the day of the ycar (an integer between | and 366) that corresponds to the date d.
(b) int compare dates(struct date d1, struct date d2) ;

Returns —! if À1 is an carlier date than d2. +1 if A1 is a later date than d2, and O if d1 and
d2 are the same.

Write thé following function, assuming that the time structure contains three members:
hours. minutes. and seconds (all of type int).

struct time split time (long total_seconds) ;

total seconds is a time represented as the number of seconds since midnight. The
function returns a structure containing the equivalent time in hours (0-23), minutes (0-59),
and seconds (0-59).

Assume that the fraction siructure contains two members: numerator and denomi -
nator (both of type int). Write functions that perform the following operations on frac-
tions:

(a) Reduce the fraction £ to lowest terms. Hinr: To reduce a fraction to lowest terms, first
compute the greatest common divisor (GCD) of the numerator and denominator. Then
divide both the numerator and denominator by the GCD.

(b) Add the fractions £1 and £2.

(c) Subtract the fraction £2 from the fraction £1.

(d) Multiply the fractions £1 and £2.

(e) Divide the fraction £1 by the fraction £2.

The fractions f, £1, and f£2 will be arguments of type struct fraction: cach function

Will return a value of type struct fraction. The fractions returned by the functions in

parts (b)-(e) should be reduced to lowest terms. Hint: You may use the funetion from part
(a) to help write the functions in parts (b)(e).

***************************page_434***************************
Section 16.3

10.

 

Exercises 409

Let color be the following structure:

struct color {
int red;
int green;
int blue;
} ;
(a) Write a declaration for a const variable named MAGENTA of type struct color
whose members have the values 255, O, and 255, respectively.

(b) (C99) Repeat part (a). but use à designated initializer that doesn’t specify the value of
green, allowing 1t to default to 0.

Write the following l'unctions. (The color structure is defined in Exercise 8.)

(a) struct color make color(int red, int green, int blue);
Returns a color structure containing the specificed red, green, and blue values. If any argu-
ment 1s less than zero, the corresponding member of the structure will contain zero instead.
If any argument is greater than 255, the corresponding member of the structure will contain
255.

(b) int getRed(struct color c);

Returns the value of c’s red member.

(c) bool equal color(struct color colori, struct color color2) ;
Returns true if the corresponding members of color1 and color2 are equal.

(d) struct color brighter(struct color c);

Returns a color structure that represents a brighter version of the color c. Thè strueture is
identical to c, except that cach member has been divided by 0.7 (with the result truncated to
an integer). However, there are three special cases: (1) lf all members of c are zero. the
function returns a color whose members all have the value 3. (2) If any member of c is
greater than O but less than 3, it is replaced by 3 before the division by 0.7. (3) If dividing by
0.7 causes a member to exceed 255, it is reduced to 255.

(e) struct color darker (struct color c);

Returns a color structure that represents a darker version of the color c. The structure is
identical to c, except that each member has been multiplied by 0.7 (with the result truncated
to an integer).

The following structures are designed to store information about objects on a graphics
screen:

struct point { int x, y; };
struct rectangle { struct point upper left, lower right; };

À point structure stores the x and y coordinates of à point on the screen. À rectangle
structure stores the coordinates of the upper left and lower right corners of à rectangle. Write
functions that perform the following operations on a rectangle structure r passed as an
argument:

(a) Compute the area of r.

(b) Compute the center of r, returning it as a point value. If either the x or y coordinate of
the center isn’t an integer, store its truncated value in the point structure.

(c) Move r by x units in the x direction and y units in the y direction, returning the modi-
fied version of r. (x and y are additional arguments to the function.)

(d) Determine whether a point p lies within r. returning true or false. (p is an addi-
tional argument of type struct point,)

***************************page_435***************************
410 Chapter 16  Structures, Unions, and Enumerations

Section 16.4

® 1.

Suppose that s 1s the following structure:

struct |
double a;
union {
char b[4] ;
double c;

int d;
} e:
char Ê [4];

} s;

If char values occupy one byte, int values occupy four bytes, and double values occupy
eight bytes, how much space will a C compiler allocate for s? (Assume that the compiler
leaves no ‘“holes” between members.)

Suppose that u is the following union:

union {
double a;
struct {
char b[4] ;
double c;
int d;
} es
char £E[4];
} u;
If char values occupy one byte. int values occupy four bytes, and double values occupy
eight bytes, how much space will a C compiler allocate for u? (Assume that the compiler
leaves no “holes” between members.)

Suppose that s is the following structure (point 1s à structure tag declared in Exercise 10):

struct shape |

int shape _kind; /* RECTANGLE or CIRCLE */
struct point center; /* coordinates of center */
union {

struct |

int height, width;
} rectangle;
struct
int radius;
} circle;
} u;
} s:
If the value of shape _ kind is RECTANGLE, the height and width members store the
dimensions of a rectangle. If the value of shape _kind is CIRCLE, the radius member
storcs the radius of a circle. Indicate which of the followine statements are legal, and show
how to repair the ones that aren’t:

(a) s.shape_kind = RECTANGLE ;
(b) s.center.x = 10;

(c) s.height = 25;

(d) s.u.rectangle.width = 8;
(e) s.u.circle = 5;

(M s.u.radius = 5;

***************************page_436***************************
Section 16.5

@ 14.

© |5.

16.

18.

19.

20.

 

Exercises 411

Let shape be the structure tag declared in Exercise 13. Write functions that perform the
lollowing operations on a shape structure s passed as an argument:
(a) Compute the area of s.

(b) Move s by x units in the x direction and y units in the y direction, returning the modi-
fied version of s. (x and y are additional arguments to the function.)

(c) Scale s by a factor of c (a double value), returning the modified version of s. (c is an
udditional argument to the funetion.)

(a) Declare a tag for an enumeration whose values represent the seven days of the week.

(b) Use typedef to define a name for the enumeration of part (a).

Which of the following statements about enumeration constants are true?

(a) An enumeration constant may represent any integer specified by the programmer.

(b) Enumeration constants have exactly the same properties as constants created using
#define.

(c) Enumeration constants have the values O, 1. 2, … by default.
(d) AlI constants in an enumeration must have different values.
(e) Enumeration constants may be used as integers in expressions.

Suppose that b and i are declared as follows:

enum {FALSE, TRUE} b;

int i;

Which of the following statements are legal? Which ones are “safc” (always yield a mean-
ingful result)?

(a) b = FALSE;

(b) b = i;
(c) b++;
(d) i = b;

(e) ài = 2 * b + 1;

(a) Each square of a chessboard can hold one piece—a pawn. knight, bishop. rook. queen.
or king—or it may be empty. Each piece is either black or white. Define two enumerated
types: Piece, which has seven possible values (one of which is “empty”). and Color,
which has two.

(b) Using the types from part (a), define a structure type named Square that can store both
the type of a piece and its color.

(c) Using the Square type from part (b), declare an 8 x 8 array named board that can
Storc the entire contents of a chessboard.

(d) Add an initializer to the declaration in part (c) so that board's initial value corresponds
to the usual arrangement of pieces at the start of a chess game. À square that's not occupied
by à picce should have an “empty” piece value and the color black.

Declare à structure with the following members whose tag is pinball machine:

name — a string of up to 40 characters

year — an integer (representing the year of manufacture)

type — an enumeration with the values EM (electromechanical) and SS (solid state)
players — an integer (representing the maximum number of players)

Suppose that the direction variable is declared in the following way:
enum {NORTH, SOUTH, EAST, WEST} direction;

***************************page_437***************************
412

Chapter 16  Structures, Unions, and Enumerations

tV
ID

ID

—

6.

Let x and y be int variables. Write a switch statement that tests the value of direc-
tion, incrementing x if direction is EAST. decrementing x if direction 1s WEST,
incrementing y if direction is SOUTH, and decrementing y if direction is NORTH.

What are the integer values of the enumeration constants in cach of the following declara-
tions?

(a) enum {NUL, SOH, STX, ETX};

(b) enum {VT = 11, FF, CR};

(c) enum {SO = 14, SI, DLE, CAN = 24, EM};

(d) enum {ENQ = 45, ACK, BEL, LF = 37, ETB, ESC};

Let chess pieces be the following enumeration:
enum chess pieces {KING, QUEEN, ROOK, BISHOP, KNIGHT, PAWN} ;

(a) Write a declaration (including an initializer) for a constant array of integers named
piece_value that stores the numbers 200, 9, 5, 3. 3, and |.representing the value of each
chess piece, from king to pawn. (The king’s value is actually infinite, since “capturing” the
king (checkmute) ends the game. but some chess-playing software assigns the king a large
value such as 200.)

(b) (C99) Repeat part (a). but use à designated initializer to initialize the array. Use the enu-
meration constants in chess_pieces as subscripts in the designators. (Hinr: Sce the last
question in Q&A for an example.)

Programming Projects

Write à program that asks the user to enter an international dialing code and then looks it up
in the country _codes array (see Section 16.3). IT it finds the code, the program should
display the name of the corresponding country: if not, the program should print an error
message.

Modify the inventory .c program of Section 16.3 so that the p (print) operation displays
the parts sorted by part number.

Modify the inventory.c program of Section 16.3 by making inventory and
num _parts local to the main function.

Modify the inventory.c program of Section 16.3 by adding a price member to the
part structure. The insert f'unction should ask the user for the price of à new ttem. The
search and print functions should display the price. Add a new command that allows
the user to change the price of à part.

Modify Programming Project 8 from Chapter S so that the times are stored in a single array.
The clements of the array will be structures. each containing a departure time and the corre-
sponding arrival time. (Each time will be an integer, representing the number of minutès
since midnight.) The program will use à loop to scarch the array for the departure time clos-
est to the timé entered by the user.

Modify Programming Project 9 from Chapter 5 so that cach date entered by the user is
stored in à date structure (see Exercise 5). Incorporate the compare_dates function of
Exercise 5 into your program.

***************************page_438***************************
Advanced Uses of Pointers

One can only display complex information in the mind.
Like seeing, movement or flow or alteration of view is more
important than the static picture, no matter how lovely.

In previous chapters, we've seen two important uses of pointers. Chapter 11
showed how using a pointer to a variable as a function argument allows the fune-
tion to modify the vartable. Chapter 12 showed how Llo process arrays by perform-
ing arithmetic on pointers to array elements. This chapter completes our coverage
of pointers by examining two additional applications: dynamic storage allocation
and pointers to functions.

Using dynamic storage allocation, a program can obtain blocks of memory as
needed during execution. Section 17.1 explains the basics of dynamic storage allo-
cation. Section 17.2 discusses dynamically allocated strings, which provide more
[exibility than ordinary character arrays. Section 17.3 covers dynamic storage
allocation for arrays in general. Section 17.4 deals with the issue of storage deallo-
cation—releasing blocks of dynamically allocated memory when they‘re no longer
needed.

Dynamically allocated structures play a big role in C programming, since they
can be linked together to form lists, trees, and other highly flexible data structures.
Section 17.5 locuses on linked lists, the most fundamental linked data structure.
One of the issues that arises in this section—the concept of a “pointer to a
pointer'—is important enough to warrant a section of its own (Section 17.6).

Section 17.7 introduces pointers to functions. a surprisingly useful concept.
Some of C's most powerful library functions expect function pointers as areu-
ments. We [J examine one of these functions, qsort, which is capable of sorting
any array.

The last two sections discuss pointer-related fceatures that first appeared in
C99: restricted pointers (Section 17.8) and flexible array members (Section 17.9).
These features are primarily of interest to advanced C programmers, so both sec-
tions can be safely be skipped by the beginner.

413

***************************page_439***************************
414 Chapter 17  Advanced Uses of Pointers

171

variable-length arrays > 8.3

<stdlib.h>header »26.2

Dynamic Storage Allocation

C’s data structures are normally fixed in size. For example, the number of elements
in an array 1s fixed once the program has been compiled. (In C99, the length of a
variable-length array 1s determined at run time, but it remains fixed for the rest of
the array’s lifetime.) Fixed-size data structures can be a problem, since we're
forced to choose their sizes when writing a program; we can’t change the sizes
without modifying the program and compiling it again.

Consider the inventory program of Section 16.3, which allows the user to
add parts to a database. The database is stored in an array of length 100. To en-
large the capacity of the database, we can increase the size of the array and recom-
pile the program. But no matter how large we make the array, there’s always the
possibility that it will fil] up. Fortunately, all 1s not lost. C supports dynamic stor-
age allocation: the ability to allocate storage during program execution. Using dy-
namic storage allocation, we can design data structures that grow (and shrink) as
needed.

Although 1t’s available for all types of data, dynamic storage allocation 1s used
most often for strings, arrays, and structures. Dynamically allocated structures are
of particular interest, since we can link them together to form lists, trees, and other
data structures.

Memory Allocation Functions

To allocate storage dynamnically. we'Il need to call one of the three memory alloca-
tion functions declared in the <stdlib.h> header:

u malloc—Allocates a block of memory but doesn’t initialize it.
u Calloc—Allocates a block of memory and clears it.

# realloc—Resizes a previously allocated block of memory.

Of the three, malloc is the most used. It’s more efficient than calloc, since it
doesn’t have to clear the memory block that :t allocates.

When we call a memory allocation function to request a block of memory. the
function has no idea what type of data we’re planning to store in the block, so it
can*t return a pointer to an ordinary type such as int or char. Instead, the func-
tion returns a value of type void *. À void * value is a “generic” pointer—
essentially, just a memory address.

Null Pointers

When a memory allocation function is called, there’s always a possibility that it
won’t be able to locate a block of memory large enough to satisfy our request. If

***************************page_440***************************
QeÂA

 

17.1  Dynamic Storage Allocation 415

that should happen, the function will return a null pointer. À null pointer is a
“pointèr to nothing”—a special value that can be distinguished from all valid
pointers. After we’ve stored the function’s return value in a pointer variable, we
must test to see 1f it’s à null pointer.

 

It’'s the programmer’s responsibility to test the return value of any memory alloca-
tion function and take appropriate action if it’s a null pointer. The effect of attempt-
ing to access memory through a null pointer is undefined: the program may crash
or behave unpredictably.

 

The null pointer 1s represented by à macro named NULL, so we can test
malloc’s return value in the following way:

p = malloc (10000) ;
if (p == NULL) {
/* allocation failed; take appropriate action */

}

Some programmers combine the call of malloc with the NULL test:

if ((p = malloc(10000)) == NULL) (
/* allocation failed; take appropriate action */

}

The NULL macro 1s defined in six headers: <locale.h>. <stddef.h>.
<stdio.h>, <stdlib.h>. <string.h>, and <time.h>. (The C99 header
<wchar .h> also defines NULL.) Às long as one of these headers is included in à
program, the compiler will recognize NULL. À program that uses any of the mem-
ory allocation functions will include <stdlib.h>. of course, making NULL
available.

In C, pointers test true or false in the same way as numbers. All non-null
pointers test true; only null pointers are false. Thus, instead of writing

if (p == NULI)
we could write

if (!p)

and instead of writing
if (p != NULL)
we could write

if (p)

Às a matter of style, I prefer the explicit comparison with NULL.

***************************page_441***************************
416

Chapter 17  Advanced Uses of Pointers

17.2

size t lype »7.6

Q&AÀ

Dynamically Allocated Strings

Dynamic storage allocation is often uscful for working with strines. Strings are
stored in character arrays. and it can be hard to anticipate how long these arrays
need to be. By allocating strings dynamically, we can postpone the decision until
the program 1s runnine.

Using malloc to Allocate Memory for a String

The malloc function has the following prototype:
void *malloc(size t size);

malloc allocates a block of size bytes and returns a pointer to it. Note that
size has type size t, an unsigned integer type defined in the C library. Unless
we*re allocating a very large block of memory, we can just think of size as an
ordinary integer.

Using malloc to allocate memory for a string 1s easy, because C guarantees
that a char value requires exactly one byte of storage (sizeof (char) 1s |, in
other words). To allocate space for a string of n characters, we'd write

p = malloc(n + 1);

where p is a char * variable. (The argument is n + 1 rather than n to allow room
for the null character.) The generic pointer that malloc returns will be converted
to char * when the assignment 1s performed; no cast 1s necessary. (In general, we
can assign a void * value to a variable of any pointer type and vice versa.) Never-
theless, some programmers prefer to cast malloc's return value:

p = (char *) malloc(n + 1);

 

When using malloc lo allocate space for à string, don’t forget to include room for
the null character.

 

Memory allocated using malloc isn’t cleared or initialized in any way, s0 p
will point to an uninitialized array of n + | characters:

 

***************************page_442***************************
172  Dynamically Allocated Strings _ 417

Callinge strcpy is one way to initialize this array:
strcpy(p, "abc”") ;

The first four characters in the array will now be a, b. c, and \ 0:

 

 

Using Dynamic Storage Allocation in String Functions

Dynamic storage allocation makes it possible to write functions that return a
pointer to a “new” string—a string that didn’t exist before the l'unction was called.
Consider the problem of writing a function that concatenates two strings without
changing either one. C's standard library doesn’t include such a function (strcat
isn°t quite what we want, since it modifies one of the strings passed to it), but we
can easily write our own.

Our function will measure the lengths of the two strings to be concatenated.
then call malloc to allocate just the right amount of space for the result. The
function next copies the first string into the new space and then calls strcat lo
concatenate the second string.

char *concat (const char *s1, const char *s2)

{

char *result;

result = malloc(strlen(s1) + strlen(s2) + 1);
if (result == NULL) |{
printf ("Error: malloc failed in concat\n") ;
exit (EXIT FAILURE) ;

}

strcopy(result, s1l);
strcat (result, s2);
return result ;

}

f malloc returns à null pointer, concat prints an error message and terminates
the program. That’s not always the right action to take: some programs need to
recover from memory allocation failures and continue runnine.

Here’s how the concat f'unction might be called:

p = concat ("abc", "def") ;

After the call, p will point to the string "abcde£". which is stored in a dynami-
cally allocated array. The array is seven characters long, including the null charac-
ter at the end.

***************************page_443***************************
418

Chapter 17  Advanced Uses of Pointers

/

Éree function » 17.4

PROGRAM

remind2.c

 

Functions such as concat that dynamically allocate storage must be used with
care. When the string that concat returns 1s no longer needed, we'Il want to call
the free function to release the space that the string occupies. If we don’t, the
program may eventually run out of memory.

 

Arrays of Dynamically Allocated Strings

In Section 13.7, we tackled the problem of storing strings in an array. We found
that storing strings as rows in a lwo-dimensional array of characters can waste
space, so we tried selting up an array of pointers to string literals. The techniques
of Section 13.7 work just as well if the elements of an array are pointers to dynam-
ically allocated strines. To illustrate this point, let’s rewrite the remind.c pro-
gram of Section 13.5, which prints a one-month list of daily reminders.

Printing a One-Month Reminder List (Revisited)

The original remind. c program stores the reminder strings in a two-dimensional
array of characters, with each row of the array containing one string. After the pro-
gram reads a day and its associated reminder, it searches the array to determine
where the day belongs, using stremp to do comparisons. Ît then uses strcpy to
move all strings below that point down one position. Finally, the program copies
the day into the array and calls strcat lo append the reminder to the day.

In the new program (remind2 . c), the array will be one-dimensional; its ele-
ments will be pointers to dynamically allocated strings. SWitching to dynamically
allocated strings in this program will have two primary advantages. First, we can
use space more efficiently by allocating the exact number of characters needed to
store a reminder, rather than storing the reminder in a fixed number of characters
as the original program does. Second, we won't need to call strocpy to move
existing reminder strings in order to make room for a new reminder. Instead, we'Il
merely move pointers Lo strings.

Here’s the new program, with changes in bold. Switching from a two-dimen-
sional array to an array of pointers turns out to be remarkably easy: we’Il only need
to change eight lines of the program.

/* Prints a one-month reminder list (dynamic string version) */
finclude <stdio.h>
#include <stdlib.h>

#include <string.h>

#define MAX REMIND 50 /* maximum number of reminders */
#define MSG _LEN 60 /* max length of reminder message */

int read _ line(char str[], int n);

***************************page_444***************************
 

172  Dynamically Allocated Strings

int main(void)

{

}

char *reminders [MAX REMIND] ;
char day str[3], msg_str [MSG_LEN+1] ;
int day, i, j, num_remind = 0;

for (;;) {
if (num_remind == MAX REMIND) {
print£f("-- No space left --\n") ;
break ;

}

print£ ("Enter day and reminder: "),
scanf ("=2d", &day) ;
if (day == O)

break ;
sprint£ (day_str, "%2d", day) ;
read_line (msg_str, MSG_LEN) ;

for (i = 0O0; i < num _remind; i++)
if (stromp(day_str, reminders[i]) < 0)
break;
for (j = num remind; j > i; j--)
reminders[j] = reminders[j-1] ;

reminders[i] = malloc (2 + strlen(msg str) + 1);
Lf (reminders[i] == NULL) (

print£f("-- No space left --\n") ;

break;

}

strcpy (reminders[i], day _ str) ;
strcat (reminders [i], msg_str) ;

num_remind++;

}

print£f ("\nDay Reminder\n") ;

for (i = 0; i < num remind; i++)
print£(" %s\n"', reminders ([i]) ;
return 0;

int read_line(char str[], int n)

{

}

int ch, i = OD;

while ((ch = getchar()) != '\n')
LË (ài < n)
str[i++] = ch;

str[i] = '\0O';
return i;

 

419

***************************page_445***************************
420

Chapter 17  Advanced Uses of Pointers

173

sizeofË operator » 7.6

Dynamically Allocated Arrays

Dynamically allocated arrays have the same advantages as dynamically allocated
strines (not surprisingly, since strings are arrays). When we’re writing a program,
it's often difficult to estimate the proper size for an array: it would be more conve-
nient to wait until the program is run to decide how large the array should be. C
solves this problem by allowing a program to allocate space for an array during
execution, then access the array through a pointer to its first element. The close
relationship between arrays and pointers, which we explored in Chapter 12, makes
a dynamically allocated array just as easy Lo use as an ordinary array.

Although malloc can allocate space for an array, the calloc function 1s
sometimes used instead, since it initializes the memory that it allocates. The
realloc function allows us to make an array “grow” or “shrink” as needed.

Using malloc to Allocate Storage for an Array

We can use malloc to allocate space for an array in much the same way we used
it to allocate space for a string. The primary difference 1s that the elements of an
arbitrary array won*t necessarily be one byte long, as they are in a string. Às à
result, we’Il need to use the sizeof operator to calculate the amount of space
required for each element.

Suppose we’re writing a program that needs an array of n integers, where n is
to be computed during the execution of the program. We'lI first declare a pointer
vartable:

int *a;

Once the value of n is known, we’Il have the program call malloc to allocate
space for the array:

a = malloc(n * sizeof (int));

 

Always use sizeof when calculating how much space is needecl for an array.
Failing to allocate enough memory can have severe consequences. Consider the
lollowing attempt to allocate space for an array of n integers:

a = malloc(n * 2);

If int values are larger than two bytes (as they are on most computers), malloc
won°t allocate a large enough block of memory. When we later try to access ele-
ments of the array, the program may crash or behave erratically.

 

Once it points to a dynamically allocated block of memory, we can ignore the
fact that à is à pointer and use it instead as an array name. thanks to the relation-

***************************page_446***************************
QaÀ

 

17.3  Dynamically Allocated Arrays 421

ship between arrays and pointers in C. For example, we could use the following
loop to initialize the array that a points to:

for (i = 0; i < n; i++)
a[li] = 0;

We also have the option of using pointer arithmetic instead of subscripting to
access the elements of the array.

The calloc Function

Although the malloc function can be used to allocate memory for an array, C
provides an alternative—the calloc function—that's sometimes better. calloc
has the following prototype in <stdlib.h>:

void *calloc(size t nmemb, size t size);

calloc allocates space for an array with nmemb elements. each of which is
size bytes long; it returns a null pointer if the requested space isn’t available.
After allocating the memory, calloc initializes it by setting all bits to O. For
example, the following call of calloc allocates space for an array of n integers,
which are all guaranteed to be zero initially:

a = calloc(n, sizeof (int));

Since calloc clears the memory that it allocates but malloc doesn't, we
may occasionally want to use calloc to allocate space for an object other than an
array. By calling calloc with 1 as its first argument, we can allocate space for a
data item of any type:

struct point { int x, y; } *p,
p = calloc(1, sizeof (struct point)) ;

After this statement has been executed, p will point to a structure whose x and y
members have been set to zero.

The realloc Function

Once we've allocated memory for an array, we may later find that itl’s too large or
too small. The realloc function can resize the array to better suit our needs. The
following prototype for realloc appears in <stdlib.h>:

void *realloc (void *ptr, size t size);

When realloc is called. ptr must point to a memory block obtained by a previ-
ous call of malloc, calloc, or realloc. The size parameter represents the
new size of the block, which may be larger or smaller than the original size.
Although realloc doesn't require that ptr point to memory that’s being used as
an array, in practice it usually does.

***************************page_447***************************
22

Chapter 17  Advanced Uses of Pointers

/

17.4

 

Be sure that a pointer passed to realloc came from a previous call of malloc,

calloc, or realloc. If1t didn°{, calling realloc causes undefined behavior.

 

The C standard spells out a number of rules concerning the behavior of
realloc:

u When it expands a memory block, realloc doesn’t initialize the bytes that
are added to the block.

u If realloc can’t enlarge the memory block as requested, it returns a null
pointer; the data in the old memory block is unchanged.

u lf realloc is called with a null pointer as its first argument, it behaves like
malloc.

u If realloc is called with O as its second argument, it frees the memory
block.

The C standard stops short of specifying exactly how realloc works. Still,
we expect it to be reasonably efficient. When asked to reduce the size of a memory
block, realloc should shrink the block “in place,” without moving the data
Stored in the block. By the same token, realloc should always attempt to
expand a memory block without moving it. If it’‘s unable to enlarge the block
(because the bytes following the block are already in use for some other purpose),
realloc will allocate a new block elsewhere, then copy the contents of the old
block into the new one.

 

Once realloc has returned, be sure Lo update all pointers to the memory block,
since it’s possible that realloc has moved the block elsewhere.

 

Deallocating Storage

malloc and the other memory allocation functions obtain memory blocks from a
storage pool known as the heap. Calling these functions too often—or asking them
for large blocks of memory—can exhaust the heap, causing the functions to return
a null pointer.

To make matters worse, a program may allocate blocks of memory and then
lose track of them, thereby wasting space. Consider the following example:

p = malloc (...) ;
q = malloc (...) ;
P

=q;

***************************page_448***************************
 

17.4  Deallocating Storage 423

After the first two statements have been executed. p points to one memory block.
while q points to another:

 

 

 

Therc are no pointers to the first block (shaded), so we’Il never be able to use it
again.

À block of memory that’s no longer accessible to a program is said to be gar-
bage. À program that leaves garbage behind has a memory leak. Some languages
provide a garbage collector that automatically locates and recycles garbage, but C
doesn't. Instead, each C program is responsible for recycling its own garbage by
calling the £ree function to release unneeded memory.

The £ree Function
The £ree function has the following prototype in <stdlib.h>:
void free (void *ptr) ;

Using free is easy; we simply pass it a pointer to a memory block that we no
longer need:

p = malloc (...) ;
q = malloc (...) ;
£ree (p) ;

P = q;

Calling £ree releases the block of memory that p points to. This block is now
available for reuse in subsequent calls of malloc or other memory allocation
functions.

 

The argument to free must be a pointer that was previously returned by a mem-
ory allocation function. (The argument may also be a null pointer, in which case
the call of free has no effect.) Passing £ree a pointer to any other objeet (such
as a variable or array element) causes undefined behavior.

 

***************************page_449***************************
424

Chapter 17  Advanced Uses of Pointers

17.5

The ‘‘Dangling Pointer””’ Problem

Although the £ree function allows us to reclaim memory that's no longer needed,
using it leads to à new problem: dangling pointers. The call £ree (p) deallocates
the memory block that p points to, but doesn't change p itself. If we forsget that p
no longer points to a valid memory block, chaos may ensue:

char *p = malloc(4) ;
free (p) ;

strcpy(p, "abc”") ; /*** WRONG ***/

Modifying the memory that p points to is a serious error, since our program no
longer has control of that memory.

 

Attempting to access or modify a deallocated memory block causes undefined
behavior. Trying to modify a deallocated memory block 1s likely to have disastrous
consequences that may include à program crash.

 

Dangling pointers can be hard to spot, since several pointers may point to
the same block of memory. When the block is freed, all the pointers are left dan-

gling.

Linked Lists

Dynamic storage allocation 1s especially useful for building lists, trees, graphs, and
other linked data structures. We’1l look at linked lists in this section; a discussion
of other linked data structures is beyond the scope of this book. For more informa-
tion. consult a book such as Robert Sedgewick’s Algorithms in C, Parts 1+4: Fun-
damentals. Data Structures, Sorting, Searching, Third Edition (Reading, Mass.:
Addison-Wesley, 1998).

À linked list consists of a chain of structures (called rrodes), with each node
containing a pointer to the next node in the chain:

—Ch

The last node in the list contains a null pointer, shown here as a diagonal line.

In previous chapters, we’ve used an array whenever we’ve needed to store a
collection of data items; linked lists give us an alternative. À linked list is more
flexible than an array: we can easily insert and delete nodes in a linked list, allow-
ing the list to grow and shrink as needed, On the other hand, we lose the “random
access” capability of an array. Any element of an array can be accessed in the same

 

 

 

 

 

***************************page_450***************************
Qaâ

 

17.5  Linked Lists 425

amount of time: accessing a node in a linked list is fast if the node is close to the
beginning of the list, slow if it’s near the end.

This section describes how to set up a linked list in C. It also shows how to
perform several common operations on linked lists: inserting a node at the begin-
ning of a list, searching for a node, and deleting a node.

Declaring a Node Type

To set up a linked list, the first thing we'Il need is a structure that represents à sin-
gle node in the list. For simplicity, let’s assume that a node contains nothing but an
integer (the node’s data) plus a pointer to the next node in the list. Here's what our
node structure will look like:

struct node {
int value; /* data stored in the node */
struct node *next; /* pointer to the next node */

}

Notice that the next member has type struct node *, which means that it can
store à pointer to a node structure. There’s nothing special about the name node.
by the way: il’s just an ordinary structure tag.

One aspect of the node structure deserves special mention. As Section 16.2
explained, we normally have the option of using cither a tag or a typedef name
to define a name for a particular kind of structure. However, when a structure has a
member that points to the same kind of structure. as node does. we*re required to
use à structure tag. Without the node tag, we'd have no way to declare the type of
next.

Now that we have the node structure declared. we’1] need a way to keep track
of where the list begins. In other words. we1l need a variable that always points to
the first node in the tist. Let*s name the variable first:

struct node *first = NULL;

Setting £irst to NULL indicates that the list is initially empty.

Creating a Node

Âs we construct a linked list, we*Il want to create nodes one by one, adding each to
the list. Creating a node requires three steps:

1. Allocate memory for the node.
2. Store data in the node.
3. Insert the node into the list.

We'1l concentrate on the first two steps for now.
When we creale a node. we'Il need à variable that can point to the node tem-
porarily, until itl’s been inserted into the list, Let’s call this variable new _node:

struct node *new node;

***************************page_451***************************
426 Chapter 17

QaA

table of operators »-Appendix À

Advanced Uses of Pointers

We'll use malloc to allocate memory for the new node, saving the return value in
new _node:

new_node = malloc (sizeof (struct node) ) ;

new_node now points to a block of memory just large enough to hold a node

structure:
new_node El——‘ ! l

valus naexe

 

Be careful to give sizeoËf the name of the /ype to be allocated, not the name of a
pointer to that type:

new_node = malloc (sizeof (new_node) ) ; /*** WRONG ***/

The program will still compile, but malloc will allocate only enough memory for
a pointer to a node structure. The likely result is a crash later, when the program
attempts to store data in the node that new_node is presumably pointing to.

 

Next, we'll store data in the value member of the new node:
(*new_node) .value = 10;

Here’s how the picture will took after this assignment:

new_node ‘ °—l—>{ 10 I l

valué next

To access the value member of the node, we've applied the indirection operator
* (to reference the structure to which new_node points), then the selection oper-
ator . (to select a member of the structure). The parentheses around *new _ node
are mandatory because the . operator would otherwise take precedence over the *
operator.

The - > Operator

Before we go on to the next step, inserting a new node into a list, let’s take a
moment to discuss a useful shortcut. Accessing a member of a structure using a
pointer is so common that C provides a special operator just for this purpose. This
operator, known as right arrow selection, is a minus sign followed by >. Using the
- > Operator, we can write

new_node->value = 10;

instead of

***************************page_452***************************
Ivalues » 4.2

 

175  Linked Lists 427

(*new_node) .value = 10;

The -> operator is a combination of the * and . operators; it performs indirection
on new_node to locate the structure that it points to, then selects the value
member of the structure.

The -> operator produces an Ivalue, so we can use it wherever an ordi-
nary variable would be allowed. We’ve just seen an example in which
new_node->value appears on the left side of an assignment. It could just as
easily appear in a call of scanf:

scanf ("%d", &new _node->value) ;

Notice that the & operator is still required, even though new node is a pointer.
Without the &, we*d be passing scan£ the value of new_node->value, which
has type int.

Inserting a Node at the Beginning of a Linked List

One of the advantages of a linked list is that nodes can be added at any point in the
list: at the beginning, at the end, or anywhere in the middle. The beginning of a list
is the easiest place to insert a node, however, so let’s focus on that case.

lfnew _node is pointing to the node to be inserted, and first is pointing to
the first node in the linked list, then we’1l need two statements to insert the node
into the list. First, we’Il modify the new node’s next member to point to the node
that was previously at the beginning of the list:

new_node->next = first;
Second, we’Il make f£irst point to the new node:
first = new node;

Will these statements work if the list is empty when we insert a node? Yes,
fortunately. To make sure this is true, let’s trace the process of inserting two nodes
into an empty list. We’1l insert a node containing the number 10 first, followed by a
node containing 20. In the figures that follow, null pointers are shown as diagonal
lines.

first = NULL; Ç
first

new_node

new_node = malloc (sizeof (struct node) ) ; first

 

 

/J—l___l

new_node

LU'QUE

***************************page_453***************************
Chapter 17  Advanced Uses of Pointers

new_node->value = 10;

 

 

 

 

 

nev_node | <T

new node->next = first; ;
— first

 

 

 

new_node

first = new node,; firet
— re

——
new_node | <T

£irst —— _

 

 

 

new_node = malloc(sizeof (struct node) ) ;

 

 

.
Ë

new_node

Hl A
\

 

 

 

 

 

 

new node->value = 20; ;
— fairst
J20 l 10_//q
AN
new_node
new node->next = Éfirst; _,
— rIirst

 

 

A_
|
|
<

 

 

 

m7—Jw

new_node

ï
J

first = new _ node;

 

first

 

Ëw
E
£

 

«
\

LU L
-

newv_node

 

Inserting a node into a linked list is such a common operation that we’1l probably
want to write à function for that purpose. Let’s name the function add_to list.
[t will have two parameters: 1ist (a pointer to the first node in the old list) and n
(the integer to be stored in the new node).

struct node *add to list (struct node *list, int n)

{

struct node *new _node;

new_node = malloc(sizeof (struct node) ) ;

if (new node == NULL) {
print£f ("Error: malloc failed in add to list\n") ;
exit (EXIT FAILURE) ;

}

 

***************************page_454***************************
idiom

 

17.5  Linked Lists 429

new _node->value = n;
new _ node->next = list;
return new _node ;

}

Note that add_to list doesn’{ modify the list pointer. Instead, it returns a
pointer to the newly created node (now at the beginning of the list). When we call
add_to_list,. we'll need to store its return value into first:

first = add to list (first, 10);
first = add to list(first, 20);

These statements add nodes containing 10 and 20 to the list pointed to by first.
Getting add_to list to update first directly, rather than return a new value
for first, turns out to be tricky. We'1l return to this issue in Section 17.6.

The following function uses add_to _ list tocreate a linked list containing
numbers entéred by the user:

struct node *read _numbers (void)

(

struct node *first = NULL;
int n;

print£ ("Enter a series of integers (0 to terminate) : ");
for (;;) |
scanf ("%$d", &n) ;
if (n == O)
return first;
first = add to list(first, n);

}
}

The numbers will be in reverse order within the list, since first always points to
the node containing the last number entered.

Searching a Linked List

Once we’ve created a linked list, we may need to search it for a particular piece of
data. Although a while loop can be used to search a list, the for statement is
often superior. We’re accustomed to using the £or statement when writing loops
that involve counting, but its flexibility makes the for statement suitable for other
tasks as well, including operations on linked lists. Herc’s the customary way to
visit the nodes in a linked list, using a pointer variable p to keep track of the ““cur-
rent” node:

for (p = first; p != NULL; p = p->next)

The assignment

p = p->next

***************************page_455***************************
430

Chapter 17  Advanced Uses of Pointers

advances the p pointer from one node to the next. An assignment of this form is
invariably used in C when writing a loop that traverses a linked list.

Let's write a function named search _list that searches a list (pointed to
by the parameter 1i st) for an integer n. If it finds n. search list will return
a pointer to the node containing n; otherwise, it will return a null pointer. Our first
version of search_list relies on the “list-traversal” idiom:

struct node *search list (struct node *list, int nD)

(

struct node *p;

for (p = list; p != NULL; p = p->next)
if (p->value == n)
return p;
return NULL;

}

Of course, there are many other ways to write search list. One alterna-
tive would be to eliminate the p variable, instead using 1i st itself to keep track of
the current node:

struct node *search list (struct node *list, int n)

(

for (; list != NULL; list = list->next)
if (list->value == n)
return list;
return NULL;

}

Since list is a copy of the original list pointer, there’s no harm in changing it
within the function.

Another alternative is to combine the list->value == n test with the
list != NULL test:

struct node *search list (struct node *list, int n)

{

for (; list != NULL && list->value != n; list = list->next)
return list;

}

Since list 1s NULL if we reach the end of the list, returning 1ist is correct even
if we don’t find n. This version of search list might be a bit clearer if we
used a while statement:

struct node *search list (struct node *list, int n)

while (list != NULL && list->value != n)
list = list->next;
return list;
}

-—

 

***************************page_456***************************
 

17.5  Linked Lists 431

Deleting a Node from a Linked List

À big advantage of storing data in a linked list is that we can easily delete nodes
that we no longer need. Deleting à node, like creating a node, involves three steps:

1. Locate the node to be deleted.
2. Alter the previous node so that it ‘“bypasses” the deleted node.
3. Call £ree to reclaim the space occupied by the deleted node.

Step ! is harder than it looks. If we search the list in the obvious way, we'Il end up
with a pointer to the node to be deletcd. Unfortunately, we won°t be able to per-
form step 2, which requires changing the previous node.

There are various solutions to this problem. We'1l use the “trailing pointer”
technique: as we search the list in step !, we'll keep a pointer to the previous node
(prev) as well as a pointer to the current node (cur). If 1ist points to the list to
be searched and n is the integer to be deleted. the following loop implements step
l:

for (cur = list, prev = NULL;
cur != NULL && cCur->value != n;
prev = cur, cur = cur->next)

.
/

Here we see the power of C’s £or statement. This rather exotic example, with its
emply body and liberal use of the comma operator, performs all the actions needed
to search for n. When the loop terminates, cur points to the node to be deleted.
while prev points to the previous node (if there is one).

To sce how this loop works, let’s assume that 1i st points to a list containing
30, 40. 20, and 10, in that order:

list | ’—l—’ 30 *—}-_—"; 40 }" 20 u —”I 10 /

Let's say that n is 20, s0 our goal is to delete the third node in the list. After
cur = list, prev = NULL has been executed, cur points to the first node in
the list:

 

 

 

 

 

 

prev cur

ul

list| °——*3_ij'*"}0 ’_—‘—* 10 l/l

The test cur != NULL && cur->value != nis true, since cur is pointing to a
node and the node doesn’t contain 20. After prev = cur, cur = cur->next
has been executed, we begin to see how the prev pointer will trail behind cur:

 

 

 

***************************page_457***************************
432

Chapter 17  Advanced Uses of Pointers

prev cur
L- _ __
list [3-* 30 °—l‘—’ 40 ' — 20 *—}-_" 10 |/|

Again, the test cur != NULL && cur->value != n iis true. so prev = cur,
cur = cur->next 1s executed once more:

 

 

 

 

B

 

prev

 

 

se [JH 1001 420107

Since cur now points to the node containing 20, the condition cur->value ! =
n 1s faise and the loop terminates.

Next, we’IIl perform the bypass required by step 2. The statement

 

prev->next = cur->next ;

makes the pointer in the previous node point to the node after the current node:

prev cur

list[:::]——ô{30 I *—r—'

We're now ready for step 3, releasing the memory occupied by the current node:

 

free (cur) ;

The following function. delete £from _list, uses the strategy that we’ve
just outlined. When given a list and an integer n. the function deletes the first node

containing n. If no node contains n. delete from list does nothing. In
either case, the function returns a pointer to the list.

struct node *delete £from list (struct node *list,

{

int n)

struct node *cur, *prev;

for (cur = list, prev = NULL;
cur != NULL && cCur->value

!= n;
prev = cur, cur = cCur->next)

—H — _— ——

***************************page_458***************************
PROGRAM

 

w
17.5  Linked Lists 433
i£f (cur == NULL)
return list; /* n was not found */
if (prev == NULL)
list = list->next; /* n is in the first node */
else
prev->next = cur->next; /* n is in some other node * /

free (cur) ;
return list;

}

Deleting the first node in the list is a special case. The prev == NULL test checks
for this case, which requires à different bypass step.

Ordered Lists

When the nodes of a list are kept in order—sorted by the data stored inside the
nodes—we say that the list is ordered. Inserting a node into an ordered list is more
difficult (the node won't always be put at the beginning of the list), but searching is
faster (we can stop looking after reaching the point at which the desired node
would have been located). The following program illustrates both the increased
difficulty of inserting a node and the faster search.

Maintaining a Parts Database (Revisited)

Let's redo the parts database program of Section 16.3, this time storing the data-
base in a linked list. Using a linked list instead of an array has two major advan-
tages: (1) We don’i need to put a preset limit on the size of the database; it can
grow until there’s no more memory to store parts. (2) We can casily keep the data-
base sorted by part number—when à new part is added to the database, we simply
insert it in its proper place in the list. In the original program, the database wasn°t
sorted.

[n the new program, the part structure will contain an additional member (a
pointer to the next node in the linked list). and the variable inventory will be a
pointer to the first node in the list:

struct part (
int number;
char name [NAME LEN+1] ;
int on hand;
struct part *next;

struct part *inventory = NULL; /* points to first part */

Most of the functions in the new program will closely resemble their counter-
parts in the original program. The find _part and insert functions will be
more complex, however. since we'll keep the nodes in the inventory list sorted
by part number.

***************************page_459***************************
434

Chapter 17  Advanced Uses of Pointers

inventory2.c

In the original program, find _ part returns an index into the inventory
artay. In the new program, find_part will return a pointer to the node that con-
tains the desired part number. If it doesn*1 find the part number, find part will
return a null pointer. Since the inventory list is sorted by part number, the new
version of £find_part can save time by stopping its search when it finds a hode
containing a part number thats greater than or equal to the desired part number.
find _ part's search loop will have the form

p = inventory;
p != NULL && number > p->number ;
p=

The loop will terminate when p becomes NULL (indicating that the part number
wasn't found) or when number > p->number is false (indicating that the part
number we're looking for is less than or equal to a number already stored in a
node). In the latter case, we still don’t know whether or not the desired number is
actually in the list, so we*1] need another test:

if (p != NULL && number == p->number)
return p;

The original version of insert stores a new part in the next available array
element. The new version must determine where the new part belongs in the list
and insert it there. We'Il also have insert check whether thc part number is
already present in the list. insert can accomplish both tasks by using a loop sim-
ilar to the one in f£ind_part:

for (cur = inventory, prev = NULL;
cur != NULL && new node->number > cur->number;
prev = cur, cur = cur->next)

/

This loop relies on two pointers: cur, which points to the current node. and prev,
which points to the previous node. Once the loop terminates, insert will check
whether cur isn’t NULL and new_node->number equals cur->number: if
so, the part number is already in the list. Otherwise insert will insert a new node
between the nodes pointed to by prev and cur. using a strategy similar to the one
we employed for deleting a node. (This strategy works even if the new part number
is larger than any in the list; in that case, cur will be NULL but prev will point to
the last node in the list.)

Here's the new program. Like the original program, this version requires the
read_line function described in Section 16.3; ! assume that readline.h
contains a prototype for this function.

/* Maintains a parts database (linked list version) */

#include <stdio.h>
#include <stdlib.hs
finclude "readline.h"

***************************page_460***************************
 

17.5  Linked Lists 435

#define NAME LEN 25

struct part (
int number ;
char name [NAME _ LEN+1] ;
int on hand;
struct part *next;

Struct part *inventory = NULL; /* points to first part */

Struct part *find part (int number) ;
void insert (void) ;

void search (void) ;

void update (void) ;

void print (void) ;

/**********************************************************

* main: Prompts the user to enter an operation code, *
* then calls a function to perform the requested *
* action. Repeats until the user enters the *
* command 'q'. Prints an error message if the user *
* enters an illegal code. *
***********************************'À'**************—k*—k*****

int main (void)

{

char code;

for (;;) {
print£ ("Enter operation code: "),;
scan£(" %c", &code) ;
while (getchar() != '\n') /* skips to end oË line */

switch (code) {

case 'i': insert ();
break ;

case 's': search();
break ;

case 'u': update();
break ;

case 'p': print();
break;

case 'q': return O0;

default:  print£f("I11egal code\n") ;

}

print£ ("\n") ;

}

/********************************‘k*‘k*************'k'k********k

* find part: Looks up a part number in the inventory *
* list. Returns a pointer to the node *
* containing the part number; if the part *
* number is not found, returns NULL. *

‘k**‘k*********‘k******‘k*************‘k*****:‘:*****************

/

/

***************************page_461***************************
436 Chapter 17  Advanced Uses of Pointers

struct part *find part (int number)

{

Sstruct part *p;

for (p = inventory;
p != NULL && number > p->number;
p p->next)

if (p != NULL && number == p->number)
return p;
return NULL;

}

/—k**********‘k**********‘k***********************************

* insert: Prompts the user for information about a new *
* part and then inserts the part into the *
* inventory list; the list remains sorted by *
* part number. Prints an error message and *
* returns prematurely if the part already exists *
* or space could not be allocated for the part. *
KKK KKARRRRRRRRKKAX

/

void insert (void)

{

struct part *cur, *prev, *new node;

new_node = malloc (sizeof (struct part)) ;

if (new node == NULL) |
printf ("Database is full; can't add more parts.\n") ;
return;

}

print£ ("Enter part number: ") ;
scanf ("%d", &new node->number) ;

for (cur = inventory, prev = NULL;
|

cur != NULL && new _ node->number > cur->number ;
prev = cur, cur = cur->next)
if (cur != NULL && new _ node->number == cur->number) {

print£f("Part already exists.\n") ;
Êree (new_node) ;
return;

}

print£ ("Enter part name: ");
read_line (new node->name, NAME_LEN) ;
print£ ("Enter quantity on hand: ");
scanf ("%d", &new_node->on hand) ;

new_node->next = cur;
if (prev == NULL)
inventory = new node;
else
prev->next = new node;

***************************page_462***************************
 

17.5  Linked Lists

437

/**—k**********—k******—k******‘****************—k***********—k*—k

*
*
*

*

search: Prompts the user to enter a part number, then

*

looks up the part in the database. If the part *

exists, prints the name and quantity on hand;
1f not, prints an error message.

*
*

*************:‘c***********‘k**************1‘:*****************/

void search(void)

{

int number;
struct part *p;

print£f ("Enter part number: ") ;
scanf£f ("%d"', &number) ;
p = find part (number) ;
if (p != NULL) {
printf ("Part name: $s\n", p->name) ;
printf ("Quantity on hand: %$d\n", p->on _hand) ;
} else
print£ ("Part not found.\n") ;

/**********************************************************

{

*
*
*
*

æ

update: Prompts the user to enter a part number.
Prints an error message if the part doesn't
exist; otherwise, prompts the user to enter
change in quantity on hand and updates the
database.

*
*
*
*
*
*

KX KKEAEKKKKÉKAEKAEAKRAAAAERARNKAERAAKAAAAAARAK KK /

void update (void)

int number, change;
struct part *p;

printf ("Enter part number: ") ;
scan£ ("%d", &number) ;
p = find part (number) ;
i£f (p != NULL) Ç|(
print£ ("Enter change in quantity on hand: ") ;
scanf ("%3d", &change) ;
p->on hand += change;
} else
printf ("Part not found.\n") ;

/***************1‘:******************************************

{

*
*
E
*

print: Prints a listing of all parts in the database,
showing the part number, part name, and
quantity on hand. Part numbers will appear in
ascending order.

*
*
*
*

***‘A"À'************‘k***‘k*‘k*‘k**‘k‘k*****‘k**‘À'***'k***‘k*****‘k'k**‘k*/

void print (void)

struct part *p;

***************************page_463***************************
438

Chapter 17

17.6

Advanced Uses of Pointers

printf ("Part Number Part Name "
"Quantity on Hand\n") ;
for (p = inventory; p != NULL; p = p->next)
print£("%7d %-25s%11d\n", p->number, p->name,
p->on _hand) ;

Notice the use of free in the insert function. insert allocates memory
for a part before checking to see if the part already exists. If it does, insert
releases the space to avoid a memory leak.

Pointers to Pointers

In Section 13.7, we came across the notion of à pointer to a pointer. In that section.
we used an array whose elements were of type char *: à pointer to one of the
array elements itself had type char * *. The concept of “pointers to pointers’’ also
pops up frequently in the context of linked data structures. In particular, when an
argument to à function is a pointer variable, we’II sometimes want the function to
be able to modify the variable by making it point somewhere else. Doing so
requires the use of a pointer to a pointer.

Consider the add_to _list function of Section 17.5, which inserts a node
at the beginning of a linked list. When we call add_to list., we pass it a
pointer to the first node in the original list; it then returns a pointer to the first node
in the updated list:

struct node *add_to list (struct node *list, int n)

{

Struct node *new _node;

new_node = malloc (sizeof (struct node) ) ;

if (new node == NULL) {
print£f ("Error: malloc failed in add to list\n") ;
exit (EXIT FAILURE) ;

new_node->value = n;
new_node->next = list;
return new node;

}

Suppose that we modify the function so that it assigns new _node to list
instead of returning new_node. In other words, let’s remove the return state-
ment from add_to_list and replace it by

list = new node;

Unfortunately, this idea doesn’t work. Suppose that we call add_to list in the
following way:

add_to list(first, 10);

***************************page_464***************************
177

 

17.7  Pointers to Functions 439

At the point of the call, first is copied into list. (Pointers, like all arguments,
are passed by value.) The last line in the function changes the value of 1ist, mak-
Ing it point to the new node. This assignment doesn’t affect first. however.

Getling add_to _list to modify first is possible, but it requires pass-
ing add_to_list a pointer to first. Here’s the correct version of the func-
tion:

void add_to _list (struct node **list, int n)

(

struct node *new _node;

new_node = malloc (sizeof (struct node) ) ;

if (new_node == NULL) {
printf ("Error: malloc failed in add_to list\n") ;
exit (EXIT FAILURE) ;

new_node->value = n;
new_node->next = *list,;
*list = new node;

}

When we call the new version of add_to list, the first areument will be the
address of first:

add _ to _ list(&first, 10);

Since 1ist is assigned the address of first, we can use *#1ist as an alias for
£irst. In particular, assigning new_node to *1ist will modify first.

Pointers to Functions

We've seen that pointers may point to various kinds of data, including variables,
array elements, and dynamically allocated blocks of memory. But C doesn't
require that pointers point only to data; it’s also possible to have pointers to feic-
tions. Pointers to functions aren’t as odd as you might think. After all, functions
occupy memory locations, so every function has an address, just as each variable
has an address.

Function Pointers as Arguments

We can use function pointers in much the same way we use pointers to data. In par-
ticular, passing a function pointer as an argument is fairly common in C. Suppose
that we're writing a function named integrate that integrates a mathematical
lunction £ between points a and b. We*d like to make integrate as general as
possible by passing it £ as an argument. To achieve this effect in C, we*11 declare f
to be à pointer to a function. Assuming that we want to integrate functions that have

***************************page_465***************************
440

Chapter 17  Advanced Uses of Pointers

sin lunction >23.3

QaÂ

à double parameter and return a double result, the prototype for integrate
will look like this:

double integrate (double (*£f) (double), double a, double b):;

The parentheses around * £ indicate that £ is a pointer to a function, not a function
that returns a pointer. It’s also legal to declare £ as though it were a function:

double integrate (double f (double), double a, double b);

From the compiler”s standpoint, this prototype is identical to the previous one.

When we call integrate, we'’Il supply a function name as the first argu-
ment. For example, the following call will integrate the sin (sine) function from O
to 77/2:

result = integrate(sin, 0.0, PI / 2);

Notice that there arc no parentheses after sin. When a function name isn’t fol-
lowed by parentheses, the C compiler produces a pointer to the function instead of
generating code for à function call. In our cxample, we're not calling sin; instead.
we're passing integrate a pointer to sin. If this seems confusing. think of how
C handles arrays. If à is the name of an array, then a [i] represents one element of
the array, while a by itself serves as a pointer to the array. In a similar way, if £ is a
function, C treats £ (x) as a call of the function but £ by itself as a pointer to the
function.
Within the body of integrate, we can call the function that £ points to:

y = (*f) (x);

* £ represents the function that £ points to: x is the argument to the call. Thus, dur-
ing the execution of integrate (sin, 0.0, PI / 2). each call of *F is actu-
ally à call of sin. As an alternative to (*£) (x), C allows us to write £ (x) to
call the function that £ points to. Although £ (x) looks more natural, l’Il stick
with (*£) (x) as a reminder that £ is a pointer to a function, not a function name.

The gsort Function

Although it might seem that pointers to functions aren1 relevant to the average
programmer, that couldn’t be further from the truth. In fact, some of the most use-
ful functions in the C library require a function pointer as an argument. One of
these is gsort, which belongs to the <stdlib.h> header. qsort is a general-
purpose sorting l'unction that’s capable of sorting any array. based on any criteria
that we choose.

Since the elements of the array that it sorts may be of any type—even a struc-
ture or union type—qsort must be told how to determine which of two array ele-
ments is “smaller” We’l1 provide this information to gsort by writing a
comparison function. When given two pointers p and q to array elements, the
comparison function must return an integer that is negative if *p is “less than” *q,

***************************page_466***************************
QaA

17.7  Pointers to Functions 441

zero 1f *p 1s “equal to” *g, and positive 1f *p 1s “greater than” *q. The terms “less
than;” “equal to” and ‘“greater than” are in quotes because it’s our responsibility to
determine how *p and *q are compared.

qsort has the following prototype:

void qsort (void *base, size t nmemb, size t size,
int (*compar) (const void *, const void *));

base must point to the first element in the array. (IF only a portion of the array 1s
to be sorted, we’Il make base point to the first element in this portion.) In the sim-
plest case, base is just the name of the array. nmemb 1s the number of clements to
be sorted (not necessarily the number of elements in the array). size 1s the size of
each array element, measured in bytes. compar is a pointer to the comparison
function. When qsort is called, it sorts the array into ascending order, calling the
comparison function whenever 1t needs to compare array elements.

To sort the inventory array of Section 16.3. we’d use the following call of
qsort:

gsort (inventory, num_parts, sizeof (struct part), compare _ parts) ;

Notice that the second argument is num_parts, not MAX PARTS; we don’! want
to sort thé entire inventory array, just the portion in which parts are currently
stored. The last argument, compare parts, 1s a function that compares two
part structurcs.

Writing the compare _ parts function isn’t as easy as you might expect.
qsort requires that its parameters have type void *. but we can’t access the
members of a part structure through à void * pointer; we need a pointer of type
struct part * instead. To solve the problem, wc'Il have compare parts
assign its parameters, p and q, to variables of type struct part *, thereby con-
verting them to the desired type. compare _parts can now use these variables to
access the members of the structures that p and q point to. Assuming that we want
to sort the inventory array into ascending order by part number. here’s how the
compare parts function might look:

int compare parts (const void *p, const void *g)

{

const struct part *p1l = p;
const struct part *ql = q;

1f (pl->number < ql->number)
return -l;

else if (pl->number == g1l->number)
return 0;
else

return l;

}

The declarations of p1 and ql include the word const to avoid getting a warning
from the compiler. Since p and q are const pointers (indicating that the objects

***************************page_467***************************
442

Chapter 17  Advanced Uses of Pointers

to which they point should not be modified). they should be assigned only to
pointer variables that are also declared to be const.

Although this version of compare parts works, most C programmers
would write the function more concisely. First, notice that we can replace p1 and
ql by cast expressions:

int compare_parts(const void *p, const void *qg)

{

Lif (((struct part *) p)->number <
((struct part *) q)->number)

return -l;

else 1f (((struct part *) p)->number ==

((struct part *) q)->number)

return 0;

else
return 1l;

}

The parentheses around ( (struct part *) p) are necessary; without them, the
compiler would try to cast p->number to type struct part *.
We can make compare _parts even shorter by removing the i f statements:

int compare parts(const void *p, const void *q)

(

return ((struct part *) p)->number -
((struct part *) g)->number;
}

Subtracting q’s part number from p’s part number produces a negative result if p
has a smaller part number, zero if the part numbers are equal. and a positive result
if p has a larger part number. (Note that subtracting two integers is potentially
risky because of the danger of overflow. l’m assuming that part numbers are posi-
tive integers, so that shouldn’t happen here.)

To sort the inventory array by part name instead of part number, we’d use
the following version of compare parts:

int compare _parts(const void *p, const void *g)

{

return stromp(((struct part *) p)->name,
((struct part *) q)->name) ;
}

All compare_parts has to do is call stremp, which conveniently returns a
negative, zero, or positive result,

Other Uses of Function Pointers

Although l’ve emphasized the usefulness of function pointers as arguments to
other functions. that’s not all they’re good for. C treats pointers to functions just
like pointers to data: we can store function pointers in variables or use them as ele-

***************************page_468***************************
PROGRAM

<math.h>header »23.3

 

17.7  Pointers to Functions 443

ments of an array or as members of a structure or union. We can even write func-
tions that return function pointers.
Here's an example of a variable that can store à pointer to a function:

void (*pf) (int) ;

p£ can point lo any function with an int parameter and à return type of void. If
E is such a function, we can make p£ point to £ in the following way:

Notice that therc’s no ampersand preceding f£. Once p£ points to £, we can call f
by writing either

(*p£) (i) ;
or
p£(i) ;

Arrays whose elements are function pointers have a surprising number of
applications. For example, suppose that we’re writing a program that displays a
menu of commands for the user to choose from. We can write functions that imple-
ment these commands, then store pointers to the functions in an array:

void (*file cmd[]) (void) = {new cmd,
open cmd,
close _cmd,
close_all _cmd,
save_cmd,
save _as cmd,
save all _ cmd,
print cmd,
exit cmd

} ;

IF the user selects command n, where n falls between O and 8, we can subscript the
file cmd array and call the corresponding function:

(*file cmd [n] ) () ; /* or file cmd{[n] () ; */

Of course, we could get a similar effect with a switch statement. Using an array
of function pointers gives us more flexibility, however, since the elements of the
array can be changed as the program is runnine.

Tabulating the Trigonometric Functions

The following program prints tables showing the values of the cos, sin, and tan
functions (all three belong to <math.h>). The program is built around a funetion
named tabulate that, when passed a function pointer £, prints a table showing
the values of £.

***************************page_469***************************
444 Chapter 17  Advanced Uses of Pointers

tabulate.c. /* Tabulates values of trigonometric functions */

#include <math.h>
#include <stdio.h>

void tabulate (double (*£) (double), double first,
double last, double incer) ;

int main(void)

{

double final, increment, initial;

print£f ("Enter initial value: ") ;
scanf ("%1f£", &initial) ;

printf ("Enter final value: ") ;
scanf ("S1f£", &final) ;

printf ("Enter increment : ") ;
scanf ("$1£", &increment) ;

print£ ("\n x cos (x) "

rn — -------00 ------- \n") ;
tabulate(cos, initial, final, increment) ;
printf ("\n x sin(x)"

tn ------70 ------- \n") ;
tabulate (sin, initial, final, increment) ;
printf ("\n x tan (x) "

tn ------- ------- \n") ;

tabulate(tan, initial, final, increment) ;

return 0;

}

void tabulate (double (*£f) (double), double first,
double last, double incr)
{

double x;
int i, num intervals;

num _ intervals = ceil((last - first) / iner);
for (i = 0; i <= num intervals; i++) (

x = first + i * iner;

printf("%10.5£ %10.5£\n", x, (*f)(x));

}
}

tabulate uses the ceil function, which also in <math.h>. When given an
argument x of double type. ceil returns the smallest integer that’s greater than
or equal to x.

Here's what a session with tabulate. c might look like:

***************************page_470***************************
 

 

 

178  Restricted Pointers (C99) 445

Enter initial value: O

Enter final value: .5

Enter increment: .1

x cos (x)
0.00000 1.00000
0.10000 0.99500
0.20000 0.98007
0.30000 0.95534
0.40000 0.92106
0.. 50000 0.87758

x sin(x)
0.00000 0.00000
0.10000 0.09983
0.20000 0.19867
0.30000 0.29552
0.40000 0.38942
0.50000 0.47943

x tan(x)
0.00000 0.00000
0.10000 0.10033
0.20000 0.20271
0.30000 0.30934
0.40000 0.42279
0.50000 0.54630

17.8 Restricted Pointers (C99)

This section and the next discuss two of C99’s pointer-related features. Both are
primarily of interest to advanced C programmers; most readers will want to skip
these sections.

In C99, the keyword restrict may appear in the declaration of a pointer:

int * restrict p;

À pointer thats been declared using restrict is called a restricted pointer. The
intent is that if p points to an object that is later modified. then that object is not
accessed in any way other than through p. (Alternative ways to access the object
include having another pointer to the same object or having p point to a named
variable.) Having more than one way to access an object is often called aliasing.
Let's look at an example of the kind of behavior that restricted pointers are
supposed to discourage. Suppose that p and q have been declared as follows:

int * restrict p;
int * restrict g;

***************************page_471***************************
446 Chapter 17  Advanced Uses of Pointers

extern storage class » /8.2

blocks » 10,3

file scope > 10.2

<string .h> header » 23.6

Now suppose that p is made to point to a dynamically allocated block of memory:
p = malloc(sizeofËf (int)) ;

(A similar situation would arise if p were assigned the address of a variable or an
array element.) Normally it would be legal to copy p into q and then modify the
integer through q:

q = P

*q = 0; /* causes undefined behavior */

Because p is a restricted pointer, however, the effect of executing the statement
*q = 0; 1s undefined. By making p and q point to the same object, we caused *p
and *q to be aliases.

If a restricted pointer p is declared as a local variable without the extern
storage class, restrict applies only to& p when the block in which p is declared
is being executed. (Note that the body of a function is a block.) restrict can be
used with function parameters of pointer type, in Which case it applies only when
the function is executing. When restrict is applied to a pointer variable with
file scope, however, the restriction lasts for the entire execution of the program.

The exact rules for using restrict are rather complex: see the C99 stan-
dard for details. There are even situations in which an alias created from a
restricted pointer is legal. For example, a restricted pointer p can be legally copied
into another restricted pointer variable q, provided that p is local to a function and
q is defined inside a block nested within the function’s body.

To illustrate the use of restrict. let’s look at the memcpy and memmove
functions, which belong to the <string.h> header. memcpy has the following
prototype in C99:

void *memcpy (void * restrict sl, const void * restrict s2,
size t n);

memcpy 1s similar to strcopy, except that it copies bytes from one object to
another (strcopy copies characters from one string into another). s2 points to the
data to be copied, s1 points to the destination of the copy, and n is the number of
bytes to be copied. The use of restrict with both s1 and s2 indicates that the
source of the copy and the destination shouldn’t overlap. (It doesn't guarantee that
they don’t overlap, however.)

In contrast, restrict doesn't appear in the prototype for memmove:

void *memmove (void *s1, const void *s2, size t n);

memmove does the same thing as memcpy: it copies bytes from one place to
another. The difference 1s that memmove is guaranteed to work even if the source
and destination overlap. For example, we could use memmove to shift the elements
of an array by one position:

int a[100] ;

***************************page_472***************************
register storage class » 18.2

17.9

17.9 Flexible Array Members (C99) … 447

memmove (&a [(0], &a[1], 99 * sizeof (int));

Prior to C99, there was no way to document the difference between memcpy and
memmove. The prototypes for the two functions were nearly identical:

void *memcpy (void *s1, const void *s2, size t n);
void *memmove (void *sl, const void *s2, size t n});

The use of restrict in the C99 version of memcpy”s prototype lets the pro-
grammer know that s1 and s2 should point to objects that don’t overlap. or else
the function isn°’t guaranteed to work.

Although using restrict in function prototypes is useful documentation.
that’s not the primary reason for its existence. restrict provides information to
the compiler that may enable 1t to produce more efficient code—a process known
as optimization. (The register storage class serves the same purpose.) Not
every compiler attempts to optimize programs, however, and the ones that do nor-
mally allow the programmer to disable optimizalion. Às a result, the C99 standard
guarantees that restrict has no effect on the behavior of a program that con-
forms to the standard: if all uses of restrict are removed from such a program.
it should behave the same.

Most programmers won't use restrict unless they're fine-tuning a pro-
gram to achieve the best possible performance. Still, it’s worth knowing about
restrict because it appears in the C99 prototypes for a number of standard
library functions.

Flexible Array Members (C99)

Every once in a while, we’Il need to define a structure that contains an array of an
unknown size. For example, we might want to store strings in a form that’s differ-
ent from the usual one. Normally, à string is an array of characters. with a null
character marking the end. However, there are advantages to storing strines in
other ways. One alternative is to store the length of the string along with the
string’s characters (but with no null character). The length and the characters could
be stored in a structure such as this one:

struct vstring {
int len;
char chars (N] ;

}

Here N is a macro that represents the maximum length of a string. Using a fixed-
length array such as this 1s undesirable, however, because 1t forces us to limit the
length of the string, plus it wastes memory (since most strings won't need all N
characters in the array).

C programmers have traditionally solved this problem by declaring the length
of chars to be | (a dummy value) and then dynamically allocating each string:

***************************page_473***************************
448

Chapter 17  Advanced Uses of Pointers

struct vstring {
int len;
char chars [1] ;

}7

struct vstring *str = malloc(sizeof (struct vstring) + n - 1);
str->len = n;

We’re “cheating” by allocating more memory than the structure is declared to have
(in this case, an extra n — ! characters). and then using the memory to store addi-
tional elements of the chars array. This technique has become so common over
the years that it has a name: the “struct hack.

The struct hack isn’t limited to character arrays: it has a variety of uses. Over
time, it has become popular enough to be supported by many compilers. Some
(including GCC) even allow the chars array to have zero length, which makes
this trick a little more explicit. Unfortunately, the C89 standard doesn't guarantee
that the struct hack will work, nor does it allow zero-length arrays.

[n recognition of the struct hack's usefulness. C99 has a feature known as the

fexible array member that serves the same purpose. When the last member of a

structurc is an array, its length may be omitted:

struct vstring {
int len;
char chars [] ; /* flexible array member - C99 only */

}

The length of the chars array isn’t determined until memory is allocated for a
vstring structure, normally using a call of malloc:

struct vstring *str = malloc(sizeof (struct vstring) + n});
str->len = n;

In this example, str points to a vstring structure in which the chars array
occupies n characters. The sizeof operator ignores the chars member when
computing the size of the structure. (A flexible array member is unusual in that it
takes up no space within a structure.)

À lew special rules apply to a structure that contains a flexible array member.
The flexible array member must appear last in the structure, and the structure must
have at least one other member. Copying a structure that contains a flexible array
member will copy the other members but not the flexible array itself.

À structure that contains à fexible array member 1s an incomplete type. An
incomplete type 1s missing part of the information needed to determine how much
memory it requires. Incomplete types, which are discussed further in one of the
Q&A questions at the end of this chapter and in Section 19.3. are subject to various
restrictions. In particular, an incomplete type (and hence a structure that contains a
flexible array member) can’t be a member of another structure or an element of an
array. However, an array may contain pointers to structures that have a flexible
array member; Programming Projeet 7 at the end of this chapter is built around
such an array.

***************************page_474***************************
>.

variable-length argument lists
>26.1

 

Q & À 449

Q & À

What does the NULL macro represent? [p. 415]

NULL actually stands for 0. When we use O in a context where a pointer would be
required, C compilers treat it as a null pointer instead of the integer 0. The NULL
macro is provided merely to help avoid confusion. The assignment

p = 0;

could bc assigning the value 0 to à numeric variable or assigning à null pointer to a
pointer variable; we can°t easily tell which. In contrast, the assignment

p = NULL;

makes it clear that p is a pointer.

In the header files that come with my compiler, NULL is defined as follows:
#define NULL (void *) O

What’s the advantage of casting O to void *?

This trick, which is allowed by the C standard, enables compilers to spot incorrect
uses of the null pointer. For example, suppose that we try to assign NULL Lo an
integer variable:

i = NULL;

IF NULL is defined as O, this assignment is perfectly legal. But if NULL is defined
as (void *) O, the compiler can warn us that we're assigning a pointer to an inte-
ger variable.

Defining NULL as (void *) O has a second, more important, advantage.
Suppose that we call a f'unction with a variable-leneth argument list and pass NULL
as one of the arguments. If NULL is defined as O. the compiler will incorrectly pass
à zero integer value. (In an ordinary function call, NULL works fine because the
compiler knows from the function’s prototype that it expects a pointer. When a
function has a variable-length areument list, however, the compiler lacks this
Knowledge.) Tf NULL is defined as (void *) O, the compiler will pass a null
pointer.

To make matters even more confusing, some header files define NULL to be
OL (the 1long version of 0). This definition, like the definition of NULL as O. is à
holdover from C’s earlier years, when pointers and integers were compatible. For
MOSL purposes, though, it really doesn’t matter how NULL is defined; just think of
it as a name for the null pointer.

Since O is used to represent the null pointer, I guess a null pointer is just an
address with all zero bits, right?

***************************page_475***************************
450

Chapter 17  Advanced Uses of Pointers

Â:

> .&

Not necessarily. Each C compiler is allowed to represent null pointers in à different
way, and not all compilers use a zero address. For example, some compilers use a
nonexistent memory address for the null pointer; that way, attempting to access
memory through a null pointer can be detected by the hardware.

How the null pointer is stored inside the computer shouldn’t concern us; that’s
a detail for compiler experts to worry about. The important thing is that, when used
In à pointer context, O is converted to the proper internal form by the compiler.

[s it acceptable to use NULL as a nuil character?

Definitely not. NULL is a macro that represents the null poinrer, not the null char-
acter. Using NULL as a null character will work with some compilers, but not with
all (since some define NULL as (void *) 0). In any event, using NULL as any-
thing other than a pointer can Icad to a great deal of confusion. Lf you want a name
for the null character, define the following macro:

#define NUL '\0O!'

When my program terminates, I get the message “Null pointer assignment.”
What does this mean?

This message, which is produced by programs compiled with some older DOS-
based C compilers, indicates that the program has stored data in memory USINg a
bad pointer (but not necessarily a null pointer). Unfortunately, the message isn’t
displayed until the program terminates, so there’s no clue as to which statement
caused the error. The “Null pointer assignment” message can be caused by a miss-
ing & in scanf:

scanf ("sd", i); /* ghould have been scanf ("$d", &i); */
Another possibility is an assignment involving a pointer that’s uninitialized or null:
*p = i; /* p is uninitialized or null */

How does a program know that a “null pointer assignment” has occurred?

The message depends on the fact that, in the small and medium memory models.
data is stored in a single segment, with addresses beginning at O. The compiler
leaves a “hole” at the beginning of the data segment—a smail block of memory
that's initialized to O but otherwise isn’t used by the program. When the program
terminates, it checks to see if any data in the “hole” area is nonzero. If so, it must
have been altered through a bad pointer.

 

Is therc any advantage to casting the return value of malloc or the other
memory allocation functions? [p. 416]

Not usually. Casting the void * pointer that these functions return is unnecessary.
since pointers of type void * are automatically converted to any pointer type
upon assignment. The habit of casting the return value is a holdover from older
versions of C, in which the memory allocation functions returned a char * value,
making the cast necessary. Programs that are designed to be compiled as C++ code

 

***************************page_476***************************
:}:Qz

incomplete types » 79,3

Q & A 451

may benefit from the cast, but that’s about the only reason to do it.

In C89, there’s actually a small advantage to nor performing the cast. Suppose
that we’ve forgotten to include the <stdlib.h> header in our program. When
we call malloc, the compiler will assume that its return type is int (the default
return value for any C function). IF we don't cast the return value of mal loc, a
C89 compiler will produce an error (or at least à warning), since we’re trying Lo
assign an integer value to a pointer variable. On the other hand, if we cast the
return value to à pointer, the program may compile. but likely won’t run properly.
With C99, this advantage disappears. Forgetting to include the <stdlib.h>
header will cause an error when malloc is called, because C99 requires that a
function be declared before it's called.

The calloc function initializes a memory block by setting its bits to zero.
Does this mean that all data items in the block become zero? [p. 421]

Usually, but not always. Setting an integer to zero bits always makes the integer
Zero. Setting à floating-point number to zero bits üsually makes the number zero,
bul this isn’t guaranteed—it depends on how floating-point numbers are stored.
The story is the same for pointers; a pointer whose bits are zero isn’t necessary a
null pointer.

I see how the structure tag mechanism allows a structure to contain a pointer
to itself. But what if two structures each have a member that points to the
other’? [p. 425]

Here’s how we’d handle that situation:
struct s1; /* incomplete declaration of s1 */
struct s2 (

struct sl *p;

u°

struct sl {
struct s2 *g;

B

The first declaration of s1 creates an incomplete structure type. since we haven*t
specified the members of s1. The second declaration of s1 “completes” the type
by describing the members of the structure. Incomplete declarations of a structure
type are permitted in C, although their uses are limited. Creating a pointer to such a
type (as we did when declaring p) is one of these uses.

Calling malloc with the wrong argument—causing it to allocate too much
memory or too little memory—scems to be a common error. Is there à safer
way to use malloc? [p. 426]

***************************page_477***************************
452

Chapter 17  Advanced Uses of Pointers

À:

Yes, there 1s. Some programmers use the following idiom when calling malloc to
allocate memory for a single object:

p = malloc (sizeoË (*p)) ;

Since sizeof (*p) 1s the size of the object to which p will point. this statement
guarantees that the correct amount of memory will be allocated. At first glance.
this idiom looks fishy: 10s likely that p 1s uninitialized, making the value of *p
undefined. However. sizeof doesn't evaluate *p. it merely computes its size, so
the idiom works even 1f p 1s uninitialized or contains a null pointer.

To allocate memory for an array with n elements, we can use a slightly modi-
fied version of the idiom:

p = malloc(n * sizeof (*p));

Why isn°t the gsort function simply named sort? [p. 440]

The name gsort comes from the Quicksort algorithm published by C. A. R.
Hoare in 1962 (and discussed in Section 9.6). Ironically, the C standard doesn't
require that qsort use the Quicksort algorithm. although many versions of
qsort do.

Isn’t it necessary to cast qsort?s first argument to type void *, as in the fol-
lowing example? [p. 441]

qsort ((void *) inventory, num parts, sizeof(struct part),
compare parts) ;

No. À pointer of any type can be converted to void * automatically.

J want to use gsort to sort an array of integers, but l’m having trouble writ-
ing a comparison function. What*s the secret?

Here's a version that works:

int compare ints(const void *p, const void *g)

{
}

Bizarre. eh? The expression (int *)p casts p to type int *, so * (int *)p
would be the integer that p points to. À word of warning, though: Subtracting two
integers may cause overflow. If the integers being sorted are completely arbitrary,
1s safer to use i £ statements to compare * (int *) p with * (int *) q.

return * (int *)p - *(int #*)g;

[ needed to sort an array of strings, so I figured d just use stromp as the
comparison function. When Ll passed it to qgsort, however, the compiler gave
me a warning. | tried to tix the problem by embedding strcmp in a compari-
son function:

***************************page_478***************************
Section 17.1

Section 17.2

Section 17.3

Section 17.5

D

Lo

Exercises 453

int compare strings(const void *p, const void *q)

{
}

Now my program compiles, but qsort doesn’t seem to sort the array. What
am Î doing wrong?

return stremp(p, q);

First, you can’t pass strcemp itself to gsort, since gsort requires a comparison
function with two const void * parameters. Your compare strings func-
tion doesn't work because it incorrectly assumes that p and q are strings (char *
pointers). In fact, p and q point to array elements containing char * pointers. To
fIx compare strings, we’Il cast p and g lo type char **, then use the *
operator to remove one level of indirection:

int compare _ strings(const void *p, const void *g)

(
}

return stremp (* (char **)p, * (char **)q) ;

Exercises

Having to check the return value of malloc (or any other memory allocation function)
each time we call it can be an annoyance. Write a function named my_malloc that serves
as a “wrapper” for malloc. When we call my_malloc and ask it to allocate n bytes, it in
turn calls malloc, tests to make sure that malloc doesn’t return a null pointer, and then
returns the pointer from malloc. Have my_malloc print an error message and terminate
the program i1f malloc returns a null pointer.

Write à function named dupliicate that uses dynamic storage allocation to create à copy
of a string. For example, the call

p = duplicate(str) ;

would allocate space for a string of the same length as str. copy the contents of str into
the new string, and return a pointer to it. Have duplicate return a null pointer if the
memory allocation fails.

Write the following function:
int *create _array(int n, int initial value) ;

The function should return à pointer to a dynamically allocated int array with n members.
each of which is initialized to initial _value. The return value should be NULL if the
array can’t be allocated.

Suppose that the following declarations arc in effect:

struct point { int x, y; };
struct rectangle { struct point upper left, lower right; };
struct rectangle *p;

***************************page_479***************************
454

Chapter 17  Advanced Uses of Pointers

10.

ll.

Assume that we want p to point to a rectangle structure whose upper left comer is at
(10, 25) and whose lower right corner is at (20, 15). Write a series of statements that allocate
such a structure and initialize it as indicated.

Suppose that £ and p are declared as follows:

struct {
union |
char a, b;
int c;
} à;
int e[5] ;
} f, *p = &f;
Which of the following statements are legal?
(a) p->b = ' "!;
(b) p->e[3)] = 10;
(c) (*p) .d.a = '*',;
(d) p->d->c = 20;

Modify the delete_from_list function so that it uses only one pointer variable instead
of two (cur and prev).

The following loop is supposed to delete al! nodes from à linked list and release the memory
that they occupy. Unfortunately, the loop is incorrect. Explain what's wrong with it and
show how to fix the bue.

for (p = first; p != NULL; p = p->next)
free (p) ;

Section 15.2 describes a file, stack.c, that provides functions for storing integers in a
stack. In that section, the stack was implemented as an array. Modify stack.c so that à
stack is now stored as a linked list. Replace the contents and top variables by a single
variable that points to the first node in the list (the “top” of the stack). Write the functions in
stack.c so that they use this pointer. Remove the is fu1ll function, instead having
push return either true (if memory was available to create a node) or f£al se (if not).

True or false: IË x is a structure and a is a member of that structure. then (&x) - >a is the
same as x. a. Justify your answer.

Modify the print_part function of Section 16.2 so that its parameter is a pointer to a
part structure. Use the -> operator in your answer.

Write the following function:

int count_occurrences (struct node *list, int n);

The 1ist parameter points to a linked list; the function should return the number of times
that n appears in this list. Assume that the node structure is the one defined in Section 17.5.
Write the following function:

struct node *find last (struct node *list, int n);

The 1ist parameter points to a linked list. The function should return à pointer to the /as?
node that contains n: it should return NULL if n doesn't appear in the list. Assume that the
node structure is the onc defined in Section 17.5.

The following function is supposed lo insert a new node into its proper place in an ordered
list, returning a pointer to the first node in the modified list. Unfortunately, the function

***************************page_480***************************
Section 17.6

Section 17.7

]4.

@ 15.

16.

@ 17.

18.

19.

Exercises 455

doesn't work correctly in all cases. Explain what’s wrong with it and show how to fix it.
Assume that the node structure 1s the one defined in Section 17.5.

struct node *insert_into ordered _ list (struct node *list,
( struct node *new node)

struct node *cur = list, *-prev = NULL;
while (cur->value <= new node->value) ({
prev = cur;
cur = cur->next;
}

prev->next = new node;
new_node->next = cur;
return list;

}

Modify the delete from list function (Section 17.5) so that its first parameter has
type struct node ** (a pointer to a pointer to the first node in a list) and its return type is
void. delete from list must modify its first argument to point to the list after the
desired node has been deleted.

Show the output of the following program and explain what it does.

#include <stdio.h>

int f1(int (*f) (int));
int f2 (int i);

int main(void)

{

printf ("Answer: %d\n", f1(f2));
return 0;

}

int f£fl(int (*E) (int))

{

int n = O0;

while ((*f)(n)) n++;
return n;

}

int f2(int i)

{
}

Write the following function. The call sum(g, i, j) should rctum g(i) +… +g(5).

return i #* i + i - 12;

int sum(int (*f) (int), int start, int end);

Let a be an array of 100 integers. Write a call of gsort that sorts only the /as: 50 elements
in a. (You don’t need to write the comparison function).

Modify the compare parts function so that parts are sorted with their numbers in
descending order.

Write a function that, when given a string as its argument. searches the following array of
structures for a matching command name, then calls the function associated with that name.

***************************page_481***************************
456 Chapter 17  Advanced Uses of Pointers

L

Un

struct {

char *cmd_name;

void (*cmd pointer) (void) ;
} fFile cmd[] =

"new”, new cmd},
( _
{"open", open cmd},
{"close", close _cmd},
{"close all", close all cmd},
{"save", save _cmd},
{"save as", - save _as _ cmd},
{("save all",  save all _ cmd},
{"print", print _ cmd},
"exit", exit_cmd
( _

Programming Projects

Modify the inventory. c program of Section 16.3 so that the inventory array is allo-
cated dynamically and later reallocated when it fills up. Use malloc initially to allocate
enough space for an array of 10 part structures. When the array has no more room for new
parts, use realloc to double its size. Repcat the doubling step each time the array
becomes full.

Modify the inventory.c program of Section 16.3 so that the p (print) command calls
qsort to sort the inventory array bcfore 1t prints the parts.

Modify the inventory2 .c program of Section 17.5 by adding an e (erase) command
that allows the user to remove a part from the database.

Modify the justi£y program of Section 15.3 by rewriting the line. c file so that it
stores the current line in a linked list. Each node in the list will store a single word. The
line array will be replaced by à variable that points to the node containing the first word.
This variable will store à null pointer whenever the line is empty.

Write à program that sorts a series of words entercd by the user:

Enter word: foo

Enter word: bar

Enter word: baz

Enter word: quux
Enter word :

 

In sorted order: bar baz foo quux

Assume that each word is no more than 20 characters long. Stop reading when the user
enters an empty word (i.e., presses Enter without entering a word). Store each word in a
dynamically allocated string, using an array of pointers to keep track of the strings. as in the
remind2 .c program (Section 17.2). After all words have been read, sort the array (using
any sorting technique) and then use a loop to print the words in sorted order. Hint: Use the
read_line function to read each word. as in remind2.c.

Modify Programming Projeet 5 so that it uses gsort to sort the array of pointers.

(C99) Modify the remind2.c program of Section 17.2 so that each element of the
reminders array is a pointer to a vstring structure (see Section 17.9) rather than à
pointer to an ordinary string.

***************************page_482***************************
 

- S Ÿ

18

18.1

Declarations

Making something variable is easy.
Controlling duration of constancy is the trick.

Declarations play à central role in C programming. By declaring variables and
functions. we furnish vital information that the compiler will need in order to
check a program for potential errors and translate it into object code.

Previous chapters have provided examples of declarations without going Into
full details; this chapter fills in the gaps. It explores the sophisticated options that
can be used in declarations and reveals that variable declarations and function dec-
larations have quite a bit in common. It also provides a firm grounding in the
important concepts of storage duration, scope. and linkage.

Section 18.1 examines the syntax of declarations in their most general form,
a topic that we've avoided up to this point. The next four sections focus on the
ilems that appear in declarations: storage classes (Section 18.2). type qualifiers
(Section 18.3), declarators (Section 18.4), and initializers (Section 18.5). Section
18.6 discusses the inline keyword, which can appear in C99 function declara-
tions.

Declaration Syntax

Declarations furnish information to the compiler about the meaning of identifiers.
When we write

int i;

we're informing the compiler that, in the current scope, the name i represents a
variable of type int. The declaration

float £ (float) ;

457

***************************page_483***************************
458

Chapter 18  Declarations

declaration

tells the compiler that £ is a function that returns a £loat value and has one areu-
ment, also of type float.
In general, a declaration has the following appearance:

declaration-specifiers declarators ;

Declaration specifiers describe the properties of the variables or functions being
declared. Declarators give their names and may provide additional information
about their properties.

Declaration specifiers fall into three categories:

m Storage classes. There are four storage classes: auto, static, extern,
and register. Ât most one storage class may appear in a declaration: if
present, it should come first.

=m Type qualifiers. In C89, there are only two type qualifiers: const and vol-
atile. C99 has a third type qualifier, restrict. À declaration may con-
tain Zzero or more type qualifiers.

m T'ype specifiers. The keywords void, char, short, int. long. float.
double, signed, and unsigned are all type specifiers. These words may
be combined as described in Chapter 7; the order in which they appear doesn*t
matter (int unsigned long is the same as long unsigned int). Type
specifiers also include specifications of structures, unions, and enumerations
(for example. struct point { int x, y; }, struct { int x, y; },or
struct point). Type names created using typedef are type specifiers as
well.

(C99 has a fourth kind of declaration specifier, the function specifier, which is
used only in function declarations. This category has just one member. the key-
word inline.) Type qualifiers and type specifiers should follow the storage class,
but there are no other restrictions on their order. As a matter of style, TI! put type
qualifiers before type specifiers.

Declarators include identifiers (names of simple variables), identifiers fol-
lowed by [] (array names), identifiers preceded by * (pointer names), and identif-
ers followed by () (function names). Declarators are separated by commas. A
declarator that represents a variable may be followed by an initializer.

Let’s look at a few examples that illustrate these rules. Here’s a declaration
with a storage class and three declarators:

storage class declarators
$ v/ vl \
static float x, y, *p;
A

|
type specifier

The following declaration has a type qualifier but no storage class. Tt also has an
initializer:

***************************page_484***************************
 

182  Storage Classes 459

type qualifier declarator
y ç
const char month[] = "January";
A A
| |
type specifier initializer

The following declaration has both a storage class and a type qualifier. Tt also has
three type specifiers; their order isn°’t important:

storage class type specifiers
} / \ \;
extern const unsigned long int a[10];
ñ A
| |
type qualifier declarator

Function declarations, like variable declarations, may have a storage class, type
qualifiers, and type specifiers. The following declaration has a storage class and a
type specifier:

storage class declarator
J v
extern int square (int) ;
A

|
type specifier

The next four sections cover storage classes, type qualifiers, declarators. and
initializers in detail.

18.2 Storage Classes

Storage classes can be specified for variables and—to a lesser extent—functions
and parameters. We’1l concentrate on variables for now.

Recall from Section 10.3 that the term block refers to the body of a function
(the part enclosed in braces) or a compound statement, possibly containing decla-
rations. In C99, selection statements (i£ and switch) and iteration statements
(while, do, and for)—along with the “inner” statements that they control—are
EU S — considered to be blocks as well, although this is primarily a technicality.

@

Properties of Variables
Every variable in a C program has three properties:

u Sforage duration. The storage duration of a variable determines when mem-
ory 1s set aside for the variable and when that memory is released. Storage for
a variable with automatic storage duration is allocated when the surrounding

***************************page_485***************************
460

Chapter 18  Declarations

Q&AÀ

Q&A

block is executed: storage 1s deallocated when the block terminates, causing
the variable to lose its value. À variable with static storage duration stays at
the same storage location as long as the program is running, allowing it to
retain its value indefinitely.

m Scope. The scope of a variable is the portion of the program text in which the
variable can be referenced. À variable can have either block scope (the vari-
able is visible from its point of declaration to the end of the enclosing block)
or file scope (the variable 1s visible from its point of declaration to the end of
the enclosing file).

m Linkage. The linkage of a variable determines the extent to which it can be
shared by different parts of a program. À variable with external linkage may
be shared by several (perhaps all) files in a program. À variable with internal
linkage is restricted to a single file. but may be shared by the functions in that
file. (If a variable with the same name appears in another file, it’s treated as a
different variable.) À variable with no linkage belongs to a single function and
can’t be shared at all.

The default storage duration, scope, and linkage of a variable depend on where
il’s declared:

m Variables declared inside a block (including a function body) have automatic
storage duration, block scope, and no linkage.

u Variables declared outside any block, at the outermost level of a program, have
static storage duration, file scope, and external linkage.

The following example shows the default properties of the variables i and j:
_— Static storage duration
int i;, — file scope

external linkage

void f (void)

{ automatic storage duration
int j ; I—— block scope
no linkage
}

For many variables, the default storage duration, scope, and linkage are satis-
factory. When they aren’t, we can alter these properties by specifying an explicit
storage class: auto, static, extern, orregister.

The auto Storage Class

The auto storage class is legal only for variables that belong to a block. An auto
variable has automatic storage duration (not surprisingly), block scope. and no
linkage. The auto storage class is almost never specified explicitly. since it’s the
default for variables declared inside a block.

***************************page_486***************************
information hiding > 79.2

18.2 Storage Classes 461

The static Storage Class

The static storage class can be used with all variables, regardless of where
they’re declared, but it has a different effect on a variable declared outside a block
than it doëes on a variable declared inside a block. When used ourside a block, the
word static specifies that a variable has internal linkage. When used inside a
block, static changes the variable's storage duration from automatic to static.
The following figure shows the effect of declaring i and j to be static:

_— gtatic storage duration
static int i,— file scope
- internal linkage

void f (void)

{ static storage duration
static int j;——-bMŒ<ampe
no linkage
}

When used in a declaration outside a block. static essentially hides a vari-
able within the file in which ils declared: only functions that appear in the same
file can see the variable. In the following example. the functions £1 and f2 both
have access to i, but functions in other files don’t:

static int i;

void £1(void)

/* has access to i */
void £2 (void)

/* has access to i */
This use of static can help implement a technique known as information hid-
ing.

A static variable declared within a block resides at the same storage loca-
tion throughout program execution. Unlike automatic variables, which lose their
values each time the program leaves the enclosing block, a static variable will
retain its value indefinitely. static variables have some interesting properties:

m À static variable in a block is initialized only once. prior to program execu-
tion. An auto variable is initialized every time it comes into existence (pro-
vided. of course, that it has an initialiZer).

w Each time a function is called recursively. it gets a new set of auto variables.
If it has a static variable. on the other hand, that variable is shared by all
calls of the function.

***************************page_487***************************
462

Chapter 18  Declarations

u Although a function shouldn’t return a pointer to an auto variable. there’s
nothing wrong with it returning a pointer to a static variable.

Declaring one of its variables to be static allows a function to retain infor-
mation between calls in a ‘“‘hidden” area that the rest of the program can°t access.
More often, however, we’ll use static to make programs more efficient. Con-
sider the following function:

char digit _to hex char(int digit)

{

const char hex chars[16] = "0123456789ABCDEF" ;

return hex chars [digit] ;

}

Each time the digit to hex char function is called, the characters
0123456789ABCDEF will be copied into the hex chars array to initialize it.
Now, let’s make the array static:

char digit_to hex char(int digit)

(

static const char hex chars[16] = "0123456789ABCDEF" ;

return hex chars [digit] ;

}

Since static variables are initialized only once, we’ve improved the speed of
digit to hex char.

The extern Storage Class

The extern storage class enables several source files to share the same variable.
Section 15.2 covered the essentials of using extern, so [ won’t devote much
space to it here. Recall that the declaration

extern int i;

informs the compiler that i is an int variable, but doesn’{ cause it to allocate
memory for i. In C terminology, this declaration is not a definition of i; it merely
informs the compiler that we need access to a variable that’s defined elsewhere
(perhaps later in the same file, or—more often—in another file). À variable can
have many declarations in à program but should have only one definition.

There’s one exception to the rule that an extern declaration of a variable
Isn’t a definition. An extern declaration that initializes a variable serves as a def-
inition of the variable. For example, the declaration

extern int i = 0;
is effectively the same as

int ài = 0;

***************************page_488***************************
QaÂÀ

182  Storage Classes 463

This rule prevents multiple extern declarations from initializing à variable in
different ways.

A variable in an extern declaration always has static storage duration. The
scope of the variable depends on the declaration’s placement. 1f the declaration 1s
inside a block, the variable has block scope; otherwise, it has file scope:

_— Static storage duration

extern int i;r— file scope
? linkage
void f (void)
{ static storage duration
extern int j ; Dlock scope
? linkage
}

Determining the linkage of an extern variable is a bit harder. If the variable was
declared static earlier in the file (outside of any function definition), then it has
internal linkage. Otherwise (the normal case), the variable has external linkage.

The register Storage Class

Using the register storage class in the declaration of a variable asks the com-
piler to store the variable in a register instead of keeping it in main memory like
other variables. (A register is a storage area located in a computer's CPU. Data
stored in a register can be accessed and updated faster than data stored in ordinary
memory.) Specifying the storage class of a variable to be register 1s a request.
not a command. The compiler is free to store a register variable in memory if
it chooses.

The regisster storage class is legal only for variables declared in a block. À
register variable has the same storage duration, scope, and linkage as an auto
variable. However, a register variable lacks one property that an auto vari-
able has: since registers don’t have addresses, it’s illegal to use the & operator to
take the address of a register variable. This restriction applies even 1f the com-
piler has elected to store the variable in memory.

register is best used for variables that are accessed and/or updated fre-
quently. For example, the loop control variable in a for statement is a good candi-
date for register treatment:

int sum array(int a[], int n)
register int i;
int sum = OD;

for (i = O0; i < n; i++)
sum += a[ai];
return sum;

***************************page_489***************************
464

Chapter 18  Declarations

register isn’t nearly as popular among C programmers as il once was.
Today's compilers are much more sophisticated than early C compilers; many can
determine automatically which variables would benefit the most from being kept in
registers. Still, using register provides useful information that can help the
compiler optimize the performance of à program. In particular, the compiler knows
that a register variable can’t have its address taken. and therefore can’t be
modified through a pointer. In this respect, the register keyword is related to
C99’s restrict keyword.

The Storage Class of a Function

Function declarations (and definitions), like variable declarations, may include a
storage class, but the only options are extern and static. The word extern
at the beginning of a function declaration specifies that the function has external
linkage. allowmg 1t to be called from other files. static indicates internal link-
age, limiting use of the function’s name to the file in which it’s defined. If no stor-
age class is specified, the function is assumed to have external linkage.

Consider the following function declarations:

extern int f (int i);
static int g(int i);
int h(int i);

£ has external linkage, g has internal linkage, and h (by default) has external link-
age. Because it has internal linkage, g can’t be called directly from outside the file
in which 1Cs defined. (Declaring g to be static doesn‘t completely prevent it
from being called in another file: an indirect call via a function pointer is still pos-
sible.)

Declaring functions to be extern is like declaring variables to be auto—it
serves no purpose. For that reason, | don’t use extern in function declarations.
Be aware, however, that some programmers use extern extensively. which cer-
tainly does no harm.

Declaring functions to be static, on the other hand. is quite useful. In fact, 1
recommend using static when declaring any function that isn‘t intended to be
called from other files. The benefits of doing so include:

=s Fasier maintenance. Declaring à function £ to be static guarantees that f
isn°t visible outside the file in which its definition appears. As a result, some-
one modifying the program later knows that changes to £ won°’t affect func-
tions in other files. (One exception: à function in another file that’s passed a
pointer to £ might be affected by changes to £. Fortunately, that situation is
easy to spot by examining the file in which £ is defined, since the function that
passes f must also be defined there.)

u Reduced “name space pollution.”” Since functions declared static have
internal linkage, their names can be reused in other files. Although we proba-

***************************page_490***************************
Table 18.1
Properties of Variables
and Parameters

18.2 Storage Classes 465

bly wouldn’t deliberately reuse à function name for some other purpose, it can
be hard to avoid in large programs. An excessive number of names with exter-
nal linkage can result in what C programmers call “name space pollution”:
names in different files accidentally conflicting with each other. Using
static helps prevent this problem.

Function parameters have the same properties as auto variables: automatic

storage duration, block scope. and no linkage. The only storage class that can be
specified for parameters is register.

Summary

Now that we’ve covered the various storage classes, let’s summarize what we
know. The following program fragment shows all possible ways to include—or
omit—storage classes in declarations of variables and parameters.

int

a;

extern int b;
static int C;

void f(int d, register int e)

(

auto int g;

int h;

static int i;
extern int j;
register int k;

}

Table 18.1 shows the properties of each variable and parameter in this example.

 

 

Name = Storage Duration — Scope … Linkage
a statuic file external
b stautic file ï
C static file internal
d automatic block none
e automatic block none
q automatic block none
h automatic block none
i Static block nNonc
j static block T
k automatic block none

 

 

 

"The definitions of b and j aren‘t shown, so it’s not
possible to determine the linkage of these variables. In
most cases, the variables will be defined in another file
and will have external linkage.

Of the four storage classes. the most important are static and extern.

auto has no effect. and modern compilers have made register less impor-

tant.

***************************page_491***************************
466

Chapter 18  Declarations

18.3
æ

restricted pointers » 17.8

e 1T

Type Qualifiers

There are two type qualifiers: const and volatile. (C99 has a third type qual-
ifier, restrict, which is used only with pointers.) Since the use of volatile
Is limited to low-level programming, TIl postpone discussing it until Section 20.3.
const is used to declare objects that resemble variables but are “read-only”: a
program may access the value of a const object, but can’t change it. For exam-
ple, the declaration

const int n = 10;
creates a const object named n whose value is 10. The declaration
const int tax brackets[] = {750, 2250, 3750, 5250, 7000};

creates a const array named tax_brackets.
Declaring an object to be const has several advantages:

m Îts à form of documentation: it alerts anyone reading the program to the read-
only nature of the object.

m The compiler can check that the program doesn’t inadvertently attempt to
change the value of the object.

m When programs are written for certain types of applications (embedded sys-
tems, in particular), the compiler can use the word const to identify data to
be stored in ROM (read-only memory).

At first glance, it might appear that const serves the same role as the
#define directive, which we’ve used in previous chapters to create names for
constants. There are significant differences between #define and const. how-
ever:

m We can use #define to create a name for a numerical, character, or string
constant. const can be used to create read-only objects of any type, including
arrays, pointers, structures. and unions.

u const objects are subject to the same scope rules as variables; constants cre-
ated using #define aren’{. In particular, we can*t use #define to create a
constant with block scope.

u The value of a const object, unlike the value of à macro, can be viewed in a
debusger.

u Unlike macros, const objects can’t be used in constant expressions. For
example, we can’t write

const int n = 10;
int afn]; /*** WRONG ***/

since array bounds must be constant expressions. (In C99, this example would

***************************page_492***************************
18.4

18.4  Declarators 467

be legal if à has automatic storage duration—iL would be treated as a variable-
length array—but not if it has static storage duration.)

u Îts legal to apply the address operator (&) to a const object, since it has an
address. À macro doesn't have an address.

There arè no absolute rules that dictate when to use #define and when to
use const. ! recommend using #define for constants that represent numbers or
characters. That way, you’Il be able to use the constants as array dimensions, in
switch statements, and in other places where constant expressions are required.

Declarators

A declarator consists of an identifier (the name of the variable or function being
declared), possibly preceded by the * symbol or followed by [] or (). By com-
bining *, [], and (). we can create declarators of mind-numbing complexity.

Before we look at the more complicated declarators, let's review the declara-
tors that we’ve seen in previous chapters. In the simplest case, a declarator is just
an identifier, like i in the following example:

int i;
Declarators may also contain the symbols *, []. and ():
m À declarator that begins with * represents a pointer:
int *p;
wm À ceclarator that ends with [] represents an array:
int a[10];

The brackets may be left empty if the array is a parameter, if it has an initial-
izer, or if its storage class is extern:

extern int a[];

Since a is defined elsewhere in the program, the compiler doesn't need to
know its length here. (In the case of a multidimensional array, only the first set
of brackets can be empty.) C99 provides two additional options for what goes
between the brackets in the declaration of an array parameter. One option 1s
the keyword static, followed by an expression that specifies the array’s
minimum length. The other is the * symbol, which can be used in a function
prototype to indicate a variable-length array argument. Section 9.3 discusses
both C99 features.

m À declarator that ends with () represents a function:
int abs(int i);

void swap(int *a, int *b);
int find _largest (int a[], int n);

***************************page_493***************************
468

Chapter 18  Declarations

C allows parameter names to be omitted in a function declaration:

int abs(int) ;
void swap(int *, int *);
int find largest (int [), int);

The parentheses can even be left empty:

int abs();
void swap () ;
int find largest () ;

The declarations in the last group specify the return types of the abs, swap,
and find_largest functions, but provide no information about their argu-
ments. Leaving the parentheses empty isn’t the same as putting the word
void between them, which indicates that thère are no arguments. The empty-
parentheses style of function declaration has largely disappeared. It’s inferior
Lo the prototype style introduced in C89, since it doesn*t allow the compiler to
check whether l'unction calls have the right areuments.

If all declarators were as simple as these, C programming would be a snap.
Unfortunately, declarators in actual programs often combine the *. []. and ()
notations. We've seen examples of such combinations already. We know that

int *ap (10] ;
declares an array of 10 pointers to integers. We know that
float *fp(float) ;

declares a function that has a float argument and returns a pointer to a float.
And, in Section 17.7, we learned that

void (*p£) (int);

declares a pointer to à function with an int argument and a void return type.

Deciphering Complex Declarations

So far, we haven*t had too much trouble understanding declarators. But what about
declarators like the one in the Ffollowing declaration?

int *(*x[10] ) (void) ;

This declarator combines *. [], and () . so it’s not obvious whether x is a pointer.
an array. or à function.

Fortunately, there are two simple rules that will allow us to understand any
declaration, no matter how convoluted:

# Always read declarators from the inside out. In other words, locate the identi-
fier that's being declared. and start deciphering the declaration from there.

***************************page_494***************************
184  Declarators 469

u When there’s a choice, always favor [) and () over *. If * precedes the
identifier and [] follows it, the identifier represents an array. not a pointer.
Likewise, if * precedes the identifier and () follows it, the identifier repre-
sents a function, not a pointer. (Of course, we can always use parentheses to
override the normal priority of [] and () over *.)

Let’s apply these rules to our simple examples first. In the declaration
int *ap [10] ;

the identifier is ap. Since * precedes ap and [] follows it. we give preference to
[] , s0 ap 1s an array of pointers. In the declaration

float *fp(float) ;

the identifier is £p. Since #* precedes £p and () follows 1it, we give preference to
() , s0 Ép 1s a function that returns a pointer.
The declaration

void (*pf) (int) ;

is a little trickier. Since *p£ 1s enclosed in parentheses, p£ must be a pointer, But
(*pf) is followed by (int), so p£ must point to a function with an int argu-
ment. The word void represents the return type of this function.

Âs the last example shows, understanding a complex declarator often involves
zigzagging from one side of the identifier to the other:

void (*p£) (int);

y Type of p£:

1\‘ 2 â $uîäËnïvith int argument
. 1n

—— 3. returning voi d

 

 

3

Let’s use this zigzagging technique to decipher the declaration given earlier:
int *(*x[10]) (void) ;

First, we locate the identifier being declared (x). We see that x 1s preceded by *
and followed by []; since [] have priority over *, we go right (x 1s an array).
Next, we go left to find out the type of the elements in the array (pointers). Next.
we go right to find out what kind of data the pointers point to (functions with no
arguments). Finally, we go left to see what each function returns (a pointer to an
int). Graphically, here’s what the process looks like:

int *(Îx[10])(void);

 

 

 

\\ Type of x:
e 1 1. array of

2. pointers to
/> 3 3. functions with no arguments
4 < 4. returning pointer to int

***************************page_495***************************
 

470

Chapter 18  Declarations

18.5

Mastering C declarations takes time and practice. The only good news is that
there are certain things that can’t be declared in C. Functions can*t return arrays:

int f(int) []; /*** WRONG ***/
Functions can’t return functions:

int g(int) (int) ; /*** WRONG ***/
Arrays of functions aren’t possible, either:
int a[10] (int) ; /*** WRONG ***/

In each case, we can use pointers to get the desired effect. À function can’t return an
array, but it can return a pointer to an array. À function can’t return a function, but
it can return a pointer to a function. Arrays of functions aren’t allowed, but an array
may contain pointers to functions. (Section 17.7 has an example of such an array.)

Using Type Definitions to Simplify Declarations

Some programmers use type definitions to help simplify complex declarations.
Consider the declaration of x that we examined earlier in this section:

int #(*x{[10] ) (void) ;

To make x’s type easier to understand. we could use the following series of type
definitions:

typedef int *#*Fcn (void) ;

typedef Fcen *Fcen ptr;

typedef Fcen ptr Fcon ptr array [10] ;
Fen _ptr array x;

IF we read these lines in reverse order, we see that x has type Fon _ptr _ array,a
Fon ptr array is an array of Fen _ptr values, a Fon ptr is a pointer lo
type Fon, and a Fen is a function that has no arguments and returns a pointer to an
int value.

Initializers

For convenience, C allows us to specify initial values for variables as we’re declar-
ing them. To initialize a variable, we write the = symbol after its declarator, then
follow that with an initializer. (Don't confuse the = symbol in a declaration with
the assignment operator: initialization isn’t the same as assignment.)

We’ve seen various kinds of initializers in previous chapters. The initializer
for a simple variable is an expression of the same type as the variable:

int i = 5 / 2; /* i is initially 2 */

***************************page_496***************************
conversion during assignment » 7.4

œ

designated initializers » 8.7, 16.1

185  Initializers 471

If the types don’t match, C converts the initializer using the same rules as for
assignment:

int j = 5.5; /* converted to 5 */

The initializer for a pointer variable must be a pointer expression of the same type
as the variable or of type void *:

int *p = K&i;

The initializer for an array, structure, or union 1s usually a series of values enclosed
in braces:

int a[5)] = ({1, 2, 3, 4, 5});

In C99., brace-enclosed initializers can have other forms. thankKs to designated ini-
tializers.

To complete our coverage of declarations, let's take a look at some additional
rules that govern initializers:

u Àn initializer for a variable with static storage duration must be constant:

#define FIRST 1
#define LAST 100

static int à = LAST - FIRST + 1;

Since LAST and FIRST are macros, the compiler can compute the initial
value of i (100 — 1 + 1 = 100). If LAST and FIRST had been variables, the
initializer would be illegal.

u Îf à variable has automatic storage duration, its initializer need not be con-
stant:

int f(int nD)

{

int last = n - 1;

}

u À brace-enclosed initializer for an array, structure, or union must contain only
constant expressions, never variables or function calls:

#define N 2
int powers[5] = {1, N, N #* N, N * N * N, N # N * N * N};

Since N is a constant, the initializer for powers 1s legal; 1f N were a variable,
the program wouldn't compile. In C99, this restriction applies only if the vari-
able has static storage duration.

u The initializer for an automatic structure or union can be another structure or
union:

***************************page_497***************************
472

Chapter 18  Declarations

calloc function » 177.3

18.6

void g(struct part partl)

(

struct part part2 = partl;

}

The initializer doesn't have to be à variable or parameter name, although it
does need to be an expression of the proper type. For example. part2's ini-
tializer could be #p, where p is of type struct part *, or f (part1),
where £ is a function that returns a part structure.

Uninitialized Variables

In previous chapters, we've implied that uninitialized variables have undefined val-
ues. That's not always true: the initial value of a variable depends on its storage
duration:

u Variables with auromatic storage duration have no default initial value. The
initial value of an automatic variable can*t be predicted and may be different
each time the variable comes into existence.

u Variables with sratic storage duration have the value zero by default. Unlike
memory allocated by calloc, which is ssimply set to zero bits, a static vari-
able 1s correctly initialized based on its type: integer variables are initialized to
O, floating variables are initialized to 0.0, and pointer variables contain a null
pointer.

Âs a matter of style, it?s better to provide initializers for static variables rather
than rely on the fact that they*re guaranteed to be zero. If a program accesses a
variable that hasn’t been initialized explicitly, someone reading the program later
can’t easily determine whether the variable is assumed to be zero or whether it’s
initialized by an assignment somewhere in the program.

Inline Functions (C99)

C99 function declarations have an additional option that doesn’t exist in C89: they
may contain the keyword inline. This keyword is a new breed of declaration
specifier. distinct from storage classes, type qualifiers. and type specifiers. To
understand the effect of inline, wel need to visualize the machine instructions
that are generated by a C compiler to handle the process of calling a function and
returning from a function.

At the machine level. several instructions may need to be executed to prepare
for the call. the call itself requires jumping to the first instruction in the function,
and there may be additional instructions executed by the function itself as it begins
to execute. If the function has arguments, they’Il need to be copied (because C
passes its arguments by value). Returning from a function requires a similar

***************************page_498***************************
parameterized macros » 14.3

186 Inline Functions (C99) 473

amount of effort on both the part of the f'unction that was called and the one that
called it. The cumulative work required to call a function and later return from it is
often referred to as “overhead’ since itl’s extra work above and beyond what the
function is really supposed to accomplish. Although the overhead of à function call
slows the program by only a tiny amount, it may add up in certain situations, such
as when a function is called millions or billions of times, when an older, slower
processor is in use (as might be the case in an embedded system), or when à pro-
gram has to meet very strict deadlines (as in a real-time system).

In C89. the only way to avoid the overhead of a l'unction call 1s to use à param-
eterized macro. Parameterized macros have certain drawbacks, though, C99 offers
a better solution to this problem: create an inline function. The word ‘inline” sug-
gests an implementation strategy in which the compiler replaces each call of the
function by the machine instructions for the function. This technique avoids the
usual overhead of a function call, although it may cause a minor increase in the
size of the compiled program.

Declaring a function to be inline doesn’t actually force the compiler to
“inline” the function. however, Tt merely suggests that the compiler should try to
make calls of the function as fast as possible, perhaps by performing an inline
expansion when the function is called. The compiler is free to ignore this sugges-
tion. In this respect. inline is similar to the register and restrict key-
words, which the compiler may use to improve the performance of a program but
may also choose to ignore.

Inline Definitions
An inline function has the keyword inline as one of its declaration specifiers:

inline double average (double a, double b)

(
}

Here’s where things get a bit complicated. average has external linkage, so other
source files may contain calls of average. However, the definition of average
isn*t considered to be an external definition by the compiler (it’s an inline defini-
tion instead). so attempting to call average from another file will be considered
an error.

There are two ways Lo avoid this error. One option 1s to add the word static
to the function definition:

return (a + b) / 2;

static inline double average (double a, double b)

{
}

average now has internal linkage. so it can’t be called from other files. Other
files may contain their own definitions of average, which might be the same as
this definition or might be different.

return (a + b) / 2;

***************************page_499***************************
474

Chapter 18  Declarations

The other option 1s to provide an external definition for average so that calls
are permitted from other files. One way to do this 1s to write the average func-
tion à second time (without using inline) and put the second definition in a dif-
ferent source file. Doing so 1s legal, but i1t’s not a good idea to have two versions of
the same function, because we can't guarantee that they'Il remain consistent when
the program 1s modified.

Here’s a better approach. First, we’Il put the inline definition of average in a
header file (let's name t average. h):

#ifndef AVERAGE H
#define AVERAGE H

inline double average (double a, double b)

{
}

#endif

return (a + b) / 2;

Next, we’ll create a matching source file, average. c:
#include "average.h"

extern double average (double a, double b) ;

Now, any file that needs to call the average function may simply include aver-
age .h, which contains the inline definition of average. The average.. c file
contains a prototype for average that uses the extern keyword, which causes
the definition of average included from average.h to be treated as an exter-
nal definition in average. c.

The general rule in C99 1s that If all top-level declarations of a function in a
particular file include inline but not extern, then the definition of the function
in that file 1s inline. If the function 1s used anywhere in the program (including the
file that contains its inline definition), then an external definition of the function
will need to be provided by some other file. When the function 1s called, the com-
piler may choose to perform an ordinary call (using the function’s external defini-
tion) or perform inline expansion (using the function’s inline definition). There’s no
way to tell which choice the compiler wil] make, so it’s crucial that the two defini-
tions be consistent. The technique that we just discussed (using the average.h
and average. c files) guarantees that the definitions are the same.

Restrictions on Inline Functions

Since inline functions are implemented in a way that’s quite different from ordi-
nary functions, they're subject to different rules and restrictions. Variables with
static storage duration are a particular problem for inline functions with external
linkage. Consequently, C99 imposes the following restrictions on an inline fune-
tion with external linkage (but not on one with internal linkage):

***************************page_500***************************
:{:Q=
æ
À:

compound literals > 9.3, 76.2

Q & À 415

u The function may not define a modifiable static variable.
u The function may not contain references to variables with internal linkage.

Such a function is allowed to define a variable that is both static and const,
but each inline definition of the function may create its own copy of the variable.

Using Inline Functions with GCC

Some compilers, including GCC, supported inline functions prior to the C99 stan-
dard. As a result, their rules for using inline functions may vary from the stan-
dard. In particular, the scheme described earlier (using the average.h and
average. c files) may not work with these compilers. Version 4.3 of GCC (not
available at the time this book was written) is expected to support inline func-
tions in the way described in the C99 standard.

Functions that are specified to be both static and inline should work
ne, regardless of the version of GCC. This strategy is legal in C99 as well, so it’s
the safest bet. À static inline function can be used within a single file or
placed in a header file and included into any source file that needs to call the func-
tion.

There’s another way to share an inline function among multiple files that
works with older versions of GCC but conflicts with C99. This technique involves
putting a definition of the function in a header file, specifying that the function is
both extern and inline, then including the header file into any source file that
contains à call of the function. À sécond copy of the definition—without the words
extern and inl ine—is placed in one of the source files. (That way, if the com-
piler is unable to “inline” the function for any reason, it will still have a definition.)

ÀA final note about GCC: Functions are ‘“inlined’’ only when optimization 1s
requested via the -O command-line option.

Q & À

Why are selection statements and iteration statements (and their ‘“inner”’
statements) considered to be blocks in C99? [p. 459]

This rather surprising rule stems from a problem that can occur when compound
literals are used in selection statements and iteration statements. The problem has
to do with the storage duration of compound literals, so let's take a moment to dis-
cuss that issue first.

The C99 standard states that the object represented by a compound literal has
static storage duration if the compound literal occurs outside the body of a func-
tion. Otherwise, it has automatic storage duration; as a result, the memory occu-
pied by the object is deallocated at the end of the block in which the compound
literal appears. Consider the following function, which returns a point structure
created using a compound literal:

***************************page_501***************************
476

Chapter 18  Declarations

struct point create point (int x, üint y)

{

return (struct point) {x, y};

}

This function works correctly, because the object created by the compound literal
will be copied when the function returns. The original object will no longer exist,
but the copy will remain. Now suppose that we change the function slightly:

struct point *create point (int x, int y)

(

return &(struct point) {x, y};

}

This version of create _ point suffers from undefined behavior, because it
returns a pointer to an object that has automatic storage duration and won°t exist
after the function returns.

Now let’s return to the question we started with: Why are selection statements
and iteration statements considered to be blocks? Consider the following example:

/* Example 1 - if statement without braces */

double *coefficients, value;

if (polynomial _selected == 1)
coefficients = (double[3]) (1.5, -3.0, 6.0};
else

coefficients = (double[3]) (4.5, 1.0, -3.5};
value = evaluate polynomial (coefficients) ;

This program fragment apparently behaves in the desired fashion (but read on).
coefficients will point to one of two objects created by compound literals.
and this object will still exist at the time evaluate polynomial is called.
Now consider what happens if we put braces around the “’inner” statements—the
ones controlled by the i £ statement:

/* Example 2 - if statement with braces */

double *coefficients, value;

if (polynomial selected == 1) {

coefficients = (double[3]) {1.5, -3.0, 6.0};
} else (

coefficients = (double[3]) ({(4.5, 1.0, -3.5};
}

value = evaluate polynomial (coefficients) ;

Now we're in trouble. Each compound literal causes an object to be created, but
that object exists only within the block formed by the braces that enclose the
statement in which the literal appears. By the time evaluate polynomial 1s
called, coefficients points to an object that no longer exists. The result:
undefined behavior.

***************************page_502***************************
> &

Q & À 477

The creators of C99 were unhappy with this state of affairs. because program-
mers were unlikely to expect that simply adding braces within an 1£ statement
would cause undefined behavior. To avoid the problem, they decided that the inner
statements would always be considered blocks. As a result, Example | and Exam-
ple 2 are equivalent. with both exhibiting undefined behavior.

À similar problem can arise when à compound literal 1s part of the controlling
expression of a selection statement or iteration statement. For this reason, each
entire selection statement and iteration statement is considered to be a block as
well (as though an invisible set of braces surrounds the entire statement). So, for
example, an if statement with an else clause consists of three blocks: each of
the two inner statements is a block, as 1s the entire 1 £ statement.

You said that storage for a variable with automatic storage duration is allo-
cated when the surrounding block is executed. Is this true for C99’s variable-
length arrays? [p. 460]

No. Storage for a variable-length array isn°t allocated at the beginning of the sur-
rounding block, because the length of the array isn’t yet known. Instead, it’s allo-
cated when the declaration of the array is reached during the execution of the
block. In this respect, variable-length arrays are different from all other automatic
variables.

What exactly is the difference between ““scope” and ““linkage”’? [p. 460]

Scope is for the benefit of the compiler, while linkage is for the benefit of the
linker. The compiler uses the scope of an identifier to determine whether or not it’s
legal to refer to the identifier at a given point in à file. When the compiler translates
a source file into object code, it notes which names have external linkage, eventu-
ally storing these names in a table inside the object file. Thus, the linker has access
to names with external linkage; names with internal linkage or no linkage are
invisible to the linker.

I don’t understand how a name could have block scope but external linkage.
Could you elaborate? [p. 463]

Certainly. Suppose that one source file defines a variable i:
int i;

Let’s assume that the definition of i lies outside any function, so i has external
linkage by default. In another file. there’s a function £ that needs to access i, so
the body of £ declares i as extern:

void f (void)

(

extern int i;

}

In the first file, i has file scope. Within £, however, 1 has block scope. If other
functions besides £ need access to i, they'Il need to declare it separately. (Or we

***************************page_503***************************
478

Chapter 18  Declarations

can simply move the declaration of i outside £ so that i has file scope.) What’s
confusing about this entire business is that each declaration or definition of i
establishes a different scope; sometimes it’s file scope, and sometimes it’s block
scope.

Why can’t const objects be used in constant expressions? const means
““constant” right? [p. 466]

In C, const means ‘’read-only,” not “constant.’ Let’s look at a few examples that
illustrate why const objects can’t be used in constant expressions.

To starl with, a const object might only be constant during 1its lifetime, not
throughout the execution of the program. Suppose that a const object is declared
inside a function:

void f (int n)

(

const int m = n / 2;

}

When £ 1s called. m will be initialized to the value of n / 2. The value of m will
then remain constant until £ returns. When £ 1s called the next time, m will likely
be given a different value. That’s where the problem arises. Suppose that m appears
in a switch statement:

void f (int n)

{

const int m = n / 2;
switch (…) {

case m: … /*** WRONG **+/

}

The value of m won’t be known until f is called. which violates C’s rule that the
values of case labels must be constant expressions.

Next, let’s look at const objects declared outside blocks. These objects have
external linkage and can be shared among files. Lf C allowed the use of const
objects in constant expressions, we could easily find ourselves in the following sit-
uation:

extern const int n;
int a[n]; /*** WRONG ***/

n is probably defined in another file. making it impossible for the compiler to
determine a’s length. (l'm assuming that à is an external variable, so it can’t be a
variable-length array.)

***************************page_504***************************
 

volatile type qualifier »20.3

Section 18.1

Section 18.2

@ 2.

Exercises 479

If that’s not enough to convince you, consider this: If a const object is also
declared to be volatile, its value may change at any time during execution.
Here’s an example from the C standard:

extern const volatile int real time _ clock;

The real time clock variable may not be changed by the program (because
il’s declared const), yel its value may change via some other mechanism
(because il’s declared volatile).

Why is the syntax of declarators so odd?

Declarations are intended to mimic use. À pointer declarator has the form *p.
which matches the way the indirection operator will later be applied to p. An array
declarator has the form a [...] . which matches the way the array will later be sub-
scripted. À function declarator has the form £ (… ) . which matches the syntax of a
function call. This reasoning extends to even the most complicated declarators.
Consider the £ile cmd array of Section 17.7, whose elements are pointers to
functions. The declarator for £ile cmd has the form

(*file _cmd[]) (void)
and a call of one of the functions has the form
(*file cmd[n]) () ;

The parentheses, brackets, and * are in identical positions.

Exercises

For each of the following declarations, identify the storage class, type qualifiers, type speci-
fiers, declarators, and initializers.

(a) static char **lookup (int level) ;

(b) volatile unsigned long io flags;

(c) extern char *file name [MAX FILES), path[] ;

(d) static const char token bu£f[] = "";

Answer each of the following questions with auto. extern. register. and/or
static.

(a) Which storage class is used primarily to indicate that a variable or function can be
shared by several files”

(b) Suppose that a variable x 1s to be shared by several functions in one file but hidden from
functions in other files. Which storage class should x be declared to have?

(c) Which storage classes can affcet the storage duration of u variable?

List the storage duration (static or automatic), scope (block or file), and linkage (internal,
external, or nonc) of each vartable and parameter in the following file:

***************************page_505***************************
480 Chapter 18  Declarations

Section 18.3

Section 18.4

L à

6.

T.

@ s.

@ 10.

extern float a;

void f (register double b)

(

static int C;
auto char d;

}

Let £ be the following f'unction. What will be the value of £ (10) 1f £ has never been called
before? What will be the value of £ (10) 1f £ has been called Live times previously?

int f(int i)
static int y = O;
return i * j++;

}

State whether each of the following statements is true or faise. Justify cach answer.
(a) Every variable with static storage duration has file scope.

(b) Every variable declared inside à function has no linkage.

(c) Every variable with internal linkage has static storage duration.

(d) Every parameter has block scope.

The following function is supposed to print an error message. Each message is prececled by
an integer, indicating the number of times the function has been called. Unfortunately. the
function always displays ! as the number of the error message. [Locate the error and show
how to fix it without making any changes outside the function.

void print error(const char *message)

{

int n = 1;
print£f ("Error %d: %s\n", n++, message) ;

}

Suppose that we declare x to be a const object. Which one of the following statements
about x 1s false”

(a) If x is of type int, it can be used as the value of a case label in a switch statement.
(b) The compiler will check that no assignment is made to x.

(c) x is subject to the same scope rules as variables.,

(d) x can be of any type.

Write a complete description of the type of x as specified by each of the following declara-
tions.

(a) char (*x[10]) (int) ;

(b) int (*x(int)) [5] ;

(c) float * (*x(void) ) (int) ;

(d) void (*x(int, void (*y) (int))) (int) ;

Use à series of type definitions to simplify each of the declarations in Exercise 8.

Write declarations for the following variables and functions:

(a) p is a pointer to u function with a character pointer argument that returns a character
pointer.

***************************page_506***************************
Section 18.5

l1.

#12

® 13.

14.

@ 15.

Exercises 481

(b) £ is a function with two arguments: p. à pointer to a structure with tag t, and n, a long
integer. £ returns a pointer to à function that has no arguments and returns nothing.

(c) a is an array of four pointers to functions that have no arguments and return nothing.
The elements of à initially point to functions named insert, search, update, and
print.

(d) b is an array of 10 pointers to functions with two int arguments that return structures
with tag t.

In Section 18.4, we saw that the following declarations are illegal:

int f (int) [] ; /* functions can't return arrays */
int g(int) (int) ; /* functions can't return functions */
int a(10] (ant) ; /* array elements can't be functions */

We can, however, achieve similar effects by using pointers: à function can return a pointer to
the first clement in an array, a function can return a pointer to a function, and the elements
of an array can bc pointers to functions. Revise each of these declarations accordingly.

(a) Write a complete description of the type of the function £. assuming that it’s declared as
follows:

int (*f(float (*) (long), char *)) (double) ;

(b) Give an example showing how £ would be called.

Which of the following declarations are legal? (Assume that PI 1S à macro that represents
3.14159.)

(a) char c 65;

(b) static int i = 5, j = i * i;

(c) double d = 2 * PI;

(d) double angles[] = {o, PI / 2, PI, 3 # PI / 2};

Which kind of variables cannot be initialized?
(a) Array variables

(b) Enumeration variables

(c) Structure variables

(d) Union variables

(e) None of the above

Which property of à variable determines whether or not it has a default initial value?
(a) Storage duration

(b) Scope

(c) Linkage

(d) Type

***************************page_507***************************

***************************page_508***************************
19

eF3

Program Design

Wherever there is modularity there is the potential for misunderstanding:
Hiding information implies a need to check communication.

It’s obvious that real-world programs are larger than the examples in this book, but
you may not realize just how much larger. Faster CPUs and larger main memories
have made it possible Lo write programs that would have been impractical just a
few years ago. The popularity of graphical user interfaces has added greatly to the
average length of a program. Most full-featured programs today are at least
100,000 lines long. Million-line programs are commonplace, and it’s not unheard-
of for a program to have 10 million lines or more.

Although C wasn’t designed for writing large programs, many large programs
have in fact been written in C, Its tricky, and it requires a great deal of care, but it
can be done. In this chapter. l'Il discuss techniques that have proved to be helpful
for writing large programs and show which C features (the static storage class,
for example) are especially useful.

Writing large programs (often called “programming-in-the-large") is quite dif-
ferent from writing small ones—it's like the difference between writing a term
paper (10 pages double-spaced, of course) and a 1000-page book. À large program
requires more attention to style, since many people will be working on it. It
requires careful documentation. [t requires planning for maintenance, since it will
likely be modified many times.

Above all, a large program requires careful design and much more planning
than a small program. As Alan Kay, the designer of the Smalltalk programming
language, puts it, “You can build a doghouse out of anything.” À doghouse can be
built without any particular design, using whatever materials are at hand. À house
for humans, on the other hand. is too complex to just throw together.

Chapter 15 discussed writing large programs in C, but it concentrated on lan-
guage details. In this chapter. we'll revisit the topic, this time focusing on tech-
niques for good program design. À complete discussion of program design issues
is obviously beyond the scope of this book. However, l'Il try to cover—briefly—

483

***************************page_509***************************
484

Chapter 19 Program Design

19.1

some important concepts in program design and show how to use them to create C
programs that are readable and maintatnable.

Section 19.1 discusses how to view a C program as a collection of modules
that provide services to each other. We”1I then see how the concepts of information
hiding (Section 19.2) and abstract data types (Section 19.3) can improve modules.
By focusing on a single example (a stack data type), Section 19.4 illustrates how
an abstract data type can be defined and implemented in C. Section 19.5 describes
some limitations of C for defining abstract data types and shows how to work
around them.

Modules

When designing a C program (or a program in any other language, For that matter).
ils often useful to view it as a number of indépendent modules. À module is a col-
lection of services, some of which are made available to other parts of the program
(the clients). Each module has an interface that describes the available services.
The details of the module—including the source code for the services them-
selves—are stored in the module’s implementation.

In the context of C, “services” are functions. The interface of à module is a
header file containing prototypes for the functions that will be made available to
clients (source files). The implementation of a module is a source file that contains
definitions of the module’s functions.

To illustrate this terminology, let’s look at the calculator program that was
sketched in Sections 15.1 and 15.2. This program consists of the file calc.c.
which contains the main function, and a stack module. which is stored in the files
stack.h and stack. c (see the figure at the top of the next page). calc.c is a
client of the stack module. stack.h is the inrerface of the stack module: it sup-
plies everything the client needs to know about the module. stack.c is the
inplementation of the module; it contains definitions of the stack functions as well
as declarations of the variables that make up the stack.

The C library is itself a collection of modules. Each header in the library
serves as the interface to a module. <stdio.h>. for example, is the interface lo a
module containing I/O functions, while <string. h> is the interface to a module
containing string-handling functions.

Dividing a program into modules has several advantages:

u Abstraction. Tf modules are properly designed, we can treat them as abstrac-
tions, we know what they do, but we don’t worry about the details of how
they do it. Thanks to abstraction, it’s not necessary to understand how the
entire program works in order to make changes lo one part of it. What's more,
abstraction makes it easier for several members of a team to work on the
same program. Once the interfaces for the modules have been agreed upon.
the responsibility for implementing each module can be delegated to a partic-

***************************page_510***************************
19.1 Modules 485

 

#include <stdbool.h>

void make empty (void) ;
bool is_empty (void) ;
bool is f£ull (void) ;
void push(int i);

int pop (void) ;

 

 

///’ stack.h ‘\\

 

 

t/ 4
#include "stack.h" #include "stack.h"
int main(void) int contents [100] ;
{ int top = 0;

make empty () ;

void make_empty (void)

{ …. }

bool is empty (void)
calc.c {

 

 

bool is_full (void)

{ … }

void push(int i)

}

int pop (void)
[}

 

 

stack.c

ular person. Team members can then work largely independently of one
another.

u Reusability. Any module that provides services 1s potentially reusable in other
programs. Our stack module, for example, is reusable. Since it’s often hard to
anticipate the future uses of a module, it’s a good idea to design modules for
reusability.

u Maintainability. À small bug will usually affect only a single module imple-
mentation. making the bug easier to locate and fix. Once the bug has been
fixed, rebuilding the program requires only a recompilation of the module
implementation (followed by linking the entire program). On a larger scale.
we could replace an entire module implementation, perhaps to improve per-
formance or when transporting the program to a different platform.

Although all these advantages are important, maintainability is the most criti-
cal. Most real-world programs are in service over a period of years, during which
bugs are discovered, enhancements are made, and modifications are made to meet
changing requirements. Designing à program in a modular fashion makes mainte-
nance much easier. Maintaining a program should be like maintaining a car—fixing
à flat tire shouldn’t require overhauling the engine.

***************************page_511***************************
486 Chapter 19 Program Design

<float .h> header >23.7
<limits.h>header >23.2

For an example, we need look no further than the inventory program of
Chapters 16 and !7. The original program (Section 16.3) stored part records in an
array. Suppose that, after using this program for a while, the customer objects to
having a fixed limit on the number of parts that can be stored. To satisfy the cus-
tomer, we might switch to a linked list (as we did in Section 17.5). Making this
change required going through the entire program, looking for all places that
depend on the way parts are stored. If we'd designed the program differently in the
first place—with a separate module dealing with part storage—we would have
only needed to rewrite the implementation of that module, not the entire program.

Once we’re convinced that modular design is the way to go, the process of
designing a program boils down to deciding what modules it should have. what
services each module should provide. and how the modules should be interrelated.
We'll now look at these issues briefly. For more information about design. consult
a software engineering text, such as Fundamentals of Software Engineering, Sec-
ond Edition, by Ghezzi, Jazayeri, and Mandrioli (Upper Saddle River, N.J.: Pren-
tice-Hall. 2003).

Cohesion and Coupling

Good module interfaces aren't random collections of declarations. In a well-
designed program, modules should have two properties:

u High cohesion. The elements of each module should be closely related to one
another; we might think of them as cooperating toward a common goal. High
cohesion makes modules easier to use and makes the entire program casier to
understand.

= Low coupling. Modules should be as independent of each other as possible.
Low coupling makes it easier to modify the program and reuse modules.

Does the calculator program have these properties? The stack module 1s
clearly cohesive: its functions represent operalions on a stack. There’s little cou-
pling in the program. The calc.c file depends on stack.h (and stack.c
depends on stack .. h, of course), but there are no other apparent dependencies.

Types of Modules

Because of the need for high cohesion and low coupling, modules tend to fall into
certain typical categories:

u À data pool is a collection of related variables and/or constants. In C, à mod-
ule of this type 1s often just a header file. From a design standpoint, putting
variables in header files isn’{ usually « good idea, but collecting related con-
stants in a header file can often be useful. In the C library, <float .h> and
<limits .h> are both data pools.

w À library is a collection of related functions. The <string.h> header, for
example, 1s the interface to a library of string-handline functions.

***************************page_512***************************
19.2

static storage class > 18.2

192 Information Hiding 487

= An abstract object is a collection of functions that operate on a hidden data
structure. (In this chapter, the term ‘’object” has a different meaning than in
the rest of the book. In C terminology, an object is simply a block of mem-
ory that can store a value. In this chapter, however, an object is a collection
of data bundled with operations on the data. If the data is hidden, the object
is “abstract”’) The stack module we’ve been discussing belongs to this cate-
gory.

= An abstract data type (ADT) is a type whose representation is hidden. Client
modules can use the type to declare variables, but have no knowledge of the
structure of those variables. For a client module to perform an operation on
such a variable, it must call a function provided by the abstract data type mod-
ule. Abstract data types play a significant role in modern programming:; wel
return to them in Sections 19.3-19.5.

Information Hiding

À well-designed module often keeps some information secret from its clients. Cli-
ents of our stack module, for example, have no need to know whether the stack 1s
stored in an array, in a linked list, or in some other form. Deliberately concealing
information from the clients of a module is known as information hiding. Infor-
mation hiding has two primary advantages:

w Security. 1f clients don’t know how the stack is stored, they won't be able to
corrupt it by tampering with its internal workings. To perform operations on
the stack, they'll have to call functions that are provided by the module
itsel!—functions that we’ve written and tested.

u Flexibility. Making changes—no matter how large—to a module’s internal
workings won’t be difficult. For example, we could implement the stack as
an array at first, then later switch to a linked list or other representation.
We’ll have to rewrite the implementation of the module, of course, but—if
the module was designed properly—we won’t have to alter the module’s
interface.

In C, the major tool for enforcing information hiding is the static storage
class. Declaring a variable with file scope to be static gives it internal linkage,
thus preventing it from being accessed from other files, including clients of the
module. (Declaring a function to be static is also useful—the function can be
directly called only by other functions in the same file.)

A Stack Module

To see the benefits of information hiding. let’s look at two implementations of a
stack module, one using an array and the other à linked list. The module’s header
file wilt have the following appearance:

***************************page_513***************************
488

w>

Chapter 19 Program Design

stack.h

stack1.c

fifndef STACK H
fdefine STACK H

#include <stdbool .h> /* C99 only */

void make_empty (void) ;
bool is _ empty (void) ;
bool is full (void) ;
void push(int i);

int pop (void) ;

#endif

l’ve included C99's <stdbool .h> header so that the is _ emptyand iis full
functions can return a bool result rather than an int value.
Let’s first use an array to implement the stack:

#include <stdio.h>
#include <stdlib.h>
#Hinclude "stack.h"

#define STACK SIZE 100

static int contents [STACK SIZE] ;
static int top = O0;

static void terminate (const char *message)

{

printf("%s\n"', message) ;
exit (EXIT FAILURE) ;

}

void make _ empty (void)

{
}

bool is empty (void)

{
}

bool is full (void)

{
}

void push(int i)

(

top = 0;

return top == D0;

return top == STACK SIZE;

if (is full())
terminate ("Error in push: stack is full.");
contents [top++] = i;

}

***************************page_514***************************
stack2.c

19.2 |Information Hiding 489

int pop (void)

{
if (is empty())
terminate ("Error in pop: stack is empty.") ;
return contents [--top] ;

}

The variables that make up the stack (contents and top) are both declared
static, since there’s no reason for the rest of the program to access them
directly. The terminate function is also declared static. This function isn°t
part of the module’s interface; instead, il’‘s designed for use solely within the
implementation of the module.

Âs a matter of style, some programmers use macros to indicate which func-
tions and variables are ““public” (accessible elsewhere in the program) and which
are “private” (limited to a single file):

#define PUBLIC /* empty */
#define PRIVATE static

The reason for writing PRIVATE instead of static is that the latter has more
than one usc in C: PRIVATE makes it clear that we*re using it to enforce informa-
tion hiding. Here’s what the stack implementation would look like if we were to
use PUBLIC and PRIVATE:

PRIVATE int contents [STACK SIZE] ;
PRIVATE int top = OD;

PRIVATE void terminate (const char *message) { … }
PUBLIC void make empty(void) { … }
PUBLIC bool is empty(void) { … }
PUBLIC bool is full(void) { … }
PUBLIC void push(int i) { … }
PUBLIC int pop(void) { … }
Now we’ll switch to a linked-list implementation of the stack module:
#finclude <stdio.h>
finclude <stdlib.h>
#include "stack.h"
struct node (

int data;
struct node *next;

}

static struct node *top = NULL;

***************************page_515***************************
490

Chapter 19

Program Design

static void terminate (const char *message)

{

printf("%s\n"', message) ;
exit (EXIT FAILURE) ;

}

void make_empty (void)

{

while (!is empty())
, pop () ;

bool is empty (void)

{

return top == NULL;

}

bool is full (void)

{

return f£alse;

}

void push(int i)

{

struct node *new_node = malloc (sizeof (struct node) ) ;
if (new node == NULL)
terminate ("Error in push: stack is full.") ;

new _node->data = i;
new _node->next = top;
top = new _ node;

}

int pop(void)

{

struct node *old top;
int i;

i£ (is empty())
terminate ("Error in pop: stack is empty. ") ;

old top = top;

i = Eop->data;
top = top->next;
free (old_top) ;
return i;

}

Note that the is £ull function retums false every time it’s called. À linked
list has no limit on its size, so the stack will never be full. Is possible (but not
likely) that the program might run out of memory, which will cause the push
function to fail, but there’s no easy way to test for that condition in advance.

Our stack example shows clearly the advantage of information hiding: it

***************************page_516***************************
19.3

 

 

19.3  Abstract Data Types 491

doesn’t matter whether we use stack1.c or stack2. c to implement the stack
module. Both versions match the module’s interface, so we cun switch from one to
the other without having to make changes elsewhere in the program.

Abstract Data Types

À module that serves as an abstract object, like the stack module in the previous
section, has a serious disadvantage: there’s no way to have multiple instances of
the object (more than one stack, in this case). To accomplish this, we’Il need to go
à step further and create a new rype.

Once we've defined a Stack type, we'I be able to have as many stacks as we
want. The following fragment illustrates how we could have two stacks in the same
programn:

Stack s1, s2;

make_empty (&s1l) ;
make empty (&s2) ;
push(&s1, 1);
push(&s2, 2);
if (!is empty(&s1))
print£ ("*d\n"', pop(&s1l)) ; /* prints "1" */

We're not really sure what s1 and s2 are (structures? pointers?). but it doesn*t
matter. To clients, s1 and s2 are abstractions that respond to certain operations
(make_empty, is empty, is full. push, and pop).

Let's convert our stack.h header so that it provides a Stack type. where
Stack is a structure. Doing so will require adding a Stack (or Stack *) param-
eter to each function. The header will now look like this (changes to stack .h are
in bold; unchanged portions of the header aren’t shown):

#define STACK SIZE 100

typedef struct {
int contents [STACK SIZE] ;
int top;

} Stack;

void make empty (Stack *s) ;
bool is _ empty (const Stack *s) ;
bool is full (const Stack *s) ;
void push(Stack *s, int i);
int pop(Stack *s) ;

The stack parameters to make _ empty, push, and pop need to be pointers, since
these functions modify the stack. The parameter to is_empty and is full
doesn't need to be a pointer, but l’ve made it one anyway. Passing these functions a
Stack pointer instead of a Stack value is more efficient, since the latter would
result in à structure being copied.

***************************page_517***************************
492

Chapter 19 Program Design

Qa&Â

Qa&ÂÀ

Encapsulation

Unfortunately, Stack isn’t an abstract data type, since stack.h reveals what
the Stack type really is. Nothing prevents clients from using a Stack variable as
à structure:

Stack s1;

sl.top = 0;
sl.contents [top++] = 1;

Providing access to the top and contents members allows clients to corrupt the
stack. Worse still. we won’t be able to change the way stacks are stored without
having to assess the effect of the change on clients.

What we need is a way to prevent clients from knowing how the Stack lype
iS represented. C has only limited support for encapsulating types in this way.
Newer C-based languages, including C++, Java, and C#, are better equipped for
this purpose.

Incomplete Types

The only tool that C gives us for encapsulation is the incomplete type. (Incomplete
types were mentioned briefly in Section 17.9 and in the Q&A section at the end of
Chapter 17.) The C standard describes incomplete types as ‘’types that describe
objects but lack information needed to determine their sizes.” For example, the
declaration

struct t; /* incomplete declaration of t */

tells the compiler that t is a structure tag but doesn't describe the members of the
structure. Às a result, the compiler doesn*t have enough information to determine
the size of such a structure. The intent is that an incomplete type will be completed
elsewhere in the program.

Âs long as a type remains incomplete, its uses are limited. Since the compiler
doesn’t know the size of an incomplete type, it can’t be used to declare a variable:

struct t s; /*** WRONG #***/

However, it's perfectly legal to define a pointer type that references an incomplete
type:
typedef struct t *T;

This type definition states that a variable of type T is a pointer to a structure with
lag t. We can now declare variables of type T. pass them as arguments to func-
tions, and perform other operations that are legal for pointers. (The size of a
pointer doesn'{ depend on what it points to, which explains why C allows this
behavior.) What we can*t do. though, is apply the - > operator to one of these vari-
ables, since the compiler knows nothing about the members of a t structure.

***************************page_518***************************
19.4

stackADT.h
(version 1)

194 A Stack Abstracit Daia Type 493

A Stack Abstract Data Type

To illustrate how abstract data types can be encapsulated using incomplete types,
we'1l develop a stack ADT based on the stack module described in Section 19.2. In
the process, we‘Il explore three different ways to implement the stack.

Defining the Interface for the Stack ADT

First, we‘1! need a header file that defines our stack ADT type and gives prototypes
for the functions that represent stack operations. Let’s name this file stack-
ADT .h. The Stack type will be à pointer to a stack_type structure that stores
the actual contents of the stack. This structure is an incomplete type that will be
completed in the file that implements the stack. The members of this structure will
depend on how the stack is implemented. Herc’s what the stackADT . h fîle will
look like:

#ifndef STACKADT H
#define STACKADT H

#include <stdbool .h> /* c99 only */
typedef struct stack type *Stack;

Stack create (void) ;

void destroy (Stack s) ;
void make empty ((Stack s) ;
bool is empty (Stack s) ;
bool is full (Stack s) ;
void push(Stack s, int i);
int pop(Stack s) ;

#endif

Clients that include stackADT.h will be able to declare variables of type
Stack, each of which is capable of pointing to a stack_type structure. Clients
can then call the functions declared in stackADT.h to perform operations on
stack variables. However, clients can’t access the members of the stack_type
structure, since that structure will be defined in à separate file.

Note that each function has a Stack parameter or returns a Stack value.
The stack functions in Section 19.3 had parameters of type Stack *. The rea-
son for the difference is that a Stack variable is now a pointer; it points to a
stack type structure that stores the contents of the stack, If a function needs
to modify the stack, it changes the structure itself, not the pointer to the struc-
ture.

Also note the presence of the create and destroy functions. À module

***************************page_519***************************
494

Chapter 19  Program Design

stacKclient.c

generally doesn’t need these functions, but an ADT does. create will dynami-
cally allocate memory for a stack (including the memory required for a
stack_type structure), as well as initializing the stack to its “empty” state.
destroy will release the stack’s dynamically allocated memory.

The following client file can be used to test the stack ADT. It creates two
stacks and performs a variety of operations on them.

#include <stdio.hs>
#include "stackADT.h"

int main (void)
Stack s1l, s2;
int n;

sl = create();
s2 = create();

push(s1i, 1);
push(s1, 2);

n = pop(s1);
print£f ("Popped %d £rom sl\n", n);
push(s2, n) ;
n = pop(si);
print£ ("Popped %$d from si\n", n) ;
push(s2, n) ;

destroy (s1) ;

while (!is empty(s2))
print£ ("Popped %$d from s2\n", pop(s2));

push(s2, 3);
make _empty (s2) ;
if (is empty(s2))
printf("s2 is empty\n") ;
else
printf ("s2 is not empty\n") ;

destroy (s2) ;

return 0;

}

If the stack ADT is implemented correctly. the program should produce the follow-
ing output:

Popped 2 from sl
Popped 1 f£from sl
Popped 1 from s2
Popped 2 £rom s2
s2 is empty

***************************page_520***************************
stackADT.c

194 ÀA Stitack Abstract Daita Type 495

Implementing the Stack ADT Using a Fixed-Length Array

There are several ways to implement the stack ADT. Our first approach 1s the sim-

plest. We*Il have the stackADT. c file define the stack_type structure so thal
it contains a fixed-length array (to hold the contents of the stack) along with an
integer that keeps track of the top of the stack:

struct stack type Ç
int contents [STACK SIZE] ;
int top;

}
Here’s what stackADT. c will look like:

#include <stdio.h>
#include <stdlib.h>
#include "stackADT.h"

#define STACK SIZE 100

struct stack _ type {
int contents (STACK SIZE] ;

int top;
static void terminate (const char *message)

printf ("$s\n", message) ;
exit (EXIT FAILURE) ;

}

Stack create (void)

{

Stack s = malloc(sizeof (struct stack_type));
if (s == NULL)
terminate ("Error in create: stack could not be created.") ;
s->top = O0;
return s;

}

void destroy (Stack s)

(

£ree (s) ;

}

void make empty (Stack s)

(

s->top = Q0;

Î

bool is empty(Stack s)

(

return s->top == D0;

}

***************************page_521***************************
496

Chapter 19  Program Design

stackADT.h
(version 2)

bool is full(Stack s)

{

return s->top == STACK SIZE;

}

void push(Stack s, int i)

{

iÉ (is full(s))
terminate("Error in push: stack is full.");
S->contents [s->top++] = i;

}

int pop(Stack s)

if (is empty(s))
terminate ("Error in pop: stack is empty.");
return s->contents [--s->top)] ;

}

The most striking thing about the l'unctions in this file is that they use the -> oper-
ator, not the . operator, to access the contents and top members of the
stack_type structure. The s parameter is a pointer to a stack _ type struc-
ture, not a structure itself, so using the . operator would be illegal.

Changing the Item Type in the Stack ADT

Now that we have a working version of the stack ADT, let’s try to improve it. First,
note that items in the stack must be integers. That's too restrictive: in fact, the item
type doesn't really matter. The stack items could just as easily be other basic types
(Eloat, double, lonc. etc.) or even structures, unions, or pointers, for that
matter.

To make the stack ADT easier to modify for different item types, let‘s add a
lype definition to the stackADT.h header. It will define a type named Item,
representing the type of data to be stored on the stack.

#ifndef STACKADT H
#define STACKADT H

#include <stdbool.h> /* C99 only */
typedef int Item;
typede£f struct stack type *Stack;

Stack create (void) ;

void destroy (Stack s) ;
void make_empty (Stack s) ;
bool is empty (Stack s) ;
bool is full(Stack s) ;

***************************page_522***************************
dynamically allocated arrays » 17.3

194 A Stack Abstract Daia Type 497

void push(Stack s, Item i);
Item pop (Stack s) ;

tendif

The changes to the file are shown in bold. Besides the addition of the Item type,
the push and pop functions have been modified. push now has a parameter of
type Item, and pop returns a value of type Item. We'll use this version of
stackADT .h from now on: it replaces the earlier version.

The stackADT. c file will need to be modified to match the new stack-
ADT . h. The changes are minimal, however. The stack_type structure will now
contain an array whose elements have type Item instead of int:

struct stack type {
Item contents [STACK SIZE] ;
int top;

}

The only other changes are to push (the second parameter now has type Item)
and pop (which returns a value of type Item). The bodies of push and pop are
unchanged.

The stackclient. c file can be used to test the new stackADT.h and
stackADT. c to verify that the Stack type still works (it does!). Now we can
change the item type any time we want by simply modifying the definition of the
Item type in stackADT.h. (Although we won't have to change the stack-
ADT. c file, we'Il still need to recompile 1it.)

Implementing the Stack ADT Using a Dynamic Array

Another problem with the stack ADT as it currently stands is that each stack has à
fixed _maximum size, which is currently set at 100 items. This limit can be
incrensed to any number we wish. of course. but all stacks created using the
Stack type will have the same limit. There’s no way to have stacks with different
capacities or to set the stack size as the program 1s running.

There are two solutions to this problem. One is to implement the stack as a
linked list, in which case there’s no fixed limit on its size. We'Il investigate this
solution in a moment. First, though, let's try the other approach. which involves
storing stack items in a dynamically allocated array.

“ The crux of the latter approach is to modify the stack_type structure so
that the contents member is à pointer to the array in which the items are stored.
not the array itself:

struct stack type {
Item *contents ;
int top;
int size;

}7

***************************page_523***************************
498 Chapter 19 Program Design

l’ve also added a new member. size, that stores the stack’s maximum size (the
length of the array that contents points to). We*Il use this member to check for
the ‘“stack full” condition.

The create function will now have a parameter that specifies the desired
maximum stack size:

Stack create (int size) ;

When create is called, it will create a stack_type structure plus an array of
length size. The contents member of the structure will point to this array.

The stackADT.h file will be the same as before, except that we'I! need to
add a size parameter to the create function. (Let's name the new version
stackADT2 .h.) The stackADT. c file will need more extensive modification,
however. The new version appears below, with changes shown in bold.

stackADT2.c #include <stdio.h>
#include <stdlib.h>
#finclude "stackADT2 .h"

struct stack type Ç
Item *contents;
int top;
int size;

}

static void terminate (const char *message)
print£("3s\n", message) ;
exit (EXIT FAILURE) ;

}

Stack create (int size)
{
Stack s = malloc(sizeof (struct stack type)) ;
if (s == NULL)
terminate ("Error in create: stack could not be created.") ;
s->contents = malloc(size * sizeof (Item) ) ;
if (s->contents == NULL) {
£ree (s) ;
terminate ("Error in create: stack could not be created.") ;
}
S->top = 0;
S->size = size;
return s;

}

void destroy (Stack s)

(

free (s->contents) ;
Éree (s) ;

}

***************************page_524***************************
 

194 À Stack Abstract Data Type 499

void make empty(Stack s)

(
;

bool is empty (Stack s)

(

s->top = Q0;

return s->top == OD;
}
bool is full (Stack s)
{

return s->top == s->size;
}
void push(Stack s, Item i)
{

if (is full(s))
terminate ("Error in push: stack is full.");
s->contents [s->top++] = i;

}

Item pop(Stack s)

{
if (is empty(s))
terminate ("Error in pop: stack is empty.") ;
return s->contents [--s->top] ;
}

The create function now calls malloc twice: once to allocate a stack _ type
structure and once to allocate the array that will contain the stack items. Either call
of malloc could fail, causing terminate to be called. The destroy function
must call £ree twice to release all the memory allocated by create.

The stackclient . c file can again be used to test the stack ADT. The calls
of create will need to be changed. however. since create now requires an
argument. For example, we could replace the statements

sl = create();
s2 = Create()

’

with the following statements:

sl = create (100) ;
s2 = create(200) ;

Implementing the Stack ADT Using a Linked List

Implementing the stack ADT using a dynamically allocated array gives us more
Mexibility than using a fixed-size array. However, the client 1s still required to spec-
ify a maximum size for a stack at the time 1t’s created. If we use à linked-list imple-
mentation instead, there won’t be any preset limit on the size of a stack.

***************************page_525***************************
500

Chapter 19  Program Design

stackADT3.c

Our implementation will be similar to the one in the stack2. c file of Sec-
tion 19.2. The linked list will consist of nodes, represented by the following struc-
ture:

struct node {
Item data;
struct node *next,;

} ;

The type of the data member is now Item rather than int. but the structure is
otherwise the same as before.
The stack_type structure will contain a pointer to the first node in the list:

struct stack type |{
struct node *top;

} ;

ÀL first glance. the stack type structure seems superfluous; we could just
dcfine Stack to be struct node * and let a Stack value be a pointer to the
first node in the list. However, we still need the stack _ type structure so that
the interface to the stack remains unchanged. (1f we did away with it. any func-
tlon that modified the stack would need a Stack * parameter instead of a
Stack parameter.) Moreover, having the stack _ type structure will make it
easier to change the implementation in the future, should we decide to store addi-
tional information. For example, if we later decide that the stack type struc-
ture should contain a count of how many items are currently stored in the stack,
we can easily add a member to the stack_type struclure to store this informa-
tion.

We won't need to make any changes to the stackADT.h header. (We'll
use this header file, not stackADT2 .h.) We can also use the original stack-
client .c file for testing. All the changes will be in the stackADT. c file.
Here’s the new version:

#include <stdio.h>
#include <stdlib.h>
#finclude "stackADT .h"

struct node {
Item data;
struct node *next;

}

struct stack type {
struct node *top;

}

static void terminate (const char *message)

{

print£("%s\n"', message) ;
exit (EXIT _ FAILURE) ;

)

***************************page_526***************************
194 À Stack Abstract Data Type 501

Stack create (void)
{
Stack s = malloc(sizeof (struct stack type));
if (s == NULL)
terminate ("Error in create: stack could not be created. ") ;
S->top = NULL;
return s;

;

void destroy (Stack s)

(

make empty(s) ;
£ree (s) ;

}

void make empty (Stack s)

(

while (!is empty(s))
pop(s) ;

bool is empty (Stack s)

{

return s->top == NULL;

}

bool is full (Stack s)

{

return false;

}

void push(Stack s, Item i)
(
struct node *new_node = malloc(sizeof (struct node) ) ;
if (new node == NULL)
terminate ("Error in push: stack is full.");

new_node->data = i;
new_node->next = s->top;
s->top = new node;

}

Item pop(Stack s)

struct node *old top:;
Item i;

if (is empty(s))
terminate ("Error in pop: stack is empty.") ;

old _ top = s->top;

j = old top->data;
s->top = old top->next;
Êree (old top) ;

return i;

***************************page_527***************************
502

Chapter 19 Program Design

19.5

assert macro > 24<.1

Note that the destroy function calls make_empty (to release the memory
occupied by the nodes in the linked list) before it calls £ree (to release the mem-
ory for the stack_type structure).

Design Issues for Abstract Data Types

Section 19.4 described a stack ADDT and showed several ways to implement it.
Unfortunately, this ADT suffers from several problems that prevent it from being
industrial-strength. Let's look at each of these problems and discuss possible solu-
tions.

Naming Conventions

The stack ADT functions currently have short, easy-to-understand names: cre-
ate, destroy, make _empty, is_empty. is full, push. and pop. If we
have more than one ADT in a program. name clashes are likely. with functions
in two modules having the same name. (Each ADT will need its own create
function, for example.) Therefore, we’I] probably need to use function names
that incorporate the name of the ADT itself, such as stack _ create instead of
create.

Error Handling

The stack ADT deals with errors by displaying an error message and terminating
the program. That’s not a bad thing to do. The programmer can avoid popping an
empty stack or pushing data onto a full stack by being careful to call is empty
prior to each call of pop and is £ull prior to each call of push, so in theory
there’s no reason for a call of push or pop to fail. (In the linked-list implementa-
tion. however, calling is £ull 1sn’{ foolproof, a subsequent call of push can
süûll fail.) Nevertheless, we might want to provide a way for a program to recover
from these errors rather than terminatine.

An alternative 1s to have the push and pop functions return a bool value to
indicate whether or not they succeeded. push currently has a void return type, so
it would be easy to modify it to return true 1f the push operation succeeds and
false if the stack is full. Modifving the pop function would be more difficult,
since pop currently returns the value that was popped. However, if pop were to
return a pointer to this value, instead of the value itself, then pop could return
NULL to indicate that the stack is empty.

À final comment about error handline: The C standard library contains a
parameterized macro named assert that can terminate a program if a specified
condition isn’t satisfied. We could use calls of this macro as replacements for the
i É statements and calls of terminate that currently appear in the stack ADT.

***************************page_528***************************
19.5  Design Issues for Abstract Data Types 503

Generic ADTSs

Midway through Section 19.4, we improved the stack ADT by making it easier to
change the type of items stored in à stack—all we had to do was modify the defini-
tion of the Item type. lls still somewhat of à nuisance to do so; it would be nicer
if a stack could accommodate items of any type, without the need to modify the
stack.h file. Also note that our stack ADT suffers from a serious flaw: a pro-
gram can’t create two stacks whose items have different types. It’s easy to create
multiple stacks, but those stacks must have items with identical types. To allow
stacks with different item types. we'd have to make copies of the stack ADT's
header file and source file and modify one set of files so that the Stack type and
its associated functions have different names.

What we’d like to have is a single ‘“generic” stack type from which we could
create a stack of integers, a stack of strings, or any other stack that we might need.
There are various ways to create such a type in C, but none are completely satisfac-
tory. The most common approach uses void * as the item type, which allows
arbitrary pointers to be pushed and popped. With this technique, the stack-
ADT. h file would be similar to our original version; however, the prototypes of the
push and pop functions would have the following appearance:

void push(Stack s, void *p) ;
void *pop(Stack s);

pop returns a pointer to the item popped from the stack; if the stack is empty, it
returns a null pointer.

There are two disadvantages to using void * as the item type. One is that this
approach doesn’t work for data that can’t be represented in pointer form. Items
could be strings (which are represented by à pointer to the first character in the
string) or dynamically allocated structures but not basic types such as int and
double. The other disadvantage is that error checking is no longer possible. À
stack that stores void * items will happily allow a mixture of pointers of different
types: there’s no way to detect an error caused by pushing à pointer of the wrong

type.

ADTS in Newer Languages

The problems that we“ve just discussed are dealt with much more cleanly in newer
C-based languages, such as C++. Java, and C#. Name clashes are prevented by
defining function names within à class. À stack ADT would be represented by a
Stack class; the stack functions would belong to this class, and would only be
recognized by the compiler when applied to a Stack object. These languages
have a feature known as exception handling that allows functions such as push
and pop Lo “throw” an exception when they detect an error condition. Code in the
client can then deal with the error by “catching” the exception. C++, Java, and C#
also provide special features for defining generic ADTs. In C++, for example, we
would define à stack template, leaving the item type unspecified.

***************************page_529***************************
504

Chapter 19 Program Design

A:
FILE type » 22.1

Q & À

You said that C wasn°t designed for writing large programs. Isn’t UNIX a
large program? [p. 483]

Not at the time C was designed. In à 1978 paper. Ken Thompson estimated that the
UNIX kernel was about 10,000 lines of C code (plus a small amount of assembler).
Other components of UNIX were of comparable size; in another 1978 paper. Den-
nis Ritchie and colleagues put the size of the PDP-11 C compiler at 9660 lines. By
today's standards, these are indeed small programs.

Âre there any abstract data types in the C library?

Technically there aren’t, but a few come close, including the FILE type (defined in
<stdio.h>). Before performing an operation on a file, we must declare a vari-
able of type FILE *:

FILE *fp;

The £p variable will then be passed to various file-handling functions.

Programmers are expected to treat FILE as an abstraction. It’'s not necessary
to know what a FILE is in order to use the FILE type. Presumably FILE is à
structure type, but the C standard doesn’t even guarantee that. In fact, it’s better not
lo Know too much about how FILE values are stored, since the definition of the
FILE type can (and often does) vary from one C compiler to another.

Of course, we can always look in the stdio.h file and see what à FILE is.
Having done so, there’s nothing to prevent us from writing code to access the inter-
nals of a FILE. For example, we might discover that FILE is a structure with a
member named bsi ze (the file’s buffer size):

typedef struct {

int bsize; /* buffer size */
} FILE;
Once we know about the bsize member, there’s nothing to prevent us from
accessing the buffer size for a particular file:
print£ ("Buffer size: %d\n", fp->bsize) ;
Doing so isn’t a good idea, however, because other C compilers might store the
buffer size under a different name, or keep track of it in some entirely different
way. Changing the bsize member is an even worse idea:

fp->bsize = 1024;

Unless we know all the details about how files are stored, this is a dangerous thing
to do. Even if we do know the details, they may change with a different compiler or
the next release of the same compiler.

***************************page_530***************************
Section 19.1

Section 19.2

œ

flexible array members » 77.9

O

>.

Exercises 505

What other incomplete types are there besides incomplete structure types? [p.
492]

One of the most common incomplete types occurs when an array 1s declared with
no specified size:

extern int a(];

After this declaration (which we first encountered in Section 15.2), a has an
incomplete type. bécause the compiler doesn’t know a’s length. Presumably à 1s
defined in another file within the program; that definition will supply the missing
length. Another incomplete type occurs in declarations that specify no length for
an array but provide an initializer:

int a[) = {1, 2, 3};

In this example. the array a initially has an incomplete type, but the type 1s com-
pleted by the initializer.

Declaring a union tag without specifying the members of the union also cre-
ates an incomplete type. Flexible array members (a C99 feature) have an incom-
plete type. Finally, void is an incomplete type. The void type has the unusual
property that it can never be completed, thus making it impossible to declare a
variable of this type.

What other restrictions are there on the use of incomplete types? [p. 492]

The sizeof operator can't be applied to an incomplete type (not surprisingly.
since the size of an incomplete type is unknown). À member of a structure or
union (other than a flexible array member) can’t have an incomplete type. Simi-
larly, the elements of an array can’t have an incomplete type. Finally, a parameter
in à function definition can’t have an incomplete type (although this 1s allowed in
a function declaration). The compiler “adjusts” each array parameter in à function
definition so that it has à pointer type, thus preventing it from having an incom-

plete type.

Exercises

À queue is similar to a stack, except that items are added at one end but removed from the
other in a FIFO (first-in, first-out) fashion. Operations on a queue might include:

Inserting an item at the end of the queue

Removing an item from the beginnine of the queue

Returning the first item in the queue (without changing the queue)

Returning the last item in the queue (without changing the queue)

Testing whether the queue is empty

Write un interface for a queue module in the form of a header file named queue.h.

Modify the stack2. c file to use the PUBLIC and PRIVATE macros.

***************************page_531***************************
506 Chapter 19 Program Design

Section 19.3

Section 19.4

2

® 4.

6.

(a) Write an array based implementation of the queue module described in Exercise 1. Use
three integers to keep track of the queue’s status. with one integer storing the position of the
first empty slot in the array (used when an item is inserted), the second storing the position
of the next item to be removed, and the third storing the number of items in the queue. An
insertion or removat that would cause either of the first two integers to be incremented past
the end of the array should instead reset the variable to zero, thus causing it to “wrap
around” to the beginning of the array.

(b) Write à linked-list implementation of the queue module described in Exercise 1. Use
two pointers, one pointing (o the first node in the list and the other pointing to the last node.
When an item is inserted into the queue, add it to the end of the list. When an item is
removed from the queue, delete the first node in the list.

(a) Write an implementation of the Stack type, assuming that Stack is a structure con-
taining a fixed-length array.

(b) Redo the Stack type, this time using à linked-Hist representation instead of an array.
(Show both stack.h and stack.c.)

Modify the queue .h header of Exercise | so that it defines a Queue type, where Queue
IS à Structure containing a fixed-length array (see Exercise 3(a)). Modify the functions in
queue .h to take a Queue * parameter.

(a) Add a peek function to stackADT.c. This function will have a parameter of type
Stack. When called, it returns the top item on the stack but doesn’t modify the stack.

(b) Repeat part (a), modifving stackADT2. c this time.
(c) Repeat part (a). modifying stackADT3. c this time.

Modify stackADT2.c€ so that a stack automatically doubles in size when it becomes full.
Have the push function dynamically allocate a new array that’s twice às large as the old
one and then copy the stack contents from the old array to the new one. Be sure to have
push deallocate the old array once the data has bcen copied.

Programming Projects

Modify Programming Project ! from Chapter 10 so that it uses the stack ADT described in
Section 19.4. You may use any of the implementations of the ADT described in that section.

Modify Programming Project 6 from Chapter 10 so that it uses the stack ADT described in
Section 19.4. You may use any of the implementations of the ADT described in that section.

Modify the stackADT3. c file of Section 19.4 by adding an int member named l1en to
the stack_type structure. This member will keep track of how many items are currently
stored in a stack. Add a new function named length that has a Stack parameter and
returns the value of the len member. (Some of the existing functions in stackADT3.c
will need to be modified as well.) Modify stackclient .c so that it calls the length
function (and displays the value that it returns) after each operation that modifies a stack.

Modify the stackADT.h and stackADT3. c files of Section 19.4 so that a stack stores
values of type void *, as described in Section 19.5; the Item type will no longer be used.
Modify stackclient .c so that it stores pointers to strings in thé s1 and s2 stacks.

***************************page_532***************************
‘U\

Programming Projects 507

Starting from the queue .h header of Exercise |, create a file named queueADT .h that
defines the following Queue type:

typedef struct queue type *Queue ;

queue _type 1s an incomplete structure type. Create à file named queueADT. c that con-
tains the full definition of queue_type as well as definitions for all the functions in
queue .h. Use a fixed-lensth array to store the îtems in a queue (sce Exercise 3(a)). Create
a file named queueclient. c (similar to the stackclient . c file of Section 19.4) that
creates (Wo queues and performs opérations on them. Be sure to provide create and
destroy functions for your ADT.

Modify Programming Project 5 so that the items in a queue are stored in a dynamically allo-
cated array whose length is passed to the create function.

Modify Programming Project 5 so that the items in a queue are stored in a linked list (see
Exercise 3(b)).

***************************page_533***************************

***************************page_534***************************
20

20.1

Low-Level Programming

À programming language is low level when its
programs require attention to the irrelevant.

Previous chapters have described C’s high-level, machine-independent features.
Although these features are adequate for many applications, some programs need
Lo perform operations at the bit level. Bit manipulation and other low-level opera-
tions are especially useful for writing systems programs (including compilers and
operating systems), encryption programs, graphics programs, and programs for
which f'ast execution and/or efficient use of space is critical.

Section 20.1 covers C’s bitwisc operators. which provide easy access to both
individual bits and bit-fields. Section 20.2 then shows how to declare structures
that contain bit-ficlds. Finally. Section 20.3 describes how certain ordinary C fea-
tures (type definitions, unions, and pointers) can help in writing low-level pro-
grams.

Some of the techniques described in this chapter depend on knowledge of how
data is stored in memory, which can vary depending on the machine and the com-
piler. Relying on these techniques will most likely make a program nonportable. so
it's best to avoid them unless absolutely necessary. If you do need them, try to limit
their use to certain modules in your program; don’t spread them around. And,
above all, be sure to document what you*re doine!

Bitwise Operators

C provides six bifwise operators, which operate on integer data at the bit level.
We'Il discuss the two bitwise shift operators first, followed by the four other bit-
wise operators (bitwise complement, bitwise and. bitwise exclusive or, and bitwise
inclusive or).

509

***************************page_535***************************
510

Table 20.1
Bitwise Shift Operators

portability tip

Chapter 20  Low-Level Programming

Bitwise Shift Operators

The bitwise shift operators can transform the binary representation of an integer by

shifting its bits to the left or right. C provides two shift operators, which are shown
in Table 20.1.

 

 

 

 

Symbol — Meaning
<< left shift
>> right shift

 

The operands for << and >> may be of any integer type (including char). The
integer promotions are performed on both operands: the result has the type of the
left operand after promotion.

The value of i << 1s the result when the bits in i are shifted left by j places.
For each bit that is “shifted off” the left end of i, a zero bit enters at the right. The
value of i >> j 1s the result when i 1s shifted right by j places. I à 1s of an
unsigned type or if the value of i is nonnegative, zeros are added at the left as
needed. If i 1s a negative number, the result 1s implementation-defined: some
implementations add zeros at the left end. while others preserve the sign bit by
adding ones.

l'or portability, it’s best to perform shifts only on unsigned numbers.

The following examples 1illustrate the effect of applying the shift operators to
the number 13. (For simplicity, these examples—and others in this section—use
short integers, which are typically 16 bits.)

unsigned short i, j;

i = 13; /* i is now 13 (binary 0000000000001101) */
j = i << 2; /* j is now 52 (binary 0000000000110100) */
j = i >> 2; /* j is now 3 (binary 0000000000000011) */

Âs these examples show, neither operator modifies its operands. To modify a vari-
able by shifting its bits, we’d use the compound assignment operators <<= and

>>=:

i = 13; /* i is now 13 (binary 0000000000001101) */
i <<= 2; /* i is now 52 (binary 0000000000110100) */
i >>= 2; /* i is now 13 (binary 0000000000001101) */

 

The bitwise shift operators have lower precedence than the arithmetic operators.
which can cause surprises. For example, à << 2 + 1 means i << (2 + 1), not
(i << 2) +1.

 

***************************page_536***************************
Table 20.2
Other Bitwise Operators

>

QaÂÀ

 

20.1  Bitwise Operators 511

Bitwise Complement, And, Exclusive Or, and Inclusive Or

Table 20.2 lists the remaining bitwise operators.

 

Symbol Meaning

 

- bitwise complement

& bitwise and

A . . .
bitwise exclusive or

| bitwise inclusive or

 

 

 

The - operator is unary; the integer promotions are performed on its operand. The
other operators are binary; the usual arithmetic conversions are performed on their
operands.

The -. & “, and | operators perform Boolean operations on all bits in their
operands. The - operator produces the complement of its operand, with zeros
replaced by ones and ones replaced by zeros. The & operator performs a Boolean
and operation on all corresponding bits in its two operands. The * and | operators
are similar (both perform a Boolean or operation on the bits in their operands):
however, “ produces O whenever both operands have a 1 bit. whereas | produces
].

 

Don't confuse the bitwise operators & and | with the /ogical operators && and |
The bitwise operators sometimes produce the same results as the logical operators,
but they’re not equivalent.

 

The following examples illustrate the effect of the —. & “, and | operators:

unsigned short i, j, kK;

= 21; /* i is now 21 (binary 0000000000010101) */
j = 56; /* j is now 56 (binary 0000000000111000) */
k = —-i; /* k is now 65514 (binary 1111111111101010) */
k = i & j; /* k is now 16 (binary 0000000000010000) */
k = i “ ;; /* k is now 45 (binary 0000000000101101) */
k = i | j; /* k is now 61 (binary 0000000000111101) */

The value shown for -i is based on the assumption that an unsigned short
value occupies 16 bits.

The - operator deserves special mention. since we can use it to help make
even low-level programs more portable. Suppose that we need an integer whose
bits are all 1. The preferred technique is to write -0, which doesn‘t depend on the
number of bits in an integer. Similarly, if we need an integer whose bits are all |
excepi for the last five, we could write -Ox1f.

***************************page_537***************************
512 Chapter 20

/

table of operators » Appendix À

Low-Level Programming

Each of the —, & “, and | operators has a different precedence:

Highest: -
&

Lowest: |

Às à result, we can combine these operators in expressions without having to use
parentheses. For example, we could write i & -j | K instead of (i & (-j)) | K
and i “ j & -k instead of i ” (j & (-k)). Of course. it doesn’t hurt to use
parentheses to avoid confusion.

 

The precedence of &. *, and | is lower than the precedence of the relational and
equality operators. Consequently, statements like the following one won’t have the
desired effect:

if (status & 0x4000 != O)

Instead of testing whether status & Ox4000 isn't zero. this statement will
evaluate Ox4000 != O (which has the value !), then test whether the value of
status & 1 isn’{ zero.

 

The compound assignment operators &=, “=, and |= correspond to the bit-
wise operators &. *. and |:

i = 21; /* i is now 21 (binary 00000000C0010101) */
j = 56; /* j is now 56 (binary 0000000000111000) */
i & ;; /* i is now 16 (binary 0000000000010000) */
i “= j; /* i is now 40 (binary 00000000C00101000) */
i |= j; /* i is now 56 (binary 00000000C0111000) */

Using the Bitwise Operators to Access Bits

When we do low-level programming. we’1l often need to store information as sin-
gle bits or collections of bits. In graphics programming, for example, we may want
to squeeze two or more pixels into a single byte. Using the bitwise operators. we
can extract or modify data that's stored in a small number of bits.

Let's assume that i 1s a 16-bit unsigned short variable. Let’s see how to
perform the most common single-bit operations on i:

u Seffing a bit. Suppose that we want to set bit 4 of i. (We'I] assume that the
leftmost—or mosf significant—bit 1s numbered 15 and the least significant 1s
numbered 0.) The casiest way Lo set bit 4 is to or the value of 1 with the con-
stant Ox0010 (a “mask” that contains a | bit in position 4):

i = 0x0000; /* i is now 0000000000000000 */
i |= 0x0010; /* i is now 0000000000010000 */

More generally, 1f the position of the bit is stored in the variable j, we can use
a shift operator to create the mask:

***************************page_538***************************
idiom

idiom

idiom

 

20.1  Bitwise Operators 513

i |= 1 << j; /* sets bit j */
For example, if j has the value 3, then 1 << j is 0x0008.

m Clearing à bit. To clear bit 4 of i. we'd use a mask with a O bit in position 4
and | bits everywhere else:

i = OxOOfE; /* i is now 0000000011111111 */
i & -0x0010; /* i is now 0000000011101111 */

Using the same idea, we can easily write a statement that clears a bit whose
position is stored in a variable:

i &= —-(1 << j); /* clears bit yj */
# Testing a bit. The following i £ statement tests whether bit 4 of à is set:
if (i & 0x0010) … /* tests bit 4 */
To test whether bit j is set, we'd use the following statement:
Lif (i & 1 << j) … /* tests bit y */

To make working with bits easier, we'Il often give them names. For example,
suppose that we want bits Ü, 1, and 2 of a number to correspond to the colors blue.
green, and red, respectively. First, we define names that represent the three bit
positions:

#define BLUE 1
#define GREEN 2
#define RED 4

Setting, clearing, and testing the BLUE bit would be done as follows:

i |= BLUE; /* sets BLUE bit */
i & -BLUE; /* clears BLUE bit */
if (i & BLUE) … /* tests BLUE bit */

It’s also easy to set. clear, or test several bits at time:

i |= BLUE | GREEN; /* sets BLUE and GREEN bits */
i & -(BLUE | GREEN) ; /* clears BLUE and GREEN bits */
L£ (i & (BLUE | GREEN)) … — /* tests BLUE and GREEN bits */

The i £ statement tests whether either the BLUE bit or the GREEN bit is set.

Using the Bitwise Operators to Access Bit-Fields

Dealing with a group of several consecutive bits (a bit-field) is slightly more com-
plicated than working with single bits. Here are examples of the two most common
bit-field operations:

= Modifying a bit-field. Modifying a bit-field requires a bitwise and (to clear the
bit-field), followed by a bitwise or (to store new bits in the bit-field). The fol-
lowing statement shows how we might store the binary value 101 in bits 4—6
of the variable i:

***************************page_539***************************
514 Chapter20 Low-Level Programming

PROGRAM

ASCII character set » Appendix E

input and output redirection >22. /

i = i & -0x0070 | 0x0050; /* stores 101 in bits 4-6 */

The & operator clears bits 46 of i; the | operator then sets bits 6 and 4.
Notice that i_ | = Ox0050 by itself wouldn’t always work: it would set bits 6
and 4 but not change bit 5. To generalize the example a little, let’s assume that
the variable j contains the value to be stored in bits 46 of i. We'll need to
shift # into position before performing the bitwise or:

 

i = (i & -0x0070) | (j << 4); /* stores j in bits 4-6 */

The | operator has lower precedence than & and <<, so we can drop the paren-
theses 1f we wish:

i = i & -0x0070 | j << 4;

= Retrieving a bit-field. When the bit-field is at the right end of a number (in the
least significant bits), fetching its value is casy. For example, the following
statement retrieves bits O—2 in the variable i:

j = i & 0x0007; /* retrieves bits 0-2 */

If the bit-field isn’t at the right end of of i, then we can first shift the bit-field
to the end before extracting the field using the & operator. To extract bits 46
of i, for example. we could use the following statement:

j = (i >> 4) & 0x0007; /* retrieves bits 4-6 */

XOR Encryption

One of the simplest ways to encrypt data is to exclusive-or (XOR) each character
with a secret key. Suppose that the key is the & character. If we XOR this key with
the character z, we'll get the \ character (assuming that we’re using the ASCII
character set):

00100110 (ASCII code for &)
XOR 01111010 (ASCII code for z)
01011100 (ASCII code for \)

To decrypt a message, we just apply the same algorithm. In other words, by
encrypting an already-encrypted message, we’Il recover the original message. If
we XOR the & character with the \ character, for example, we’1l get the original
character, z:

00100110 (ASCII code for &)
XOR 01011100 (ASCII code for \)
01111010 (ASCII code for z)

The following program. xor . c. encrypts a message by XORing each charac-
ter with the & character. The original message can be entered by the user or read
from a file using input redirection; the encrypted message can be viewed on the
screen or saved in à file using output redirection. For example. suppose that the file

***************************page_540***************************
isprint function >23.5

XOI.C

 

20.1  Bitwise Operators 515

msg contains the following lines:

Trust not him with your secrets, who, when left
alone in your room, turns over your papers.
--Johann Kaspar Lavater (1741-1801)

To encrypt the msg file. saving the encrypted message in newmsg. we*d use the
following command:

XOr <msg >newmsqg
newmsg will now contain thesc lines:

YTSUR HIR NOK QORN _IST UCETCRU, ONI, QNCH JC@R
GJIHC OH _IST TIIK, RSTHU IPCT _IST VGVCTU.
--1INGHH mGUVGT jGPGRCT (1741-1801)

To recover the original message, we’d use the command
xor <newmsg

which will display it on the screen.

Às the example shows, our program won" change some characters, includine
digits. XORing these characters with & would produce invisible control characters,
which could cause problems with some operating systems. In Chapter 22, we*1Il see
how Lo avoid problems when reading and writing files that contain control charac-
ters. Until then, we*II play it safe by using the isprint function to make sure
that both the original character and the new (encrypted) character are printing char-
acters (i.e.… not control characters). If either character fails this test, we’Il have the
program write the original character instead of the new character.

Here’s the finished program, which is remarkably short:

/* Performs XOR encryption */

finclude <ctype.h>
#include <stdio.h>

#define KEY 'g!'

int main (void)

(

int orig char, new char;

while ((orig _ char = getchar()) != EoOF) Ç{
new_char = orig char ” KEy;
if (isprint (orig char) && isprint (new char))
putchar (new _ char) ;
else
putchar (orig _char) ;
}

return 0;

***************************page_541***************************
516

Chapter 20  Low-Level Programming

20.2

Qahâ

portability tip

æ

Bit-Fields in Structures

Although the techniques of Section 20.1 allow us to work with bit-fields. these
techniques can be tricky to use and potentially confusing. Fortunately, C provides
an alternative: declaring structures whose members represent bit-fields.

As an example, let’s look at how the MS-DOS operating system (often just
called DOS) stores the date at which a file was created or last modified. Since
days, months, and years are small numbers, storing them as normal integers would
waste space. Instead, DOS allocates only 16 bits for a date, with 5 bits for the day.
À bits for the month, and 7 bits for the year:

 

 

15 146 13 12 11 10 9 8 7 6 5

e
L
v
=
O

Using bit-fields, we can define a C structure with an identical layout:

struct file date [(
unsigned int day: 5;
unsigned int month: 4;
unsigned int year: 7;

}

The number after each member indicates its length in bits. Since the members all
have the same type, we can condense the declaration 1f we want:

struct file date {
unsigned int day: 5, month: 4, year: 7;

}

The type of a bit-field must be either int, unsigned int, or signed int.
Using int is ambiguous; some compilers treat the field’s high-order bit as a sign
bit, but others don’t.

Declare all bit-fields to be either unsigned int or signed int.

In C99, bit-fields may also have type _Bool. C99 compilers may allow additional
bit-field types.

We can use a bit-field just like any other member of a structure, as the follow-
ing example shows:

struct file date fd;

fd.day = 28;
fd.month = 12;
fFd.year = 8; /* represents 1988 */

Note that the year member is storcd relative to 1980 (the year the world began.

***************************page_542***************************
20.2  Bit-Fields in Structures 517

according to Microsoft). After these assignments, the £d variable will have the fol-
lowing appearance:

 

 

15 1218 13 12 11 10 89 8 7 6 5 â 3 2 1 Û

We could have used the bitwise operators to accomplish the same effect: using
these operators might even make the program a little faster. However, having a
readable program 1s usually more important than gaining a few microseconds.

Bit-fields do have one restriction that doesn’t apply to other members of a
structure. Since bit-ficlds don’t have addresses in the usual sense, C doesn’t allow
us to apply the address operator (&) to a bit-field. Because of this rule, functions
such as scan£ can’t store data directly in a bit-field:

scanf ("#d", &fd. day) ; /*** WRONG ***/

Of course, we can always use scan£ (o read input into an ordinary variable and
then assign it to £d.day.

How Bit-Fields Are Stored

Let’s take a close look at how a compiler processes the declaration of a structure
that has bit-field members. Às we’Il see, the C standard allows the compiler con-
siderable latitude in choosing how 1t stores bit-fields.

The rules concerning how the compiler handles bit-fields depend on the notion
of “storage units.” The size of a storage unit is implementation-defined: typical
values are 8 bits, 16 bits, and 32 bits. ÀS 1t processes a structure declaration, the
compiler packs bit-fields one by one into a storage unit, with no gaps betwcen the
fields, until there’s not enough room for the next field. At that point, some compil-
ers skip to the beginning of the next storage unit, while others split the bit-field
across the storage units. (Which one occurs is implementation-defined.) The order
in which bit-fields are allocated (left to right or right to left) is also implementa-
tion-defined.

Our file date example assumes that storage units are |6 bits long. (An 8-
bit storage unit would also be acceptable. provided that the compiler splits the
month field across two storage units.) We also assume that bit-fields are allocated
from right to left (with the first bit-field occupying the low-order bits).

C allows us to omit the name of any bit-field. Unnamed bit-fields are useful as
‘“padding” to ensure that other bit Felds are properly positioned. Consider the time
associated with a DOS file, which is stored in the following way:

struct file time |
unsigned int seconds: S;
unsigned int minutes: 6;
unsigned int Hours: 5;

};

***************************page_543***************************
518

Chapter20  Low-Level Programming

20.3

(You may be wondering how 1t’s possible to store the seconds—a number between
O and 59—in a field with only 5 bits. Well, DOS cheats: it divides the number of
seconds by 2, so the seconds member 1s actually between O and 29.) If we*re not
interested in the seconds field, we can leave out its name:

struct file time {
unsigned int : 5; /* not used */
unsigned int minutes: 6;
unsigned int hours: 5;

} ;

The remaining bit-fields will be aligned as 1f the seconds field were still present.
Another trick that we can use to control the storage of bit-fields is to specify 0
as the length of an unnamed bit-field:

struct s (
unsigned int a: 4;
unsigned int : 0; /* 0-length bit-£ield */
unsigned int b: 8;

} ;

À O0-length bit-field 1s à signal to the compiler to align the following bit-field at the
beginning of a storage unit. If storage units are 8 bits long, the compiler will allo-
cate 4 bits for the a member, skip 4 bits to the next storage unit, and then allocate 8
bits for b. IF storage units are 16 bits long, the compiler will allocate 4 bits for a,
skip 12 bits, and then allocate 8 bits for b.

Other Low-Level Techniques

Some of the language features that we’ve covered in previous chapters are used
often in low-level programming. To wrap up this chapter, we’1l take a look at sev-
eral important examples: defining types that represent units of storage, using
unions to bypass normal type-checking, and using pointers as addresses. We'I1 also
cover the volatile type qualifier, which we avoided discussing in Section 18.3
because of its low-level nature.

Defining Machine-Dependent Types

Since the char type—by definition—occupies one byte, we'll sometimes treat
characters as bytes, using them to store data that’s not necessarily in character
form. When we do so, it’s a good idea to define à BYTE type:

typedef unsigned char BYTE;

Depending on the machine, we may want to define additional types. The x86 archi-
tecture makes extensive use of 16-bit words, so the following definition would be
useful for that platform:

***************************page_544***************************
 

20.3  Other Low-Level Techniques 519

typedef unsigned short WORD;

We'll use the BYTE and WORD types in later examples.

Using Unions to Provide Multiple Views of Data

Although unions can be used in a portable way—see Section 16.4 for examples—
they’re often used in C for an entirely different purpose: viewing a block of mem-
ory in two or more different ways.

Here’s a simple example based on the file date structure described in
Section 20.2. Since a file date structure fits into two bytes, we can think of
any two-byte value as a file date structure. In particular, we could view an
unsigned short value as a file date structure (assuming that short inte-
gers are 16 bits long). The following union allows us to easily convert a short inte-
ger to a file date or vice versa:

 

union int date (
unsigned short i;
struct file date £fd;

}

With the help of this union, we could fetch a file date from disk as two bytes, then
extract its month, day, and year fields. Conversely, we could construct a date as
a file date structure, then write it to disk as a pair of bytes.

Âs an example of how we might use the int _ date union. here’s a function
that, when passed an unsigned short argument, prints it as a file date:

void print date (unsigned short n)

{

union int date u;

u.i = n;
print£ ("%d/%d/%d\n"', u.fd.month, u.fd.day, u.fd.year + 1980) ;

}

Using unions to allow multiple views of data is especially useful when work-
ing with registers, which are often divided into smaller units. x86 processors, for
example, have 16-bit registers named AX. BX, CX, and DX. Each of these regis-
ters can be treated as two 8-bit registers. AX, for example, is divided into registers
named ÀH and AL. (The H and L stand for “high” and “low.”)

When writing low-level applications for x86-based computers. we may need
variables that represent the contents of the AX, BX, CX, and DX registers. We
want access to both the 16- and 8-bit registers; at the same time, we need to take
their relationships into account (a change to AX affects both AH and AL; changing
AH or ÂL modifies AX). The solution is to set up two structures, one containing
members that correspond to the 16-bit registers. and the other containing members
that match the 8-bit registers. We then create a union that encloses the two struc-
tures:

***************************page_545***************************
520

Chapter 20  Low-Level Programming

QahÀ

union (
struct |
WORD ax, bx, cx, dx;
} word;
struct {
BYTE al, ah, bl, bh, cl, ch, dl, dh;
} byte;
regs;

The members of the word structure will be overlaid with the members of the
byte structure; for example, ax will occupy the same memory as al and ah. And
that, of course, is exactly what we wanted. Here’s an example showing how the
regs union might be used:

regs.byte.ah = 0x12;
regs.byte.al = 0Ox34;
printf ("AX: %hx\n"', regs.word.ax) ;

Changing ah and al affects ax, so the output wilt be
AX: 1234

Note that the byte structure lists al before ah. even though the AL register
is the “low” half of AX and AH is the “high” half. Here’s the reason. When a data
item consists of more than one byte, there are two logical ways to store it in mem-
ory: with the bytes in the ‘‘natural” order (with the leftmost byte stored first) or
with the bytes in reverse order (the leftmost byte 1s stored last). The first alternative
is called big-endian; the second is known as little-endian. C doesn’t require a spe-
cific byte ordering. since that depends on the CPU on which à program will be exe-
cuted. Some CPUs use the big-endian approach and some use the little-endian
approach. What does this have to do with the byte structure” Ît turns out that x86
processors assume that data is stored in little-endian order. so the first byte of
regs.word.ax isthe low byte.

We don't normally need to worry about byte ordering. However, programs that
deal with memory at a low level must be aware of the order in which bytes are
stored (as the regs example illustrates). lls also relevant when working with files
that contain non-character data.

 

Be careful when using unions to provide multiple views of data. Data that is valid
in its original format may be invalid when viewed as a different type, causing
unexpected problems.

 

Using Pointers as Addresses

We saw in Section 11.1 that à pointer is really some kind of memory address,
although we usually don't need to know the details. When we do low-level pro-
grammine, however. the details matter.

***************************page_546***************************
PROGRAM

viewmemory.c

20.3  Other Low-Level Techniques B21

An address often has the same number of bits as an integer (or long integer).
Creating a pointer that represents a specific address is easy: we just cast an integer
into a pointer. For example, here’s how we might store the address 1000 (hex) in a
pointer variable:

BYTE *p;

p = (BYTE *) 0x1000; /* p contains address 0x1000 */

Viewing Memory Locations

Our next program allows the user to view segments of computer memory; it relies
on C’s willingness to allow an integer to be used as a pointer. Most CPUs execute
programs in “protected mode.” however, which means that a program can access
only those portions of memory that belong to the program. This prevents a pro-
gram from accessing (or changing) memory that belongs to another application or
to the operating system itself. Às a result. we'Il only be able to use our program to
view areas of memory that have been allocated for use by the program itself. Goine
outside these regions will cause the program to crash.

The viewmemory.c program begins by displaying the address of its own
main function as well as the address of one of its variables. This will give the user
a clue as to which areas of memory can be probed. The program next prompts the
user to enter an address (in the form of a hexadecimal integer) plus the number of
bytes to view. The program then displays a block of bytes of the chosen length.
starting at the specified address.

Bytes are displayed in groups of 10 (except for the last group,. which may have
fewer than 10 bytes). The address of a group of bytes is displayed at the beginning
of a line, followed by the bytes in the group (displayed as hexadecimal numbers)!
followed by the same bytes displayed as characters (just in case the bytes happen to
represent characters, as some of them may). Only printing characters (as deter-
mined by the isprint function) will be displayed: other characters will be
shown as periods.

We 1l assume that int values are stored using 32 bits and that addresses arc
also 32 bits long. Addresses are displayed in hexadecimal, as is customary.

/* Allows the user to view regions of computer memory */

finclude <ctype.h>
#include <stdio.h>

typedef unsigned char BYTE;

int main(void)
unsigned int addr;
int i, n;
BYTE *ptr;

print£ ("Address of main function: %“x\n", (unsigned int) main) ;
print£ ("Address of addr variable: %x\n"', (unsigned int) &addr) ;

***************************page_547***************************
522

Chapter 20  Low-Level Programming

printf ("\nEnter a (hex) address: ") ;

scanf ("*x", &addr}) ;

print£ ("Enter number of bytes to view: ") ;
scant ("*d", &n) ;

print£("\n") ;

print£(" Address Bytes Characters\n") ;
print£f(" -------  -------=-----meee e - r1 C0 C0C0 -1 00000000 \n") ;
ptr = (BYTE *) addr;
for (j n > 0; n -= 10) [(
printft("*8X ", (unsigned int) ptr);
for (i = 0; i < 10 && i < n: i++)
print£ ("#.2X ", *(ptr + i));
for (; i < 10; i++)
print£ (" " ;

print£(" ");
for (i = 0; i < 10 && i < n; i++) (
BYTE ch = *(ptr + i);
if (!isprint (ch))
ch = '."';
printf("%c", ch);

print£("\n") ;
ptr += 10;

}

return 0:

}

The program is complicated somewhat by the possibility that the value of n
isn’ta multiple of 10, so there may be fewer than 10 bytes in the last group. Two of
the £or statements are controlled by the condition i < 10 && i < n. This condi-
tion causes the loops to execute 10 times or n times, whichever is smaller. There’s
also a £or statement that compensates for any missing bytes in the last group by
displaying three spaces for each missing byte. That way, the characters that follow
the last group of bytes will align properly with the character groups on previous
lines.

The X conversion specifier used in this program is similar to 3x, which was
discussed in Section 7.1. The difference is that X displays the hexadecimal digits
À, B, C, D, E, and F as upper-case letters; %x displays them in lower case.

Here’s what happened when I compiled the program using GCC and tested it
on an x86 system running Linux:

Address of main function: 804847c
Address of addr variable: bff41154

Enter a (hex) address: 8048000
Enter number of bytes to view: 4

Address Bytes Characters
8048000 7F 45 4C 46 O1 O1 01 00 00 OO .ELF......
804800A 00 00 00 00 00 00 02 00 03 00 ........….
8048014 01 OO 00 00 CO 83 04 08 34 00 ........ 4.
804801E 00 00 CO OA 00 00 00 00 00 OO ........….

***************************page_548***************************
20.3  Other Low-Level Techniques 523

] asked the program to display 40 bytes starting at address 5S048000, which pre-
cedes the address of the main function. Note the 7F byte followed by bytes repre-
senting the letters E, L, and F. These four bytes identify the format (ELF) in which
the executable file was stored. ELF (Executable and Linking Format) is widely
used by UNIX systems, including Linux. 8048000 is the default address at which
ELF executables are loaded on x86 platforms.

Let's run the program again, this time displaying a block of bytes that starts at
the address of the addr variable:

Address of main function: 804847c
Address of addr variable: bfec5484

Enter a (hex) address: bfec5484
Enter number of bytes to view: 64

Address Bytes Characters
BFEC5484 84 54 EC BF BO 54 EC BF F4 6F .T...T...O
BFEC548E 68 00 34 55 EC BF CO 54 EC BF h.4U...T..
BFEC5498 08 55 EC BF E3 3D 57 00 00 00 .U...=W...

BFECS54A2 00 00 AO BC 55 00 08 SS EC BF P:....U..U..
BFECS4AC E3 3D 57 OO O1 00 00 00 34 55 .=W..... AU
BFECS4B6 EC BF 3C 55 EC BF 56 11 55 00 ..<U..V.U.
BFECS4CO F4 6F 68 OO .oh.

None of the data stored in this region of memory is in character form, so it’s a bit
hard to follow. However, we do know one thing: the addr variable occupies the
first four bytes of this region. When reversed, these bytes form the number
BFEC5484, the address entered by the user. Why the reversal? Because x86 pro-
cessors store data in little-endian order, as we saw earlier in this section.

The volatile Type Qualifier

On some computers, certain memory locations are “volatile”; the value stored at
such a location can change as a program is running, even though the program 1tself
isn’t storing new values there. For example, some memory locations might hold
data coming directly from input devices.

The volatile type qualifier allows us to inform the compiler if any of the
data used in a program is volatile. volatile typically appears in the declaration
of a pointer variable that wil] point to a volatile memory location:

volatile BYTE *p; /* p will point to a volatile byte */

To see why volatile 1s needed, suppose that p points to a memory location
that contains the most recent character typed at the user’s keyboard. This location
1s volatile: its value changes each time the user enters a character. We might use the
following loop to obtain characters from the keyboard and store them in a buffer
array:

***************************page_549***************************
524

Chapter 20

> 2

Low-Level Programming

while (buffer notfull) {
wait for inpuit ;
buf£fer[i] = *p;
if (buffer[i++] == '\n')
break ;
}

À sophisticated compiler might notice that this loop changes neither p nor *p. so il
could optimizc the program by altering it so that *p is fetched just once:

store *p in u register ;
while (buffer not full) {
wait for input ;

buffer[i] = value stored in register;
LÉ (buffer[i++] == '\n')
break ;

}

The optimized program wilt fill the buffer with many copies of the same charac-
ter—not exactly what we had in mind. Declaring that p points to volatile data
avoids this problem by telling the compiler that *p must be fetched from memory
each time it’s needed.

Q & À

What do you mean by saying that the & and | operators sometimes produce
the same results as the && and | | operators, but not always? [p. 511]
Let’s compare i & j with i && j (similar remarks apply to | and | [). As long as
i and j have the value O or 1 (in any combination), the two expressions will have
the same value. However, if à and j should have other values, the expressions may
not always match. [F à is l and j is 2, for example. then i & } has the value O (i
and j have no corresponding | bits), while i && j has the value !. If i is 3 and =
is 2, then i & j has the value 2, while i && ÿ has the value |.

Side effects are another difference. Evaluating i & j++ always increments j
as a side effect, whereas evaluating i && j++ sometimes increments j.

 

Who cares how DOS stores file dates? Isn’t DOS dead? [p. 516]

For the most part, yes. However, there are still plenty of files created years ago
whose dates are stored in the DOS format. In any event, DOS file dates are a good
example of how bit-felds are used.

Where do the terms “‘big-endian” and “little-endian” come from? [p. S20]

In Jonathan Swift's novel Gulliver’s Travels, the fictional islands of Lilliput and
Blefuscu are perpetually at odds over whether to open boiled eggs on the big end
or the little end. The choice 1s arbitrary, of course, just like the order of bytes in a
dlata item.

***************************page_550***************************
Section 20.1

#1.

t

6.

Exercises 525

Exercises

Show the output produced by each of the following program fragments. Assume that i, j.
and k are unsigned short variables.
(a) i = 8; j = 9;
print£("%d", i >> 1 + j >> 1);
(b) à = 1;
printf("3d", i & -i
(c) i = 2; j = 1; k = O
printf("%$d", -i & j “ Kk);
(d) i = 7; 3 = 8; k = 9;
print£("%d", i “ j & k);

Describe u simple way to “toggle” a bit (change it from O to ! or from L to O). Hlustrate the
technique by writing a statement that toggles bit 4 of the vartable @.

Explain what effect the following macro has on its arguments. You may assume that the
arguments have the same type.

#define M(x,y) ((x)"=(y), (y)*=(x), (x)°=(y))

In computer graphies, colors arc often stored as three numbers. representing recd, green, and
blue intensities. Suppose that each number requires eight bits. and we'd like to store all three
values in a single long integer, Write a macro named MK_COLOR with three parameters (the
red, grcen, and blue intensities). MK_COLOR should return à Long in which the last three
bytes contain the red. green, and blue intensities, with the red value as the last byte and the
sreen value as the next-to-last byte.

Write macros named GET_RED. GET GREEN, and GET_BLUE that. when given a color as
an argument (see Exercise 4), return its 8-bit red. green. and bluc intensities.

(a) Use the bitwise opcrators to write the following funetion:

unsigned short swap bytes (unsigned short i);

swap_bytes should return the number that results from swapping the two bytes in i.
(Short integers occupy two bytes on most computers.) For example. if à has the value
0x1234 (00010010 00110100 in binary), then swap_bytes should return Ox3412
(00110100 00010010 in binary). Test your function by writing à program that reads a num-
ber in hexadecimal. then writes the number with its bytes swapped:

Enter a hexadecimal number (up to four digits): 1234
Number with bytes swapped: 3412

Hint: Use the 3hx conversion to read and write the hex numbers.

(b) Condense the swap_bytes f'unction so that its body is a single statement.

Write the following functions:

unsigned int rotate _ left (unsigned int i, int n);
unsigned int rotate right (unsigned int i, int n);

rotate le£t should return the result of shifting the bits in i to the left by n places.
with the bits that were “shifted off* moved to the right end of i. (For example, the call

***************************page_551***************************
526 Chapter 20  Low-Level Programming

Section 20.2

® s.

0.

10.

ll.

*13,

@ 14.

rotate_left (0x12345678, 4) should return 0x23456781 if integers are 32 bits
long.) rotate_right is similar. but it should “rotate” bits to the right instead of the left.

Let £ be the following function:

unsigned int f (unsigned int i, int m, int n)

{

return (i >> (m + 1 - n)) & -(-0 << n);
}

(a) What is the value of =- (-0 << n)?
(b) What does this function do?

(a) Write the following function:
int count ones (unsigned char ch);
count_ones should return the number of ! bits in ch.

(b) Write the function in part (a) without using a loop.

Write the following function:
unsigned int reverse _ bits (unsigned int n);

reverse bits should return an unsigned integer whose bits are the same as those in n
but in reverse order.

Each of the following macros defines the position of a single bit within an integer:

#define SHIFT BIT 1
#define CTRL BIT 2
#define ALT BIT 4

The following statement ts supposed to test whether any of the three bits have been set. but it
never displays the specified message. Explain why the statement doesn't work and show
how to fix it. Assume that key_code is an int variable.

if (key code & (SHIFT BIT | CTRL BIT | ALT BIT) == O)
print£f("No modifier keys pressed\n") ;

The following function supposedly combines two bytes to form an unsigned short integer.
Explain why the function doesn’t work and show how to fix it.

unsigned short create short (unsigned char high byte,
unsigned char low byte)
{

return high _ byte << 8 + low byte;

}

If n is an unsigned int variable, what effect does the following statement have on the
bits in n?

n & n -Tl;

Hint: Consider the effect on n if this statement is executed more than once.

When stored according to the IEEE floating-point standard. a float value consists of a |-
bit sign (the leftmost—or most significant—bit), an 8-bit exponent, and à 23-bit fraction. in
that order. Design à structure type that occupies 32 bits, with bit-field members correspond-
ing to the sign. exponent, and fraction. Declare the bit-fields to have type unsigned int.
Check the manual for your compiler to determine the order of the bit-fields.

***************************page_552***************************
Section 20.3

*15.

16.

Programming Projects 527

(a) Assume that the variable s has been declared as follows:

struct |
int flag: 1;
} Si

With some compilers, executing the following statements causes 1 to be displayed, but with
other compilers, the output is —1. Explain the reason for this behavior.

s.flag = 1;
print£ ("%d\n"', s.flag) ;

(b) How can this problem be avoided?

Starting with the 386 processor, x86 CPUs have 32-bit registers named EAX. EBX, ECX,
and EDX. The second half (the least significant bits) of these registers is the same as AX,
BX, CX, and DX, respectively. Modify the regs union so that it includes these registers as
well as the older ones. Your union should be set up so that modifying EAX changes AX and
modifying AX changes the second half of EAX. (The other new registers will work in à sim-
ilar fashion.) You’1l nceed to add some “dummy” members to the word and byte siructures,
corresponding to the other half of EAX, EBX, ECX. and EDX. Declare the type of the new
registers to be DWORD (double word), which should be defined as unsigned long. Don'!
forget that the x86 architecture is little-endian.

Programming Projects

Design a union that makes it possible to view a 32-bit value as cither a £loat or the struc-
ture described in Exercise 14. Write a program that stores | in the structure’s sign field, 128
in the exponent field, and O in the fraction field, then prints the float value stored in the
union. (The answer should be —2.0 if you’ve set up the bit-fields correctly.)

***************************page_553***************************

***************************page_554***************************
21

21.1

æ

Table 21.1
Standard Library Headers

The Standard Library

Every program is a part of some other program and rarely fits.

In previous chapters we*ve looked at the C library piecemeal: this chapter focuses
on the library as a whole. Section 21.1 lists general guidelines for using the library.
It also describes a trick found in some library headers: using a macro to “hide” a
function. Section 21.2 gives an overview of each header in the C89 library; Section
21.3 does the same for the new headers in the C99 library.

Later chapters cover the library's headers in depth. with related headers
grouped together into chapters. The <stddef .h> and <stdbool .h> headers
are very brief, so l've chosen to discuss them in this chapter (in Sections 21.4 and
21.5. respectively).

Using the Library

The C89 standard library is divided into 15 parts. with each part described by a
header. C99 has an additional nine headers, for a total of 24 (see Table 21.1).

 

<sassert .h> <inttypes.h>+ <signal.h> <stdlib.h>
<complex.h>{ <iso646.h>' <stdarg.h> <string.h>
<ctype.h> <limits.h> <stdbool.h>' _ <tgmath.h>’
<errno.h> <locale.h> <stdde£f .h> <time.h>

<fenv.h>" <math.h> <stdint.h>! <wchar.h>!
<£loat.h> <setjmp.h> <stdio.h> <wctype.h>‘

 

 

 

*C99 only

Most compilers come with a more extensive library that invariably has many
headers that don’t appear in Table 21.1. The extra headers aren’t standard, of

529

***************************page_555***************************
530

Chapter 21

The Standard Library

course, so we can't count on them to be available with other compilers. These
headers often provide functions that are specific on a particular computer or oper-
ating system (which explains why they’re not standard). They may provide fune-
tions that allow more control over the screen and keyboard. Headers that support
graphics or a window-based user interface are also common.

The standard headers consist primarily of function prototypes, type defini-
tilons, and macro definitions. If one of our files contains a call of a function
declared in a header or uses one of the types or macros defined there, we*Il need to
include the header at the beginning of the file. When a file includes several stan-
dard headers, the order of #include directives doesn’t matter. Is also legal to
include a standard header more than once.

Restrictions on Names Used in the Library

Any file that includes a standard header must obey a couple of rules. First, it can°t
use the names of macros defined in that header for any other purpose. If a file
includes <stdio.h>, for example, it can’t reuse NULL, since a macro by that
name 1s already defined in <stdio.h>. Second, library names with file scope
(typede£ names, in particular) can”t be redefined at the file level. Thus, if a file
includes <stdio.h>, it can’t define size_t asa identifier with file scope, since
<stdio.h> defines size t to be a typedef name.

Although these restrictions are pretty obvious, C has other restrictions that you
might not expect:

= Identifiers that begin with an underscore followed by an upper-case letter or
a second underscore are reserved for use within the library; programs should
never use names of this form for any purpose.

u /dentifiers that begin with an underscore are reserved for use as identifiers
and tags with file scope. You should never use such a name for your own pur-
poses unless it’s declared inside a function.

= Every identifier with external linkage in the standard library is reserved for
Use as an identifier with external linkage. In particular, the names of all stan-
dard library functions are reserved. Thus, even if a file doesn'i include
<stdio.h>, it shouldn’t define an external function named print£, since
there’s already a function with this name in the library.

These rules apply to every file in a program, regardless of which headers the file
includes. Although these rules aren’t always enforced, failing to obey them can
lead to a program that’s not portable.

The rules listed above apply not just to names that are currently used in the
library, but also to names that are set aside for future use. The complete description
of which names are reserved is rather lengthy; you'Il find it in the C standard under
“future library directions.’ As an example, C reserves identifiers that begin with
str followed by a lower-case letter, so that functions with such names can be
added to the <string .h> header.

***************************page_556***************************
Q&ÂÀ

#unde£ directive » 14.3

21.2

 

212  C89 Library Overview = 531

Functions Hidden by Macros

It’'s common for C programmers to replace small functions by parameterized mac-
ros. This practice occurs even in the standard library. The C standard allows head-
ers to define macros that have the same names as library functions, but protects the
programmer by requirine that a true function be available as well. As a result, tt’s
not unusual for a library header to declare a function and define a macro with the
same name.

We’ve already seen an example of a macro duplicating a Hibrary function.
getchar 1s a library function declared in the <stdio .h> header. It has the fol-
lowing prototype:

int getchar (void) ;
<stdio.h> usually defines getchar as a macro as well:
#define getchar() getc(stdin)

By default, a call of getchar will be treated as a macro invocation (since macro
names are replaced during preprocessing).

Most of the time, we’re happy using a macro instead of a true function,
because it will probably make our program run faster. Occasionally, though. we
want a genuine function, perhaps to minimize the size of the executable code.

[f the need arises, we can remove a macro definition (thus gaining access to
the true function) by using the #undef directive. For example, we could undefine
the getchar macro after including <stdio.h>:

#Hinclude <stdio.h>
fundef getchar

If getchar isn't! a macro, no harm has been done: #undef has no effect when
given a name that's not defined as a macro.

Âs an alternative, we can disable individual uses of a macro by putting paren-
theses around its name:

ch = (getchar) (); /* instead of ch = getchar (); */

The preprocessor can’t spot a parameterized macro unless its name is followed by
a left parenthesis. The compiler isn’t so easily fooled, however; it can still recog-
nize getchar as a function.

C89 Library Overview

We’ll now take a quick look at the headers in the C89 standard library. This section
can serve as a ‘“road map” to help you determine which part of the library you
need. Each header is described in detail later in this chapter or in a subsequent
chapter.

***************************page_557***************************
532 Chapter 21

<assert.h>

<assert .h> header »24.1

<ctype.h>

<ctype .h> header »23.5

<errno.h>

<errno.h>header >24.2

<float.h>

<float .h> header »23.1

<limits.h>

<limits.h>header »23.2

<locale.h>

<locale.h> header >25, 1

<math.h>

<math.h> header »23.3

<setjmp.h>

<setjmp .h> header > 24.4

The Standard Library

Diagnostics

Contains only the assert macro, which allows us to insert self-checks into a pro-
gram. If any check fails, the program terminates.

Character Handling

Provides functions for classifying characters and for converting letters from lower
to upper case or vice versa.

Errors

Provides errno (‘error number”). an Ivalue that can be tested after a call of cer-
tain library functions to see if an error occurred during the call.

Characteristics of Floating Types

Provides macros that describe the characteristics of floating types, including their
range and accuracy.

Sizes of Integer Types

Provides macros that describe the characteristics of integer types (including char-
acter types), including their maximum and minimum values.

Localization

Provides functions to help a program adapt its behavior to a country or other geo-
graphic region. Locale-specific behavior includes the way numbers are printed
(such as the character used as the decimal point), the format of monetary values
(the currency symbol, for example). the character set, and the appearance of the
date and time.

Mathematics

Provides common mathematical functions. including trigonometric, hyperbolic,
exponential, logarithmic, power, nearest integer, absolute value, and remainder
functions.

Nonlocal Jumps

Provides the set jmp and longjmp functions. set-jmp “marks” a place in a pro-
gram; longjmp can then be used to return to that place later. These functions

***************************page_558***************************
<signal.h>

<signal .h> header »24.3

<stdarg.h>

<stdarg.h> header »26.1

<stdde£.h>

<stdde£ .h> header » 27.4

<stdio.h>

<stdio.h> header » 2?2.1-22.8

<stdlib.h>

<stdälib.h> header >26.2

<string.h>

<string .h> header »23.6

<time.h>

<time .h> headar »26.3

212  C89 Library Overview 533

make it possible to jump from one function into another, still-active function.
bypassing the normal function-return mechanism, setjmp and Iongjmp are
used primarily for handling serious problems that arise during program execution.

Signal Handling

Provides functions that deal with exceptional conditions (signals), including inter-
rupts and run-time errors. The signal function installs a l'unction to be called if a
given signal should occur later. The rai se function causes a signal to occur.

Variable Arguments

Provides tools for writing functions that, like print£f and scan£, can have a
variable number of arguments.

Common Definitions

Provides definitions of frequently used types and macros.

Input/Ouiput

Provides a large assortment of input/output functions. including operations on both
scquential and random-access files.

General Utilities

A “catchall* header for functions that don't fit into any of the other headers. The
functions in this header can convert strings to numbers, generate pseudo-random
numbers. perform memory management tasks, communicate with the operating
system. do searching and sorting. and perform conversions between multibyte
characters and wide characters.

String Handling
Provides functions that perform string operations, including copying, concatena-

tion, comparison, and searching, as well às functions that operate on arbitrary
blocks of memory.

Date and Time

Provides functions for determining the time (and date), manipulating times, and
formatting times for display.

***************************page_559***************************
534 Chapter 21 The Standard Library

213

<complex.h>

<complex .h> header »27.4

<fenv.h>

<fenv .h> header » 27.6

<inttypes.h>

<inttypes .h> header »27.2

<iso646.h>

<is0646 .h> header »25.3

C99 Library Changes

Some of the biggest changes in C99 affect the standard library. These changes fall
into three groups:

u Additional headers. The C99 standard library has nine headers that don°t exist
in C89. Three of these (csiso646.h>, <wchar.h>. and <wctype.h>)
were actually added to C in 1995 when the C89 standard was amended. The
other six (<ccomplex.h>, <fenv.h>., <inttypes.h>, <stdbool.h».
<stdint .h>, and <tgmath.h>)are new in C99.

wm Additional macros and functions. The C99 standard adds macros and fune-
tions to several existing headers, primarily <float.h>, <math.h>. and
<stdio.h>. The additions to the <math.h> header are so extensive that
they’re covered in à separate section (Section 23.4).

# Enhanced versions of existing functions. Some existing functions, including
print£ and scan£. have additional capabilities in C99.

We'1l now take a quick look at the nine additional headers in the C99 standard
library, just as we did in Section 21.2 for the headers in the C89 library.

Complex Arithmetic

Defines the complex and I macros, which are useful when working with com-
plex numbers. Also provides functions for performing mathematical operations on
complex numbers.

Floating-Point Environment

Provides access to floating-point status flags and control modes. For example, a
program might test a flag to see if overflow occurred during a floating-point opera-
tion or set a control mode to specify how rounding should be done.

Format Conversion of Integer Types

Defines macros that can be used in format strings for input/output of the integer
types declared in <stdint .h>. Also provides functions for working with great-
est-width integers.

Alternative Spellings

Defines macros that represent certain operators (the ones containing the characters
& |, —, !, and “). These macros are useful for writing programs in an environment
where these characters might not be part of the local character set.

***************************page_560***************************
<stdbool.h>

<stdbool .h> header » 21.5

<stdint.h>

<stdint .h> header >27.1

<tgmath.h>

<tgmath.h>header »27.5

<wchar.h>

<vchar .h> header > 25.5

<wctype.h>

<wcetype .h> header »25.6

21.4

214  The <stddef .h> Header: Common Definitions 535

Boolean Type and Values

Defines the boo1, true, and f alse macros, as well as a macro that can be used
to test whether these macros have been defined.

Integer Types

Declares integer types with specified widths and defines related macros (such as
macros that specify the maximum and minimum values of each type). Also defines
parameterized macros that construct integer constants with specific types.

Type-Generic Math

In C99, there are multiple versions of many math functions in the <math.h> and
<complex.h> headers. The “type-generic” macros in <tgmath.h> can detect
the types of the arguments passed Lo them and substitute a call of the appropriate
<math.h> or <complex.h> function.

Extended Multibyte and Wide-Character Utilities

Provides functions for wide-character input/output and wide string manipulation.

Wide-Character Classification and Mapping Utilities

The wide-character version of <ctype.h>. Provides functions for classifying
and changing the case of wide characters.

The <stddef .h> Header: Common Definitions

The <stdde£ .h> header provides definitions of frequently used types and mac-
ros; it doesn’t declare any functions. The types are:

u ptrdiff t. The type of the result when two pointers are subtracted.

u size t. The type returned by the sizeoË£ operator.

u wchar t. À type large enough to represent all possible characters in all sup-
ported locales.

A11 three are names for integer types: ptrdiff t must be a signed type, while
size t must be an unsigned type. For more information about wchar t, see
Section 25.2.

The <stddef .h> header also defines two macros. One of them is NULL,
which represents the null pointer. The other macro, of fsetof, requires two argu-
ments: /ype (a structure type) and rmember-designator (à member of the structure).

***************************page_561***************************
536

Chapter 21

fwrite function » 226

21.5

The Standard Library

offsetof computes the number of bytes between the beginning of the structure
and the specified member.
Consider the following structure:

struct s (
char a;
int b[2];
float c;

}

The value of of fsetof (struct s, a) must be 0: C guarantees that the first
member of a structure has the same address as the structure itself. We can't say for
sure what the offsets of b and c are. One possibility is that of fsetof (struct
s, b) is | (since a is one byte long), and of fsetof (struct s, c) is 9
(assuming 32-bit integers). However, some compilers leave ‘“holes’—unused
bytes—in structures (see the Q&A section at the end of Chapter 16), which can
affect the value produced by of fsetoË. If a compiler should leave a three-byte
hole after a, for example, then the offsets of b and c would be 4 and 12, respec-
tively. But that’'s the beauty of offsetoË: it produces the correct offsets for any
compiler, enabling us to write portable programs.

There are various uses for of fsetoË. For example. suppose that we want to
save the first two members of an s structure in a file. ignoring the c member.
Instead of having the £write function write sizeof (struct s) bytes, which
would save the entire structure, we'Il tell it to write only of fsetof (struct s,
c) bytes.

À final remark: Some of the types and macros defined in <stddef.h>
appear in other headers as well. (The NULL macro, for example. is also defined in
<locale.h>, <stdio.h>, <stdlib.h»>. <string.h>, and <time.hs.
as well as in the C99 header <wchar.h>.) As a result, few programs need 1o
include <stddef.h>.

The <stdbool.h> Header (C99): Boolean Type
and Values

The <stdbool .h> header defines four macros:

m bool (defined tobe Bool)

m true (defined to be 1)

u false (defined to be O)

um — bool true false are defined (defined to be 1)

We've seen many examples of how bool, true, and false are used. Potential
uses ofthe _ bool true false are defined macro are more limited. À
program could use a preprocessing directive (such as #i £ or #i FdeF) to test this
macro before attempting to define its own version of bool, true, or false.

***************************page_562***************************
Section 21.1

(D

..

.
n
.

6.

Q&A 537

Q & À

I notice that you use the term “‘standard header” rather than “standard
header file:” Is there any reason for not using the word ‘‘file””?

Yes. According to the C standard. a “standard header” need not be a file. Although
most compilers do indeed store standard headers as files, the headers could in fact
be built into the compiler itself.

Section 14.3 described some disadvantages of using parameterized macros in
place of functions. In light of these problems, isn°t it dangerous to provide a
macro substitute for a standard library function? [p. 531]

According to the C standard. a parameterized macro that substitutes for a library
function must be “fully protected” by parentheses and must evaluate its arguments
exactly once. These rules avoid most of the problems mentioned in Section !4.3.

Exercises

Locate where header fles are kept on your system. Find the nonstandard headers and deter-
mine the purpose of each.

Having located the header files on your system (see Exercise 1). find a standard header in
which a macro hides à function.

When a macro hides à function. which must come first in the header file: the macro defini-
tion or the function prototype? Justify your answer.

Make a list of all reserved identifiers in the ‘“future library directions” section of the C99
standard. Distinguish between identifiers that are reserved for use only when à specific
header is included versus identifiers that are reserved for use as external names.

The islower function. which belongs to <ctype.h>, tests whether à character 1s a
lower-case letter. Why would the following macro version of islower not be legal,
according to the C standard? (You may assume that the character set is ASCIL)

#+define islower (c) ((c) >= 'a' && (c) «= 'z')

The <ctype.h> header usually defines most of its functions us macros as well. These
macros rely on a static array that's declared in <ctype .h> but defined in a separate file. À
portion of à typical <ctype .h> header appears below. Use this sample to answer the fol-
lowing questions.

(a) Why do the names of the “bit” macros (such as__UPPER) and the _ctype array begin
with an underscore?

(b) Explain what the _ctype array will contain. Assuming that the character set is ASCIT.
show the values of the array elements at positions 9 (the horizontal tab character), 32 (the
space character), 65 (the letter A). and 94 (the “ character). Sce Section 23.5 for a descrip-
tion of what each macro should return.

***************************page_563***************************
538

Section 21 .2

Chapter 21

@ 7.

The Standard Library

(c) What's the advantage of using an array to implement thesc macros”

#define _UPPER 0x01 /* upper-case letter */
#define _LOWER 0x02 /* lower-case letter */
#define _DIGIT Ox04 /* decimal digit */
#define _CONTROL 0Ox08 /* control character */
#define _PUNCT Ox10 /* punctuation character */
#define _SPACE 0Ox20 /* white-space character */
#define _HEX Ox40 /* hexadecimal digit */
#define _BLANK Ox80 /* space character */
fdefine isalnum(c) (_ctype[c] & (_UPPER| LOWER| DIGIT))
}Hdefine isalpha(c) ( ctype[c] & ( UPPER| LOWER))
#define iscntrl(c) ( ctype[c] & _CONTROL)
#define isdigit(c) (_ctype[c] & _ DIGIT)
#define isgraph(c) ( ctype(c] &

(_PUNCT|_UPPER| LOWER| DIGIT))
idefine islower(c) (_ctype[c] & _LOWER)
Hdefine isprint(c) ( ctyvpe[c] &

(_BLANK| _ PUNCT| UPPER| LOWER| DIGIT))
#define ispunct (c) (_ctype[c] & _PUNCT)
#define isspace(c) (_ctype[c] & _SPACE)
#define isupper(c) ( ctype[c]) & _UPPER)
}Hdefine isxdigit (c) (_ctype[c] & ( DIGIT| HEX))

In which standard header would you expect to find each of the following?

(a) À function that determines the current day of the week

(b) À function that tests whether a character is a digit

(c) À macro that gives the largest unsigned int value

(d) À function that rounds à floating-point number to the next higher integer
(e) À macro that specifies the number of bits in a character

(f) À macro that specifies the number of significant digits in a double value
(g) À function that searches à string for a particular character

(h) A function that opens a file for reading

Programming Projects

Write a program that declares the s structure (see Section 21.4) and prints the sizes and off-
sets of the a, b, and c members. (Use sizeof to find sizes:; use of f setof to find off-
sets.) Have the program print the size of the entire structure as well. From this information,
determine whether or not the structure has any holes. If it docs, describe the location and
size of each.

***************************page_564***************************
22 Input/Output

In man-machine symbiosis, it is man
who must adjust: The machines can't.

C’s input/output library is the biggest and most important part of the standard
library. As befits its lofty status, we*1l devote an entire chapter (the longest in the
book) to the <stdio. h> header, the primary repository of input/output functions.

We've been using <stdio.h> since Chapter 2. and we have experience with
the print£, scanf. putchar. getchar. puts, and gets functions. This
chapter provides more information about these six functions, as well as introduc-
ing à host of new functions, most of which deal with files. Fortunately. many of the
new functions are closely related to functions with which we're already
acquainted. Eprint£. for instance, is the “file version” of the print£ function.

We'1l start the chapter with a discussion of some basic issues: the stream con-
cept, the FILE type, input and output redirection, and the difference between text
files and binary files (Section 22.1). We*Il then turn to functions that are designed
specifically for use with files, including functions that open and close files (Section
22.2). Afler covering print£. scan£. and related functions for “formatted”
input/output (Section 22.3), we'11 look at functions that read and write unformatted
data:

u getc, putc, and related functions, which read and write one character at a
time (Section 22.4).

#n gets, puts, and related functions, which read and write one line at a time
(Section 22.5).

= fread and fwrite. which read and write blocks of data (Section 22.6).

Section 22.7 then shows how to perform random access operations on files.
Finally, Section 22.8 describes the sprint£, snprint£. and sscan£ func-
tions, variants of print£ and scan£ that write to a string or read from a string.
This chapter covers all but eight of the functions in <stdio.h>. One of
these eight, the perror function, is closely related to the <errno .h> header, so

539

***************************page_565***************************
540

Chapter 22

æ

<wchar .h> header >25.5

221

Input/Output

111 postpone it until Section 24.2, which discusses that header. Section 26.1 covers
the remaining functions (vÉprint£. vprint£, vsprint£f. vsnprintË,
vÉfscan£, vscan£f, and vsscan£f). Thesc functions rely on the va_list type,
which 1s introduced in that section.

In C89, all standard input/output functions belong to <stdio.h>. but such is
not the case in C99, where some 1/O functions are declared in the <wchar .h>
header. The <wchar .h> functions deal with wide characters rather than ordinary
characters; the good news 1s that most of these functions closely resemble those of
<stdio.h>. Functions in <stdio.h> that read or write data are known as byte
input/output functions; similar functions in <wchar .h> are called wide-charac-
ter input/output functions.

Streams

In Ç, the term sfream means any source of input or any destination for output.
Many small programs, like the ones in previous chapters, obtain all their input
from one stream (usually associated with the keyboard) and write all their output to
another stream (usually associated with the screen).

Larger programs may need additional streams. These streams often represent
files stored on various media (such as hard drives, CDs, DVDs, and flash memory).
but they could just as easily be associated with devices that don’t store files: net-
work ports. printers, and the like. We'Il concentrate on files, since they*re common
and easy to understand. (l may even occasionally use the term /i/e when I should
say stream.) Keep in mind, however, that many of the functions in <stdio.h>
work equally well with all streams, not just the ones that represent files.

File Pointers

Accessing a stream in a C program is done through a fîle pointer, which has type
FILE * (the FILE type 1s declared in <stdio.h>). Certain streams are repre-
sented by file pointers with standard names; we can declare additional file pointers
as needed. For example, if a program needs two streams in addition to the standard
ones, it might contain the following declaration:

FILE *fp1, *fp2;

À program may declare any number of FILE * variables, although operating sys-
tems usually limit the number of streams that can be open at one time.

Standard Streams and Redirection

<stdio.h> provides thrce standard streams (Table 22.1). These streams arc
ready to use—we don’t declare them. and we don’t open or close them.

***************************page_566***************************
Table 22.1
Standard Streams

 

22.1  Streams 541

 

 

File Pointer Stream Default Meaning
stdin Standard input Keyboard
stdout Standard output Screen
stderr Standard error Screen

 

 

 

The functions that we've used in previous chapters—print£. scanf.
putchar. getchar, puts, and gets—obtain input from stdin and send out-
put to stdout. By default, stdin represents the keyboard; stdout and
stderr represent the screen. However. many operating systems allow these
default meanings to be changed via a mechanism known as redirection.

Typically. we can force a program to obtain its Input from a file instead of
from the keyboard by putting the name of the file on the command line, preceded
by the < character:

demo <in.dat

This technique, known as input redirection, essentially makes the stdin stream
represent « file (in . dat, in this case) instead of the keyboard. The beauty of redi-
rection is that the demo program doesn°t realize that it's reading from in. dat: as
lar as it knows, any data it obtains from stdin is being entered at the keyboard.

Output redirection is similar. Redirecting the stdout stream is usually done
by putting a file name on the command line. preceded by the > character:

demo >out.dat

AÎI data written to stdout will now g0 into the out . dat file instead of appear-
ing on the screen. Incidentally, we can combine output reclirection with input redi-
rection:

demo <in.dat >sout.dat

The < and > characters don*t have to be adjacent to file names. and the order in
which the redirected files are listed doesn't matter, so the followine examples
would work just as well:

demo < in.dat > out.dat
demo >out.dat <in.dat

One problem with output redirection is that evervthing written to stdout is
put into a file. If the program goes off the rails and begins writing error messages.
we won't see them until we look at the file. This is where stderr comes in. By
writing error messages to stderr instead of stdout, we can guarantee that
those messages will appear on the screen even when stdout has been redirected.
(Operating systems often allow stderr itself to be redirectecl, though.)

Text Files versus Binary Files

<stdio.h> supports two kinds of files: text and binary. The bytes in a text file
represent characters, making it possible for a human to examine the file or edit IL.

***************************page_567***************************
542

Chapter 22

QaÂ

Q&ÂÀ

little-endian order > 20.3

Input/Ouiput

The source code for a C program is stored in a text file, for example. In a binary
file, on the other hand, bytes don’t necessarily represent characters; groups of
bytes might represent other types of data, such as integers and floating-point num-
bers. An executable C program 1s stored in a binary file, as you’Il quickly realize if
you try to look at the contents of one.

Text files have two characteristics that binary files don’t possess:

m Text files are divided into lines. Each line in a text file normally ends with
one or two special characters; the choice of characters depends on the operat-
ing system. In Windows, the end-of-line marker is a carriage-return character
("\x0d') followed immediately by a line-feed character (" \x0a'). In
UNIX and newer versions of the Macintosh operating system (Mac OS). the
end-of-line marker is a single line-feed character. Older versions of Mac OS
use a single carriage-return character.

wm Text files may contain a special ““end-of-file” marker. Some operating sys-
tems allow a special byte to be used as a marker at the end of a text file. In
Windows, the marker 1s " \x1a' (Ctrl-Z). There’s no requirement that Ctrl-Z
be present, but 1f it 18, 1t marks the end of the file; any bytes after Ctrl-Z are to
be ignored. The Ctrl-Z convention is a holdover from DOS, which in turn
inherited it from CP/M, an early operating system for personal computers.
Most other operating systems, including UNIX, have no special end-of-file
character.

Binary files aren’t divided into lines. In a binary file, there are no end-of-line or
end-of-file markers; all bytes are treated equally.

When we write data to a file, we'Il need to consider whether to store it in text
form or in binary form. To see the difference, consider how we might store the
number 32767 in a file. One option would be to write the number in text form as
the characters 3, 2, 7, 6, and 7. IË the character set is ASCII. we'd have the follow-
ing five bytes:

00110011‘00110010|00110111,00110110‘00110111

 

I3l l2l l7l l6l I7l

The other option 1s to store the number in binary, which would take as few as two

bytes:
'01111111|11111111l

(The bytes will be reversed on systems that store data in little-endian order.) Às
this example shows, storing numbers in binary can often save quite a bit of
space.

When we're writing a program that reads from a file or writes to a file, we
need to take into account whether 1Cs à text file or a binary file. À program that dis-
plays the contents of a file on the screen will probably assume it’s a text file. À file-

 

***************************page_568***************************
222

fopen

restrict keyword > 17.8

æ

/

escape sequences > 7.3

 

22.2  File Operations 543

copying program, on the other hand, can’t assume that the file to be copied is a text
file. 1f it does, binary files containing an end-of-file character won*t be copied
completely. When we can’t say for sure whether a file is text or binary, it’s safer to
assume that it’s binary.

File Operations

Simplicity is one of the attractions of input and output redirection; there’s no need
to open a file, closc a file, or perform any other explicit file operations. Unfortu-
nately, redirection is too limited for many applications. When a program relies on
redirection, it has no control over its files: it doesn’t even know their names. Worse
still, redirection doesn*t help if the program needs to read from two files or write to
two files at the same time.

When redirection isn’t enough, we’Il end up using the file operations that
<stdio.h> provides. In this section. we’1l explore these operations. which
include opening a file, closing a file, changing the way a file is buffered, deleting a
file, and renaming a file.

Opening a File

FILE *fopen (const char * restrict filename,
const char * restrict mode) ;

Opening a file for use as a stream requires a call of the fopen function. fopen's
first argument is a string containing the name of the file to be opened. (A “file
name” may include information about the file’s location. such as a drive specifier
or path.) The second argument is a ‘“mode string” that specifies what operations we
intend to perform on the file. The string "r", for instance, indicates that data will
be read from the file, but none will be written to it.

Note that restrict appears twice in the prototype for the fopen function.
restrict, which is a C99 keyword, indicates that f i lename and mode should
point to strings that don’t share memory locations. The C89 prototype for fopen
doesn't contain restrict but is otherwise identical. restrict has no effect
on the behavior of £open. so it can usually just be ignored. In this and subsequent
chapters, lll italicize restrict as a reminder that it’s a C99 feature.

 

Windows programmers: Be careful when the file name in à call of fopen includes
the \ character, since C treats \ as the beginning of an escape sequence. The call

fopen ("c:\project\testl.dat", "r")

will fail, because the compiler treats \t as a character escape. (\p isn‘t a valid
character escape, but it looks like one. The C standard states that its meaning is

***************************page_569***************************
544

Chapter 22

Table 22.2
Mode Strings
for Text Files

Input/Output

undefined.) There are two ways to avoid the problem. One is to use \\ instead of

\:
Fopen ("c:\\project\\testl.dat", "r")
The other technique is even easier—just use the / character instead of \:

fopen ("c:/project/testl.dat", "r")

Windows will happily accept / instead of \ as the directory separator.

 

fopen returns a file pointer that the program can (and usually will) save in a
variable and use later whenever 1t needs to perform an operation on the file. Here’s
à typical call of fopen, where É£p is a variable of type FILE *:

p = fopen("in.dat", "r") ; /* opens in.dat for reading */

When the program calls an input function to read from in.dat later, it will sup-
ply £p as an argument.

When it can1 open a file, fopen returns a null pointer. Perhaps the file
doesn't exist, or it’s in the wrong place, or we don‘t have permission to open it.

 

Never assume that a file can be opened; always test the return value of fopen to
make sure 1t’s nol a null pointer.

 

Modes

Which mode string we'Il pass to Éopen depends not only on what operations we
plan to perform on the file later but also on whether the file contains text or binary
data. To open a text file, we’d use one of the mode strines in Table 22.2.

 

 

 

 

String Meaning

"r" Open for readine

w" Open for writing (file need not exist)

"a" Open for appending (file necd not exist)

"r+" _ Open for reading and writine. starting at beginning
"y+" ; Open for reading and writing (truncate 1f file exists)
"a+" - Open for reading and writing (append if file exists)

 

When we use fopen to open a binary file, we'll need to include the letter b in
the mode string. Table 22.3 lists mode strines for binary files.

From Tables 22.2 and 22.3, we see that <stdio.h> distinguishes between
writing data and appending data. When data 1s written to a file, it normally over-
writes what was previously there. When a file 1s opened for appending. however.
data written to the file 1s added at the end, thus preserving the file’s original contents.

By the way, special rules apply when a file is opened for both reading and writ-
ing (the mode string contains the + character). We can‘tswitch from reading to writ-

***************************page_570***************************
Table 22.3
Mode Strings for
Binary Files

file-positioning funclions » 22. 7

fclose

QaÂÀ

22.2  File Operations 545

 

 

 

 

String Meaning

"rb" Open for reading

"wb" Open for writing (file need not exist)

"ab" Open Ffor appending (file need not exist)
tr+b" or "rb+" _ Open for rcading and writing, starting at beginnine
"w+b" or "wb+" _ Open for reading and writing (truncate Iif file exists)
"a+b" or "'ab+" _ Open for reading and writing (append if file exists)

 

ing without first calling a file-positioning function unless the reading operation
encountered the end of the file. Also, we can‘t switch from writing to reading with-
out either calling fflush (covered later 1n this section) or calling a file-positioning
function.

Closing a File

int fclose (FILE *stream) ;

The fclose function allows à program to close « file that 1t’s no longer using.
The argument to fclose must be a file pointer obtained from a call of fopen or
freopen (discussed later in this section). fclose returns zero if the file was
closed successfully; otherwise, 1t returns the error code EOF (a macro defined in
<stdio.h>).

To show how £open and fclose are used in practice, here’s the outline of a
program that opens the file example. dat for reading, checks that it was opened
successfully, then closes it before terminating:

#include <stdio.h>
#include <stdlib.h>

#define FILE NAME "example.dat"

int main (void)

{

FILE *fp;

fp = fopen (FILE NAME, "r") ;

if (fp == NULL) {
printf ("Can't open %s\n", FILE NAME) ;
exit (EXIT FAILURE) ;

}

Éclose (£p) ;
return 0;

}

Of course, C programmers being the way they are, it’s not unusual to see the call of
fopen combined with the declaration of fp:

FILE *fp = fopen (FILE NAME, "r");

***************************page_571***************************
546

Chapter 22

freopen

QaÂÀ

Input/Output

or the test against NULL:

if ((£fp = fopen (FILE NAME, "r")) == NULL)

Attaching a File to an Open Stream

FILE *Éfreopen(const char * restrict filename,
const char * restrict mode,
FILE * restrict stream) ;

freopen attaches a different file to a stream that’s already open. The most com-
mon use of freopen is to associate a file with one of the standard streams
(stdin, stdout, or stderr). To cause a program to begin writing Lo the file
Foo, for instance, we could use the following call of £reopen:

if (freopen("foo", "w", stdout) == NULL) {
/* error; foo can't be opened */
}

After closing any file previously associated with stdout (by command-line redi-
rection or a previous call of freopen), freopen will open foo and associate it
with stdout.

Éfreopen'’s normal return value 1s its third argument (a file pointer). If it can't
open the new file, freopen returns a null pointer. (freopen 1gnores the error 1f
the old file can*t be closed.)

C99 adds a new twist. If £ilename is a null pointer, £reopen attempts to
change the stream’s mode to that specified by the mode parameter. Implementa-
Lions aren’t required to support this feature. however: 1f they do, they may place
restrictions on which mode changes are permitted.

Obtaining File Names from the Command Line

When we’re writing a program that will need to open a file. one problem soon
becomes apparent: how do we supply the file name to the program” Building file
names into the program itself docsn’t provide much flexibility, and prompting the
üser to enter file names can be awkward. Often, the best solution 1s to have the pro-
gram obtain file names from the command line. When we execute a program
named demo, for example, we might supply it with file names by putting them on
the command line:

demo names.dat dates.dat

In Section 13.7, we saw how to access command-line arguments by defining
main as a function with two parameters:

int main(int argc, char *argv[])

{
}

***************************page_572***************************
PROGRAM

canopen.c

 

22.2  File Operations 547

argc is the number of command-line arguments; argv is an array of pointers to
the argument strings. argv [0] points to the program name, argv[1] through
argv [argc-1] point to the remaining arguments. and argv [argc] is a null
pointer. In the example above, argc is 3, argv [0] points Lo a string containine
the program name, argv [1] points to the string "names.dat". and argv(2)
points to the string "dates. dat":

argv

—* program name

 

 

——> n|/a|m|e |s | ..|d|a|t \o

 

—_—»; d|a|t |e|s|.|d{|a|t \o

 

 

 

 

 

 

 

 

 

 

 

Checking Whether a File Can Be Opened

The following program determines if à file exists and can be opened for reading.
When the program is run, the user will give it a file name to check:

canopen file

The program will then print cither file can be opened or file can't be
opened. If the user enters the wrong number of arguments on the command line,
the program will print the message usage : canopen filename to remind the
user that canopen requires a single file name.

/* Checks whether a file can be opened for reading */

fiinclude <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])

(

FILE *fp;

if£ (argc != 2) (
print£ ("usage: canopen filename\n'") ;
exit(EXIT_FAILURE):

}

L£ ((fp = fopen(argv[1], "r")) == NULL) {
print£f("%s can't be opened\n", argv/[1]) ;
exit (EXIT FAILURE) ;

;

print£("%s can be opened\n", argv[1]) ;
Éclose (£p) ;
return 0;

***************************page_573***************************
548

Chapter 22

tmpfile

tmpnam

Input/Output

Note that we can use redirection 10 discard the output of canopen and simply test
the status value it returns.

Temporary Files

FILE #*tmpfile (void) ;
char *tmpnam(char *s) ;

Real-world programs often need to create temporary files—files that exist only as
long as the program 1s running. C compilers. for instance, often create temporary
files. À compiler might first translate a C program to some intermediate form,
which Il stores in a file. The compiler would then read the file later as it translates
the program lo object code. Once the program 1s completely compiled, there's no
need to preserve the file containing the program’s intermediate form. <stdio.h>
provides two functions. tmpfile and tmpnam, for working with temporary files.

tmpfile creates a temporary file (opened in "wb+" mode) that will exist
unül 1s closed or the program ends. À call of tmp£ile returns a file pointer that
can be used to access the file later:

FILE *tempptr;

tempptr tmpfile () ; /* creates a temporary file */

[f it fails to create a file. tmp£ile returns a null pointer.

Although tmpfile 1s easy to use, it has a couple of drawbacks: (1) we don’t
know the name of the file that tmpfile creates, and (2) we can’t decide later to
make the file permanent. If these restrictions turn out to be a problem. the alterna-
tive 1S to create a temporary file using £open. Of course, we don’t want this file to
have the same name as a previously existing File, so we need some way to generate
new file names; that's where the tmpnam function comes in.

tmpnam generates a name for a temporary file. If its argument is a null

pointer, tmpnam stores the file name 1n a static variable and returns à pointer to it:
char *filename ;
£ilename = tmpnam (NULL) ; /* creates a temporary file name */

Otherwise, tmpnam copies the file name into a character array provided by the
programmer:

char filename [L _ tmpnam] ;
tmpnam (filename) ; /* creates a temporary file name */

In the latter case. Empnam also returns a pointer to the first character of this array.
L _ tmpnamis a macro in <stdio.h> that specifies how long to make a character
array that will hold à temporary file name.

***************************page_574***************************
fflush

QaÂÀ

22.2  File Operations 549

 

Be sure that tmpnam’s argument points to an array of at least L_tmpnam charac-
ters. Also. be careful not to call tmpnam too often; the TMP_MAX macro (defined
in <stdio.h>) specifies the maximum number of temporary file names that can
potentially be generated by tmpnam during the execution of à program. If it fails
to generate a file name, tmpnam returns a null pointer.

 

File Buffering

int fflush(FILE *stream) ;

void setbuft (FILE * restrict stream,
char * restrict buË) ;

int setvbuf (FILE * restrict stream,
char * restrict buf,
int mode, size t size);

Transferring data to or from a disk drive is a relatively slow operation. Às a result.
it isn°t feasible for a program to access a disk file directly each time it wants to
read or write a byte. The secret to achieving acceptable performance is buffering:
data written to a stream is actually stored in a buffer area in memory; when it’s full
(or the stream is closed), the buffer 1s ‘’flushed’”’ (written to the actual output
device). Input streams can be buffered in a similar way: the buffer contains data
from the input device; input is read from this buffer instead of the device itself.
Buffering can result in enormous gains in efficiency, since reading a byte from a
buffer or storing a byte in a buffer takes hardly any time at all. Of course, it takes
time to transfer the buffer contents to or from disk, but one large “block move” 1s
much faster than many tiny byte moves.

The functions in <stdio .h> perform buffering automatically when it seems
advantageous. The buffering takes place behind the scenes. and we usually don‘t
worry about it. On rare occasions. though. we may need to take a more active role.
IF so, we can use the functions £flush. setbuf. and setvbuf.

When a program writes outpul to a file, the data normally goes into a buffer
first. The buffer is flushed automatically when it's full or the file 1s closed. By call-
ing fflush, however, a program can flush à file’s buffer as often as it wishes. The
call

fflush(fp) ; /* flushes buffer for £p */
flushes the buffer for the file associated with fp. The call
fflush (NULL) ; /* flushes all buffers */

flushes a!/ output streams. f flush returns zero if it’s successful and EOF if an
error oceurs.

***************************page_575***************************
550 Chapter 22

setvbuf

setbuf

Input/Ouitput

setvbuf allows us to change the way a stream is buffered and to control the
size and location of the buffer. The f'unction’s third argument. which specifies the
Kind of buffering desired, should bc one of the following macros:

u _IOFBF (full buffering). Data is read from the stream when the buffer is
empty or written to the stream when it's full.

u _IOLBF (line buffering). Data is read from the stream or written to the stream
one line at a time.

u _IONBF (no buffering). Data is read from the stream or written to the stream
directly, without a buffer.

(AIL three macros are defined in <stdio.h>.) Full buffering is the default for
streams that aren’t connected to interactive devices.

setvbu£'s second argument (if it’s not a null pointer) is the address of the
desired buffer. The buffer might have static storage duration, automatic storage
duration, or even be allocated dynamically. Making the buffer automatie allows its
space to be reclaimed automatically at block exit: allocating it dynamically enables
us to free the buffer when it’s no longer needed. setvbu£'s last argument is the
number of bytes in the buffer. À larger buffer may give better performance: a
smaller buffer saves space.

For example, the following call of setvbuf changes the buffering of
stream to full buffering, using the N bytes in the buf fer array as the buffer:

char buf£er (N] ;

setvbuf (stream, buffer, _IOFBF, N);

 

setvbu£ must be called after stream 1s opened but before any other operations
arc performed on 1t.

 

It’s also legal to call setvbu£ with a null pointer as the second argument.
which requests that setvbuf create a buffer with the specified size. setvbuf
returns Zero If it’s successful. It returns a nonzero value if the mode argument is
invalid or the request can*t be honored.

setbuf 1s an older function that assumes default values for the buffering
mode and buffer size. If bu£ is à null pointer, the call setbuf (stream, buËf)
is equivalent to

(void) setvbuf (stream, NULL, _IONBF, O);
Otherwise, it’s equivalent to
(void) setvbuf (stream, buf, _IOFBF, BUFSIZ) ;

where BUFSIZ is à macro defined in <stdio.h>. The setbuf f'unction is con-
sidered obsolete; it’s not recommended for use in new programs.

***************************page_576***************************
remove

rename

22.3

22.3  Formatted I/O 551

 

When using setvbuË or setbuË, be sure to close the stream before its buffer 1s
deallocated. In particular, if the buffer 1s local to a function and has automatic stor-
age duration, be sure to close the stream before the l'unction returns.

 

Miscellancous File Operations

int remove (const char *filename) ;
int rename (const char *old, const char *nevw) ;

The functions remove and rename allow a program to perform basic file man-
agement operations. Unlike most other functions in this section, remove and
rename work with file names instead of file pointers. Both functions return zero
if they succeed and a nonzero value 1f they fail.

remove deletes a file:

remove (" foo") ; /* deletes the file named "foo" */

lf a program uses fopen (instead of tmp£file) to create à temporary file, it can
use remove to delete the file before the program terminates. Be sure that the file
to be removed has been closed; the effect of removing a file that’s currently open 1s
implementation-defined.

rename changes the name of a file:

rename ("foo", "bar") ; /* renames "foo" to "bar" */

rename is handy for renaming à temporary file created using £open if a program
should decide to make it permanent. If à file with the new name already exists, the
effect is implementation-defined.

 

If the file to be renamed is open, be sure to close it before calling rename: the
function may fail if asked to rename an open file.

 

Formatted I/O

In this section, we*1l examine library functions that use format strings to control
reading and writing. These functions, which include our old friends print£ and
scanf, have the ability to convert data from character form to numeric form dur-
ing input and from numeric form to character form during output. None of the
other O functions can do such conversions.

***************************page_577***************************
552

Chapter 22

fprintf
printf

ellipsis »26.1

v.…printf functions » 26.1

Input/Output

The .print£ Functions

int fprintf (FILE * restrict stream,
const char * restrict £ormat, ...);
int printf (const char * restrict format, ...);

The fprint£ and print£ functions write a variable number of data items
to an output stream, using à format string to control the appearance of the output.
The prototypes for both functions end with the . . . symbol (an ellipsis). which
indicates a variable number of additional arguments. Both functions return the
number of characters written: a negative return value indicates that an error
occurred.

The only difference between print£ and fprintf is that print£ always
writes to stdout (the standard output stream), whereas fprint£ writes to the
stream indicated by its first argument:

printf ("Total: %d\n"', total) ; /* writes to stdout */
{Iprintf (fp, "Total: %d\n', total) ; /* writes to fp */

À call of print£ is equivalent to a call of £print£ with stdout as the first
argument.

Don't think of fprintf as merely a function that writes data to disk files,
though. Like many functions in <stdio.h>, fprintf works fine with any out-
put stream. In fact, onc of the most common uses of fprint f—writing crror
messages to stderr, the standard error stream—has nothing to do with disk files.
Here’s what such a call might look like:

Eprintf (stderr, "Error: data file can't be opened.\n") ;

Writine the message to stderr guarantees that it will appear on the screen even
if the user redirects stdout.

There are two other functions in <stdio.h> that can write formatted output
{o a stream. These functions, named v£fprint£ and vprintE. are fairly
obscure. Both rely on the va_list type. which is declared in <stdarg.h>, so
they're discussed along with that header.

…print£ Conversion Specifications

Both print£ and fprint£ require a format string containing ordinary charac-
ters and/or conversion specifications. Ordinary characters are printed as is; conver-
sion specifications describe how the remaining arguments are to be converted to
character form for display. Section 3.1 described conversion specifications briefly.
and we added more details in later chapters. We'll now review what we know
about conversion specifications and fill in the remaining gaps.

À .…print£ conversion specification consists of the % character. followed by
as many as five distinct items:

***************************page_578***************************
Table 22.4
Flags for …print£
Functions

22.3  Formatted I/0 553

 

 

 

 

 

 

 

 

 

conversion
flags precision … specifier
Ÿ Ÿ Y
3|#0|112/.5/L|g
! |
minimum length

field width modifier

Here’s a detailed description of these items, which must appear in the order shown:

e Flags (optional; more than one permitted). The - flag causes left justification
within à field; the other fMags affect the way numbers are displayed. Table 22.4
gives a complete list of flags.

 

 

 

 

 

 

 

Flag Meaning |

- Left-justify within field. (The default 1s right justification.)

+ Numbers produced by signed conversions always begin with + or -. (Normally,
only negative nuinbers are preceded by à sign.) |

space … Nonnegative numbers produced by signed conversions are preceded by a space.
(The + flag overrides the space flag.)

# Octal numbers begin with 0, nonzero hexadecimal numbers with Ox or OX.
Floatine-point numbers always have a decimal point. Trailing Zeros aren’1
removed from numbers printed with the g or G conversions.

0 Numbers are padded with leading zeros up to the field width. The O flag 1s

(zero) — ignored if the conversion 1s d. i, O, u, x, or X and a precision is specified. (The

- flag overrides the O flag.)

 

= Minimum field width (optional). An item thal’s too small to occupy this num-
ber of characters will be padded. (By default, spaces are added to the left of
the item, thüs right-justifvine it within the field.) An item that’s too large for
the field width will still be displayed in its entirety. The field width 1s either an
integer or the character *. IF * 1s present, the field width 1s obtained from the
next argument. If this argument 1s negative. 1s treated as a positive number
preceded by a - flag.

u Precision (optonal). The meaning of the precision depends on the conversion:

d. i, O, u, X. X: minimum number of digits

(leading zeros are added 1f the number has fewer digits)

a, À, e, E, f, F: number of digits after the decimal point

q, G: number of significant digits
s: maximum number of bytes

The precision ts a period (. ) followed by an integer or the character *. If * 1s
present, the precision 1s obtained from the next areument. (1f this argument 1s
negative, the effect is the same as not specifying a precision.) IF only the
period 1s present, the precision 1s Zero.

***************************page_579***************************
554 Chapter 22 Input/Output

= Length modifier (optional). The presence of à length modifier indicates that
the 1tem to be displayed has a type that’s longer or shorter than is normal for a
particular conversion specification. (For example. %d normally refers to an
int value; %hd is used to display a short int and %1d is used to display a
long int.) Table 22.5 lists each length modifier, the conversion specifiers
with which it may be used, and the type indicated by the combination of the
two. (Any combination of length modifier and conversion specifier not shown
in the table causes undefined behavior.)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Table 22.5 Length |
Length Modifiers for Modifier — Conversion Specifiers Meaning |
«print£ Functions hh* d,i.o,u. x. X signed char. unsigned char [

n signed char *
h d.i.o,u.x. X short int. unsigned short int ‘
n short int *
l d.i.o.u.x.X long int, unsigned long int
(ell) n long int *
C wint t
S wchar t*
a,A.e E, fÉ.F.g.G no effect
117 d.i,o,u.x,X long long int. unsigned long long int
(ell-ell) n long long int *
j' d.i,o.u.x,X intmax t,uintmax t ;
n intmax_t *
A d.i.o.u.x.X size t î
n size t* ;
t* d, i, o.u, x, X ptrdiff t
n ptrdif£ t*
L a, À, e, E, f, F, g,.G long double
*C99 only

= Conversion specifier. The conversion specifier must be one of the characters
listed in Table 22.6. Notice that £, F, @, E, g, G, a, and A are all designed to
write double values. However, they work fine with £loat values as well;
default argument promotions »-9.3 thanks to the default argument promotions. float areuments are converted
automatlically to double when passed to a function with a variable number of
arguments. Similarly, a character passed to …printf is converted automati-
cally to int. so the c conversion works properly.

 

Î Be careful to follow the rules described here; the effect of using an invalid conver-
sion specification 1s undefined.

 

***************************page_580***************************
Table 22.6
Conversion Specifiers for
…print£ Functions

æ

greatest-width integers >27,7

22.3  Formatted I/0 555

 

Conversion
Specifier

iMeaning

 

d,i

Converts an int value to decimail form.

 

o,u,.x, X

Converts an unsigned int value to base 8 (0o). base ! (u). or base 16
(x, X). x displays the hexadecimal digits a—£ in lower case: X displays
them in upper case,

 

f, F!

Converts à double vulue to decimal form, putting the decimal point in
the correct position. If no precision 1s specified, displays six digits after
the decimal point.

 

e E

Converts a double value to scientific notation. If no precision is speci- |
fied, displays sIx digits after the decimal point. If @ 1s chosen. the expo-
nent is preceded by the letter e; if E 1s chosen, the exponent is preceded

by E.

 

g. G

g converts a double value to cither £ form or e form. € forin is selected
if the number’s exponent 1s less than — or greater than or equal to the
precision. Trailing zeros are not displayed (unless the # fag 1s used); a
decimal point appears only when followed by à digit. G chooses between
F and E forms.

 

Converts a double value to hexadecimal scientific notation using the
form [-]0xA.hhhhpxd, where [-] 1s an optional minus sign, the hs rep-
resent hex digits, + 1s either à plus or minus sign, and d is the exponent. d
is a decimal number that represents a power of 2. If no precision is speci-
filed. enough digits are displayed after the decimal point to represent the
exact value of the number (1f possible). à displays the hex digits a—£ in
lower case; A displays them in upper case. The choice of à or À also
affects the case of the letters x and p.

 

Displays an int value as an unsigned character.

 

Writes the characters pointed to by the argument. Stops writing when the
number of bytes specified by the precision (1f present) 1s reached or a null
character is encountered.

 

"O

Converts a void * value to printable form.

 

J

The corresponding argument must point to an object of type int. Stores
in this object the number of characters written so far by this call of
…printÉ; produces no output.

 

°
<

 

Writes the character %.

 

*C99 only

C99 Changes to ….print£ Conversion Specifications

The conversion specifications for print£ and fprint£ have undergone à num-
ber of changes in C99:

= Additional length modifiers. C99 adds the hh. 11, j, z, and t leneth modifi-
ers. hh and 11 provide additional length options, j allows greatest-width inte-
gers to be written. and z and t make it easier to write values of type size t
and ptrdif£ t, respectively.

***************************page_581***************************
556

Chapter 22

IEEE floating-point standard >23.4

wide characters » 25.2

Table 22.7

Effect of Flags on
the d Conversion

Input/Output

m Additional conversion specifiers. C99 adds the F, a, and A conversion specifi-

ers. F 1s the same as £ except for the way in which infinity and NaN (see
below) are written. The à and A conversion specificalions are rarely used.
They're related to hexadecimal floating constants, which are discussed in the
Q&A section at the end of Chapter 7.

m Ability to write infinity and NaN. The IEEE 754 floating-point standard

allows the result of a floating-point operation to be infinity, negative infinity.
or NaN (Cnot a number”). For example. dividing !.0 by 0.0 yields positive
infinity. dividing —!.0 by 0.0 yields negative infinity, and dividing 0.0 by 0.0
yields NaN (because the result 1s mathematically undefined). In C99, the a, A,
e, E, £, F, g, and G conversion specifiers arc capable of converting these spe-
cial values to à form that can be displayed. a, e, £. and g convert positive
infinity to in£ or infinity (cither one is legal), negative infinity to -inf
or -infinity, and NaN to nan or -nan (possibly followed by a series of
characters enclosed in parentheses). A, E. F. and G arc equivalent to a. e. £.
and g. except that upper-case letters are used (INF. INFINITY, NAN).

æ Support for wide characters. Another C99 feature is the ability of fprint£f

to write wide characters. The 1c conversion specification is used to write a
single wide character; 31s Is used for a string of wide characters.

Previously undefined conversion specifications now allowed. In C89, the
effect of using le, %1E, S1£, %1g. and 31G is undefined. These conversion
specifications are legal in C99 (the 1 length modifier 1s simply ignored).

FExamples of …print£ Conversion Specifications

Whew! Is about time for à few examples. We've seen plenty of everyday conver-
sion specifications in previous chapters, so we'll concentrate here on illustrating
some of the more advanced ones. Às in previous chapters. Il use ® to represent

the space character.

Let’s start off by examining the effect of flags on the %d conversion (they have
a similar effect on other conversions). The first line of Table 22.7 shows the effect
of 8d without any flags. The next four lines show the effect of the -. +. space,
and O flags (the # flag 1s never used with %d). The remaining lines show the effect

of combinations of flags.

 

 

 

Conversion — Result of Applying = Result of Applying

Specification = Conversion to 123 — Conversion to —123
<8d eoo0o0e123 eooe-123
2-8d 123ec0606 -123000e
*+8d 000123 ceooe-123
% Bd eeoo0e123 ee…oe-123
<08d 00000123 -0000123
s-+8d +1230e000 -123e000
%- B8d 12300080 —-123e00e
=+08d +0000123 -0000123
< 08d e0000123 -0000123

 

 

***************************page_582***************************
Table 22.8
Effect of the # Flag

Table 22.9

Effect of Minimum Field
Width and Precision on
the &s Conversion

Table 22.10
Examples of the
%g Conversion

22.3  Formatted |/0 557

Table 22.8 shows the effect of the # llag on the o. x, X, g. and G conversions.

 

 

 

Conversion — Result of Applying — Result of Applying
Specification = Conversion to 123 _ Conversion to 123.0
380 …….73
*#B0 oo.0(0)1]"73
2.8x 0.00h
=#8x o0o0e0x7b
s&x e…0….0/FRr
z#ax <……0X7B
389 ...3
s#8g 123.000
*8G eoooo]223
N <#B8G e123.000

 

 

 

In previous chapters, we‘ve used the minimum field width and precision
when displaying numbers, so there’s no point in more examples here. Instead,
Table 22.9 shows the effect of the minimum field width and precision on the %s

 

 

conversion.
Result of Applying = Result of Applying
Conversion Conversion to Conversion to
Specification "bogus" "buzzword"
+6S eboqus buzzword
+-6S bogus®e buzzword
.4S bogu buzz
$6.4S eebogu eebuzz
+-6.4S boguee buzzee

 

 

 

 

Table 22.10 illustrates how the %g conversion displays some numbers in e
form and others in $f form. AIl numbers in the table were written using the % . 49
conversion specification. The first two numbers have exponents of at least 4, so
they’re displayed in $e form. The next eight numbers are displayed in $£ form.
The last two numbers have exponents less than —4, so they’re displayed in %e

 

 

 

form.
Result of Applying % . 4g
Number Conversion to Number
123456. 1.235e+05
12345.6 1.235e+04
1234.56 1235
123.456 123.5
12.3456 12.35
1.23456 1.235
123456 0.1235
0123456 0.01235
.00123456 0.001235
.000123456 0.0001235
.0000123456 1.235e-05
00000 123456 1.235e-06

 

 

 

***************************page_583***************************
558

Chapter 22

iscanf
scanf

Input/Ouiput

[In the past, we've assumed that the minimum field width and precision were
constants embedded 1n the format string. Putting the * character where either num-
ber would normally go allows us to specify it as an argument afrer the format
string. For example. the following calls of print£ all produce the same output:

print£f("%6.4d", i);

printf£f("=*.4d", 6, i);
printf("%6.*d", 4, i);
print£("%*.+d", 6, 4, i);

Notice that the values to be filled in for the * come just before the value to be dis-
played. À major advantage of *, by the way. is that it allows us to use à macro to
specify the width or precision:

print£("%*d", WIDTH, i);
We can even compute the width or precision during program execution:
print£("%*d", page width / num cols, i);

The most unusual specifications are %p and $n. The %p conversion allows us
to print the value of a pointer:

print£("*p", (void *) ptr); /* displays value of ptr */

Although p 1s occasionally useful during debugging, it’s not a feature that most
programmers use on a daily basis. The C standard doesn’t specify what a pointer
looks like when printed using %p, but it’s likely to be shown as an octal or hexa-
decimal number.

The %n conversion 1s used to find out how many characters have been printed
so far by à call of .printE£. For example, after the call

print£("%d%n\n", 123, &len}) ;

the value of 1en will be 3, since print£ had written 3 characters (123) by the
time it reached %n. Notice that & must precede len (because %n requires a
pointer) and that 1en itself isn°t printed.

The …scanf Functions

int Escanf (FILE * restrict stream,
const char * restrict format, ...);
int scanf (const char * restrict format, ...);

Éscan£ and scan£ read data items from an input stream, using a format string to
indicate the layout of the input. After the format string. any number of pointers—
euach pointing to an object—follow as additional arguments. Input items are con-
verled (according to conversion specifications in the format string) and stored in
thesc objects.

***************************page_584***************************
æ

mullibyte characters » 25.2

idiom

white-space characters » 3.2

22.3  Formatited I/0O 559

scanf always reads fromn stdin (the standard input stream), whereas
fscanf£ reads from the stream indicated by 1ts first argument:

scanf ("$d%$d", &i, &]j); /* reads from stdin */
Éscanf (fp, "%“d&d", &i, &j); /* reads from £fp */

À call of scan£ 1s equivalent to à call of £scanf with stdin as the first argu-
ment.

The …scanf£ functions return prematurely 1f an irput failure occurs (no more
input characters could be read) or if a matching failure occurs (the input charac-
ters didn’t match the format string). (In C99. an input failure can also oceur
because of an encoding error, which means that an attempt was made lo read a
multibyte character, but the input characters didn’t correspond to any valid multi-
byte character.) Both functions return the number of data items that were read and
assigned to objects; they return EOF 1l an input failure occurs before any data items
can be read.

Loops that test scan£'s return value are common in C programs. The follow-
ing loop. for example, reads a series of integers one by one. stopping at the first
sign of trouble:

while (scanf("%d", &i) == 1) |

}

…scanf Format Strings

Calls of the ….scanf functions resemble those of the ….printf functions. That
similarity can be misleading, however; the …scan£ functions work quite differ-
ently from the …printf functions. It pays to think of scan£ and £scant as
“pattern-matching” functions. The format string represents a pattern that a
…Scanf function attempts to match as it reads input. If the input doesn't match
the format string, the function returns as soon as it detects the mismatch; the input
character that didn’t match 1s “pushed back” to be read in the future.
À .…scanf£ format string may contain three things:

w Conversion specifications. Conversion specifications in a …scan£ format
string resemble those in a….printf£ format string. Most conversion specifica-
tions skip white-space characters at the beginning of an input item (the excep-
tions are $ [. $c, and Sn). Conversion specifications never skip trailine white-
space characters, however. If the input contains e1237, the %d conversion
specification consumes e, 1, 2, and 3, but leaves 9 unread. (l’m using e to
represent the space character and © to represent the new-line character.)

= White-space characters. One or more consecutive white-space characters In a
…Scanf format string match zero or more white-space characters in the input
stream.

= Non-white-space characters. À non-white-space character other than % matches
the same character in the input stream.

***************************page_585***************************
560

Chapter 22

Table 22.11
Length Modifiers f'or
…scanf Functions

Input/Output

For example, the format string "ISBN %d-%d-%1d-%d" specifies that the
Input will consist of:

the letters ISBN

possibly some white-space characters

an integer

the - character

an integer (possibly preceded by white-space characters)

the - character

a long integer (possibly preceded by white-space characters)

the - character

an integer (possibly preceded by white-space characters)

…scan£f Conversion Specifications

Conversion specifications for ….scan£ functions are actually à little simpler than
those for ….print£ functions. À …scan£ conversion specification consists of the
character % followed by the items listed below (in the order shown).
m * (optional). The presence of * signifies assigmment suppression: an input
item is read but not assigned to an object. llems matched using # aren°
included in the count that …scan£ returns.

= Maximuim field width (optional). The maximum field width limits the number
of characters in an input item: conversion of the item ends if this number is
reached. White-space characters skipped at the beginning of a conversion
don’t count.

#s Length modifier (optional). The presence of à length modifier indicates that the
object in which the input item will be stored has à type that’s longer or shorter
than is normal for a particular conversion specification. Table 22.11 lists each
length modifier, the conversion specifiers with which it may be used. and the
type indicated by the combination of the two. (Any combination of length mod-
ifier and conversion specifier not shown in the table causes undefined behavior.)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Lengtli
Modifier _ Conversion Specifiers Meaning
hh* d.i.o.u.x.X.n signed char *, unèiâned char *
h d. JÎ o.u.x.X.n e short int * unsigned short int *
l d.i.0o,u.x.X,n long int *. unsigned long int * u
(el) - aAe. E f.FgG = double *
c.s.or ( wchar t*
C 01 d.i,o.u.x. X.n long long int *,
(ell-ell) unsigned long long int *
‘ j' diouxxn _ intmax_t * uintmax t*
A d.i.o.u,x, X.n size t* C
t* d,i,o,u, x. X.n ptrdiff t*
L a,À.e. E. £.F.g.G long double *

 

 

 

 

*C99 only

***************************page_586***************************
 

Table 22.12
Conversion Specifiers for
.….scanf Functions

 

22.3  Formatited /0 561

=m Conversion specifier. The conversion specifier must be one of the characters
listed in Table 22.12.

 

 

 

 

 

 

Conversion
Specifier MVeaninge ;
d Matches a decimal integer; the corresponding argument is assumed to
have type int *.
i Matches an integer; the corresponding argument is assumed to have type
int *. The integer is assumed to be in base 10 unless it begins with O
(indicating octal) or with Ox or OX (hexadecimal).
O Matches an octal integer; the corresponding argument is assumed to have
type unsigned int *.
u Matches a decimal integer; the corresponding argument is assumed to {
have type unsigned int *. Ç
. ° ° ° î
x.x Matches a hexadecimal integer: the corresponding argument is assumed

to have type unsigned int *.

Matches a floating-point number; the corresponding argument is
assumed to have type float *. In C99, the number can be infinity or
NaN. ;

 

Matches n characters, where n is the maximum field width. or one char-
acter if no field width is specified. The corresponding argument is
assumed to be a pointer to à character array (or à character object. if no
field width is specified). Doesn't add a null character at the end.

 

Matches a sequence of non-white-space characters, then adds à null char-
acter at the end. The corresponding argument is assumed to be à pointer
to a character array.

 

Matches à nonempty sequence of characters from a scanset, then adds à
null character at the end. The corresponding argument is assumed to be a
pointer to à character array.

 

Matches à pointer value in the form that ..print£ would have written
I. The corresponding argument is assumed to be a pointer to a void *
object.

 

The corresponding argument must point to an object of type int. Stores
in this object the number of characters read so far by this call of
…Scan£. No input is consumed and the return value of …scanf isn’
affected.

 

©
<

 

Matches the character %.

 

‘C99 only

Numeric data items can always begin with « sign (+ or -). The o. u. x, and X
specifiers convert the item to unsigned form, however, so they’re not normally used
to read negalive numbers.

The [ specifier is a more complicated (and more flexible) version of the s
specifier. À complete conversion specification using [ has the form % [ser] or
% [“ser] , where ser can be any set of characters. (If ] is one of the characters in
set.however, it must come first.) % [se/] matches any sequence of characters in ser
(the scanset). % [*ser] matches any sequence of characters not in ser (in other
words, the scanset consists of all characters not in ser). For example. % [abc]

***************************page_587***************************
562 Chapter 22

numeric convarsion functions > 26.2

Table 22.13
Correspondence between
…Scanf Conversion
Specifiers and Numeric
Conversion Functions

/

Input/Ouiput

matches any string containing only the letters a, b. and c. while % [*abc]
matches any string that doesn*{ contain a, b. or c.

Many of the ….scanf conversion specifiers are closely related to the numeric
conversion functions in <stdlib.h>. These functions convert stings (like
"-297") to their equivalent numeric values (-297). The d specifier. for example,
looks for an optional + or - sign, followcd by à series of decimal digits; this is
exactly the same form that the strtol function requires when asked to convert a
string to a decimal number. Table 22.13 shows the correspondence between con-
version speciliers and numeric conversion functions.

 

 

Conversion
Specifier Viunneric Conversion Function

d strtol with 10 as the base
i strtol with 0 as the base
O strtoul with 8 as the base
u strtoul with !O as the base

x. X strtoul with 16 us the base

a.A,e, E,f,F.g.G  strtod

 

 

 

 

[t pays to be careful when writing calls of scan£. An invalid conversion specifica-
llon in a scan£ format string is just as bad as onc in a printf format strine;
either one causes undefined behavior.

 

C99 Changes to …scan£ Conversion Specifications

The conversion specifications for scanf and fscanf have undergone some
changes in C99, but the list isn’Las extensive as it was for the .printf functions:

« Additional length modifiers. C99 adds the hh. 11. j. z. and t length modifi-
ers. These correspond to the length modifiers in .printf conversion specifi-
cations.

# Additional conversion specifiers. C99 adds the F. a. and A conversion specifi-

ers. They're provided for symmetry with …print£: the …scanf functions
treat them the same as e, E, f, g, and G.

« Ability to read infinity and NaN. Just as the .printf functions can write
infinity and NaN, the …scan£ functions can read these values. To be read
properly, they should have the same appearance as values written by the
—print£ functions, with case being ignored. (For example, either INF or
in£ will be read as infinity.)

# Support for wide characters. The …scan£ functions are able to read multi-
byte characters, which are then converted to wide characters for storage. The
1C conversion specification is used to read a single multibyte character or a

***************************page_588***************************
223  Formatited I/0 563

sequence of multibyte characters: 31s is used to read a string of multibyte
characters (a null character is added at the end). The 1 [ser] and 31 [“ser]
conversion specifications can also read a string of multibyte characters.

scanf Examples

The next three tables contain sample calls of scan£. Each call is applied to the
input characters shown to its right. Characters printed in stäkeeut are consumed
by the call. The values of the variables after the call appear to the right of the in-
put.

The examples in Table 22.14 show the effect of combining conversion specifi-
cations, white-space characters, and non-white-space characters. In three cases no
value is assigned to j, so it retains its value from before the call of scan£. The
examples in Table 22.15 show the effect of assignment suppression and specifying
à field width. The examples in Table 22.16 illustrate the more esoteric conversion
specifiers (i, [. and n).

 

 

 

 

 

 

 

 

 

 

Table 22.14 scan£ Call Input Variables
scanf Examples n = scanf("%dsd", &i, &j); 32—0, 8340 n |
(Group !) i: 12
j: unchanged
n = scan£f("%d,%d", &i, &]); 120,0340 n: |
i: 12
j: unchanged
n = scanf("%d ,%d", &i, &3); 224340 n: 2
i: 12
j: 34
n = scanf ("%d, %d", &i, &j);  2420,e340 n: l
i: 12
j: unchanged
Table 22.15 scan£ Call Input Variables
scan£ Examples n = scanf("%*tdgd", &i); — 124340 n: l
(Group 2) i: 34

 

n = SC8.I‘1f("%*S%S", str) ; ixeIadyg n: |
Ÿ
str: "Fair"

 

 

n = scanf ("%1d%2d%3d", 123450 n: 3
&i, &j, &k); i: l
j: 23
k: 45
n = scanf ("%2d%2s%2d", 1234560 n: 3
&i, str, &]); i: 12
str:"34"

 

 

j: 56

 

***************************page_589***************************
564

Chapter 22

Table 22.16
scanf Examples
(Group 3)

clearerr

Input/Output

 

 

 

 

 

 

 

 

scan£f Call Input Variables

n = scan£f("%i%sisi"', e&i, &j, &k); 12+012—06420  N:3

i: 12

j: 10

k: 18
n = scanf ("%[0123456789]", str); 123abc5 n: |

str: "123"
n = scanf ("%[0123456789]"', str); abc1232 n:0

str:

unchanged
n = scanf ("*[°0123456789]", str);  abe1230 n: l

str: "abc"
n = scan£f("%*dsd&n", &i, &j); 3042003000 n: l

i: 20

j:5

 

Detecting End-of-File and Error Conditions

void clearerr (FILE *stream) ;
int feof (FILE *stream) ;
int ferror (FILE *stream) ;

If we ask a .scan£ function to read and store n data items. we expect its return
value to be ». If the return value is less than n, something went wrong. There are
three possibilities:

= End-of-file. The function encountered end-of-file before matching the format
string completely.

# Read error. The function was unable to read characters from the stream.

= Matching failure. À data item was in the wrong format. For example, the
function might have encountered a letter while searching for the first digit of
an integer,.

But how can we tell which Kind of failure occurred? In many cases, it doesn‘t mat-
ter: something went wrong, and we’ve got to abandon the program. There may be
times, however, when we"1l need to pinpoint the reason for the failure.

Every stream has two indicators associated with it: an error indicator and an
end-of-file indicator. These indicators are cleared when the stream is opened. Not
surprisingly, encountering end-of-file sets the end-of-file indicator. and à read error
sets the error indicator. (The error indicator is also set when a write error occurs on
an output stream.) À matching failure doesn’t change either indicator.

Once the error or end-of-file indicator is set, it remains in that state until it's
explicitly cleared, perhaps by à call of the clearerr function. clearerr clears
both the end-of-file and error indicators:

clearerr (fp) ; /* clears eof and error indicators for p */

***************************page_590***************************
QaÂÀ

feof
ferror

QaÂÀ

223  Formatted |/O 565

clearerr isn't needed often, since somc of the other library functions clear one

or both indicators as a side effect.
We can call the Feof and ferror functions to test a stream’s indicators Lo

determine why a prior operation on the stream failed. The call £eof (£p) returns
a nonzero value if the end-of-file indicator is set for the stream associated with fp.
The call ferror (fp) returns a nonzero value if the error indicator is set, Both
functions return zero otherwise.

When scanf returns a smaller-than-expected value. we can use feoË£ and
ferror to determine the reason. I! feof returns a nonzero value. we‘ve reached
the end of the input file. If £error returns a nonzero value, a read error occurred
during input. If neither returns a nonzero value, a matching failure must have oc-
curred. Regardless of what the problem was, the return value of scanf£ tells us
how many data items were read before the problem occurred.

To see how feof and ferror might be used, let’s write a function that
searches a file for a line that begins with an integer. Here's how we intend to call
the function:

n = find _int ("foo") ;

" foo" is the name of the file to be searched. The function returns the value of the
integer that it finds, which 1s then assigned to n. If à problem arises—the file can t
be opened, a read error oceurs, or no line begins with an integer—find_int will
return an error code (—1. —2, or —3, respectively). TIl assume that no line in the file
begins with a negalive integer.

int find int (const char *filename)

{
FILE *fp = fopen(filename, "r") ;
int n;
if (fp == NULL)
return -1; /* can't open file */
while (fscanf (fp, "%d", &n) != 1) {
if (ferror(fp)) {
Éclose (fp) ;
return -2; /* read error */
}
if (feof(fp)) {
fclose (£p) ;
return -3; /* integer not found */
}
fscan£ (fp, "%*["\n]") ; /* skips rest of line */
}
fclose (fp) ;
return n;
}

The while loop's controlling expression calls fscan£f in an attempt Lo read an
integer from the file. If the attempt fails (Éscan£ returns a value other than !).

***************************page_591***************************
 

566

Chapter 22

22.4

putchar

fputc
putc

QaA

Input/Output

find_int calls ferror and feof to see if the problem was a read error or end-
of-file. If not, fscanf must have failed because of a matching error, so
£ind _int skips the rest of the characters on the current line and tries again. Note
the use of the conversion %* [“\n] to skip all characters up to the next new-line.
(Now that we know about scansets, it’s time to show off!)

Character |/O

In this section, we'll examine library functions that read and write single charac-
ters. These functions work equally well with text streams and binary streams.

You’1! notice that the functions in this section treat characters as values of type
int, not char. One reason is that the input functions indicate an end-of-file (or
error) condition by returning EOF, which is à negative integer constant.

Output Functions

int fputc(int c, FILE *stream) ;
int putc(int c, FILE *stream) ;
int putchar (int C) ;

putchar writes one character to the stdout stream:
putchar (ch) ; /* writes ch to stdout */

fputc and putc are more general versions of putchar that write a character Lo
an arbitrary stream:

fputc (ch, fp) ; /* writes ch to £p */
putc(ch, fp) ; /* writes ch to fp */

Although putc and fputc do the same thing, putc is usually implemented
as a macro (as well as a function), while £putc is implemented only as a function.
putchar itself is usually a macro defined in the following way:

tdefine putchar(c) putc((c), stdout)

[t may seem odd that the library provides both putc and Éputc. But, as we saw
in Section 14.3. macros have several potential problems. The C standard allows the
putc macro to cvaluate the stream argument more than once, which fputc
isn°t permitted to do. Although programmers usually prefer putc, which gives a
faster program, fputc is available as an alternative.

If à write error occurs, all three functions set the error indicator for the stream
and return EOF; otherwise, they return the character that was written.

***************************page_592***************************
getchar

fgetc
getc

idiom

22.4  Character I/O 567

Input Functions

int fgetc (FILE *stream) ;

int getc (FILE *stream) ;

int getchar (void) ;

int ungetc(int c, FILE *stream) ;

getchar reads a character From the stdin stream:
ch = getchar () ; /* reads a character from stdin */
fgetc and getc read a character from an arbitrary stream:

ch = Égetc(fp) ; /* reads a character from £p */
ch = getc (fp); /* reads a character from fp */

All three functions treat the character as an unsigned char value (which is then
converted to int type before it’s returned). Às a result, they never return a nega-
tive value other than EOF.

The relationship between getc and fgetc 1s similar to that between putc
and fputc. getc is usually implemented as a macro (as well as a function).
while f£getc is implemented only as a function. getchar 1s normally a macro as
well:

#define getchar() getc(stdin)

For reading characters from a file, programmers usually prefer getc over Égetc.
Since getc is normally available in macro form, it tends to be faster. £getc can
be used as a backup if getc isn’t appropriate. (The standard allows the getc
macro to evaluate its argument more than once, which may be a problem.)

The fgetc, getc, and getchar functions behave the same if a problem
occurs. At end-of-file. they set the stream’s end-of-file indicator and return EOF. If
a read error occurs. they set the stream’s error indicator and return EOF. To differ-
entiate between the two situations, we can call either feof or ferror.

One of the most common uses of fgetc, getc, and getchar 1s to read
characters from a file, one by one, until end-of-file occurs. It’s customary to use the
following while loop for that purpose:

while ((ch = getc(fp)) != EOF) (|

7

After reading a character from the file associated with £p and storing it in the vari-
able ch (which must be of type int), the while test compares ch with EOF. If
ch isn’t equal to EOF, we*re not at the end of the file yet, so the body of the loop 1s
executed. If ch is equal to EOF, the loop terminates.

***************************page_593***************************
568 Chapter 22

ungetc

isdigit function »23.5

file-positioning functions » 22. 7

PROGRAM

fcopy.c

Input/Ouitput

 

Always store the return value of fgetc. getc, or getchar in an int variable,
not à char variable. Testing à char variable against EOF may give the wrong
result.

 

There’s one other character input function, ungetc, which “pushes back”
a character read from a stream and clears the stream’s end-of-file indicator.
This capability can be handy if we need a “lookahead” character during input.
For instance, to read a series of digits, stopping at the first nondigit, we could
Write

while (isdigit(ch = getc(fp))) |

}

ungetc (ch, £fp); /* pushes back last character read */

The number of characters that can be pushed back by consecutive calls of
ungetc—with no intervening read operations—depends on the implementation
and the type of stream involved; only the first call is guaranteed to succeed. Calling
à file-positioning function (Eseek, fsetpos. or rewind) causes the pushed-
back characters Lo be lost.

ungetc returns the character it was asked to push back. However, it returns
EOF if an attempt is made to push back EOF or to push back more characters than
the implementation allows.

Copying a File

The following program makes a copy of a file. The names of the original file and
Lhe new file will be specified on the command line when the program is executed.
For example, Lo copy the file £1 .c to f2. c. we'd use the command

fcopy Él.c £2.c

Écopy will issue an error message if there aren’t exactly two file names on the
command line or if either file can‘t be opened.

/* Copies a EFile */

finclude <stdio.h>
finclude <stdlib.h>

int main(int argc, char *argv[])

FILE *source _fp, *dest fp;
int ch;

***************************page_594***************************
 

22.5  Line [/0 569

if (arge != 3) (
Éprintf (stderr, "usage: fcopy source dest\n") ;
exit (EXIT FAILURE) ;

}

i£ ((source fp = fopen(argv{1], "rb")) == NULL) {
Eprint£ (stderr, "Can't open %s\n", argv[1]);
exit (EXIT FAILURE) ;

}

if ((dest_fp = fopen(argv[2], "wb")) == NULL) {
Eprintf(stderr, "Can't open %s\n", argv[2]);
fclose(source_fp);
exit (EXIT FAILURE) ;

}

while ((ch = getc(source fp)) != EOF)
putc(ch, dest fp);

Éclose (source _Ep) ;
fclose (dest Ep);
return 0;

Using "rb" and "wb" us the file modes enables fcopy to copy both text and
binary files. If we used "r" and "w" instead. the program wouldn't necessarily be
able to copy binary files.

22.5 Line I/O

We'IL now turn to library functions that read and write lines. These functions are
Used mostly with text streams, although it's lesal to use them with binäry streams
as well.

Output Functions

int fputs(const char * restrict s,
FILE * restrict stream) ;
int puts(const char *s);

puts  We encountered the puts function in Section 13.3: it writes a string of characters
to stdout:

puts("Hi, there!”") ; /* writes to stdout */

After it writes the characters in the string, puts always adds a new-line character.

***************************page_595***************************
570

Chapter 22

fputs

gets

fgets

Input/Output

Eputs is a more general version of puts. Îts second argument indicates the
stream to which the output should be writien:

Éputs("Hi, there!", fp); /* writes to fp */

Unlike puts, the Éputs function doesn’t write a new-line character unless one is
present in the string.

Both functions return EOF if a write error occurs: otherwise, they return à
nonnegative number.

Input Functions

char *fgets(char * restrict s, int nB,
FILE * restrict stream) ;
char *gets (char *s) ;

The gets function, which we first encountered in Section 13.3. reads a line of
input from stdin:

gets (str) ; /* reads a line from stdin */

gets reads characters one by one, storing them in the array pointed to by str,
until it reads a new-line character (which it discards).

fgets is a more general version of gets that can read from any stream.
Êgets is also safer than gets, since it limits the number of characters that it will
store. Here’s how we might use £gets, assuming that str is the name of a char-
acter array:

Égets(str, sizeof (str), fp); /* reads a line from fp */

This call will cause fgets to read characters until it reaches the first new-line
character or sizeof (str) — | characters have been read, whichever happens
first. If it reads the new-line character, £gets stores it along with the other charac-
ters. (Thus, gets never stores the new-line character, but Égets sometimes does.)

Both gets and fgets return a null pointer if a read error occurs or they
reach the end of the input stream before storing any characters. (As usual, we can
call feof or ferror to determine which situation occurred.) Otherwise, both
return their first argument. which points to the array in which the input was stored.
Âs you’d expect, both functions store a null character at the end of the string.

Now that you know about fgets, l’d suggest using it instead of gets in
most situations. With gets, there’s always the possibility of stepping outside the
bounds of the receiving array, so it’s safe to use only when the string being read is
guaranteed to fit into the array. When there’s no guarantee (and therce usually
Isn°{), il’s much safer to use Egets. Note that fgets will read from the standard
input stream if passed stdin as its third argument:

fgets(str, sizeof (str), stdin) ;

***************************page_596***************************
22.6

Q&À
fwrite

fread

22.6  Block /0O 571

Block l/O

size t fread(void * restrict ptr,
size t size, size t nmemb,
FILE #* restrict stream) ;
size t fwrite (const void * restrict ptr,
size t size, size t nmemb,
FILE * restrict stream) ;

The fread and £write functions allow a program to read and write large
blocks of data in a single step. £read and fwrite are used primarily with
binary streams, although—with care—it's possible to use them with text streams

as well.

fwrite is designed to copy an array from memory to a stream. The first
argument in a call of fwrite 1s the array's address, the second argument 1s the
size of each array element (in bytes), and the third argument is the number of ele-
ments to write. The fourth argument 1s a file pointer, indicating where the data
should be written. To write the entire contents of the array a, for instance, we
could use the following call of fwrite:

fwrite(a, sizeof (a[0]), sizeof (a) / sizeof (a[0]), fp);

There’s no rule that we have to write the entire array; we could just as easily
write any portion of it. fwrite returns the number of elements (nor bytes) actu-
ally written. This number will be less than the third argument if a write error oc-
CUrs.

fread will read the elements of an array from a stream. fread'’s arguments

are similar to £write's: the array's address, the size of each element (in bytes).
the number of elements to read, and a file pointer. To read the contents of a file into
the array a, we might use the following call of fread:

n = fread(a, sizeof(a[0]), sizeof(a) / sizeof(a[0]), Éfp);

It’s important to check £fread’s return value, which indicates the actual number of
elements (nor bytes) read. This number should equal the third argument unless the
end of the input file was reached or a read error occurred. The feof and ferror
functions can be used to determine the reason for any shortage.

 

Be careful not to confuse fread's second and third arguments. Consider the fol-
lowing call of £read:

fread(a, 1, 100, Éfp)

We’re asking fread to read 100 one-byte elements, so it will return a value

***************************page_597***************************
572

Chapter 22

22.17

iseek

Input/Output

between O and 100. The following call asks Fread to read one block of 100
bytes:

fread(a, 100, 1, fp)

Éread's return value in this case will be either O or |.

 

Ewrite is convenient for a program that needs to store data in a file before
terminating. Later, the program (or another program. for that matter) can use
Eread to read the data back into memory. Despité appearances, the data doesn’t
need to be in array form; fread and £write work just as well with variables of
all kinds. Structures, in particular, can be read by fread or written by fwrite.
To write a structure variable s to a file, for instance. we could use the following
call of fwrite:

Ewrite(&s, sizeof(s), 1, £p);

 

Be careful when using fwrite to write out structures that contain pointer values;
these values aren’t guaranteed to be valid when read back in.

 

File Positioning

int fgetpos(FILE * restrict stream,
fpos t * restrict pos);
int fseek (FILE *stream, long int offset, int whence) ;
int fsetpos (FILE *stream, const Épos t *pos) ;
long int ftell (FILE *stream) ;
void rewind(FILE *stream) ;

Every stream has an associated file position. When a file is opened, the file posi-
lion 1s set at the beginning of the file. (IF the file is opened in “append” mode. how-
ever, the initial file position may be at the beginning or end of the file, depending
on the implementation.) Then, when a read or write operation is performed, the file
position advances automatically. allowing us to move through the file in a sequen-
tial manner.

Although sequential access is fine for many applications. some programs need
the ability to jump around within a file, accessing some data here and other data
there. [[ a file contains a series of records. for example, we might want to jump
directly to à particular record and read it or update it. <stdio.h> supports this
form of access by providing five functions that allow a program to determine the
current file position or to change it.

The £seek function changes the file position associated with the first argu-
ment (a file pointer). The third argument specifies whether the new position is to

***************************page_598***************************
îtell

errno variable > 24.2

22.7  File Positioning 573

be calculated with respect to the beginning of the file, the current position, or the
end of the file. <stdio .h> defines three macros for this purpose:

SEEK SET = Beginning of file
SEEK _ CUR = Current file position
SEEK END — Endoffile

The second argument is a (possibly negative) byte count. To move to the beginning
of a file, for example, the seek direction would be SEEK SET and the byte count
would be zero:

Îseek(£p, OL, SEEK SET) ; /* moves to beginning of£ file */
To move to the end of a file, the seek direction would be SEEK_END:
Îseek(fp, OL, SEEK END) ; /* moves to end of file */

To move back 10 bytes, the seek direction would be SEEK_CUR and the byte count
would be —10:

fseek(fp, -10L, SEEK CUR) ; /* moves back 10 bytes */

Note that the byte count has type long int, so l’ve used OL and -10L as areu-
ments. (O and -10 would also work, of course. since arguments are converted Lo
the proper type automatically.)

Normally. fseek returns zero. lf an error occurs (the requested position
dloesn’t exist. for example), fseek returns à nonzero value.

The file-positioning functions are best used with binary streams. by the way. C
doesn’t prohibit programs from using them with text streams. but care is required
because of operatine system differences. fseek In particular is sensitive to
whether à stream 1s text or binary. For text streams, either (1) of fset (fseek's
second argument) must be zero or (2) whence (its third argument) must be
SEEK _SET and of£fset a value obtained by a previous call of ftell. (In other
words, we can only use £seek to move to the beginning or end of a text stream or
to return to a place that was visited previously.) For binary streams, fseek isn’t
required to support calls in which whence is SEEK _ END.

The ftel1l function returns the current file position as a long integer. (If an
error occurs, ftell returns -1L and stores an error code in errno.) The value
returned by ftell may be saved and later supplied to a call of £seek. making it
possible to return to a previous file position:

long file pos;
file pos = ftell (fp); /* saves current position */

Éseek(fp, file pos, SEEK SET) ; /* returns to old position */

If £p 1s a binary stream, the call fte11 (fp) returns the current file position as a
byte count. where zero represents the beginning of the file. If £p is a text stream,
however, £tell (fp) isn't necessarily a byte count. Às a result, 1t’s best not Lo
perform arithmetic on values returned by ftell. For example, il’‘s not a good

***************************page_599***************************
574 Chapter 22

rewind

fgetpos
fsetpos

QaA

PROGRAM

invclear.c

Input/Output

idea to subtrac! values returned by £tell to see how far apart two file positions
are.

The rewind function sets the file position at the beginning. The call
rewind (fp) is nearly equivalent to fseek (£p, OL, SEEK SET). The dif-
ference? rewind doesn’t return a value but does clear the error indicator for fp.

Êseek and £tell have one problem: they're limited to files whose posi-
tions can be stored in à long integer. For working with very large files, C pro-
vides two additional functions: fgetpos and fsetpos. These functions can
handle large files because they use values of type Epos_ t lo represent file posi-
tions, An fpos_t value isn’t necessarily an integer: it could be a structure, for
instance.

The call fgetpos(fp, &file pos) stores the file position associated
with £p in the £ile_pos variable. The call £setpos (£p, &file pos) sets
the file position for £p to be the value stored in £ile pos. (This value must have
been obtained by a previous call of fgetpos.) If a call of £getpos or fsetpos
fails, it stores an error code in errno. Both functions return zero when they suc-
ceed and a nonzero value when they fail.

Here's how we might use Égetpos and £setpos to save a file position and
return to it later:

fpos t file pos;
Égetpos (fp, &file pos) ; /* saves current position */

Ésetpos (fp, &file pos) ; /* returns to old position */

Modifying a File of Part Records

The following program opens a binary file containing part structures, reads the
structures into an array, sets the on_hand member of each structure to O, and then
writes the structures back to the file. Note that the program opens the file in
"rb+" mode, allowing both reading and writing.

/* Modifies a file of part records by setting the quantity
on hand to zero for all records */

#include <stdio.h>
#include <stdlib.h>

#define NAME LEN 25
#define MAX PARTS 100

struct part |
int number;
char name [NAME LEN+1] ;
int on hand;

} inventory [MAX PARTS] ;

***************************page_600***************************
22.8

 

22.8  String l/O 575

int num parts;

int main(void)

{
FILE *fp;
int i;
if ((fp = fopen("inventory.dat", "rb+")) == NULL) {
Eprint£(stderr, "Can't open inventory file\n") ;
exit(EXIT_FÀILURE);
}

num _ parts = fread(inventory, sizeof (struct part),
MAX PARTS, fp);

for (i = 0; i < num parts; i++)
inventory [i] .on hand = 0;

rewind ( fp) ;
EÉwrite (inventory, sizeof (struct part), num parts, fp);
fclose (fp) ;

return 0;

;

Calling rewind is critical, by the way. After the fread call, the file position is at
the end of the file. IŸ we were to call fwrite without calling rewind first,
Ewrite would add new data to the end of the file instead of overwriting the old
data.

String I/O

The functions described in this section are à bit unusual, since they have nothing to
do with streams or files, Instead, they allow us to read and write data using a string
as though it were a stream. The sprintf and snprintf functions write charac-
ters into a string in the same way they would be written to a stream: the sscanf
function reads characters from a string as though it were reading from a stream.
These functions, which closely resemble printf and scanf, are quite useful.
sprintf and snprint£ give us access to printf's formattine capabilities
without actually having to write data to a stream. Similarly, sscan£ gives us
access to scanf s powerful pattern-matching capabilities. The remainder of this
section covers sprintf, snprint£, and sscanf in detail.

Three similar functions (vsprint£. vsnprint£, and vsscanf£f) also
belong to <stdio.h>. However, these functions rely on the va_list type,
which is declared in <stdarg.h>. l'Il postpone discussing them until Section
26.1, which covers that header.

***************************page_601***************************
576

Chapter 22

sprintf

snprintf

Input/Ouitput

Output Functions

int sprintf (char * restrict s,

const char * restrict format, ...);
int snprintf(char * restrict s, size t n,
const char * restrict format, ...) ;

Note: In this and subsequent chapters, the prototype for a function that 1s new In
C99 will be in italics, Also, the name of the function will be italicized when it
appears in the left margin.

The sprint£ function 1s similar to print£ and fprintE£. except that it writes
output into a character array (pointed to by its first argument) instead of à stream.
sprint£'s second argument is a format string identical to that used by printf
and fprint£. For example. the call

sprintf (datec, "%d/%d/$d", 9, 20, 2010);

will write "9/20/2010" into date. When it’s finished writing into a string,
sprint£ adds a null character and returns the number of characters stored (not
counting the null character). If an encoding error occurs (a wide character could
not be translated into a valid multibyte character), sprint£ returns a negative
value.

sprintf has à variety of uses. For example. we might occasionally want to
format data for output without actually writing 1t. We can use sprintf to do the
formatting, then save the result in à string until il’'s time to produce output.
sprintf 1s also convenient for converting numbers to character form.

The snprintf function 1s the same as sprintf, except for the additional
parameter n. No more than n — | characters will be written to the string. not count-
ing the terminating null character. which 1s always written unless n is zero. (Equiv-
alently, we could say that snprint£ writes at most n characters to the string, the
last of which 1s a null character.) For example, the call

snprint£ (name, 13, "%s, %s", "Einstein", "Albert") ;

will write "Einstein, Al" intoname.

snprint£ returns the number of characters that would have been written
(not including the null character) had there been no length restriction. If an encod-
Ing error occurs. snprinté returns a negative number. To see if snprintE£ had
room to write all the requested characters, we can test whether its return value was
nonnegative anc less than n.

Input Functions

int sscanf (const char * restrict s,
const char * restrict format, ...) ;

***************************page_602***************************
sscanf

 

Q&A 577

The sscan£ function is similar t scan£ and fscanf. except that it reads from
à string (pointed to by its first areument) instead of readine from a stream.
sscanf£ ‘s second argument is a format string identical to that used by scanf and
Éscan£.

sscanf is handy for extracting data from a string that was read by another
input function. For example, we might use fgets to obtain a line of input, then
pass the line to sscan£ for l'urther processing:

fgets(str, sizeof(str), stdin); /* reads a line of input */
sscanf (str, "%d%d", &i, &j); /* extracts twvo integers */

One advantage of using sscanf instead of scanf or fscanf is that we can
examine an input line as many times as needed, not just once, making it easier to
recognize alternate input forms and to recover from errors. Consider the problem
ofreading a date that’s written either in the form month/day/vear or month-day-
year. Assuming that str contains a line of input, we can extract the month. day.
and year as follows:

if (sscanf(str, "%d /%d /%d", &month, &day, &year) == 3)
print£ ("Month: %d, day: %d, year: %d\n"', month, day, year) ;
else if (sscanf (str, "%d -%d -%d", &month, &day, &year) == 3)

print£("Month: %d, day: %d, year: %d\n", month, day, year) ;
else
printf ("Date not in the proper form\n'") ;

Like the scan£ and £fscan£ functions, sscanf returns the number of data
items successfully read and stored. sscanf returns EOF if it reaches the end of
the string (marked by a null character) before finding the first item.

Q & À

If 1 use input or output redirection, will the redirected file names show up as
command-line arguments? [p. 541]

No: the operating system removes them from the command line. Let’s say that we
run à program by enterine

demo foo <in file bar >out file baz

The value of argc will be 4, argv[0] will point to the program name,
argv [1] will point to "£oo". argv[2] will point to "bar", and argv (3]
will point to "baz".

] thought that the end of à line was always marked by a new-line character.
Now you're saying that the end-of-line marker varies, depending on the oper-
ating system. How you explain this discrepancy? [p. 542]

C library functions make it appear as though each line ends with a single new-line

***************************page_603***************************
578

Chapter 22

Input/Ouiput

character. Regardless of whether an input file contains a carriage-return character,
a line-feed character, or both, a library function such as getc will return a single
new-line character. The output functions perform the reverse translation. !f a pro-
gram calls a library function to write a new-line character to a file, the function
will translate the character into the appropriate end-of-line marker. C’s approach
makes programs more portable and easier to write; we can work with text files
without having to worry about how end-of-line is actually represented. Note that
input/output performed on a file opened in binary mode 1sn’t subject to any char-
acter translation—carriage return and line feed are treated the same as the other
characters.

l’m writing a program that needs to save data in a file, to be read later by
another program. Is it better to store the data in text form or binary form? [p.
542]

That depends. If the data 1s all text to start with, there s not much difference. If the
data contains numbers, however, the decision 1s tougher.

Binary form is usually preferable, since it can be read and written quickly.
Numbers are already in bmary form when stored in memory, so copying them to a
file 1s easy. Writing numbers in text form 1s much slower, since each number must
be converted (usually by fprint£) to character form. Reading the file later will
also take more time, since numbers will have to be converted from text form back
to binary. Moreover, storing data in binary form often saves space, as we saw in
Section 22.1.

Binary files have two disadvantages, however. They're hard for humans lo
read, which can hamper debugging. Also, binary files generally aren’t portable
from one system to another, since different kinds of computers store data in differ-
ent ways. For instance, some machines store int values using two bytes but others
use four bytes. There’s also the issue of byte order (big-endian versus little-
endian).

C programs for UNIX never seem to use the letter b in the mode string, even
when the file being opened is binary. What gives? [p. 544]
In UNIX. text files and binary files have exactly the same format. so there’s never

any need to use b. UNIX programmers should süull include the b, however, so that
their programs will be more portable to other operating systems.

l’ve seen programs that call fopen and put the letter t in the mode string.
What does t mean?

The C standard allows additional characters to appear in the mode string, provided
that they follow r, w, à. b, or +. Some compilers allow the usc of t to indicate that
a file 1s to be opened in text mode instead of binary mode. Of course. text mode 1s
the default anyway, so t adds nothing. Whenever possible, it’s best to avoid using
& and other nonportable features.

Why bother to call f£close to close a file? Isn°t it true that all open files are
closed automatically when a program terminates? [p. 545]

***************************page_604***************************
Â:

abort lunction »26.2

> &

Q & À 579

That’s usually true. but not if the program calls abort to terminate. Even when
abort isn't used. though, there are still good reasons to call Fclose. First, it
reduces the number of open files. Operating systems limit the number of files that
à program may have open at the same time: large programs may bump into this
limit. (The macro FOPEN_MAX, defined in <stdio.h>. specifies the minimum
number of files that the implementation guarantees can be open simultancously.)
Sccond, the program becomes easier to understand and modify; by looking for the
call of £close, it’s easier For the reader to determine the point at which a file is
no longer in use. Third, there’s the issue of safety. Closing a file ensures that its
contents and directory entry are updated properly; if the program should crash
later. at Icast the file will be intact.

l’m writing a program that will prompt the user to enter a file name. How
long should I make the character array that will store the file name” [p. 546]

That depends on your operating system. Fortunately, you can use the macro
FILENAME MAX (defined in <stdio.h>) to specify the size of the array.
FILENAME MAX 1s the length of a string that will hold the longest file name that
the implementation guarantees can be opened.

Can fflush flush a stream that was opened for both reading and writing?
[p. 549]

According to the C standard, the effect of calling fflush is defined for à stream
that (a) was opened for output. or (b) was opened for updating and whose last oper-
ation was nol à read. In all other cases, the effect of calling £flush is undefined.
When £flush is passed a null pointer, it flushes all streams that satisfy either (a)
or (b).

Can the format string in a call of .print£f or ….scanf be a variable?

Sure; it can be any expression of type char *. This property makes the …printF
and …scan£ functions even more versatile than we’ve had reason to suspect. Con-
sider the following classic example from Kernighan and Ritchie’s The C Program-
ning Language, which prints a program’s command-line arguments, separated by
spaces:

while (--argec > O)

printf ((argc > 1) ? "%s " ; "2g", *+-+argv) ;
The format string is the expression (argc > 1) ? "2g " - "%s", which evalu-
ë gG

ates to "3s " for all command-line arguments but the last.

Which library functions other than clearerr clear a stream’s error and
end-of-file indicators? |p. 565]

Calling rewind clears both indicators, as does opening or reopening the stream.
Calling ungetc, fseek, or £setpos clears just the end-of-file indicator.

[ can°t get £eo£ to work; it seems to return zero even at end-of-file. What am
I doing wrong? [p. 565]

***************************page_605***************************
580

Chapter 22

À:

Input/Ouiput

FeoË will only return a nonzero value when a previous read operation has failed:
you can‘t use feof to check for end-of-file before attempting to read. Instead, you
should first attempt to read, then check the return value from the input function. If
the return value indicates that the operation was unsuccessful, you can then use
£eoëË to determine whether the failure was due to end-of-file. In other words, it’s
best not to think of calling £eo£ as a way to detect end-of-file. Instead, think of it
as à way lo confirm that end-of-file was the reason for the failure of a read opera-
tion.

I still don’t understand why the VO library provides macros named putc and
getc in addition to functions named fputc and fgetc. According to Sec-
tion 21.1, there are already two versions of putc and getc (a macro and a
function). If we need a genuine function instead of a macro, we can expose the
putc or getc function by undefining the macro. So why do fputc and
fgetc exist? [p. 566]

Historical reasons. Prior to standardization. C had no rule that there be a true func-
tion to back up each parameterized macro in the library. putc and getc were tra-
ditionally implemented only as macros; fputc and fgetc were implemented
only as functions.

Whaf*s wrong with storing the return value of fgetc, getc, or getchar in
a char variable? I don’t see how testing a char variable against EOF could
give the wrong answer. [p. 568]

There are two cases in which this test can give the wrong result. To make the fol-
lowing discussion concrete, l'Il assume two's-complement arithmetic.

First, suppose that char is an unsigned type. (Recall that some compilers
treat char as a signed type but others treat it as an unsigned type.) Now suppose
that getc returns EOF. which we store in a char variable named ch. If EOF rep-
resents — 1 (its typical value), ch will end up with the value 255. Comparing ch (an
unsigned character) with EOF (a signed integer) requires converting ch to a signed
integer (255, in this case). The comparison against EOF fails, since 255 is not equal
to — 1.

Now assume that char is a signed type instead. Consider what happens 1f
getc reads a byte containing the value 255 from a binary stream. Storing 255 in
the ch variable gives it the value —1, since ch is a signed character. Testing
whether ch is equal to EOF will (erroneously) give a true result.

The character input functions described in Section 22.4 require that the Enter
key be pressed before they can read what the user has typed. How can I write
a program that responds to individual keystrokes?

As you've noticed, the getc. fgetc, and getchar functions are buffered: they
don't start to read input until the user has pressed the Enter key. In order to read
characters as they're entered—which is important for some kinds of programs—
you’l! need to use à nonstandard library that’s tailored to your operating system. In
UNTX, for example, the curses library often provides this capability.

***************************page_606***************************
Q & À 581

When l’m reading user input, how can I skip all characters left on the current
input line?

One possibility is to write a small function that reads and ignores all characters up
to (and including) the first new-line character:

void skip_line (void)

(

while (getchar() != '\n')

,

}

Another possibility is to ask scan£ to skip all characters up to the first new-
line character:

scanf ("%* [*\n] ") ; /* skips characters up to new-line */

scanf will read all characters up to the first new-line character, but not store them
anywhere (the * indicates assignment suppression). The only.problem with using
scanf is that it leaves the new-line character unread, so you may have to discard
it separately.

Whatever you do, don’t call the £fflush function:

fflush(stdin) ; /* effect is undefined */

Although some implementations allow the use of £flush to “flush” unread input,
il's not a good idea to assume that all do. £flush 1s designed to flush outpur
streams; the C standard states that 1ts effect on input streams is undefined.

Why is it not a good idea to use £fread and fwrite with text streams? [p.
571]

One difficulty is that, under some operating systems, the new-line character
becomes a pair of characters when written to a text file (see Section 22.1 for
details). We must take this expansion into account, or else we're likely to lose track
of our data. For example, 1f we use Éwrite to write blocks of 80 characters, some
of the blocks may end up occupying more than 80 bytes in the file because of new-
line characters that were expanded.

Why are there two sets of file-positioning functions (£seek/ftell and
fsetpos/fgetpos)? Wouldn’t one set be enough? [p. 574]

fseek and ftell have been part of the C library for eons. They have one draw-
back, though: they assume that a file position will fit in a long int value. Since
long int is typically a 32-bit type, this means that £seek and ftell may not
work with files containing more than 2,147,483,647 bytes. In recognition of this
problem, fsetpos and fgetpos were added to <stdio.h> when C89 was
created. These functions aren’t required to treat file positions as numbers, so
they’re not subject to the long int restriction. But don’t assume that you have to
use fsetpos and fgetpos: if your implementation supports a 64-bit long
int type, Éseek and ftell are fine even for very large files.

***************************page_607***************************
582 Chapter 22

Section 22.1

Section 22.2

Section 22.3

Q:

À:

® 2

@ 4

Input/Output

Why doesn°t this chapter discuss screen control: moving the cursor, changing
the colors of characters on the screen, and so on?

C provides no standard functions for screen control. The C standard addresses only
issues that can reasonably be standardized across a wide range of computers and
operating systems; screen control is outside this realm. The customary way to
solve this problem in UNIX 1s to use the curses library, which supports screen
control in a terminal-independent manner.

Similarly, there are no standard functions for building programs with a graphi-
cal user interface. However, you can most likely use C function calls to access the
windowing API (application programming interface) for your operating system.

Exercises

Indicate whether each of the following files is more likcly to contain text data or binary
data:

(a) À file of object code produced by a C compiler

(b) À program listing produced by à C compiler

(c) An email message sent from one computer to another
(d) À file containing a graphics image

Indicate which mode string is most likely to be passed to £open in each of the following
situations:
(a) À database management system opens a file containing records to be updated.

(b) À mail program opens a file of saved messages so that it can add additional messages to
the end.

(c) À graphics program opens a file containing a picture to be displayed on the screen.

(d) An operating system command interpreter opens a “shell script” (or “batch file”) con-
taining commands to be executed.

Find the error in the following program fragment and show how to fix it.
FILE *fp;

if (fp = fopen(filename, "r")) {
read characters until end-of-file
)

Éclose (fp) ;

Show how each of the following numbers will look if displayed by printf with
%#012 .5g as the conversion specification:

(a) 83.7361

(b) 29748.6607
(c) 1054932234.0
(d) 0.0000235218

Js there any difference between the printf conversion specifications % . 4d and %04d? If
so, explain what it is.

***************************page_608***************************
Section 22.4

O *.

*.

0.

@ 10.

ll.

12.

Exercises 583

Write a call of print£ that prints

1 widget

if the widget variable (of type int) has the value !. and
N widgets

otherwise, where n is the value of widget. You are not allowed to use the i £ statement or
any other statement; the answer must be a single call of print£.

Suppose that we call scan£ as follows:
n = scanf ("3d%f£%d", &i, &X, &]);

(à, j, and n are int variables and x is a float variable.) Assuming that the input stream
contains the characters shown, give the values of i, j,. n, and x after the call. In addition,
indicate which characters were consumed by the call.

(a) 10e20e3078

(b) 1.0e2.0e3.,00

(c) 0.1e0.2e0.370

(d) .1e.2+e,370

In previous chapters, wc've used the scan£f format string " %c" when we wanted to skip
white-space characters and read a nonblank character. Some programmers use "%1s"
instead. Are the two techniques equivalent’ If not, what are the differences?

Which one of the following calls 1s not a valid way of reading one character from the stan-
dard input stream?

(a) getch()

(b) getchar ()

(c) getc (stdin)

(d) fgetc(stdin)

The fcopy. c program has one minor flaw: it doesn't check for errors as it’s writing to the
destination file. Errors during writing are rare, but do occasionally oceur (the disk might
become full, for example). Show how to add the missing error check to the program, assum-
ing that we want it to display a message and terminate immediately if an error oceurs.

The following loop appcars in the fcopy . c program:

while ((ch = getc(source fp)) != EOF)
putc(ch, dest fp);

Suppose that we neglected to put parentheses around ch = getc (source_fp):

while (ch = getc(source fp) != EOF)
putc(ch, dest fp);

Would the program compile without an error? If so, what would the program do when it’s
run?

Find the error in the following function and show how to fix it.

int count periods (const char *filename)

{

FILE *fp;
int n = O0;

***************************page_609***************************
584 Chapter 22

Section 22.5

Section 22.7

Section 22.8

13.

© 14.

@ 15.

16.

@

Input/Ouiput
if ((Fp = fopen(filename, "r")) != NULL) {
while (fgetc(fp) != EOF)
if (£getc(fp) == '.!)
I1++ ;

Éclose (fp) ;

}

return n;

}

Write the following function:
int line length(const char *filename, int n});

The function should return the length of line n in the text file whose name is filename
(assuming that the first line in the file is line 1). If the line doesn't exist, the function should
return 0.

(a) Write your own version of the £gets function. Make it behave as much like the real
Égets function as possible; in particular, make sure that it has the proper return value. To
avoid conflicts with the standard library, don’t name your function fgets.

(b) Write your own version of fputs, following the same rules as in part (a).

Write calls of £seek that perform the following file-positioning operations on a binary file
whose data is arranged in 64-byte “records.” Use £p as the file pointer in each case.

(a) Move to the beginning of record n. (Assume that the first record in the file is record 0.)
(b) Move to the beginning of the last record in the file.

(c) Move forward one record.
(d) Move backward two records.

Assume that str is a string that contains a ‘‘sales rank’” immediately preceded by the #
symbol (other characters may precede the # and/or follow the sales rank). À sales rank is a
series of decimal digits possibly containing commas, such as the following examples:

989
24,675
1,162,620

Write a call of sscan£ that extracts the sales rank (but not the # symbol) and stores it in a
string variable named sales_rank.

Programming Projects

Extend the canopen ..c program of Section 22.2 so that the user may put any number of
file names on the command line:

canopen foo bar baz

The program should print a separate can be opened or can' t be opened message for
each file. Have the program terminate with status EXIT FAILURE if onc or more of the
files can’t be opened.

Write à program that converts all letters in a file to upper case. (Characters other than letters
shouldn’t be changed.) The program should obtain the file name from the command line and
Write its output to stdout.

***************************page_610***************************
 

Programming Projects 585

Write a program named fcat that “concatenates” any number of files by writing them to
standard output, one after the other, with no break between files. For example, the following
command will display the files £1.c, £2.c, and £3 .c on the screen:

fcat ft1l.c f2.c f3.cC

Écat should issue an error message if any file can*t be opened. Hint: Since it has no more
than one file open at a time, £cat needs only a single file pointer variable. Once it’s fin-
ished with a file, £cat can use the same variable when it opens the next file.

(a) Write a program that counts the number of characters in a text file.

(b) Write a program that counts the number of words in a text file. (A “word” is any
sequence of non-white-space characters.)

(c) Write a program that counts the number of lines in a text file.

Have each program obtain the file name from the command line.

The xor . c program of Section 20.1 refuses to encrypt bytes that—in original or encrypted
form—are control characters. We can now remove this restriction. Modify the program so
that the names of the input and output files are command-line arguments. Open both files in
binary mode, and remove the test that checks whether the original and encrypted characters
are printing characters.

Write a program that displays the contents of a file as bytes and as characters. Have the user
specify the file name on the command line. Here’s what the output will look like when the
program 1s used to display the pun. c file of Section 2.1 :

Offset Bytes Characters

O 23 69 6E 63 6C 75 64 65 20 3C #Hinclude <
10 73 74 64 69 6F 2E 68 3E OD O0A stdio.h>..

20 OD OA 69 6E 74 20 6D 61 69 6E ..int main
30 28 76 6F 69 64 29 OD OA 7B OD (void)..(.
40 OA 20 20 70 72 69 6E 74 66 28 . printf(

50 22 54 6F 20 43 2C 20 6F 72 20 "To C, or
60 6E 6F 74 20 74 6F 20 43 3A 20 not to C:
70 74 68 61 74 20 69 73 20 74 68 that is th
80 65 20 71 75 65 73 74 69 6F 6E e question
90 2E S5C 6E 22 29 3B OD OA 20 20 .\n");..
100 72 65 74 75 72 6E 20 30 3B OD return O;.
110 OA 7D }

Each line shows 1O bytes from the file, as hexadecimal numbers and as characters. The
number in the Offset column indicates the position within the file of the first byte on the
line. Only printing characters (as determined by the isprint function) are displayed:
other characters are shown as periods. Note that the appearance of a text file may vary,
depending on the character set and the operating system. The example above assumes that
pun.c is a Windows file, so OD and OA bytes (the ASCII carriage-return and line-feed
characters) appear at the end of each line. Hinr: Be sure to open the file in "rb" mode.

Of the many techniques for compressing the contents of a file, one of the simplest and fast-
est 1s known as run-length encoding. This technique compresses a file by replacing
sequences of identical bytes by a pair of bytes: a repetition count followed by a byte to be
repeated. For example, suppose that the file to be compressed bcgins with the following
sequence of bytes (shown in hexadecimal):

46 6F 6F 20 62 61 72 21 21 21 20 20 20 20 20
The compressed file will contain the following bytes:

***************************page_611***************************
586

Chapter 22
8.
@ o
*10.

InputOutput

O1 46 02 6F O1 20 O1 62 O1 61 01 72 03 21 05 20

Run-length encoding works well if the original file contains many long sequences of identi-
cal bytes. In the worst case (a file with no repeated bytes). run-length encoding can actually
double the length of the file.

(a) Write a program named compress_file that uses run-length encoding to compréss
a file. To run compress _ file, we'd use a command of the form

compress file original-file

compress file will write the compressed version of original-file 10 original-file.rle.
For example. the command

compress file foo.txt

will cause compress_file to write a compressed version of foo. txt to a file named
Éoo.txt.rle. Hint: The program described in Programming Project 6 could be useful
for debugging.

(b) Write a program named uncompress file that reverses the compression performed
by the compress £ile program. The uncompress file command will have the
form

uncompress_file compressed-file
compressed-file should have the extension .rle. For example, the command
uncompress file foo.txt.rle

Will cause uncompress £ile to open the file foo.txt.rle and write an uncom-
pressed version of its contents to foo .txt. uncompress_file should display an error
message 1f its command-line argument doesn’t end with thé .rle extension.

Modify the inventory. c program of Section 16.3 by adding two new operations:

m Save the database in a specified file.
w |oad the database from a specified file.

Use the codes d (dump) and r (restore), respectively, to represent these operations. The
Interaction with the user should have the following appearance:

Enter operation code: d
Enter name of output file: inventory.dat

 

Enter operation code: r
Enter name of input file: inventory.dat

 

Hint: Use fwrite to write the array containing the parts to à binary file. Use £read to
restore the array by reading 1t from a file.

Write a program that merges two files containing part records storcd by the inventory.c
program (sce Programming Project 8). Assume that the records in each file are sorted by
part number, and that we want the resulting file to be sorted as well. If both files have a part
with the same number, combine the quantities stored in the records. (As a consistency
check, have the program compare the part names and print an error message if they don't
match.) Have the program obtain the names of the input files and the merged file from the
command line.

Modify the inventory2.c program of Scection 17.5 by adding the d (dump) and r
(restore) operations described in Programming Project &. Since the part structures aren’t
stored in an array, the d operation can*t save them all by à single call of fwrite. Instead. it
will need to visit each node in the linked list, writing the part number, part name, and quan-

***************************page_612***************************
ll.

12.

1 3.

14.

15.

Programming Projects 587

tity on hand to a file. (Don't save the next pointer: it won’t be valid once the program ter-
minates.) As it reads parts from a file, the r operation will rebuild the list one node at a time.

Write a program that reads a date from the command line and displays it in the following
form:

September 13, 2010

Allow the user to enter the date as either 9-13-2010 or 9/13/2010; you may assume
that there are no spaces in the date. Print an error message if the date doesn’t have one of the
specified forms. Hinr: Use sscanf to extract the month, day, and year from the command-
line argument.

Modify Programming Project 2 from Chapter 3 so that the program rcads a series of items
from a file and displays the data in columns. Each line of the file will have the following
form:

item, price, mm/dd/yyyy
For example, suppose that the file contains the following lines:

583,13.5,10/24/2005
3912,599.99,7/27/2008

The output of the program should have the following appearance:

Item Unit Purchase
Price Date

583 $ 13.50 10/24/2005

3912 S 599.99 7/27/2008

Have the program obtain the file name from the command line.

Modify Programming Project 8 from Chapter 5 so that the program obtains departure and
arrival times from a file named flights.dat. Each line of the file will contain a depar-
ture time followed by an arrival time, with one or more spaces separating the two. Times
will be expressed using the 24-hour clock. For example, here’s what £lights . dat might
look like 1f it contained the flight information listed in the original project:

8:00 10:16

9:43 11:52

11:19 13:31
12:47 15:00
14:00 16:08
15:45 17:55
19:00 21:20
21:45 23:58

Modify Programming Project 15 from Chapter & so that the program prompts the user to
enter the name of a file containing the message to be encrypted:

Enter name of file to be encrypted: message.txt
Enter shift amount (1-25): 3

 

The program then writes the encrypted message lo a file with the same name but an added
extension of .enc. In this example, the original file name is message.txt, so the
encrypted message will be stored in a file named message. txt .enc. There’s no limit on
the size of the file to be encrypted or on the length of each line in the file.

Modify the justi fy program of Section 15.3 so that it reads from one text file and writes
to another. Have the program obtain the names of both files from the command line.

***************************page_613***************************
588

Chapter 22

16.

[7.

18.

19.

Input/Output

Modify the fcopy . c program of Section 22.4 so that it uses Éread and fwrite to copy
the file in blocks of 512 bytes. (The last block may contain fewer than 512 bytes, of course.)

Write à program that reads a series of phone numbers from a file and displays them in a
standard format. Each line of the file will contain a single phone number, but the numbers
may be in a variety of formats. You may assume that each line contains 10 digits, possibly
mixed with other characters (which should be ignored). For example. suppose that the file
contains the following lines:

404.817.6900
(215) 686-1776
312-746-6000
877 275 5273
6173434200

The output of the program should have the following appearance:

(404) 817-6900
(215) 686-1776
(312) 746-6000
(877) 275-5273
(617) 343-4200

Have the program obtain the file name from the command line.

Write à program that reads integers from a text file whose name is given as a command-line
argument. Each line of the file may contain any number of integers (including none) sepa-
rated by one or more spaces. Have the program display the largest number in the file, the
smallest number. and the median (the number closest to the middle if the integers were
sorted). If the file contains an even number of integers, there will be two numbers in the
middle; the program should display their average (rounded down). You may assume that the
file contains no more than 10.000 integers. Hinr: Store the integers in an array and then sort
the array.

(a) Write a program that converts a Windows text file to a UNIX text file. (See Section 22.1
for à discussion of the differences between Windows and UNIX text files.)
(b) Write a program that converts a UNIX text file to a Windows text file.

In each case, have the program obtain the names of both files from the command line. Hinr:
Open the input file in "rb" mode and the output file in "wb" mode.

***************************page_614***************************
23

23.1

rounding direction » 23.4

 

Library Support for Numbers
and Character Data

Prolonged contact with the computer turns
mathematicians into clerks and vice versa.

This chapter describes the five most important library headers that provide support

for working with numbers, characters, and character strings. Sections 23.1 and

23.2 cover the <float .h> and <limits.h> headers, which contain macros
describing the characteristics of numeric and character types. Sections 23.3 and
23.4 describe the <math. h> header, which provides mathematical functions. Sec-
tion 23.3 discusses the C89 version of <math.h>: Section 23.4 covers the C99
additions, which are so extensive that l’ve chosen to cover them separately. Sec-
tions 23.5 and 23.6 are devoted to the <ctype.h> and <string.h> headers,
which provide character functions and string functions, respectively.

C99 adds several headers that also deal with numbers, characters, and strines.
The <wchar .h> and <wctype .h> headers are discussed in Chapter 25. Chap-
ter 27 covers <complex.h>, <fenv.h>, <inttypes.h>, <stdint.h>,
and <tgmath.h»>.

The <float.h> Header: Characteristics of
Floating Types

The <float .h> header provides macros that define the range and accuracy of
the float, double, and 1long double types. There are no types or functions
in cfloat.h»>.

Two macros apply to all floating types. The FLT ROUNDS macro represents
the current rounding direction for floating-point addition. Table 23.1 shows the
possible values of FLT ROUNDS. (Values not shown in the table indicate imple-
mentation-defined rounding behavior.)

589

***************************page_615***************************
590

Table 23.1
Rounding Directions

feset round function »27.6

Table 23.2
Significant-Digit Macros
in <float .h>

Table 23.3
Exponent Macros
in cfloat ..h>

Chapter 23  Library Support for Numbers and Character Data

 

Value Meaning

 

-1 Indeterminable
0 Toward zero
1 To nearest
2 Toward positive infinity
3 Toward negative infinity

 

 

 

Unlike the other macros in <float .h>, which represent constant expressions,
the value of FLT ROUNDS may change during execution. (The fesetround
function allows a program to change the current rounding direction.) The other
macro, FLT RADIX, specifies the radix of exponent representation; it has a mini-
mum value of 2 (indicating binary representation).

The remaining macros, which TIl present in a series of tables, describe the
characteristics of specific types. Each macro begins with either FLT. DBL, or
LDBL, depending on whether it refers to the £loat, double, or long double
type. The C standard provides extremely detailed definitions of these macros; my
descriptions will be less precise but easier to understand. The tables indicate maxi-
mum or minimum values for some macros, as specified in the standard.

Table 23.2 lists macros that define the number of significant digits guaranteed
by each floating type.

 

 

 

 

 

Name Value Description
FLT MANT DIG Number of significant digits (base FLT _ RADIX)
DBL MANT DIG
LDBL MANT DIG
FLT DIG 26 Number of significant digits (base 10)
DBL DIG >10
LDBL DIG >10

 

Table 23.3 lists macros having to do with exponents.

 

 

 

 

 

 

 

Name Valne Description
FLT MIN EXP Smallest (most negative) power to which
DBL MIN EXP FLT RADIX can be raised
LDBL MIN EXP
FLT MIN 10 EXP 537 _ Smallest (most negative) power to which 10 can be
DBL MIN 10 EXP <—37 _ raised
LDBL MIN 10 EXP — <37
FLT MAX EXP Largest power to which FLT RADIX can be raised
DBL MAX EXP
LDBL MAX EXP
FLT MAX 10 EXP 2+37 _ Largest power to which 10 can be raised
DBL MAX 10 EXP —… >+37
LDBL MAX 10 EXP — 2+37

 

Table 23.4 lists macros that describe how large numbers can be, how close to
zero they can get, and how close two consecutive numbers can be.

***************************page_616***************************
Table 23.4
Max, Min, and Epsilon
Macros in <float .h>

æ

Table 23.5
Evaluation Methods

23.2

 

232  The<limits.h> Header: Sizes of Integer Types 591

 

 

 

 

 

 

Name Value Description
FLT MAX >10**7 _ Largest finite value
DBL MAX >10**7
LDBL MAX >101*7
FLT MIN <10-77 Smallest positive value
DBL MIN <107*”
LDBL MIN <10-*7
FLT EPSILON <10® _ Smallest representable difference between two numbers
DBL EPSILON =— <10”
LDBL EPSILON — <I0"°

 

C99 provides two other macros, DECIMAL DIG and FLT_EVAL METHOD.
DECIMAL DIG represents the number of significant digits (base 10) in the wid-
est supported floating type; it has a minimum value of 10. The value of
FLT _ EVAL METHOD indicates whether an implementation will perform float-
ing-point arithmetic using greater range and precision than is strictly necessary. If
this macro has the value O, for example, then adding two float values would be
done in the normal way. If it has the value 1, however, then the float values
would be converted to double before the addition is performed. Table 23.5 lists
the possible values of FLT EVAL METHOD. (Negative values not shown in the
table indicate implementation-defined behavior.)

 

Value Meaning

 

-1 Indeterminable

 

0 Evaluate all opcrations and constants just to the range and precision of the type ‘

 

1 Evaluate operations and constants of type Éloat and double to the range
and precision of the double type

 

2 Evaluate all operations and constants to the range and precision of the Long

 

 

double type

!

Most of the macros in <float .h> are of interest only to experts in numeri-
cal analysis, making it probably one of the least-used headers in the standard
library.

The <limits.h> Header: Sizes of Integer Types

The <limits.h> header provides macros that define the range of each integer
type (including the character types). <limits .h> declares no types or functions.
One set of macros in <limits.h> deals with the character types: char,
signed char, and unsigned char. Table 23.6 lists these macros and shows
the maximum or minimum value of each.
The other macros in <limits.h> deal with the remaining integer types:
short int, unsigned short int, int, unsigned int, long int, and

***************************page_617***************************
592

Table 23.6
Character Macros
in <limits.hs>

æ

Table 23.7
Integer Macros in
<limits.h»>

#error directive > 14.5

Chapter 23  Library Support for Numbers and Character Data

 

 

 

 

Name Value Description
CHAR BIT 28 _ Number of bits per byte
SCHAR MIN <—|27  Minimum signed char value
SCHAR MAX >+127 _ Maximum signed char value
UCHAR MAX 2255  Maximum unsigned char value
CHAR MIN { - Minimum char value
CHAR MAX T — Maximum char value
MB_LEN MAX 21 - Maximum number of bytes per multibyte character
in any supported locale (see Section 25.2)

 

1ECHAR_MIN is equal to SCHAR MIN if char is treated as à signed type: otherwise.
CHAR MIN is 0.

HCHZÀ.R_I‘/IAX has the same valuc as either SCHAR MAX or UCHAR MAX, depending on
whether char is treated as a signed type or an unsigned type.

unsigned long int. Table 23.7 lists these macros and shows the maximum or
minimum value of each; the formula used to compute each value is also given.
Note that C99 provides three macros that describe the characteristics of the 1l ong
long int types.

 

 

 

 

Name Value Formula Description
SHRT_MIN <-32767  —(2'*°-1) Minimum short int value
SHRT MAX 2+32767 2°_1 Maximum short int value
USHRT MAX 265535 2'6_] Maximum unsigned
short int value

INT MIN <—32767  —2'>—1) Minimum int value

INT _ MAX 2+32767 2151 Maximum int value

UINT_MAX 265535 2'°_1  Maximum unsigned int
value

LONG MIN <—2147483647  —(2°!-1) Minimum long int value

LONG_MAX >+2147483647 23!-1  Maximum long int value

ULONG MAX 24294967295 2°_1 Maximumunsigned long
int value

LLONG_MINT <—9223372036854775807  —(2%-1) Minimum long long int
value

LLONG MAX'" — >+9223372036854775807 23_1  Maximum long long int
value

ULLONG MAX' >18446744073709551615 2_|  Maximum unsigned long

long int value

 

*C99 only

The macros in <limits .h> are handy for checking whether a compiler sup-
ports integers of a particular size. For example, to determine whether the int type
can store numbers as large as 100,000, we might use the following preprocessing
directives:

#i£f INT MAX < 100000

#error int type is too small
#endif

If the int type isn’t adequate, the #error directive will cause the preprocessor
to display an error message.

***************************page_618***************************
23.3

<ermno. H> header »24.2

Infinity » 23.4

 

23.3  The <math.h> Header (C89): Mathematics 593

Going a step further, we might use the macros in <limits.h> to help a
program choose how to represent a type. Let’s say that variables of type Quan-
tity must be able to hold integers as large as 100,000. If INT _ MAX 1s at least
100.000, we can define Quantity to be int; otherwise, we’ll need to make 1t
long int:

#if INT MAX >= 100000
typedef int Quantity;
telse

typedef long int Quantity;
#endif

The <math.h> Header (C89): Mathematics

The functions in the C89 version of <math. h> fall into five groups:

Trigonometric functions

Hyperbolic functions

Exponential and logarithmic functions

Power functions

Nearest integer, absolute value, and remainder functions

C99 adds a number of functions to these groups as well as introducing other cate-
gories of math functions. The C99 changes to <math.h> are so extensive that
l’ve chosen to cover them in a separate section that follows this one. That way,
readers who are primarily interested in the C89 version of the header—or who are
using a compiler that doesn’t support C99—won'1 be overwhelmed by all the C99
additions.

Before we delve into the functions provided by <math.h>. let’s take a brief
look at how these functions deal with errors.

Errors

The <math.h> functions handle errors in a way that’s different from other library
functions. When an error occurs, most <math.h> functions store an error code in
à special variable named errno (declared in the <errno.h> header). In addi-
tion, when the return value of a function would be larger than the largest double
value, the functions in <math. h> return a special value, represented by the macro
HUGE VAL (defined in <math.h>). HUGE VAL is of type double, but it isn’t
necessarily an ordinary number. (The IEEE standard for floating-point arithmetic
defines a value named ““infinity”—a logical choice for HUGE_VAL.)
The functions in <math.h> detect two kinds of errors:

= Domain error: An argument is outside a function’s domain. If a domain error
occurs, the function’s return value is implementation-defined and EDOM

***************************page_619***************************
594

Chapter 23 _ Library Support for Numbers and Character Data

NaN »-23.4

undertlow »-23.4

cos
sin
tan

acos
asin
atan

atan2

(“domain error”) is stored in errno. In some implementations of
<math.h>, functions return a special value known as NaN (‘“‘not a number”)
when a domain error occurs.

« Range error: The return value of a function is outside the range of double
values. If the return value’s magnitude is too large (overflow), the function
relurns positive or negative HUGE_VAL, depending on the sign of the correct
result. In addition, ERANGE (‘‘range error”) is stored in errno. If the return
value’s magnitude is too small to represent (underflow), the function returns
Zero; some implementations may also store ERANGE in errno.

We'll ignore the possibility of error for the remainder of this section. How-
ever, the function descriptions in Appendix D explain the circumstances that lead
to each type of error.

Trigonometric Functions

double acos (double x) ;

double asin (double x) ;

double atan (double x) ;

double atan2 (double y, double x) ;
double cos (double x) ;

double sin(double x) ;

double tan(double x) ;

The cos, sin, and tan functions compute the cosine, sine, and tangent, respec-
tively. If PI is defined to be 3.14159265, passing PI/4 to cos, sin, and tan
produces the following results:

cos (PI/4) => 0.707107
sin(PI/4) => 0.707107
tan (PI/4) => 1.0

Note that arguments to cos, sin, and tan are expressed in radians, not degrees.
acos, asin, and atan compute the arc cosine, arc sine, and arc tangent:

acos(1.0) => 0.0
asin(1.0) = 11.5708
atan(1.0) =— 0.785398

Applying acos to a value returned by cos won’t necessarily yield the original
argument to cos, since acos always returns a value between 0 and . asin and
atan return a value between —x/2 and 7/2.

atan2 computes the arc tangent of y/x, where y is the function’s first argu-
ment and x is its second. The return value of atan2 is between — and x. The call
atan (x) is equivalent to atan2 (x, 1.0).

***************************page_620***************************
cosh
sinh
tanh

exp

log
log10

modf

 

 

23.3  The <math.h> Header (C89): Mathematics 595

Hyperbolic Functions

double cosh (double x) ;
double sinh(double x) ;
double tanh(double x) ;

The cosh, sinh, and tanh functions compute the hyperbolic cosine, sine, and
tangent:

cosh(0.5) — 1.12763
sinh(0.5) =— 0.521095
tanh(0.5) => 0462117

Arguments to cosh, sinh, and tanh must be expressed in radians, not degrees.

Exponential and Logarithmic Functions

double exp (double x) ;

double frexp (double value, int *exp) ;
double ldexp (double x, int exp);

double log (double x) ;

double log10 (double x) ;

double mod£ (double value, double *iptr) ;

The exp function returns e raised to a power:
exp(3.0) = 20.0855

log is the inverse of exp—it computes the logarithm of a number to the base
e. log10 computes the ‘“common” (base 10) logarithm:

log(20.0855) > 3.0
log10(1000) z 3.0

Computing the logarithm to a base other than e or 10 isn’t difficult. The following
function, for example, computes the logarithm of x to the base b, for arbitrary x
and b:

double log base (double x, double b)

{
}

return log(x) / log(b) ;

The mod£ and frexp functions decompose a double value into two parts.
mod£ splits its first argument into integer and fractional parts. It returns the frac-
tional part and stores the integer part in the object pointed to by the second argu-
ment:

***************************page_621***************************
596

Chapter 23 _ Library Support for Numbers and Character Data

frexp

ldexp

pow

sqrt

mod£f (3.14159, &int part) > 0.14159 (int part is assigned 3.0)

Although int_part must have type double, we can always cast it to int or

long int later.
The frexp function splits a floating-point number into a fractional part f and

an exponent n in such a way that the original number equats # x 2”, where either
0.5 <f< l orf= 0. £rexp returns f and stores n in the (integer) object pointed to
by the second areument:

frexp(12.0, &exp) — .T5 (exp is assigned 4)
frexp(0.25, &exp) > 0.5 (exp is assigned —1)

1dexp undoes the work of £rexp by combining a fraction and an exponent
into a single number:

ldexp(.75, 4) => 12.00
ldexp(0.5, -1) > 0.25

In general, the call 1dexp (x, exp) returns x x 2°*P,
The mod£, frexp, and 1dexp functions are primarily used by other func-
tions in <math.h>. They are rarely called directly by programs.

Power Functions

double pow(double x, double y) ;
double sgrt (double x) ;

The pow function raises its first argument to the power specified by its second
argument:

pow(3.0,2.0) = 9.0
pow(3.0,0.5) = |1.73205
pow(3.0, -3.0) — 0.037037

sqrt computes the square root:

sart(3.0) = 1.73205

Using sqrt to find square roots is preferable to calling pow, since sart is usu-
ally a much faster function.

Nearest Integer, Absolute Value, and Remainder Functions

double ceil (double x) ;

double fabs (double x) ;

double floor (double x) ;

double fmod (double x, double y) ;

***************************page_622***************************
ceil
floor

fabs

fmod

23.4

 

23.4  Ihe <math.h> Header (C99): Mathematics 597

The ceil (*ceiling”) function returns—as a double value—the smallest integer
that’s greater than or equal to its argument. £loor returns the largest integer that’s
less than or equal to its argument:

ceil(7.1) => 8.0
ceil(7.9) —> 8.0
ceil(-7.1) => —.0
ceil(-7.9) => -7.0
floor(7.1) 7.0

—
floor(7.9) = 7.0
£loor(-7.1) => -8.0
floor(-7.9) => -8.0

In other words. ceil ‘“‘rounds up” to the nearest integer. while floor ‘“‘rounds
down.” C89 lacks a standard function that rounds to the nearest integer, but we can
easily use ceil and floor to write our own:

double round_nearest (double x)

{

return x < 0.0 ? ceil(x - 0.5) : floor(x + 0.5);

}

C99 provides several functions that round to the nearest integer, as we’1I see in the
next section.
£abs computes the absolute value of a number:

fabs(7.1) => 7.1
fabs(-7.1) > 7.1

fmod returns the remainder when its first argument is divided by its second
argument:

fmod(5.5, 2.2) > |l

C doesn’t allow the % operator to have floating-point operands, but fmod is a
more-than-adequate substitute.

The <math.h> Header (C99): Mathematics

The C99 version of the <math.h> header includes the entire C89 version, plus a
host of additional types. macros, and functions. The changes to this header are so
numerous that l’ve chosen to cover them separately. There are several reasons why
the standards committee added so many capabilities to <math.h>:

= Provide better support for the IEEE floating-point standard. C99 doesn‘t
mandate the use of the IEEE standard; other ways of representing floating-point

***************************page_623***************************
598 Chapter 23 _ Library Support for Numbers and Character Data

numbers are permitted. However, it’s safe to say that the vast majority of C pro-
grams are executed on systems that support this standard.

=s Provide more control over floating-point arithmetic. Better control over
floating-point arithmetic may allow programs to achieve greater accuracy and
speed.

u Make C more attractive to Fortran programmers. The addition of many math
functions, along with enhancements elsewhere in C99 (such as support for
complex numbers), was intended to increase C’s appeal to programmers who
might have used other programming languages (primarily Fortran) in the past.

Another reason that l’ve decided to cover C99’s <math .h> header in a sepa-
rate section is that it’s not likely to be of much interest to the average C programmer.
Those using C for its traditional applications, which include systems programming
and embedded systems. probably won’t need the additional functions that C99 pro-
vides. However, programmers developing engineering, mathematics, or science
applications may find these functions to be quite useful.

IFBE Floating-Point Standard

One motivation for the changes to the <math.h> header is better support for
IEEE Standard 754, the most widely used representation for floating-point num-
bers. The full title of the standard is “IEEE Standard for Binary Floating-Point
Arithmetic” (ANSVIEEE Standard 754-1985). Tts also known as IEC 60559,
which is how the C99 standard refers to it.

Section 7.2 described some of the basic properties of the IEEE standard. We
saw that the standard provides two primary formats for floating-point numbers:
single precision (32 bits) and double precision (64 bits). Numbers are stored in à
form of scientific notation, with each number having three parts: a sign, an expo-
nent, and a fraction. That limited knowledge of the IEEE standard is enough to use
the C89 version of <math.h> effectively. Understanding the C99 version. how-
ever, requires knowing more about the standard. Here’s some additional informa-
tion that we’Il need:

= Positive/negative zero. One of the bits in the IEEE representation of a float-
ing-point number represents the number’s sign. As a result, the number zero
can be either positive or negative, depending on the value of this bit. The fact
that zero has two representations may sometimes require us to treat it differ-
ently from other floating-point numbers.

# Subnormal numbers. When a floating-point operation is performed, the result
may be too small to represent, a condition known as underflow. Think of what
happens if you repeatedly divide a number using a hand calculator: eventually
the result is Zero. because it becomes too small to represent using the calcula-
tor's number representation. The IEEE standard has a way to reduce the
Impact of this phenomenon. Ordinary floating-point numbers are stored in a
“normalized” format, in which the number is scaled so that there’s exactly one

***************************page_624***************************
FLT _ EVAL METHOD >23,.1

 

23.4  The <math.h> Header (C99): Mathematics 599

digit to the left of the binary point. When a number gets small enough, how-
ever, it’s stored in a different format in which it’s not normalized. These sub-
normal numbers (also known as denormalized numbers or denormals) can
be much smaller than normalized numbers: the trade-off is that they get pro-
gressively less accurate as they get smaller.

m Special values. Each floating-point format allows the representation of three
special values: positive infinity, negative infinity, and NaN (“not a number”).
Dividing a positive number by zero produces positive infinity. Dividing a neg-
ative number by zero yields negative infinity. The result of a mathematically
undefined operation, such as dividing zero by zero, is NaN. (It's more accurate
to say “the result is à NaN” rather than “the result is NaN.” because the IEEE
standard has multiple representations for NaN. The exponent part of a NaN
value is all 1 bits, but the fraction can be any nonzero sequence of bits.) Spe-
cial values can be operands in subsequent operations. Infinity behaves just as
it does in ordinary mathematics. For example, dividing a positive number by
positive infinity yields zero. (Note that an arithmetic expression could produce
infinity as an intermediate result but have a noninfinite value overall.) Per-
forming any operation on NaN gives NaN as the result.

=m Rounding direction. When a number can’t be stored exactly using a floating-
point representation, the current rounding direction (or rounding mode)
determines which floating-point value will be selected to represent the num-
ber. There are four rounding directions: (1) Round toward nearest. Rounds to
the nearest representable value. If a number falls halfway between two values,
it is rounded to the “even” value (the one whose least significant bit is zero).
(2) Round toward zero. (3) Round toward positive infinity. (4) Round toward
negative infinity. The default rounding direction is round toward nearest.

=m Exceptions. There are five types of floating-point exceptions: overflow, under-
flow, division by zero, invalid operation (the result of an arithmetic operation
was NaN), and inexact (the result of an arithmetic operation had to be
rounded). When one of these conditions is detected, we say that the exception
1s raised.

Types

C99 adds two types, float t and double_t. to <math.h>. The float_t
type is at least as “wide” as the float type (meaning that it could be the float
type or any wider type, such as double). Similarly, double_ t is required to be
at least as wide as the double type. (It must also be at least as wide as
£loat _ t.) These types are provided for the programmer who’s trying to maxi-
mize the performance of floating-point arithmetic. float_t should be the most
efficient floating-point type that’s at least as wide as float; double_t should
be the most efficient floating-point type that’s at least as wide as double.

The float t and double t types are related to the FLT_EVAL METHOD
macro, as shown in Table 23.8.

***************************page_625***************************
600 Chapter 23  Library Support for Numbers and Character Data

Table 23.8
Relationship between
FLT EVAL METHOD
and the £loat t and
double t Types

 

 

 

 

 

 

 

Value of VTeaning of Meaning of
FLT EVAL METHOD float t double t
0 £loat double
1 double double
2 long double long double
Other Implementation-defined _ Implementation-defined

 

Macros

C99 adds a number of macros to <math.h>. l’Il mention just two of them at this
point. INFINITY represents the float version of positive or unsigned infinity.
(IF the implementation doesn’t support infinity, then INFINITY represents a
float value that overflows at compile time.) The NAN macro represents the
£loat version of “not a number” More specifically, it represents a “quiet” NaN
(one that doesn't raise an exception if used in an arithmetic expression). If quiet
NaNs aren’t supported, the NAN macro won°t be defined.

l'Il cover the function-like macros in <math.h> later in the section. along
with ordinary functions. Macros that are relevant only to a specific function will be
described with the function itself.

Errors
For the most part, the C99 version of <math.h> deals with errors in the same
way as the C89 version. However, there arc a few twists that we’!l need to discuss.

First, C99 provides several macros that give implementations a choice of how
errors are signaled: via a value stored in errno, via a floating-point exception, or
both. The macros MATH_ERRNO and MATH ERREXCEPT represent the integer
constants | and 2, respectively. À third macro, math errhandling, represents
an int expression whose value is either MATH ERRNO, MATH ERREXCEPT, or
the bitwise OR of the two values. (Tt’s also possible that math errhandling
isn’t really a macro; it might be an identifier with external linkage.) The value of
math_errhandling can’t be changed within a program.

Now, let’s see what happens when a domain error occurs during a call of one
of the functions in <math.h>. The C89 standard says that EDOM is stored in
errno. The C99 standard, on the other hand, states that if the expression
math_errhandling & MATH _ERRNO is nonzero (i.e., the MATH ERRNO bit is
set), then EDOM is stored in errno. If the expression math_errhandling &
MATH_ERREXCEPT 1s nonzero, the invalid foating-point exception is raised.
Thus, either or both actions are possible, depending on the value of
math_errhandlinoa.

Finally. let’s turn to the actions that take place when a range error is detected
during a function call. There are two cases, based on the magnitude of the func-
tion’s return value.

Overflow. 1f the magnitude is too large, the C89 standard requires the function
lo return posilive or negative HUGE VAL, depending on the sign of the correct

***************************page_626***************************
23.4  The <math.h> Header (C99): Mathematics — 601

result. In addition, ERANGE is stored in errno. The C99 standard describes a
more complicated set of actions when overflow occurs:

m If default roundinsg is in effect or if the return value is an “exact infinity” (such
as 1og (0.0) ), then the function returns either HUGE VAL, HUGE _VALF, r
HUGE VALL, depending on the function’s return type. (HUGE VALF and
HUGE VALL—1the float and long double versions of HUGE_VAL-—are
new in C99. Like HUGE VAL, they may represent positive infinity.) The value
returned has the sign of the correct result.

u If the value ofmath errhandling & MATH _ERRNO is nonzero, ERANGE
1S stored in errno.

m If the value of math errhandling & MATH_ERREXCEPT is nonzero, the
divide-by-zero floating-point exception is raised if the mathematical result 18
an exact infinity. Otherwise, the overflow exception 1s raised.

Underflow. IË the magnitude is too small to represent, the C89 standard
requires the function to return zero; some implementations may also store
ERANGE in errno. The C99 standard prescribes a somewhat different set of
actions:

u The function returns a value whose magnitude is less than or equal to the
smallest normalized positive number belonging to the function’s return type.
(This value might be zero or a subnormal number.)

u If the value of math errhandling & MATH ERRNO is nonzero, an imple-
mentation may store ERANGE in errno.

u |f the value of math errhandling & MATH_ERREXCEPT is nonzero, an
implementation may raise the uniderflow Floatine-point exception.

Notice the word “may” in the latter two cases. For reasons of efficiency, an imple-
mentation is not required to modify errno or raise the r#nderflow exception.

Functions

We're now ready to tackle the functions that C99 adds to <math.h>. l’Il present the
functions in groups, using the same calegories as the C99 standard. These categories
differ somewhat from the ones in Section 23.3, which came from the C89 standard.

One of the biggest changes in the C99 version of <math.h> is the addition
of two more versions of most functions. In C89, there’s only a single version of
each math function; typically, it takes at least one argument of type double and/
or returns a double value. In C99, however. there are two additional versions:
one for £loat and one for long double. The names of these functions are
identical to the name of the original function except for the addition of an É or 1
suffix. For example, the original sqrt function, which takes the square root of a
double value, is now joined by sqrt£ (the Float version) and sqrt1l (the
long double version). DIl list the prototypes for the new versions (in italics, as
is my custom for functions that are new in C99). | won°’t describe the functions
further. though. since they're virtually identical to their C89 counterparts.

***************************page_627***************************
602 Chapter 23  Library Support for Numbers and Character Data

fpclassify

Table 23.9
Number-Classification
Macros

isfinite
isinf
isnan
isnormal

signbit

The C99 version of <math.h> also includes a number of completely new
l'unctions (and function-like macros). PIl give a brief description of each one. As in
Section 23.3, 1 won’t discuss error conditions for these functions, but Appendix
D—which lists all standard library functions in alphabetical order—provides this
information. ! won’t list the names of all the new functions in the left margin:
instead, TIl show just the name of the primary function. For example. there are
three new functions that compute the arc hyperbolic cosine: acosh, acosh£. and
acoshl. l'Il describe acosh and display only its name in the left margin.

Keep in mind that many of the new functions are highly specialized. As a
result, the descriptions of these functions may seem sketchy. À discussion of what
these functions are used for is outside the scope of this book.

Classification Macros

int fpclassify (real-floatine x) ;
int isfinite (real-floating x) ;
int isinf (real-floating x) ;

int isnan (real-floating x) ;

int isnormal (real-floating x) ;
int signbit (real-floatinge x) ;

Our first category consists of function-like macros that are used to determine
whether a floating-point value is a “normal” number or a special value such as
infinity or NaN. The macros in this group aré designed to accept areuments of any
real floating type (£loat, double, or 1ong double).

The fpclassify macro classifies its argument, returning the value of one
of the number-classification macros shown in Table 23.9. An implementation may
support other classifications by defining additional macros whose names begin
with FP_ and an upper-case letter.

 

 

 

 

Name Meaning
FP INFINITE Infinity (positive or negative)
FP NAN Not a number
FP NORMAL Normal (not zero, subnormal. infinite, or NaN)
FP SUBNORMAL Subnormal
FP ZERO /ero (positive or negative)

 

The isfinite macro returns a nonzero value if its argument has a finite
value (zero, subnormal, or normal, but not infinite or NaN). isinf returns à non-
zero value if its argument has the value infinity (positive or negative). isnan
returns a nonzero value if its argument is a NaN value. isnormal returns a non-
zero value if its argument has a normal value (not zero, subnormal, infinite, or
NaN).

The last classification macro is a bit different from the others. signbit
returns a nonzero value 1f the sign of its argument is negative. The argument need
not be a finite number; signbit also works for infinity and NaN.

***************************page_628***************************
 

23.4  The <math.h> Header (C99): Mathematics 603
Trigonometric Functions

float acosf (float x); see acos
long double acosl (1ong double x); see acos
float asinf (float x); see asin
long double asinl (long double x) ; see asin
float atanf (float x); see atan
long double atanl (long double x) ; see atan
float atan2f(float y, float x); see atan2
long double atan21 (l1ong double w,

lJong double x); see atan2
float cosf (float x); see COS
long double cosl (long double x); see COs
float sinf (float x) ; see sin
long double sinl (long double x); see sin
float tanf (float x); see tan
long double tanl (long double x); see tan

The only new trigonometric functions in C99 are analogs of C89 functions. For
descriptions, see the corresponding functions in Section 23.3.

Hyperbolic Functions

double acosh(double x) ;
float acoshf (float x) ;
long double acoshl (long double x);

double asinh (double x);
float asinhf (float x);
long double asinhl (long double x);

double atanh (double x) ;
float atanhf (float x) ;
long double atanhl (long double x) ;

float coshf (float x) ; see cosh
long double coshl (long double x) ; see cosh
float sinhf (fIoat x) ; see sinh
long double sinhl (long double x); see sinh
float tanhf (float x); see tanh
long double tanhl (long double x) ; see tanh

***************************page_629***************************
604 Chapter 23  Library Support for Numbers and Character Data

acosh  Six functions in this group correspond to the C89 functions cosh, sinh. and

asinn _ tanh. The new functions are acosh, which computes the arc hyperbolic cosine:

atanh  as inh, which computes the arc hyperbolic sine; and atanh, which computes the
arc hyperbolic tangent.

Exponential and Logarithmic Functions

float expf (float x); see exp
long double expl (long double x) ; see exp

double exp2 (double x) ;
float exp2I£ (float x);
long double exp21(long double x);

double expm1 (double x);
Éloat expmif (float x);
long double expm1l (10ng double x);

float frexpf (float value, int *exp) ; see frexp
long double frexpl (long double value,
int *exp) ; see frexp

int ilogb(double x);
int ilogb£ (Float x) ;
int ilogbl (long double x) ;

float 1ldexpf (float x, int exp); see 1dexp
Jong double 1dexp! (long double x, int exp); — seeldexp
float log£ (float x); see log
Jong double logl(long double x) ; see log
float log10f (float x) ; see log10
long double 10g101(long double x); see log10

double log1Ip(double x);
float log1pf (float x) ;
long double 10g1p1 (long double x);

double 1092 (double x) ;
float log2f (float x);
long double 10g21 {long double x);

double logb (double x);
float logb£ (float x) ;
long double l1ogbl (long double x) ;

float modff (float value, float *iptr); see modf
long double modf!1{long double value,
long double *iptr) ; see modf

***************************page_630***************************
exp2
expm1

logb
iIlogb

log1p
log2

scalbn
scalblin

cbrt

 

23.4  The <math.h> Header (C99): Mathematics 605

double scalbn (double x, int n);

float scalbnf (float x, int n);

long double scalbnl (long double x, int n);
double scalbln (double x, long int n);

float scalbln£ (float x, long int n);

long double scalblnl{(long double x, long int n);

In additional to new versions of exp, frexp., 1dexp, log. log10, and modf,
there are several entirely new functions in this category. Two of these, exp2 and
expml, are variations on the exp function. When applied to the argument x, the
exp2 function returns 2*. and expm1 returns e* — 1.

The 1logb lf'unction returns the exponent of its argument. More precisely. the
call 1ogb (x) returns log (Ixl), where » is the radix of floating-point arithmetic
(defined by the macro FLT_RADIX. which typically has the value 2). The ilogb
function returns the value of 10gb after it has been cast to int type. The 1og1p
function returns In(! + x) when given x as its argument. The 10og2 function com-
putes the base-2 logarithm of its argument.

The scalbn function returns x x FLT RADIX", which it computes in an
efficient way (not by explicitly raising FLT RADIX to the nth power). scalbln
is the same as scalbn, except that its second parameter has type long int
instead of int.

Power and Absolute Value Functions

double cbrt (double x) ;
float cbrtf(float x);
long double cbrtl (long double x);

float fabs£ (float x); see fabs
long double fabsl (long double x); see fabs

double hypot (double x, double y);
float hypotf (float x, float y);
Jong double hypotl(long double x, long double y);

float powf (float x, float y); see pow
long double powl (long double x,

long double y); see pow
float sqrtf(float x); see sqrt
Jong double sgrtl (long double x) ; see sqrt

Several functions in this group are new versions of old ones (fabs, pow, and
sqrt). Only the functions cbrt and hypot (and their variants) are entirely new.

The cbrt function computes the cube root of its argument. The pow function
can also be used for this purpose, but pow is unable to handle negative arguments

***************************page_631***************************
606

Chapter 23  Library Support for Numbers and Character Data

hypot

erf&
erfc

lgamma
tgamma

eF3 e

(a domain error occurs). cbrt, on the other hand, is defined for both positive and
negative arguments. When its argument is negative, cbrt returns a negative result.

When applied to arguments x and y, the hypot function returns /x? + y2. In
other words, this function computes the hypotenuse of a right triangle with legs x
and y.

Error and Gamma Functions

double erf (double x) ;
float erff(float x);
long double erf1(long double x) ;

double erfc (double x) ;
float erfcf (float x);
long double erfcl(long double x);

double l1gamma (double x) ;
float lgammaf (float x);
long double 1gammal (long double x) ;

double tgamnma (double x) ;
float tgammaf (float x) ;
long double tgammal (long double x);

The er£ function computes the error function erf (also known as the Gaussian
error function), which is used in probability, statistics and partial differential
equations. The mathematical definition of erf is

erf(x) = ÀJ.‘e-'zdt
JT “
erfc computes the complementary error function, erfc(x) = | — erf(x).

The gamma function T is an extension of the factorial function that can be
applied to real numbers as well as to integers. When applied to an integer n, T(n) =
(n—1)!; the definition of P for nonintegers is more complicated. The tgamma func-
tion computes l'. The 1gamma function computes In(IT(x)l), the natural logarithm
of the absolute value of the gamma function. 1gamma can sometimes be more use-
ful than the gamma function itself, because P grows so quickly that using it in cal-
culations may cause overflow.

Nearest Integer Functions

float ceilf(float x); see ceil
long double ceill (long double x); seeceil
float floorf (float x); see floor

long double f1oorl (long double x) ; see Éloor

***************************page_632***************************
nearbyint

rint

Irint
Ilrint

round

 

23.4  The <math. h> Header (C99): Mathematics 607

double nearbyint (double x) ;
float nearbyintf (float x);
long double nearbyintl (1long double x);

double rint (double x) ;
float rintf(float x),;

long

Jong
long
Jlong
long
long
long

double rintl (long double x);

int lrint (double x);
int lrintf(float x);
int lrintl (long double x);
long int llrint (double x);
long int l1lrintf (float x);
long int llrintl (1ong double x);

double round (double x) ;
float roundf (float x) ;

long

lJong
long
long
long
long

double roundl (long double x);

int l1round (double x) ;
int l1lroundf (float x);
int lround!(long double x);
long int llround (double x);
long int l]lroundf (float x);

long long int 11round1l (long double x);

double trunc (double x) ;
float truncf (float x);
Jong double truncl (long double x);

Besides additional versions of ceil and floor. C99 has a number of new func-
tions that convert a floating-point value to the nearest integer. Be careful when
using these functions: although all of them return an integer, some functions
return it in floating-point format (as a float, double, or long double
value) and some return it in integer format (as a long int or long long int
value).

The nearbyint function rounds its argument to an integer, returning it as a
floating-point number. nearbyint uses the current rounding direction and does
not raise the inexaci floating-point exception. rint is the same as nearbyint,
except that it may raise the inexact floating-point exception if the result has a dif-
ferent value than the argument.

The Lrint function rounds its argument to the nearest integer, according to
the current rounding direction. 1rint returns a long int value. 11rint is the
same as 1rint, except that it returns a long long int value.

The round function rounds its argument to the nearest integer value, return-
ing It as a floating-point number. round always rounds away from zero (so 3.5 is
rounded to 4.0, for example).

***************************page_633***************************
608

Chapter 23  Library Support for Numbers and Character Data

Iround
IIround

Irunc

remainder

remquo

The 1round function rounds its argument to the nearest integer value, return-
ing it as a long int value. Like round, it rounds away from zero. 11round is
the same as 1round, except thal it returns a long long int value.

The trunc function rounds its argument to the nearest integer not larger in
magnitude. (In other words, it truncates the argument toward zero.) trunc returns
the result as a floating-point number.

Remainder Functions

float fmodf (float x, float y); see fmod
long double fmodi (1long double x,
Jong double y); see fmod

double remainder (double x, double y);

float remainderf (float x, £loat y);

long double remainder1l(long double x,
long double y);

double remquo (double x, double y, int *quo) ;

float remquof (float x, float y, int *quo);

long double remquol (long double x, long double y,
int *quo) ;

Besides additional versions of fmod, this category includes new remainder func-

tions named remainder and remquo.
The remainder function returns x REM y, where REM is a function defined

in the IEEE standard. For y # O, the value of x REM y is » = x — ny, where n is the
integer nearest the exact value of x/y. (If x/y is halfway between two integers, n
is even.) If r = O, it has the same sign as x.

The remquo function returns the same value as remainder when given the

same first two arguments. In addition, remquo modifies the object pointed to by
the quo parameter so that it contains n low-order bits of the integer quotient Ix/yl,
where n depends on the implementation but must be at least three. The value stored
in this object will be negative 1f x/y < 0.

Manipulation Functions

double copysign (double x, double y);
float copysignf (float x, float y);
long double copysignl (long double x, long double y);

double nan(const char *tagp);
float nanf (const char *tagp);
long double nanl (const char *tagp) ;

double nextafter (double x, double y);
float nextafterf (float x, float y);

***************************page_634***************************
copysign

nan

ls Lud flunclion » 28.2

nextafter

Qa&Â
nexttoward

23.4  The <math.h> Header (C99): Mathematics 609

long double nextafterl (long double x, long double y);

double nexttoward (double x, long double y);
float nexttowardf (float x, long double y);
long double nexttowardl (long double x,

Ilong double y);

The mysteriously named ‘“manipulation functions” are all new in C99. They pro-
vide access to the low-level details of floating-point numbers.

The copysign function copies the sign of one number to another number.
The call copysign (x, y) returns a value with the magnitude oï x and the sign
of y.

The nan function converts a string to a NaN value. The call nan ( "n-char-
sequence") 1s equivalent to strtod ("NAN (n-char-sequence) ", (char**)
NULL). (Sec the discussion of strtod for a description of the format of n-char-
sequence.) The call nan ("") 1s equivalent to strtod("NAN()", (char**)
NULL). 1f the argument in à call of nan doesn’t have the value "n-char-
sequence" or "", the call is equivalent to strtod ("NAN", (char**) NULL).
If quiet NaNs aren't supported. nan returns zero. Calls of nanf and nanl are
equivalent to calls of strtof and strtold, respectively. This function 1s used
to construct a NaN value containing a specific binary pattern. (Recall from earlier
in this section that the fraction part of a NaN value 1s arbitrary.)

The nextafter function determines the next representable value of a num-
ber x (if all values of x’s type were listed in order, the number that would come
just before or just after x). The value of y determines the direction: if y < x, then
the function returns the value just before x; if x < y, it returns the value just after x.
If x and y are equal. nextafter returns y.

The nexttoward function is the same as nextaËter, except that the y
parameter has type long double instead of double. If x and y are equal,
nexttoward returns y converted to the function’s return type. The advantage of
nexttoward is that a value of any (real) floating type can be passed as the second
argument without the danger of it being incorrectly converted to a narrower type.

Maximum, Minimum, and Positive Difference Functions

double fdim(double x, double y);
float fdimf (float x, float y);
long double fdiml (long double x, long double y);

double fmax (double x, double y);
float fmaxf (float x, Éloat y);
long double fmax]l (long double x, l1ong double y);

double fmin (double x, double y);
float fminf (float x, float y);
long double fminl (long double x, long double y);

***************************page_635***************************
610

Chapter 23  Library Support for Numbers and Character Data

fdim

max
fmin

ima

The £dim function computes the positive difference of x and y:

x-y 1Ifx>y
+0 fx<y

The fmax function returns the larger of its two arguments. fmin returns the
value of the smaller argument.

Floating Multiply-Add

double fma (double x, double y, double z);

float fmaf (float x, float y, float z);

long double fmal (long double x, long double y,
Jong double z);

The fma function multiplies its first two arguments, then adds the third argument.
In other words, we could replace the statement

a = b * C + d;
with
a = fma(b, c, d);

This function was added to C99 because some newer CPUs have a ‘‘fused multi-
ply-add” instruction that both multiplies and adds. Calling fma tells the compiler
to use this instruction (if available), which can be faster than performing separate
multiply and add instructions. Moreover, the fused multiply-add instruction per-
forms only one rounding operation, not two, so it may produce a more accurate
result. lls particularly useful for algorithms that perform a series of multiplications
and additions, such as the algorithms for finding the dot product of two vectors or
multiplying two matrices.

To determine whether calling the fma function is a good idea, a C99 program
can test whether the FP_FAST_FMA macro 1s defined. If it is, then calling fma
should be faster than—or at least as fast as—performing separate multiply and add
operations. The FP _ FAST _ FMAF and FP _ FAST FMAL macros play the same
role for the fma£ and fmal functions, respectively.

Performing a combined multiply and add is an example of what the C99 stan-
dard calls ‘’contraction,” where two or more mathematical operations are combined
and performed as a single operation. As we saw with the fma function. contraction
often leads to better speed and greater accuracy. However, programmers may wish
to control whether contraction is done automatically (as opposed to calls of fma,
which are explicit requests for contraction), since contraction can lead to slightly
different results. In extreme cases, contraction can avoid a float-point exception
that would otherwise be raised.

***************************page_636***************************
#Hpragma directive » 74.5

isgreater
isgreaterequal
isless
islessequal

islessgreater

isunorderea

 

23.4  The <math.h> Header (C99): Mathematics 611

C99 provides a pragma named FP_CONTRACT that gives the programmer
control over contraction. Here’s how the pragma is used:

fpragma STDC FP CONTRACT on-off-switch

The value of on-aff-switch is either ON, OFF, or DEFAULT. If ON is selected. the
compliler is allowed to contract expressions; if OFF is selected, the compiler is pro-
hibited from contracting expressions. DEFAULT is useful for restoring the default
setting (which may be either ON or OFF). If the pragma is used at the outer level of
à program (outside any function definitions), it remains in effect until a subsequent
FP CONTRACT pragma appears in the same file, or until the file ends. If the
pragma 1s used inside a compound statement (including the body of a function), it
must appear first, before any declarations or statements; it remains in effect until
the end of the statement, unless overridden by another pragma. A program may
still call £ma to perform an explicit contraction cven when FP_ CONTRACT has
been used to prohibit automatic contraction of expressions.

Comparison Macros

int isgreater (real-floating x, real-floating y) ;

int isgreaterequal (real-floatinge x, real-floating y) ;
int isless (real-floating x, real-floating y) ;

int islessequal (real-floating x, real-floating y) ;
int islessgreater (real-floatine x, real-floating y) ;
int isunordered (real-floating x, real-floating y) ;

Our final category consists of function-like macros that compare two numbers.
These macros are designed to accept arguments of any real floating type.

The comparison macros exist because of a problem that can arise when float-
ing-point numbers are compared using the ordinary relational operators such as <
and >. If either operand (or both) is a NaN, such a comparison may cause the
invalid floating-point exception to be raised, because NaN values—unlike other
floating-point values—are considered to be unordered. The comparison macros
can be used to avoid this exception. These macros are said to be “quiet” versions of
the relational operators because they do their job without raising an exception.

The isgreater, isgreaterequal, isless, and islessequal mac-
ros perform the same operation as the >, >=, <, and <= operators, respectively,
except that they don’t cause the invalid floating-point exception to be raised when
the arguments are unordered.

The call islessgreater (x, y) is equivalent to (x) < (y) | | (x) >
(y), except that it guarantees not to evaluate x and y twice, and—like the previ-
ous macros—doesn’t cause the invalie Floating-point exception to be raised when
x and y are unordered.

The isunordered macro returns | if its arguments are unordered (at least
one of them 1s a NaN) and 0 otherwise.

***************************page_637***************************
612

Chapter 23  Library Support for Numbers and Character Data

23.5

locales » 25. 1

The <ctype.h> Header: Character Handling

The <ctype .h> header provides two kinds of functions: character-classification
functions (like isdigit, which tests whether a character is a digit) and character
case-mapping functions (like toupper, which converts a lower-case letter to
upper case).

Although C doesn*t require that we use the functions in <ctype .h> to test
characters and perform case conversions, itl’s a good idea to do so. First, these
functions have been optimized for speed (in fact, many are implemented as mac-
ros). Second, we’ll end up with a more portable program, since these functions
work with any character set. Third, the <ctype .h> functions adjust their behav-
lor when the locale is changed. which helps us write programs that run properly in
different parts of the world.

The functions in <ctype .h> all take int arguments and return int val-
ues. In many cases, the argument 1s already stored in an int variable (often as a
result of having been read by a call of fgetc, getc, or getchar). If the argu-
ment has char type, however, we need to be careful. C can automatically con-
vert a char areument to int type; if char 1s an unsigned type or if we're
Using a seven-bit character set such as ASCII, the conversion will go smoothly.
But if char is a signed type and if some characters require eight bits, then con-
verting such a character from char to int will give a negative result. The be-
havior of the <ctype .h> functions is undefined for negative arguments (other
than EOF), potentially' causing serious problems. In such a situation, the argu-
ment should be cast to unsigned char for safety. (For maximum portability,
some programmers always cast a char value to unsigned char when pass-
ing it to a <ctype.h> function.)

Character-Classification Functions

int isalnum(int
int isalpha (int
int isblank (aint
int iscntrl (int
int isdigit (int
int isgraph(int
int islower (int
int isprint (int

(

(

(

Q QO À
û SP eF m0 m0 UE C00 700 8 VN m m
- — . s. — e

. —.

v—e

int ispunct (int
int isspace (int
int isupper (int
int isxdigit (int

—

w.

QO O O QO O Q QO O

— m e
…

***************************page_638***************************
 

23.5  The <ctype.h> Header: Character Handling 613

Each character-classification function returns a nonzero value if its argument has a
particular property. Table 23.10 lists the property that each function tests.

 

 

 

 

Table 23.10 Function Test
Character—Classilîca}ion isalnum(c) [Is c alphanumeric?
Functions isalpha (c) Is c alphabetic?
isblank (c) Is c a blank ?
iscntrl (c) Is c a control character?**
isdigit (c) 1s c a decimal digit?
isgraph(c) Is c a printing character (other than a space)?
islower (c) Is c a lower-case letter?
isprint (c) Is € à printing character (including a space)?
ispunct (c) Is c punetuation ?***
isspace (c) Is c a white-space character?****
isupper (c) [s c an upper-case letter’
isxdigit(c) Is cahexadecimal digit?

 

“The standard blank characters are space and horizontal tab (\t). This
function is new in C99.

n ASCII, the control characters are \x00 through \x1£ plus \x 7£.
TT AN printing characters except those for which isspace or isalnum
are true are considcred punctuation.

TtTre White-space characters are space. form fced (\ £), new-line (\n).
carriage return (\r), horizontal tab (\t), and vertical tab (\v).

@ The C99 definition of ispunct is slishtly different than the one in C89. In
C89, ispunct (c) tests whether c is à printing character but not a space or a
character for which isalnum(c) is true. In C99, ispunct (c) tests whether
C is a printing character for which neither isspace (c) nor isalnum(c) is
true.

PROGRAM  Testing the Character-Classification Functions

The following program demonstrates the character-classification functions (with
the exception of isblank, which is new in C99) by applying them to the charac-
ters in the string "azAZO !\t".

iclassify.c /* Tests the character-classification functions */

#Hinclude <ctype.h>
#include <stdio.h>

Hdefine TEST(£) printf(" %c ", £(*p) ? 'x' : " !)
int main (void)
{
char *p;
printf (" alnum cntrl graph print"
!" space xdigit\n"
" alpha digit lower punct "

"l upper\nn ) ;

***************************page_639***************************
614

Chapter 23  Library Support for Numbers and Character Data

tolower
toupper

PROGRAM

£or (p = "azAZO !\t";

if (isentrl(*p))

print£ ("\\x302x:",
else

print£ (" +c:",
TEST (isalnum) ;
TEST (isalpha) ;
TEST (iscntr1) ;
TEST (isdigit) ;
TEST (isgraph) ;
TEST (islower) ;
TEST (isprint) ;
TEST (ispunct) ;
TEST (isspace) ;
TEST (isupper) ;
TEST (isxdigit) ;
print£("\n") ;

*p != '"\0'; p++) |
*p) ;

*p) ;

}

return 0;

}

The program produces the following output:

alnum ecntrl
alpha
x

graph print space
digit lower punct
x
x

xdigit
upper

ON PF N 9
1 KN XX
» e

“ %

“ %n
nN N À K %

r

*

l :
\x09 :

S
2
=
P

*

Character Case-Mapping Functions

int tolower (int c);
int toupper (int c);

The tolower function returns the lower-case version of a letter passed to it as an
argument, while toupper returns the upper-case version. If the argument to
either function is not a letter, it returns the character unchanged.

Testing the Case-Mapping Functions

The following program applies the case-mapping functions to the characters in the
string "aAO ! ".

***************************page_640***************************
{casemap.c

23.6

23.6  Ihe<string.h> Header: String Handling

/* Tests the case-mapping functions */

finclude <ctype.h>
#include <stdio.h>

int main (void)

{
char *p;
for (p = "aAO!"; *p != '\0'; p++) (
print£ ("tolower('%c') is '%c'; ", *p,
print£ ("toupper('%c') is '$c'\n", *p,
}
return 0;
}

The program produces the following output:

tolower('a') is 'a'; toupper('a') is 'A'
tolower('A') is 'a'; toupper('A') is 'a'
tolower('0') is 'O'; toupper('0') is "'0'
tolower ('!') is '!'; toupper('!') is "!"

tolower (*p) ) ;
toupper (*p)) ;

The <string.h> Header: String Handling

615

We first encountered the <string. h> header in Section 13.5, which covered the
most basic string operations: copying strings, concatenating strings, comparing
strings, and finding the length of a string. As we*I1 see now, there are quite a few
string-handling functions in <string.h>, as well as functions that operate on
character arrays that aren*t necessarily null-terminated. Functions in the latter cate-
gory have names that begin with mem, to suggest that these functions deal with
blocks of memory rather than strings. These memory blocks may contain data of
any type, hence the arguments to the mem functions have type void * rather than

char *.
<string.h> provides five kinds of functions:

= Copying functions. Functions that copy characters from one place in memory

to another place.

=n Concatenation functions. Functions that add characters to the end of a string.

= Comparison functions. Functions that compare character arrays.

m Search functions. Functions that search an array for a particular character, a

set of characters, or a string.

m Miscellaneous functions. Functions that initialize a memory block or com-

pute the length of a strine.

We'll now discuss these functions, one group at a time.

***************************page_641***************************
616 Chapter 23  Library Support for Numbers and Character Data

QaAâ

memcpy
memmove

strcpy
strncpy

Copying Functions

void *memcpy (void * restrict sl,
const void * restrict s2, size t n);
void *memmove (void *s1, const void *s2, size t n);
char *strcpy (char * restrict s1l,
const char * restrict s2);
char *strncpy (char * restrict sl,
const char * restrict s2, size t n');

The functions in this category copy characters (bytes) from one place in memory
(the “source”) to another (the “destination’’). Each function requires that the first
argument point to the destination and the second point to the source. AIl copying
functions return the first argument (a pointer to the destination).

memcpy copies n characters from the source to the destination. where n 1s the
function’s third argument. If the source and destination overlap. the behavior of
memcpy 1s undefined. memmove 1s the same as memcpy, except that 1t works cor-
rectly when the source and destination overlap.

strcpy copies a null-terminated string from the source to the destination.
strncepy 1s similar to stropy, but it won’t copy more than n characters, where
n is the function’s third argument. (If n is too small, strnopy won°t be able to
copy a terminating null character.) If it encounters a null character in the source,
strncopy adds null characters to the destination until it has written a total of n
characters. stropy and strnopy, like memopy, aren’t guaranteed to work if the
source and destination overlap.

The following examples illustrate the copying functions: the comments show
which characters are copied.

char SOUICE[] — {|hl, 'o', ‘t', I\Ol, ‘t', 'e'a lal};
char dest [7] ;

memcpy (dest, source, 3); /* h, o, t */
memcpy (dest, source, 4); /* h, o, t, \0O */
memcpy (dest, source, 7); /+ h, o, t, \0, t, e, a */
memmove (dest, source, 3) ; /* h, o, t */
memmove (dest, source, 4); /* h, o, t, \0O */
memmove (dest, source, 7) ; /* h, o, t, \0, t, e, a */
stropy (dest, source) ; /* h, o, t, \0O */
strncopy (dest, source, 3); /* h, o, t */
strncpy (dest, source, 4); /* h, o, t, \0O * /

strncpy (dest, source, 7) ; /* h, o, t, \0, \0, \0, \0 */

Note that memcpy, memmove, and strnopy don't require a null-terminated
string; they work just as well with any block of memory. The strcpy function, on
the other hand, doesn’t stop copying until it reaches a null character. so 1t works
only with null-terminated strings.

***************************page_642***************************
strcat

strncat

23.6  The <string.h> Header: String Handling 617

Section 13.5 gives examples of how strcpy and strnopy are typically
used. Although neither function is completely safe, strnopy at least provides a
way to limit the number of characters it will copy.

Concatenation Functions

char *strcat (char * restrict sl,
const char * restrict s2) ;
char *strncat (char * restrict sl,
const char * restrict s2, size t n);

strcat appends its second argument to the end of the first argument. Both argu-
ments must be null-terminated strings; strcat puts a null character at the end of
the concatenated string. Consider the following example:

char str[7] = "tea";
strcat (str, "bag") ; /* adds b, a, g, \0 to end of str */

The letter b overwrites the null character after the à in "tea*", so that str now
contains the string "teabag". strcat returns its first argument (a pointer).

strncat is the same as strcat, except that its third argument limits the
number of characters it will copy:

char str[7] = "tea";
strncat (str, "bag", 2); /* adds b, a, \0 to str * /
strncat (str, "bag", 3) ; /* adds b, a, g, \O to str */

strncat (str, "bag", 4); /* adds b, a, g, \0 to str */

Âs these examples show, strncat always leaves the resulting string properly
null-terminated.

In Section 13.5, we saw that a call of strncat often has the following ap-
pearance:

strncat (str1, str2, sizeof(str1) - strlen(str1) - 1);

The third argument calculates the amount of space remaining in str1 (given by
the expression sizeof (str1) - strlen(str1)) and then subtracts | to
ensure that there will be room for the null character.

Comparison Functions

int memcomp(const void *s1, const void *s2, size t n);
int streomp (const char *s1, const char *s2);
int strcoll (const char *s1, const char *s2) ;
int strnemp (const char *s1, const char *s2,
size t n);
size t strxfrm(char * restrict sl,
const char * restrict s2, size t n);

***************************page_643***************************
618

Chapter 23  Library Support for Numbers and Character Data

locales >25.1

memcmp
stremp
strnemp

strcoll

strxfrm

The comparison functions fall into two groups. Functions in the first group (mem-
cmp, stremp, and strnemp) compare the contents of two character arrays.
Functions in the second group (strcoll and strx£frm) are used if the locale
needs to be taken into account.

The memcmp, strcomp, and strnemp functions have much in common. AI
three expect to be passed pointers to character arrays. The characters in the first
array are then compared one by one with the characters in (lie second array. AÎl
three functions return as soon as a mismatch is found. Also, all three return a nega-
tive, zero, or positive integer, depending on whether the stopping character in the
first array was less than, equal to, or greater than the stopping character in the sec-
ond.

The differences among the three functions have to do with when to stop com-
paring characters if no mismatch is found. The memcomp function is passed a third
argument, n, that limits the number of comparisons performed: it pays no particu-
lar attention to null characters. stromp doesn’{ have à preset limit, stopping
instead when it reaches a null character in either array. (As a result, stromp
works only with null-terminated strings.) strnemp is a blend of memomp and
stremp; It stops when n comparisons have been performed or à null character is
reached in either array.

The following examples 1illustrate memcmp, stremp, and strnemp:

char s1[] = {'b',
char s2[) = {'b',

‘\o,
'\0':

|c|'

|ill lgll
g ‘ lcl'

'a', Irl}'.
'i': ! }

lall Itl ;
if (mememp(s1l, s2, o) … /* true */
if (mememp(s1, s2, 4) == O) … /* true */
if (memomp(s1, s2, 7) == O) /* false */

if (stromp(s1, s2) == 0) … /* true */
if (strnemp(s1, s2, 3) == 0O) … /* true */
if (strnomp(s1, s2, 4) == O) … /* true */
if (strnomp(s1, s2, 7) == 0) … /* true */

The strcol1 function is similar to stromp, but the outcome of the compar-
ison depends on the current locale.

Most of the time, strcoll 1s fine for performing a locale-dependent string
comparison. Occasionally, however, we might need to perform the comparison
more than once (a potential problem, since strcoll isn't especially fast) or
change the locale without affecting the outcome of the comparison. In these situa-
tions, the strx£rm (“string transform”) function is available as an alternative to
strcoll.

strx£E£rm transforms its second argument (a string), placing the result in the
array pointed to by the first argument. The third argument limits the number of
characters written to the array, including the terminating null character. Calling
strcemp with two transformed strings should produce the same outcome (nega-
tive, Zero, or positive) as calling strcoll with the original strines.

***************************page_644***************************
strchr

memchr

 

23.6  The <string.h> Header: String Handling 619

strxfrm returns the length of the transformed string. As a result, it’s typi-
cally called twice: once to determine the length of the transformed string and once
to perform the transformation. Here’s an example:

size t len;
char *transformed ;

len = strxfrm(NULL, original, O);
transformed = malloc(len + 1);
strxfrm(transformed, original, len}) ;

Search Functions

void *memchr (const void *s, int c, size t n);
char *strchr (const char *s, int C);
size t strespn(const char *s1, const char *s2);
char *strpbrk (const char *s1, const char *s2) ;
char *strrchr (const char *s, int c);
size_t strspn(const char *s1, const char *s2) ;
char *strstr (const char *s1, const char *s2) ;
char *strtok (char * restrict s1l,

const char * restrict s2);

The strchr function searches a string for a particular character. The following
example shows how we might use strchr to search a string for the letter £.

char *p, str[] = "Form follows function.";
p = strchr(str, 'f'); /* finds first '£' */

strchr returns a pointer to the first occurrence of £ in str (the one in the word
follows). Locating multiple occurrences of a character is easy; for example, the
call

p = strchr(p + 1, '£!); /* finds next 'f' */

finds the second £ in str (the one in function). If it can*t locate the desired
character, strchr returns a null pointer.

memchr is similar to strchr, but it stops searching after a set number of
characters instead of stopping at the first null character. memchr°s third argument
limits the number of characters it can examine—a useful capability if we don’t
want to search an entire string or if we’re searching a block of memory that’s not
terminated by a null character. The following example uses memchr to search an
array of characters that lacks a null character at the end:

char *p, str[22] = "Form follows function. ";

p = memchr(str, '£', sizeof(str));

***************************page_645***************************
620

strrchr

strpork

strspn
strespn

e F3 1N

strstr

strtok

Chapter 23 _ Library Support for Numbers and Character Data

Like the strchr function, memchr returns a pointer to the first occurrence of the
character. If it can’t find the desired character, memchr returns a null pointer.
strrchr is similar to strchr, but it searches the string in reverse order:

char *p, str[] = "Form follows function. ";

strrchr(str, 'f'),; /* finds last '£' */

p=

In this example, strrchr will first search for the null character at the end of the
string, then go backwards to locate the letter £ (the one in function). Like
strchr and memchr, strrchr returns a null pointer if it fails to find the

desired character.
strpbrk is more general than strchr; it returns a pointer to the leftmost
character in the first argument that matches any character in the second argument:

char *p, str[] = "Form follows function. ";

p = strpbrk(str, "mn") ; /* finds first 'm' or 'n' */

In this example, p will point to the letter m in Form. strpbrk returns a null
pointer 1f no match is found.

The strspn and strespn functions, unlike the other search functions,
return an integer (of type size_t), representing a position within a string. When
given a string to search and a set of characters to look for, strspn returns the
index of the first character that's nor in the set. When passed similar arguments.
strcespn returns the index of the first character that’s in the set. Here are exam-
ples of both functions:

size t n;

char str([] = "Form follows function. ";

n = strspn(str, "morF") ; /* n=4r/
n = strspn(str, " \t\n") ; /* n 0 */
n = strospn(str, "morF") ; /* n O */
n = strespn(str, " \t\n") ; /*n =4r/

strstr searches its first argument (a string) for a match with its second
argument (also a string). In the following example, strstr searches for the word
fun:

char *p, str[] = "Form follows function.";

strstr(str, "fun") ; /* locates "fun" in str */

p:

strstr returns a pointer to the first occurrence of the search string; it returns a
null pointer if it can°t locate the string. After the call above, p will point to the let-
ter £ in function.

strtok is the most complicated of the search functions. Tts designed to
search a string for a ‘“‘token’”—a sequence of characters that doesn°t include certain
delimiting characters. The call strtok(s1, s2) scans the s1 string for a non-
empty sequence of characters that are not in the s2 string. strtok marks the end

***************************page_646***************************
23.6 The <string.h> Header: String Handling 621

of the token by storing a null character in s1 just after the last character in the
token; it then returns a pointer to the first character in the token.

What makes strtok especially useful is that later calls can find additional
tokens in the same string. The call strtok (NULL, s2) continues the search
begun by the previous strtok call. As before, strtok marks the end of the
token with a null character, then returns a pointer to the beginning of the token.
The process can be repeated until strtok returns a null pointer. inclicating that no
token was found.

To see how strtok works. we'Il use it to extract a month, day, and year from
a date written in the form

month day, year

where spaces and/or tabs separate the month from the day and the day from the
year. In addition. spaces and tabs may precede the comma. Let’s say that the string
str has the following appearance to start with:

 

 

After the call
p = strtok(str, " \t") ;

str will have the following appearance:

 

 

 

p points to the first character in the month string, which is now terminated by a
null character. Calling strtok with a null pointer as its first argument causes it to
resume the search from where it left off:

p = strtok(NULL, " \t,") ;

After this call. p points to the first character in the day:

Y

str 2‘8]\0'1\9.9l8

   

À final call of strtok locates the year:

p = strtok(NULL, " \t") ;

***************************page_647***************************
622

Chapter 23  Library Support for Numbers and Character Data

(

memset

strlen

strerror function >24.2

After this call, str will have the following appearance:

 

str

 

When strtok is called repeatedly to break a string into tokens, the second argu-
ment isn’t required to be the same in each call. In our example, the second call of
strtok has the argument " \t, " insteadof " \t".

strtok has several well-known problems that limit its usefulness; PIl men-
tion just a couple. First, it works with only one string at a time; it can*t conduct
simultaneous searches through two different strings. Also, strtok treats a
sequence of delimiters in the same way as a single delimiter, making it unsuitable
for applications in which a string contains a series of fields separated by à delimiter
(such as a comma) and some of the fields are empty.

Miscellaneous Functions

void *memset (void *s, int c, size t n);
size t strlen(const char *s);

memset stores multiple copies of a character in a specified area of memory. If p
points to a block of N bytes, for example, the call

memset (p, ' ', N);

will store a space in every byte of the block. One of memsets uses is initializing
an array to zero bits:

memset (a, O, sizeof(a)) ;

memset returns its first argument (a pointer’).

strlen returns the length of a string, not counting the null character. See
Section 13.5 for examples of strlen calls.

There’s one other miscellaneous string function, strerror, which is cov-
ered along with the <errno .h> header.

Q & A

Why does the expm1 function exist, since all it does is subtract 1 from the
value returned by the exp function? [p. 605]

When applied to numbers that are close to zero, the exp function returns a value
that’s very close to 1. The result of subtracting 1 from the value returned by exp
may not be accurate because of round-off error. expm1 is designed to give a more
accurate result in this situation.

***************************page_648***************************
Section 23.3

O

2

> .&

Exercises 623

The 1log1p function exists for a similar reason. For values of x that are close
to zero, log1p (x) should be more accurate than log (1 + x).

Why is the function that computes the gamma function named tgamma
instead of just gamma? [p. 606]

Àt the time the C99 standard was being written, some compilers provided a func-
tion named gamma, but 1t computed the log of the gamma function. This function
was later renamed 1gamma. Choosing the name gamma for the gamma function
would have conflicted with existing practice, so the C99 committee decided on the
name tgamma (‘‘true gamma”) instead.

Why does the description of the nextafter function say that if x and y are
equal, nextafter returns y? If x and y are equal, what*s the difference
between returning x or y? [p. 609]

Consider the call nextafter(-0.0, +0.0). in which the arguments are
mathematically equal. By returning y instead of x, the function has a return value
of +0.0 (rather than —0.0, which would be counterintuitive). Similarly, the call
nextafter(+0.0, -O.0}) returns —0.0.

Why does <string.h> provide so many ways to do the same thing? Do we
really need four copying functions (memcpy, memmove, strcopy, and
strncpy)? [p. 616]

Let’s start with memcpy and stropy. These functions are used for different pur-
poses. stropy will only copy a character array that’s terminated with a null char-
acter (a string, in other words); memcpy can copy a memory block that lacks such
a terminator (an array of integers, for example).

The other functions allow us to choose between safety and performance.
strncpy 1s safer than strcopy, since it limits the number of characters that can be
copied. We pay a price for safety, however, since strncopy is likely to be slower
than strepy. Using memmove involves a similar trade-off. memmove will copy
bytes from one region of memory into a possibly overlapping region. memcpy isn’t
guaranteed to work properly in this situation; however, 1f we can guarantee no over-
lap, memcpy is likely to be faster than memmove.

Why does the strspn function have such an odd name? [p. 620]

Instead of thinking of strspn’s return value as the index of the first character
that’s not in à specified set, we could think of it as the length of the longest “span”
of characters that are in the set.

Exercises

Extend the round_nearest function so that it rounds a floating-point number x to n dig-
its after the decimal point. For example, the call round_nearest (3.14159, 3) would

***************************page_649***************************
624 Chapter 23  Library Support for Numbers and Character Data

Section 23.4 2.
3,
Section 23.5 4.
5.

Section 23.6 M 6.

7.
D 8

9,
@ 10.

return 3.142. Hint: Mulüiply x by 10", round to the nearest integer, then divide by 10". Be
sure that your function works correctly for both positive and negative values of x.

(C99) Write the following function:
double evaluate _ polynomial (double a[], int n, double X) ;

The function should return the value of the polynomial a,x" + a, p + ue + G, where the
a; s are stored in corresponding clements of the array a, which has length n + !. Have the
function use Horner's Rule to compute the value of the polynomial:

(C MN H An JX 4Æ A 2JN 4 000 )X 4 AIIX + A

Use the £Ema function to perform the multiplications and additions.

(C99) Check the documentation for your compiler to see if it performs contraction on arith-
metic expressions and, if so, under what circumstances.

Using isalpha and isalnum, write a function that checks whether a string has the syn-
tax ofa C identifier (it consists of letters, digits, and underscores, with a letter or underscore
at the beginning).

Using isxdigit, write a l'unction that checks whether a string represents a valid hexadec-
imal number (it consists solely of hexadecimal digits). IF so. the function returns the value of
the number as a long int. Otherwise. the function returns —I

In each of the following cases, indicate which function would be the best to use: memcpy.
memmove, strcpy. or strncpy. Assume that the indicated action is to be performed by a
single funetion call.

(a) Moving all eclements of an array “down” one position in order to leave room for a new
element in position 0.

(b) Deleting the first character in a null-terminated string by moving all other characters
back one position.

(c) Copying a string into a character array that may not be large enough to hold it. If the
array is too small. assume that the string is to be truncated; no null character is neces-
sary at the end.

(d) Copying the contents of one array variable into another.

Section 23.6 explains how to call strchr repeatedly to locate all occurrences of a charac-
ter within a string. Is it possible to locate all occurrences in reverse order by calling
strrchr repeatedly?

Use strchr to write the following function:

int numchar (const char *s, char ch);

numchar returns the number of times the character ch occurs in the string s.

Replace the test condition in the lollowing i £ statement by à single call of strchr:
if (ch == ‘'a' || ch == 'b' || ch == "c')

Replace the test condition in the following à £ statement by à single call of strstr:

O || stremp(str, "bar") == O ||
0)

Hint: Combine the string literals into à single string. separating them with a special charac-
ter. Does your solution assume anything about the contents of str”

Lif (stromp(str, "foo") =
stromp(str, "baz")

***************************page_650***************************
® 1.

Programming Projects 625

Write a call of memset that replaces the last n characters in a null-terminated string s with
! characters.

Many versions of <string.h> provide additional (nonstandard) functions, such as those
listed below. Write each function using only the fcatures of the C standard.

(a) strdup (s) — Returns a pointer to a copy of s stored in memory obtained by calling
malloc. Returns a null pointer 1f enough memory couldn’t be allocated.

(b) stricmp(s1, s2) — Similar to stromp, but ignores the case of letters.

(c) strlwr (s) — Converts upper-case letters in s to lower case. leaving other characters
unchanged; returns s.

(d) strrev (s) — Reverses the characters in s (except the null character); returns s.

(e) strset (s, ch) Fills s with copies of the character ch: returns s.

 

If you test any of these functions, you may need to alter its name. Functions whose names
begin with str are reserved by the C standard.

Use strtok to write the following function:
int count words (char *sentence) ;

count _words returns the number of words in the string sentence, where a ‘’word”’ is
any sequence of non-white-space characters. count _ words 1s allowed to modify the
string.

Programming Projects

° n . ” ° .
Write a program that finds the roots of the equation ax* + bx + c = 0 using the formula

L- —h + Jb? — dac

2a

 

Have the program prompt for the values of a, b, and c, then print both values of x. f b* —
dac is negative, the program should instead print a message to the effect that the roots are
complex.)

Write a program that copies a text file from standard input to standard output, removing all
white-space characters from the beginning of cach line. À Iime consisting entirely of white-
space characters will not be copied.

Write à program that copies a text file from standard input to standard output, capitalizing
the first letter in each word.

Write a program that prompts the user to enter a series of words separated by single spaces,
then prints the words in reverse order. Read the input as à string, and then use strtok to
break 1t into words.

Suppose that money 1s deposited into à savings account and left for / years. Assume that the
annual interest rate is r and that interest is compounded continuously. The formula A(r) =
Pe"* can be used to calculate the final value of the account. where P is the original amount
deposited. For example, $1000 left on deposit for 10 years at 6% interest would be worth
$1000 x e°°*10 Z $1000 x e° = $1000 x 1.8221188 = $1.822.12. Write a program that dis-
plays the result of this calculation after prompting the user to enter the original amount
deposited, the interest rate, and the number of years.

***************************page_651***************************
626 Chapter 23  Library Support for Numbers and Character Data

6.  Write a program that copies a text file from standard input to standard output, replacing each
control character (other than \n) by à question mark.

1. Write a program that counts the number of sentences in a text file (obtained from standard
input). Assume that each sentence ends witha .. ?, or ! followed by a white-space charac-
ter (including \n).

***************************page_652***************************
24 Error Handling

There are two ways to write error-free
programs; only the third one works.

Although student programs often fail when subjected to unexpected input, com-
mercial programs need to be ‘“bulletproof—able to recover gracefully from errors
instead of crashing. Making programs bulletproof requires that we anticipate
errors that might arise during the execution of the program, include a check for
each one, and provide a suitable action for the program to perform 1f the error
should occur.

This chapter describes two ways for programs to check for errors: by using
the assert macro and by testing the errno variable. Scction 24.1 covers the
<assert .h> header, where assert is defined. Section 24.2 discusses the
<errno.h> header, to which the errno variable belongs. This section also
includes coverage of the perror and strerror functions. These functions,
which come from <stdio.h> and <string.h>, respectively, are closely re-
lated to the errno variable.

Section 24.3 explains how programs can detect and handle conditions known
as signals, some of which represent errors. The functions that deal with signals are
declared in the <signal .h> header.

Finally, Section 24.4 explores the setjmp/longjmp mechanism, which is
often used for responding to errors. Both setjmp and longjmp belong to the
<setjmp .h> header.

Error detection and handling aren*t among C°s strengths. C indicates run-time
errors in a variety of ways rather than in a single, uniform way. Furthermore, il’s
the programmer’s responsibility to include code to test for errors. lt's easy to over-
look potential errors; if one of these should actually occur, the program often con-
tinues running, albeit not very well. Newer languages such as C++, Java, and C#
have an “exception handling” feature that makes it easier to detect and respond to
errors.

627

***************************page_653***************************
628

Chapter 24  Error Handling

241

assert

stderr stream >22 1

abort [unction » 26.2

The <assert .h> Header: Diagnostics

void assert (scalar expression) ;

assert, which is defined in the cassert .h> header, allows a program to mon-
itor its own behavior and detect possible problems at an early stage.

Although assert is actually a macro. it’s designed to be used like a func-
tion. It has one argument. which must be an “assertion’—an expression that we
expect to be true under normal circumstances. Each time assert is executed. it
tests the value of its argument. If the argument has a nonzero value, assert does
nothing. If the argument’s value is Zero, assert writes a message to stderr
(the standard error stream) and calls the abort function to terminate program
execution.

For example, let’s say that the file demo. c declares an array a of length 10.
We're concerned that the statement

a[li] = 0O;

in demo.c might cause the program to fail because i isn’t between O and 9. We
can use assert to check this condition before we perform the assignment to
a[il:

assert(0 <= i && i < 10); /* checks subscript first */
a[i] = 0; /* now does the assignment */

If j's value 1s less than O or greater than or equal to 10, the program will terminate
after displaying a message like the following one:

Assertion failed: O <= i && i < 10, file demo.c, line 109

C99 changes assert in a couple of minor ways. The C89 standard states that
the argument to assert must have int type. The C99 standard relaxes this
requirement, allowing the argument to have any scalar type (hence the word scalar
in the prototype for assert). This change allows the argument to be a floating-
point number or a pointer, for example. Also, C99 requires that a failed assert
display the name of the function in which it appears. (C89 requires only that
assert display the argument—in text form—along with the name of the source
file and the source line number). The suggested form of the message is

Assertion failed: expression, function abe, file xyz, line nnn.

The exact form of the message produced by assert may vary from one com-
piler to another. although it should always contain the information required by the
standard. For example. the GCC compiler produces the following message in the
situation described earlier:

a.out: demo.c:109: main: Assertion 0 <= i && i < 10' Ffailed.

***************************page_654***************************
24.2

Ivalues > 4.2

saqrt function »23.3

Le 191N

24.2  The <errno.h> Header: Errors 629

assert has one disadvantage: it slightly increases the running time of a pro-
eram because of the extra check it performs. Using assert once in a while prob-
ably won't have any great effect on a program's speed, but even this small time
penalty may be unacceptable in critical applications. Às à result, many program-
mers use assert durine testing, then disable it when the program is finished.
Disabline assert is easy: we need only define the macro NDEBUG prior to
including the <assert .h> header:

#define NDEBUG
#include <assert.h>

The value of NDEBUG doesn’t matter, just the fact that it’s defined. If the program
should fail later, we can reactivate assert by removing NDEBUG's definition.

 

Avoid putting an expression that has à side effect—including a function call—
inside an assert; if assert is disabled at a later date, the expression won't be
evaluated. Consider the following example:

assert ((p = malloc(n)) != NULL) ;

If NDEBUG is defined, assert will be ignored and malloc won't be called.

 

The <errno.h> Header: Errors

Some functions in the standard library indicate failure by storing an error code (a
positive integer) in errno, an int variable declared in <errno.h>. (errno
may actually be a macro. If so, the C standard requires that it represent an Ivalue,
allowing us to use it like a variable.) Most of the functions that rely on errno
belong to <math.h>, but there are a few in other parts of the library.

Let’s say that we nced to use a library function that signals an error by storing
a value in errno. After calling the function, we can check whether the value of
errno is nonzero; if so. an error occurred during the function call. For example,
suppose that we want to check whether a call of the sqrt (square root) function
has failed. Here’s what the code would look like:

errno = Q0;

y = sqrt(x);

if (errno != O) |
fprintf(stderr, "sqrt error; program terminated.\n'") ;
exit (EXIT FAILURE) ;

)

When errno is used to detect an error in a call of à library function, it’s important
to store zero in errno before calling the function. Although errno is zero at the
beginning of program execution, it could have been altered by a later function call.
Library functions never clear errno; that’s the program's responsibility.

***************************page_655***************************
 

630 Chapter 24  Error Handling

exp lunction » 23.3

æ

<wchar .h> header » 25.5

encoding errar »22.3

perror

stderr stream >22.1

The value stored in errno when an error occurs is often either EDOM or
ERANGE,. (Both are macros defined in <errno..h>.) Thèse macros represent the
two kinds of errors that can occur when a math function is called:

n Doimnain errors (EDOM): An argument passed to a function is outside the func-
tion’s domuin. For example, passing a negative number to sqrt causes a
domain error.

n Range errors (ERANGE): À functlion’s return value is too large to be repre-
sented in the function’s return type. For example, passing 1000 to the exp
function usually causes a range error, because e'”” is too large to represent as

a double on most computers.

Some functions can experience both kinds of errors; by comparing errno to
EDOM or ERANGE, we can determine which error occurred.

C99 adds the EILSEQ macro to <errno ..h> Library functions in certain
headers—especially the <wchar.h> header—store the value of EILSEQ in
errno when an encoding error oceurs.

The perror and strerror Functions

void perror (const char *s) ; from <stdio.h>
char *strerror (int errnum) ; from <string.h>

We'1l now look at two functions that are related to the errno variable, although
neither function belongs to <errno.h>.

When a library function stores a nonzero value in errno, we may want to
display a message that indicates the nature of the error. One way to do this is to call
the perror function (declared in <stdio.h>), which prints the following
items, in the order shown: (1) its argument, (2) a colon. (3) a space, (4) an error
message determined by the value of errno, and (5) a new-line character. perror
writes to the stderr stream, not to standard output.

Here’s how we might use perror:

errno = 0;

y = sgrt(x);

if (errno != O) |
perror ("sqrt error") ;
exit (EXIT FAILURE) ;

}

LF the call of sqrt fails because of a domain error, perror will generate the fol-
lowing output:

sqrt error: Numerical arqgument out of domain

The error message that perror displays after sqrt error is implementation-
defined. In this example, Numerical argument out of domain is the mes-

***************************page_656***************************
strerror

243

QaÀ

243  The <signal.h> Header: Signal Handling 631

sage that corresponds to the EDOM error. An ERANGE error usually produces a dif-
ferent message, such as Numerical result out of range.

The strerror function belongs to <string.h>. When passed an error
code. strerror returns a pointer to a string describing the error. For example,
the call

puts (strerror (EDOM) ) ;
might print
Numerical argument out of domain

The argument to strerror is usually one of the values of errno, but
strerror will return a string for any integer passed to it.

strerror is closely related to the perror function. The error message that
perror displays is the same message that strerror would return if passed
errno as its argument.

The <signal .h> Header: Signal Handling

The <signal .h> header provides facilities for handling exceptional conditions,
known as signals. Signals fall into two categories: run-time errors (such as division
by 7ero) and events caused outside the program. Many operating systems, for
example, allow users to interrupt or kill running programs; these events are treated
as signals in C. When an error or external event occurs, we say that a signal has
been raised. Many signals are asynchronous: they can happen at any time during
program execution, not just at certain points that are known to the programmer.
Since signals may occur at unexpected times, they have to be dealt with in a unique
way.

This section covers signals as they’re described in the C standard. Signals play
a more prominent role in UNIX than you might expect from their limited coverage
here. For information about UNIX signals, consult one of the UNIX programming
books listed in the bibliography.

Signal Macros

<signal .h> defines a number of macros that represent signals; Table 24.1 lists
these macros and their meanings. The value of each macro is a positive integer
constant. C implementations are allowed to provide other signal macros, as long as
their names begin with SIG followed by an upper-case letter. (UNIX implementa-
tions, in particular, provide a large number of additional signal macros.)

The C standard doesn’t require that the signals in Table 24.1 be raised auto-
matically, since not all of them may be meaningful for a particular computer and
operating system. Most implementations support at least some of these signals.

***************************page_657***************************
632 Chapter 24  Error Handling

Table 24.1
Signals

signal

abort lunction » 26.2

static storage duration > 18.2

Qa&AÀ

 

Name Meaning

 

SIGABRT = Abnormal termination (possibly caused by à call of abort)

SIGFPE Error during an arithmetic opcration (possibly division by zèro
or overflow)

SIGILL Invalid instruction

SIGINT Interrupt

SIGSEGV = Invalid storage access

SIGTERM | Termination request

 

 

 

The signal Function

void (*signal (int sig, void (*func) (int))) (int);

<signal .h> provides two functions: raise and signal. We’Il start with
signal, which installs a signal-handling function for use later if a given signal
should occur. signal is much easier to use than you might expect from its rather
imtimidating prototype. Îts first argument is the code for a particular signal; the sec-
ond argument is a pointer to a function that will handile the signal if it’s raised later
In the program. For example, the following call of signal installs a handler for
the SIGINT signal:

signal (SIGINT, handier) ;

handler 1s the name of a signal-handling function. If the SIGINT signal occurs
later during program execution. handler will be called automatically.

Every signal-handling function must have an int parameter and a return type
of void. When a particular signal is raised and its handler is called, the handler
will be passed the code for the signal. Knowing which signal caused it to be called
can be useful for a signal handler; in particular, it allows us to use the same handler
for several different signals.

À signal-handling function can do a variety of things. Possibilities include
ignoring the signal, performing some sort of error recovery. or terminating the pro-
gram. Unless itl’s invoked by abort or raise. however, a signal handiler
shouldn’t call a library function or attempt to use à variable with static storage
duration. (There are a few exceptions to these rules, however.)

If a signal-handling function returns, the program resumes executing from the
point at which the signal occurred, except in two cases: (1) If the signal was
SIGABRT, the program will terminate (abnormally) when the handler returns. (2)
The effect of returning from a function that has handled SIGFPE is undefined. (In
other words. don’t do it.)

Although signal has a return value. il’s often discarded. The return value. a
pointer to the previous handiler for the specified signal, can be saved in a variable if
desired. In particular. if we plan to restore the original signal handler later, we need
to save signal'’s return value:

void (*orig handler) (int) ; /* function pointer variable */

***************************page_658***************************
243  The <signal.h> Header: Signal Handling 633

orig handler = signal (SIGINT, handler) ;

This statement installs handler as the handler for SIGINT and then saves a
pointer to the original handler in the orig_handler variable. To restore the
original handler later, we’d write

signal (SIGINT, orig handler) ; /* restores original handler */

Predefined Signal Handlers

Instead of writing our own signal handlers, we have the option of using one of the
predefined handlers that <signal .h> provides. There are two of these, each rep-
resented by a macro:

u SIG DFL. SIG DFL handles signals in a “default” way. To 1nstall
SIG_DFL, we'’d use a call such as

signal (SIGINT, SIG_DFL) ; /* use default handler */

The effect of calling SIG_DFL is implementation-defined, but in most cases 1
causes program termination.

m SIG IGN. The call
signal (SIGINT, SIG_IGN) ; /* ignore SIGINT signal */

specifies that SIGINT is to be ignored if it should be raised later.

In addition to SIG_DFL and SIG_IGN, the <signal .h> header may provide
other signal handlers; their names must begin with SIG_ followed by an upper-
case letter. At the beginning of program execution, the handier for each signal 1s
initialized to either SIG _ DFL or SIG_IGN, depending on the implementation.

<signal .h> defines another macro, SIG_ERR, that looks like it should be
a signal handler. SIG_ERR is actually used to test for an error when installing a
signal handler. If à call of signal is unsuccessful—it can°t install a handler For
the specified signal—it returns SIG_ERR and stores à positive value in errno.
Thus, to test whether signal has failed. we could write

if (signal (SIGINT, handler) == SIG ERR) {
perror ("signal (SIGINT, handler) failed") ;

There’s one tricky aspect to the entire signal-handling mechanism: what hap-
pens if a signal is raised by the function that handles that signal? To prevent infinite
recursion, the C89 standard prescribes a two-step process when a signal is raised
for which a signal-handling function has been installed by the programmer. First.
either the handler for that signal is reset to SIG_DFL (the default handler) or else
the signal is blocked from occurring while the handler is executing. (SIGILL is à
special case; neither action is required when SIGILL is raised.) Only then is the
handler provided by the programmer called.

***************************page_659***************************
634 Chapter 24  Error Handling

/

raise

PROGRAM

tsignal.c

 

After a signal has been handled, whether or not the handler needs to be reinstalled
Is implementation-defined. UNIX implementations typically leave the signal han-
dler installed after it's been used, but other implementations may reset the handler
lo SIG_DFT. In the latter case, the handler can reinstall itself by calling signal
before it returns.

 

C99 changes the signal-handling process in a few minor ways. When a signal
Is raised, an implementation may choose to disable not just that signal but others as
well. IF à signal-handling function returns from handling a SIGILL or SIGSEGV
signal (as well as a SIGFPE signal), the effect is undefined. C99 also adds the
restriction that if à signal occurs as a result of calling the abort function or the
raise function, the signal handier itself must not call raise.

The raise Function

int raise (int sig) ,

Although signals usually arise from run-time e€rrors or external events, it's occa-
sionally handy for a program to cause à signal to occur. The raise function does
just that, The argument to raise specifies the code for the desired signal:

raise (SIGABRT) ; /* raises the SIGABRT signal */

The return value of raise can be used to test whether the call was successful:
zero indicates success, while a nonzero value indicates failure.

Testing Signals

The following program illustrates the use of signals. First, it installs a custom han-
dler for the SIGINT signal (carefully saving the original handiler), then calls
raise_sig to raise that signal. Next, it installs SIG_IGN as the handier for the
SIGINT signal and calls raise_sig again. Finally, it reinstalls the original han-
dler for SIGINT, then calls raise_sig one last time.

/* Tests signals */

#Hinclude <signal.hs
#Hinclude <stdio.hs

void handler (int sia) ;
void raise sig (void) ;

int maiîn (void)

{

void (*orig handler) (int) ;

***************************page_660***************************
24.4

24.4  The <setjmp.h> Header: Nonlocal Jumps 635

printf ("Installing handler for signal %d\n", SIGINT) ;
orig handler = signal (SIGINT, handler) ;
raise sig();

print£ ("Changing handler to SIG IGN\n") ;
signal (SIGINT, SIG _ IGN) ;
raise sig();

printf ("Restoring original handler\n") ;
signal (SIGINT, orig handler) ;
raise sig() ;

print£ ("Program terminates normally\n") ;
return 0;

}

void handler (int sig)

{

printf ("Handler called for signal %d\n", sig) ;

}

void raise sig(void)

{

raise (SIGINT) ;

}

Incidentally, the call of raise doesn’t need to be in a separate function. |
defined raise sig simply to make a point: regardiess of where a signal 1s
raised—whether it’s in main or in some other function—it will be caught by the
most recently installed handier for that signal.

The output of this program can vary somewhat. Here’s one possibility:

Installing handler for signal 2
Handler called for signal 2
Changing handler to SIG IGN
Restoring original handler

From this output, we see that our implementation defines SIGINT to be 2 and that
the original handler for SIGINT must have been SIG DFL. (If it had been
SIG _ IGN, we’d also see the message Program terminates normally.)
Finally, we observe that SIG DFL caused the program to terminate without dis-
playing an error message.

The <setjmp.h> Header: Nonlocal Jumps

int setjmp(jmp _ buf env) ;
void longjmp (jmp _ buf env, int val);

***************************page_661***************************
636

Chapter 24  Error Handling

goto statement > 6.4

setimp
QeA

longimp

/\

PROGRAM

isetimp.c

Normally, a function returns to the point at which it was called. We can°t use a
goto statement to make il go elsewhere, because a goto can jump only to a label
within the same function. The <set-jmp.h> header, however, makes it possible
for one function to jump directly to another function without returnine.

The most important items in <setjmp.h> are the setjmp macro and the
longjmp function. setjmp “marks” à place in a program: longjmp can then
be used to return to that place later. Although this powerful mechanism has a vari-
ety of potential applications, it’s used primarily f'or error handling.

To mark the target of a future jump. we call set jmp, passing it a variable of
lype jmp_buf (declared in <setjmp.h>). setjmp stores the current “environ-
ment” (including a pointer to the location of the set jmp itself) in the variable for
later use in a call of longjmp; it then returns zero.

Returning to the point of the set jmp is done by calling longjmp, passing it
the same jmp_bu£ variable that we passed to set jmp. After restoring the envi-
ronment represented by the jmp_buf variable, longjmp will—here's where it
gets tricky—retuwrn from the setjmp call. setjmp's return value this time is
val, the second argument to longjmp. (If val is 0, set jmp returns |.)

 

Be sure that the argument to longjmp was previously initialized by a call of
setjmp. Ît's also important that the function containing the original call of set-
jmp must not have returned prior to the call of longjmp. If either restriction is
violated, calling 1longjmp results in undefined behavior. (The program will prob-
ably crash.)

 

To summarize, setjmp returns zero the first time it’s called: later, longjmp
transfers control back to the original call of setjmp. which this time returns a
nonzero value. Got it? Perhaps we need an example…

Testing setjmp/longjmp

The following program uses setjmp to mark a place in main; the function f2
later returns to that place by calling longjmp.

/* Tests setjmp/longjmp */

finclude <setjmp.h>
#include <stdio.h>

jmp_buf env;

void f1 (void) ;
void f2 (void) ;

int main(void)

{
if (setjmp(env) == O)
printf ("setjmp returned O\n") ;

***************************page_662***************************
 

 

Q & À 637

else {
print£ ("Program terminates: longjmp called\n") ;
return 0;

}

£1() ;
print£f ("Program terminates normally\n") ;
return OD;

}

void f1(void)

{

printf ("£1 begins\n") ;
f2();
print£f("f1 returns\n") ;

}

void f2 (void)

(

print£ ("f2 begins\n") ;
longjmp (env, 1) ;
print£ ("f£2 returns\n") ;

}

The output of this program will be

setjmp returned O

f1 begins

f2 begins

Program terminates: longjmp called

The original call of setjmp returns O, so main calls f1. Next, f1 calls f2,
which uses longjmp to transfer control back to main instead of returning to f1.
When 1longjmp is executed, control goes back to the setmp call. This time,
setjmp returns | (the value specified in the longjmp call).

Q & À

You said that it’s important to store zero in errno before calling a library
function that may change it, but P’ve seen UNIX programs that test errno
without ever setting it to zero. What’s the story? [p. 629]

UNIX programs often contain calls of functions that belong to the operating sys-
tem. These sysfemn calls rely on errno, but they use it in a slightly different way
than described in this chapter. When such a call fails, it returns a special value
(such as —I or a null pointer) in addition to storing a value in errno. Programs
don’t necd to store zero in errno before such a call. because the function’s return
value alone indicates that an error occurred. Some functions in the C standard
library work this way as well, using errno not so much to signal an error as to
specify which error it was.

***************************page_663***************************
638 Chapter 24  Error Handling

Q:

À:

æ

_Exit function >26.2

:E:Qz

volatile type qualifier »20.3

My version of <errno.h> defines other macros besides EDOM and ERANGE.
Is this practice legal? [p. 630]

Yes. The C standard allows macros that represent other error conditions, provided
that their names begin with the letter E followed by à digit or an upper-case letter.
UNIX implementations typically define a huge number of such macros.

Some of the macros that represent signals have cryptic names, like SIGFPE
and SIGSEGV. Where do these names come from? [p. 631]

The names of these signals date back to the early C compilers, which ran on a DEC
PDP-11. The PDP-11 hardware could detect errors with names like “Floating Point
Exception” and “Segmentation Violation:

OK, Pl’m curious. Unless it’s invoked by abort or raise, a signal handler
shouldn?t call a standard library function, but you said there were exceptions
to this rule. What are they? [p. 632]

À signal handler is allowed to call the signal function, provided that the first
argument is the signal that it’s handling at the moment. This proviso is important.
because it allows a signal handler to reinstall itself. In C99, a signal handler may
also call the abort function orthe _ Exit function.

Following up on the previous question, a signal handler normally isn’t sup-
posed to access variables with static storage duration. What’s the exception to
this rule?

That one’s a bit harder. The answer involves a type named sig_atomic t that’s
declared in the <signal .h> header. sig_atomic t isan integer type that can
be accessed ‘’as an atomic entity,’ according to the C standard. In other words, the
CPU can fetch a sig _ atomic_t value from memory or store one in memory
with a single machine instruction. rather than using two or more machine instruc-
tions. sig atomic t is often defined to be int, since most CPUs can load or
store an int value in one instruction.

That brings us to the exception to the rule that a signal-handling function isn’t
supposed to access static variables. The C standard allows a signal handler to store
à value in a sig atomic_t variable—even one with static storage duration—
provided that it’s declared volatile. To see the reason for this arcane rule, con-
sider what might happen 1f a signal handler were to modify a static variable that’s
of a type that’s wider than sig_atomic t. If the program had fetched part of
the variable from memory just before the signal occurred, then completed the fetch
after the signal is handled, it could end up with a garbage value. sig atomic t
variables can be fetched in a single step, so this problem doesn’t occur. Declaring
the variable to be volatile warns the compiler that the variable’s value may
change at any time. (À signal could suddenly be raised, invoking a signal handler
that modifies the variable.)

The tsignal .c program calls print£ from inside a signal handier. Isn°t
that illegal?

***************************page_664***************************
Section 24.1

Â:

B e

ID

Exercises 639

À signal-handling funetion invoked as a result of raise or abort may call
library l'unctions. tsignal .c uses raise to invoke the signal handiler.

How can setjmp modify the argument that’s passed to it? T thought that C
always passed arguments by value. [p. 636]

The C standard says that jmp_buf must be an array type, so setjmp is actually
being passed a pointer.

P’m having trouble with setjmp. Are there any restrictions on how it can be
used?

According to the C standard, there are only two legal ways to use set jmp:

u Às the expression in an expression statement (possibly cast to void).

= Às parl of the controlling expression in an if. switch, while, do, or for
statement. The entire controlling expression must have one of the following
forms, where constexpr is an integer constant expression and 0> is a relational
or equality operator:

setjmp (...)

! setjmp (.…..)

constexpr op setjmp (...)
setjmp (...) op constexpr

Using setjmp in any other way causes undefined behavior.

After a program has executed a call of 1longjmp, what are the values of the
variables in the program?

Most variables retain the values they had at the time of the 1longjmp. However, an
automatic variable inside the function that contains the set jmp has an indetermi-
nate value unless it was declared volatile or it hasn’t been modified since the
setjmp was performed.

Is it legal to call Longjmp inside a signal handler?

Yes, provided that the signal handler wasn’t invoked because of a signal raised dur-
ing the execution of a signal handler. (C99 removes this restriction.)

Exercises

(a) Assertions can be used to test for two kinds of problems: (1) problems that should never
occur if the program is correct, and (2) problems that are beyond the control of the program.
Explain why assert is best suited for problems in the first category.

(b) Give three examples of problems that are beyond the control of the program.

Write a call of assert that causes a program to terminate if a variable named top has the
value NULL.

***************************page_665***************************
640 Chapter 24  Error Handling

Section 24.2

Section 24.4

3.
@ 4.
® 5.

Modify the stackADT2. c file of Section 19.4 so that it uses assert to test for errors
instead of using i É statements. (Note that the terminate function is no longer necessary
and can be removed.)

(a) Write à “wrapper” funclion named try math feon that calls a math function
(assumed to have a double argument and return a double value) and then checks
whether the call succeeded. Here’s how we might use try_math_fcen:

y = try _ math fen(sgrt, x, "Error in call of sqrt") ;

Ifthe call sqrt (x) 1s successful. try math _£cn returns the value computed by sart.
IF the call fails. try_math_fen calls perror to print the message Error in call of
sqrt. then calls exit to terminate the program.

(b) Write a macro that has the same effect as try_math _ £cen but builds the error mes-
sage from the function’s name:

y = TRY MATH FCN(sgrt, x);

IF the call of sqrt fails, the message will be Error in call of sart. Hinr: Have
TRY MATH FCNcall try_math _fen.

In the inventory. c program (see Section 16.3), the main function has a £or loop that
prompts the user to enter an operation code, reads the code, and then calls either insert.
search. update, or print. Add à call of setjmp to main in such a way that a subse-
quent call of longjmp will return to the £or loop. (After the longjmp, the user will be
prompted for an opcration code, and the program will continue normally.) setjmp vill
need à jmp_buË variable;: where should it be declared?

***************************page_666***************************
25

International Features

If your computer speaks English
it was probably made in Japan.

For many years, C wasn’t especially suitable for use in non-English-speaking
countries. C originally assumed that characters were always single bytes and that
all computers recognized the characters #, [. \. 1, 7 {, |. }. and —, which are
nceded to write programs. Unfortunately, these assumptions aren*t valid in all parts
of the world. As à result, the experts who created C89 added language features and
libraries in an effort to make C à more international language.

In 1994, Amendment ! to the ISO C standard was approved, creating an
enhanced version of C89 that’s sometimes known as C94 or C95. This amendment
provides additional library support for international programming via the digraph
language feature and the <iso646 .h>, <wchar.h>, and <wctype.h> head-
ers. C99 adds even more support for internationalization in the form of universal
character names. This chapter covers all of C’s international features. whether they
come from C89, Amendment |, or C99. l'II flag the Amendment | changes as C99
changes, although they actually predate C99.

The <locale .h> header (Section 25.1) provides functions that allow a pro-
gram to tailor its behavior to a particular “locale”—often a country or orher geo-
graphical area in which à particular language is spoken. Multibyte characters and
wide characters (Section 25.2) enable programs to work with large character sets
such as those found in Asian countries. Digraphs, trigraphs, and the <iso646 .h>
header (Section 25.3) make it possible to write programs on computers that lack
some of the characters normally used in C programming. Universal character
names (Section 25.4) allow programmers to embed characters from the Universal
Character Set into the source code of a program. The <wchar . h> header (Section
25.5) supplies functions for wide-character input/output and wide-string manipula-
tion. Finally, the <wctype.h> header (Section 25.6) provides wide-character
classification and case-mapping functions.

641

***************************page_667***************************
642 Chaptier 25

25.1

<String.h> header >23.6

<ctype .h> header »23.5

numeric conversion functions > 26.2

str£ftime function »26.3

æ

weosftime function >25.5

International Features

The <locale.h> Header: Localization

The <locale.h> header provides functions to control portions of the C library
whose behavior varies from one locale to another. (A locale is typically a country
or à region in which a particular language 1s spoken.)

Locale-dependent aspects of the library include:

Formatting of numerical quantities. In some locales, for example, the deci-
mal point 1s à period (297.48), while in others it’s a comma (297.48).

Formatting of monetary quantities. For example, the currency symbol varies
from country to country.

Character set. The character set often depends on the language in a particular
locale. Asian countries usually require a much larger character set than West-
ern countries.

Appearance of date and time. In some locales, it’s customary to put the month
first when writing a date (8/24/2012); in others, the day goes first (24/8/2012).

Categories

By changing locale, a program can adapt its behavior to a different area of the
world. But a locale change can affect many parts of the library, some of which we
might prefer not to alter. Fortunately, we’re not required to change all aspects of a
locale at the same time. Instead, we can use one of the following macros to specify
a category:

LC _ COLLATE. Affects the behavior of two string-comparison functions.
strcoll and strx£frm. (Both functions are declared in <string.h>).

LC CTYPE. Affects the behavior of the functions in <ctype.h> (except
isdigit and isxdigit). Also affects the multibyte and wide-character
functions discussed in this chapter.

LC _ MONETARY. Affects the monetary formatting information returned by the
localeconv function.

LC NUMERIC. Affects the decimal-point character used by formatted I/O
functions (like printf and scanf) and the numeric conversion functions
(such as strtod) in <stdlib.h>. Also affects the nonmonetary format-
ting Information returned by localeconv.

LC TIME. Affects the behavior of the strftime function (declared in

<time.h>), which converts a time into a character string. In C99, also
affects the behavior of the wes£ftime function.

Implementations are free to provide additional categories and define LC _ macros
not listed above. For example, most UNIX systems provide an LC MESSAGES
category, which affects the format of affirmative and negative system responses.

***************************page_668***************************
setlocale

getenv lunction »26.2

25.1  The <1ocale.h> Header: Localization 643

The setlocale Function

char *setlocale(int category, const char *locale) ;

The setlocale function changes the current locale, either for a single category
or for all categories. If the first argument is one of the macros LC COLLATE,
LC CTYPE, LC MONETARY, LC NUMERIC, or LC TIME, a call of set-
locale affects only a single category. If the first argument is LC_ALL, the call
affects all categories. The C standard defines only two values for the second argu-
ment: "C" and " ", Other locales, if any, depend on the implementation.

At the beginning of program execution, the call

setlocale(LC ALL, "C") ;

occurs behind the scenes. In the "C" locale, library functions behave in the “nor-
mal” way, and the decimal point 1s à period.

Changing locale after the program has begun execution requires an explicit
call of setlocale. Calling setlocale with "" as the second argument
switches to the native locale, allowing the program to adapt its behavior to the
local environment. The C standard doesn’t define the exact effect of switching to
the native locale. Some implementations of setlocale check the execution
environment (in the same way as getenv) for an environment variable with a par-
ticular name (perhaps the same as the category macro). Other implementations
don’t do anything at all. (The standard doesn’t require setlocale to have any
effect. Of course, à library whose version of setlocale does nothing isn’t likely
to sell too well in some parts of the world.)

 

 

Locales

Locales other than "C" and "" vary from one compiler to another. The GNU C
library, known as glibc, provides a "POSIX" locale, which is the same as the "c"
locale. glibe, which is used by Linux, allows additional locales to be installed if
desired. These locales have the form

language [ _territory] [. codeset] [ @modifier]

where each bracketed item is optional. Possible values for /anguage are listed in a
standard known as ISO 639, territory comes from another standard (|ISO 3166), and
codeset specifies a character set or an encoding of a character set. Here are a few
examples:

"swedish"

"en GB" (English — United Kingdom)
"en IE" (English — Ireland)

"fr CH" (French — Switzerland)

There are several variations on the "en IE" locale, including "en_IE@euro" (using
the euro currency), "en IE.iso88591" (using the ISO//EC 8859-1 character set),

***************************page_669***************************
644

Chapter 25

UTF-8 >25.2

QaÂ

localeconv

International Features

"en IE.iso885915@euro" (usingthe |ISO/EC 8859-15 character set andthe euro
currency), and "en IE.utf8" (using the UTF-8 encoding of the Unicode character
set).

Linux and other versions of UNIX support the 1ocale command, which can be
used to get locale information. One use of the 1ocale command is to get a list of
all available locales, which can be done by entering

locale -a

at the command line.

Because locale information is becoming increasingly important, the Unicode
Consortium created the Common Locale Data Repository (CLDR) project to estab-
lish a standard set of locales. More information about the CLDR project can be
found at www.unicode.org/cldr/.

 

 

When a call of setlocale succeeds, 11 returns a pointer to a string associ-
ated with the category in the new locale. (The string might be the locale name
itself, for example.) On failure, setlocale returns a null pointer.

setlocale can also be used as a query function. If its second argument is a
null] pointer, setlocale returns à pointer to à string associated with the category
in the cuwrrent locale. This feature is especially useful 1f the first argument 1s
LC ALL, since it allows us to fetch the current settings for all categories. À string
returned by setlocale can be saved (by copying it into a variable) and then
used in à later call of setlocale.

The 1ocaleconv Function

struct lconv *localeconv (void) ;

Although we can ask setlocale about the current locale, the information that it
returns isn’t necessarily in the most useful form. To find out highly specific infor-
mation about the current locale (What’s the decimal-point character? What’s the
currency symbol?), we need localeconv, the only other function declared in
<locale.h»>.

localeconv returns à pointer to a structure of type struct Iconv. The
members of this structure contain detailed information about the current locale.
The structure has static storage duration and may be modified by a later call of
localeconv or setlocale. Be sure to extract the desired information from
the 1conv structure before it’s wiped out by one of these functions.

Some members of the 1conv structure have char * type: other members
have char type. Table 25.1 lists the char * members. The first three members
describe the formatting of nonmonetary quantities, while the others deal with mon-
etary quantities. The table also shows the value of each member in the "C" locale
(the default); a value of "" means “not available.”

The grouping and mon_grouping members deserve special mention.

***************************page_670***************************
Table 25.1
char * Members of
1conv Structure

æ

Table 25.2

char Members of
lconv Structure
(Local Formatting)

25.1  The <1ocale. h> Header: Localization 645

 

 

 

 

 

Value in
Name "C" Locale Description

»| decimal_point ." Decimal-point character
8| thousands sep " Character used to separate groups of
ë digits before decimal point
= | grouping " Sizes of digit groups
S
=

mon_decimal _point " Mecimal-point character

mon thousands sep "n Character used to separate groups of
E digits before decimal point
= | mon grouping nn Sizes of digit groups
S | positive sign . String indicating nonnegative quantity
= | negative sign nn String indicating negative quantity

currency symbol " Local currency symbol

int _ curr symbol " International currency symbolŸ

 

 

TA three-letter abbreviation followed by a separator (often a space or à period). For example, the
international currency symbols for Switzerland. the United Kingdom. and the United States are
"CHF "."GBP ",and "USD ", respectively,

Each character in these strings specifies the size of one group of digits. (Grouping
takes place from right to left, starting at the decimal point.) À value of CHAR MAX
indicates that no further grouping is to be performed; O indicates that the previous
clement should be used for the remaining digits. For example, the string "\3" (\3
followed by \0O) indicates that the first group should have 3 digits. then all other
digits should be grouped in 3's as well.

The char members of the 1conv structure are divided into two groups. The
members of the first group (Table 25.2) affect the /ocal formatting of monetary
quantities. The members of the second group (Table 25.3) affect the international
formatting of monetary quantities. AIl but one of the members in Table 25.3 were
added in C99. As Tables 25.2 and 25.3 show, the value of each char member in
the "C" locale is CHAR MAX, which means “not available.”

 

Value in
Name C" Locale Description

 

frac _ digits CHAR MAX — Number of digits after decimal point

p cs precedes CHAR MAX — lifcurrency_symbol precedes
nonnegative quantity; O 1f it succeeds quantity

n cs precedes CHAR MAX — li/Currency_symbol precedes negative
quantity: O 1f it succeeds quantity

p_sep _ by _ space … CHAR MAX — Separation of currency_symbol and sign
string from nonnegative quantity (see Table
25.4)

n sep by space — CHAR MAX _ Scparation of currency_symbol and sign
string from negative quantity (see Table 25.4)

p sign posn CHAR MAX — Position of positive sign for
nonnegative quantity (see Table 25.5)
n_sign posn CHAR MAX _ Position ofnegative sign for negative

 

 

quantity (sec Table 25.5)

 

e -—

***************************page_671***************************
646 Chapter 25

Table 25.3

char Members of

lconv Structure
(International Formatting)

Table 25.4

Values of
…Sep_by _ space
Members

Table 25.5
Values of
…Sign_posn
Members

International Features

 

Name

Value in
"c" Locale

Description

 

int_frac digits
int p _ cs precedes’

int n cs precedes!

int _;>_sep__by_space’r

int _n _ sep _ by_space’

int p _sign posn'

int n sign posn*

 

CHAR MAX
CHAR MAX

CHAR MAX

CHAR MAX

CHAR MAX

CHAR MAX

CHAR MAX

Number of digits after decimal point
lifint _ curr symbol precedes
nonnegative quantity: O if it succeeds
quantity

lifint _ curr symbol precedes
negative quantity; O if it succeeds
quantity

Separation of int_curr symbol
and sign string from nonnegative
quantity (see Table 25.4)

Separation of int_curr symbol
and sign string from negative quantity
(see Table 25.4)

Position of positive _sign for
nonnegative quantity (see Table 25.5)
Position of negative_sign for
negative quantity (see Table 25.5)

 

*C99 only

Table 25.4 explains the meaning of the values of the p_sep_by space.
n _sep by space, int_p_sep by _ space, and int _n sep by space
members. The meaning of p_sep _ by _ space and n sep by space has

changed in C99. In C89, there are only two possible values for these members: |

(if there’s a space between currency _ symbol and a monetary quantity) or O (if

there’s not).

 

 

 

Value Meaning
0 No space separates currency symbol and quantity.
1 If currency symbol and sign are adjacent, à space separates them from
quantity; otherwise, a space separates currency symbol from quantity.
2 If currency symbol and sign are adjacent, a spacè separates them:
otherwise, a space separates sign from quantity.

 

 

Table 25.5 explains the meaning of the values of the p sign posn,

n sign posn,int p _sign posnand iint n sign posn members.

 

 

 

Value Meaning
0 Parentheses surround quantity and currency symbol
1 Sign precedes quantity and currency symbol
2 Sign succeeds quantity and currency symbol
3 Sign immediately precedes currency symbol
4 Sign immediately succeeds currency symbol

 

 

To see how the members of the 1conv structure might vary from one locale to

another, let’s look at two examples. Table 25.6 shows typical values of the monetary
1conv members for the U.S.A. and Finland (which uses the euro as its currency).

 

***************************page_672***************************
 

 

25.2 Multibyte Characters and Wide Characters 647

 

 

Table 25.6 Member U.S.A. Finland
T)’piCül Values of mon d€Ciïﬂâl_p0iﬁt ." ,"
MOÜC‘.ZU'Y lconv mon_thonsands_sep ," " "
Members for mon_grguping n3" 3"
U.S.A. and Finland positive sign UET n

negative _sign "" “"
currency_symbol "s" "EUR"
frac digits 2

p cs precedes
n _cs_precedes
p_sep_by space
n _sep by space
p_sign posn

n sign posn
int curr symbol "USD " - "EUR "
int_frac digits
int_p cs precedes
int_n cs precedes
int_p_sep by space
int _n sep by space
int_p sign posn
int_n sign posn

HHoosn
HFHUNOON

bHeHeepenN
HFEHENNOON

 

 

 

Here’s how the monetary quantity 7593.86 would be formatted in the two
locales, depending on the sign of the quantity and whether the formatting is local
or international:

U.S.A. Finland
Local format (positive) $7,593.86 7 593,86 EUR
Local format (negative) -$7,593.86 - 7 593,86 EUR
International format (positive) USD 7,593.86 7 593,86 EUR
International format (negative) -USD 7,593.86 - 7 593,86 EUR

Keep in mind that none of C”s library functions are able to format monetary quan-
tities automatically. Is up to the programmer to use the information in the 1conv
structure to accomplish the formatting.

25.2 Multibyte Characters and Wide Characters

One of the biggest problems in adapting programs to different locales is the char-

Latin1>73 _ acter-set issue. ASCII and its extensions, which include Latin-1, are the most pop-
ular character sets in North America. Elsewhere, the situation is morc complicated.
In many countries, computers employ character sets that are similar to ASCIIL. but
lack certain characters; we*1t discuss this issue further in Section 25.3. Other coun-
tries, especially those in Asia, face a different problem: written languages that
require à very large character set, usually numbering in the thousands.

***************************page_673***************************
648

Chapter 25

Q&AÀ

International Features

Changing the meaning of type char to handle larger character sets isn’t pos-
sible. since char values are—by definition—limited to single bytes. Instead, C
allows compilers to provide an extended character set. This character set may be
used for writing C programs (in comments and strings, for example), in the envi-
ronment in which the program is run. or in both places. C provides two techniques
for encoding an extended character set: multibyte characters and wide characters.
It also supplies functions that convert from one kind of encoding to the other.

Multibyte Characters

In a multibyte character encoding, each extended character is represented by a
sequence of one or more bytes. The number of bytes may vary. depending on the
character. C requires that any extended character set include certain essential char-
acters (letters, digits. operators, punctuation. and white-space characters); these
characters must be single bytes. Other bytes can be interpreted as the beginning of
a multibyte character.

 

 

Japanese Character Sets

The Japanese employ several different writing systems. The most complex, kanji
consists of thousands of symbols—far too many to represent in a one-byte encod-
ing. (Kanji symbols actually come from Chinese, which has a similar problem with
large character sets.) There’s no single way to encode kanj; common encodings
include JIS (Japanese Industrial Standard), Shift-JIS (the most popular encoding),
and EUC (Extended UNIX Code).

 

 

 

 

Some multibyte character sets rely on a sfate-dependent encoding. In this
kind of encoding, cach sequence of multibyte characters begins in an initial shift
state. Certain bytes encountered later (kKnown as a shift sequence) may change the
shift state, affecting the meaning of subsequent bytes. Japan's JIS encoding, for
example, mixes one-byte codes with two-byte codes: ‘“‘escape sequences” embed-
ded in strings indicate when to switch between one-byte and two-byte modes. (In
contrast, the Shift-JIS encoding is not state-dependent. Each character requires
either one or two bytes, but the first byte of à two-byte character can always be dis-
tinguished from a one-byte character.)

In any encoding, the C standard requires that a zero byte always represent a
null character, regardless of shift state. Also, a zero byte can‘t be the second (or
later) byte of a multibyte character.

The C library provides two macros, MB_LEN MAX and MB_CUR MAX, that
are related to multibyte characters. Both macros specify the maximum number of
bytes in a multibyte character. MB_LEN MAX (defined in <limits . h>) gives the
maximum for any supported locale: MB_CUR MAX (delined in <stdlib.h>)
gives the maximum for the current locale. (Changing locales may affect the inter-
pretation of multibyte characters.) Obviously, MB_CUR MAX can’t be larger than
MB LEN MAX.

***************************page_674***************************
25.2  Multibyte Characters and Wide Characters 649

Any string may contain multibyte characters, although the length of such a
string (as determined by the strlen function) is the number of bytes in the string,
not the number of characters. In particular, the format strings in calls of the
«print£ and …scan£ functions may contain multibyte characters. As a result.
the C99 standard defines the term multibyre string to be a synonym for string.

Wide Characters

The other way to encode an extended character set is to use wide characters. À
wide character is an integer whose value represents a character. Unlike multibyte
characters, which may vary in length. all wide characters supported by a particular
implementation require the same number of bytes. À wide string is a string con-
sisting of wide characters, with a null wide character at the end. (A null wide char-
acter is a wide character whose numerical value is zero.)

Wide characters have the type wchar_t (declared in <stddef .h> and cer-
tain other headers). which must be an integer type able to represent the largest
extended character set For any supported locale. For example, if two bytes are
enough to represent any extendecl character set, then wchar t could be defined
às unsigned short int.

C supports both wide character constants and wide string literals. Wide char-
acter constants resemble ordinary character constants but are prefixed by the letter
L:

L'a'
Wide string literals are also prefixed by L:
L » abÇ U

This string represents an array containing the wide characters L'a'. L'b*. and
L'c', followed by a null wide character.

Unicode and the Universal Character Set

The differences between multibyte characters and wide characters become appar-
ent when discussing Unicode. Unicode is an enormous character set developed by
the Unicode Consortium, an organization established by a group of computer man-
üfacturers to create an international character set for computer use. The first 256
characters of Unicode are identical to Latin-! (and therefore the first 128 charac-
lers of Unicode match the ASCIT character set). However, Unicode goes far
beyond Latin-], providing the characters needed for nearly all modern and ancient
languages. Unicode also includes a number of specialized symbols. such as those
used in mathematics and music. The Unicode standard was first published in 1991.

Unicode is closely related to international standard ISO/IEC 10646. which
defines a character encoding known as the Universal Character Set (UCS). UCS
was developed by the International Organization for Standardization (1SO). start-
ing at about the same time that Unicode was initially defined. Although UCS orig-
inally differed from Unicode. the two character sets were later unified. ISO now

***************************page_675***************************
650

Chapter 25

Le F3N

Table 25.7
UTF-$ Encoding

International Features

works closely with the Unicode Consortium to ensure that ISO/TEC 10646 remains
consistent with Unicode. Because Unicode and UCS are so similar. PIl use the two
terms interchangeably.

Unicode was originally limited to 65,536 characters (the number of characters
that can be represented using 16 bits). That limit was later found to be insufficient;
Unicode currently has over 100.000 characters. (For the most recent version. visit
www.unicode.org.) The first 65,536 characters of Unicode—which include the
most frequently used characters—are known as the Basic Multilingual Plane
(BMP).

Encodings of Unicode

Unicode assigns a unique number (known as a code poinf) to each character. There
are a number of ways to represent these code points using bytes: Il mention two
of the simpler techniques. One of these encodings uses wide characters; the other
uses multibyte characters.

UCS-2 is a wide-character encoding in which each Unicode code point is
stored as two bytes. UCS-2 can represent all the characters in the Basic Multilin-
gual Plane (those with code points between 0000 and FFFF in hexadecimal). but it
is unable to represent Unicode characters that don’t belong to the BMP.

À popular alternative is the 8-hit UCS Transformation Format (UTF-&),
which uses multibyte characters. UTF-8 was devised by Ken Thompson and his
Bell Labs colleague Rob Pike in 1992. (Yes, that’s the same Ken Thompson who
designed the B language, the predecessor of C.) UTF-8 has the useful property that
ASCII characters look identical in UTF-8: each character is one byte and has the
same binary encoding. Thus, software designed to read UTF-8 data can also handle
ASCH data with no change. For these reasons, UTF-8 is widely used on the Inter-
net for text-based applications such as web pages and email.

In UTF-8. each code point requires between one and four bytes. UTF-8 is
organized so that the most commonly used characters require fewer bytes, as
shown in Table 25.7.

 

Code Point Range UTF-8 Byte Sequence
(Hexadecimal) (Binary)

000000-00007F — Oxxxxxxx

000080-0007FF =— 110Xxxxx lOXXXXXX

000800-0O0FFFF =— 1110xxxx lOXXxxxxx lOxxxxXxx
010000-10FFFF = 11110XXX lOXXXXXX lOXXXXXxx lOXXXXXX

 

 

 

 

UTF-8 takes the bits in the code point value, divides them into groups (repre-
sented by the x's in Table 25.7), and assigns each group to a different byte. The
simplest case is a code point in the range 0-7F (an ASCII character), which is rep-
resented by a 0 followed by the seven bits in the original number.

À code point in the range 80-7FF (which includes all the Latin-! characters)
would have its bits split into groups of five bits and six bits. The five-bit group 1s

***************************page_676***************************
25.2  Multibyte Characters and Wide Characters 651

prefixed by 110 and the six-bit group is prefixed by 10. For example, the code
point for the character àä is E4 (hexadecimal) or 11100100 (binary). In UTF-8&, it
would be represented by the two-byte sequence 11000011 10100100. Note how
the underlined portions, when joined together, spell out 0001 1100100.

Characters whose code points fall in the range 800-FFFF, which includes the
remaining characters in the Basic Multilingual Plane, require three bytes. ÀÎI other
Unicode characters (most of them rarely used) are assigned four bytes.

UTF-8 has a number of useful properties:

m Each of the 128 ASCII characters 1s represented by one byte. À string consist-
ing solely of ASCII characters looks exactly the same in UTF-8.

m Any byte in a UTF-8 string whose leftmost bit is O must be an ASCI charac-
ter, because all other bytes begin with a | bit.

=m The first byte of a multibyte character indicates how long the character will be.
If the number of ! bits at the beginning of the byte is two, the character 1s two
bytes long. If the number of ! bits is three or four, the character 1s three or four
bytes long, respectively.

m Every other byte in a multibyte sequence has 10 as its leftmost bits.

The last three properties are especially important. because they guarantee that no
sequence of bytes within a multibyte character can possibly represent another valid
multibyte character. This makes it possible to search a multibyte string for a partic-
ular character or sequence of characters by simply doing byte comparisons,

So how does UTF-8 stack up against UCS-27? UCS-2 has the advantage that
characters are stored in their most natural form. On the other hand, UTF-8 can han-
die all Unicode characters (not just those in the BMP), often requires less space
than UCS-2, and retains compatibility with ASCIL. UCS-2 isn’t nearly as popular
as UTF-8, although it was used in the Windows NT operating system. À newer
version that uses four bytes (UCS-4) is gradually taking its place. Some systems
extend UCS-2 into a multibyté encoding by allowing a variable number of byte
pairs to represent a character (unlike UCS-2, which uses a single byte pair per
character). This encoding, known as UTF-16, has the advantage that it‘s compati-
ble with UCS-2.

Multibyte/Wide-Character Conversion Functions

int mblen(const char *s, size t n); from <stdlib.h>
int mbtowc (wchar t * restrict pwc,

const char * restrict s,

size t n); from <stdlib.h>
int wctomb(char *s, wchar t wc); from <stdlib.h>

Although the C89 standard introduced the concepts of multibyte characters and
wide characters, it provides only five functions for working with these kinds of

***************************page_677***************************
652

Chapter 25

mblen

mbtowc

International Features

characters. We'Il now describe these functions, which belong to the <stdlib.h>
header. C997s <wchar .h> and <wctype.h> headers. which are discussed in
Sections 25.5 and 25.6, supply a number of additional multibyte and wide-character
functions.

C89's multibyte/wide-character f'unctions are divided into two groups. The
first group converts single characters from multibyte form to wide form and vice
versa. The behavior of these functions depends on the LC_CTYPE category of the
current locale. If the multibyte encoding is state-dependent, the behavior also
depends on the current conversion state. The conversion state consists of the cur-
rent shift state as well as the current position within a multibyte character. Calling
any of these functions with a null pointer as the value of its char * parameter
sets the function's internal conversion state to the initial conversion state, sienify-
ing that no multibyte character is yet in progress and that the initial shift state is
in effect. Later calls of the function cause its internal conversion state to be
updated.

The mblen function checks whether its first argument points to a series of
bytes that form a valid multibyte character. If so. the function returns the number
of bytes in the character; if nol, it returns —!. As a special case, mblen returns O if
the first argument points to a null character. The second argument limits the num-
ber of bytes that mblen will examine; typically, we’Il pass MB_ CUR MAX.

The following function, which comes from P. J. Plauger’s The Standard C
Librarv, uses mblen to determine whether a string consists of valid multibyte
characters. The function returns zero if s points to a valid string.

int mbcheck (const char *s)

(

int n;

for (mblen (NULL, 0); ; s += n)
if ((n = mblen(s, MB _ CUR MAX)) <= O)
return n;

}

Two aspects of the mbcheck function deserve special mention. First, there’s the
mysterious call mblen (NULL, O), which sets mblen's internal conversion state
to the initial conversion state (in case the multibyte encoding is state-dependent).
Second, there’s the matter of termination. Keep in mind that s points to an ordi-
nary character string, which is assumed to end with a null character. mblen will
return zero when it reaches this null character, causing mbcheck to return.
mbcheck will return sooner if mblen returns —1 because of an invalid multibyte

character.
The mbtowc function converts a multibyte character (pointed to by the sec-

ond argument) into a wide character. The first argument points to a wchar t vari-
able into which the function will store the result. The third argument limits the
number of bytes that mbtowc will examine. mbtowc returns the same value as
mblen: the number of bytes in the multibyte character if 1s valid, —1 1f it's not,
and zero 1f the second argument points to à null character.

***************************page_678***************************
wctomb

mbstowecs

25.2  Multibyte Characters and Wide Characters 653

The wctomb function converts a wide character (the second argument) into a
multibyte character, which it stores into the array pointed to by the first argument.
wctomb may store as many as MB_LEN MAX characters in the array, but doesn’t
append a null character. wctomb returns the number of bytes in the multibyte
character or —1 1f the wide character doesn’t correspond to any valid multibyte
character. (Note that wctomb returns ! 1f asked to convert a null wide character.)

The following function (also from Plauger’s The Standard C Library) uses
wctomb to determine whether a stWing of wide characters can be converted to
valid multibyte characters:

int wccheck (wchar t *wcs)

{
char buf [MB_LEN MAX] ;
int n;
for (wctomb (NULL, 0); ; ++wcCs)
Lif ((n = wctomb(buf, *wcs)) <= O)
return -1; /* invalid character */
else if (bu£f[n-1] == '\0')
return 0; /* all characters are valid */
}

Incidentally, all three functions—mblen, mbtowc, and woctomb—can be
USed to test whether a multubyte encoding is state-dependent. When passed a null
pointer as its char * argument, each function returns à nonzero value if multibyte
characters have state-dependent encodings or zero if they don’t.

Multibyte/Wide-String Conversion Functions

size t mbstowcs (wchar t * restrict pwces,

const char * restrict s,

size t n); from<stdlib.h>
size t wcstombs(char * restrict s,

const wchar t * restrict pwcs,

size t n); from <stdlib.h>

The remaining C69 multibyte/wide-character functions convert a string containing
multibyte characters to a wide-character string and vice versa. How the conversion
is performed depends on the LC _ CTYPE category of the current locale.

The mbstowcs function converts a sequence of multibyte characters into
wide characters. The second argument points to an array containing the multibyte
characters to be converted. The first argument points to a wide-character array: the
third argument limits the number of wide characters that can be stored in the array.
mbstowcs stops when it reaches the limit or encounters a null character (which it
stores in the wide-character array). It returns the number of array elements modi-
fied, not including the terminatine null] wide character, 1f any. mbstowes returns
—| (cast to type size_t) if1tencounters an invalid multibyte character.

***************************page_679***************************
654

Chapter 25

wcestombs

25.3

Table 25.8
Trigraph Sequences

International Features

The wcstombs function is the opposite of mbstowcs: it converts a
scquence of wide characters into multibyte characters. The second argument points
to the wide-character string. The first argument points to the array in which the
multibyte characters are to be stored. The third argument limits the number of
bytes that can be stored in the array. westombs stops when it reaches the limit or
encounters a null character (which it stores). It returns the number of bytes stored.
not including the terminating null character, if any. westombs returns —! (cast to
lype size_t) if it encounters a wide character that doesn’t correspond to any
multibyte character.

The mbstowcs function assumes that the string to be converted begins in the
initial shift state. The string created by wostombs always begins in the initial
shift state.

Digraphs and Trigraphs

Programmers in certain countries have traditionally had trouble entering C pro-
grams because their keyboards lacked some of the characters that are required by C.
This has been especially true in Europe, where older keyboards provided the accent-
ed characters used in European languages in place of the characters that C needs,
such as #, [, \. J. . {, |. }. and -. C89 introduced trigraphs—three-character
codes that represent problematic characters—as a solution to this problem. Tri-
graphs proved to be unpopular, however. so Amendment | to the standard added
two improvements: digraphs. which are more readable than trigraphs. and the
<is0646 .h> hcader, which defines macros that represent certain C operators.

 

Trigraphs

À trigraph sequence (or simply, à trigraph) is a three-character code that can be
used as an alternative to an ASCII character. Table 25.8 gives a complete list of tri-
graphs. AIl trigraphs begin with ??. which makes them. if not exactly attractive, at
least easy to spot.

 

 

Trigraph ASCH

Sequence = Equivalent
22= #
22 ( [
??/ \
??) ]
22" ,
22< {
??! |
??> }
22- -

 

 

 

***************************page_680***************************
tokens > 2.8

Table 25.9

Digraphs

25.3  Digraphs and Trigraphs 655

Trigraphs can be freely substituted for their ASCII equivalents. For example,
the program

#include <stdio.h>

int maïin (void)

{

printf ("hello, world\n") ;
return 0;

}

could be written
??-include <stdio.h>

int main(void)
22<

print£f ("hello, world??/n") ;

return 0;
22>

Compilers that conform to the C89 or C99 standards are required to accept tri-
graphs, even though they’re rarely used. Occasionally, this feature can cause prob-
lems.

 

Be careful about putting ?? in à string literal—it's possible that the compiler will
treat it as the beginning of a trigraph. If this should happen, turn the second ? char-
acter into an escape sequence by preceding it with a \ character. The resulting ? \?
combination can*t be mistaken for the beginning of a trigraph.

 

Digraphs

Acknowledging that trigraphs are difficult to read, Amendment 1 to the C&9 stan-
dard added an alternative notation known as digraphs. As the name implies. a
digraph requires just two characters instead of three. Digraphs are available as sub-
stitutes for the six tokens shown in Table 25.9.

 

 

 

Digraph = Token
<: [
:> ]
<% {
=> }
 : #

=4 : ##

 

 

Digraphs—unlike trigraphs—are token substitutes, not character substitutes.
Thus, digraphs won°t be recognized inside a string literal or character constant. For
example, the string "< : : >" has length four; it contains the characters: <, :, :,

***************************page_681***************************
656

Chapter 25

Table 25.10
Macros Defined in
<iso646.h>

253.4

International Features

and >, not the characters [ and ]. In contrast, the string "?? (??) " has length
two, because the compiler replaces the trigraph ? ? ( by the character [ and the tri-
graph ??) by the character ] .

Digraphs are more limited than trigraphs. First. as we’ve seen. digraphs are of
no use Inside a string literal or character constant; trigraphs are still needed in these
situations. Second, digraphs don*t solve the problem of providing alternate repre-
sentations for the characters \, *. |, and —. The <iso646 .h> header, described
next, helps with this problem.

The <iso646 .h> Header: Alternative Spellings

The <iso646.h> header is quite simple. Tt contains nothing but the definitions
of the eleven macros shown in Table 25.10. Each macro represents a C operator
that contains one of the characters & | —. !. or *. making it possible to use the
operators listed in the table even when these characters are absent from the key-
board.

 

 

 

 

WMacro Value
and &E&
and eq &=
bitand &
bitor |
compl -
not !
not eq =
or |
or eq |=
xor ,
xor _ eg — *=

 

 

The name of the header comes from ISO/IEC 646, an older standard for an
ASCIT-like character set. This standard allows for “national variants.” in which
countries substitute local characters for certain ASCII characters. thereby causing
the problem that digraphs and the <iso646 .h> header are trying to solve.

Universal Character Names (C99)

Section 25.2 discussed the Universal Character Set (UCS), which is closely related
to Unicode. C99 provides a special feature, wniversal character names, that allows
us to use UCS characters in the source code of a program.

À universal character name resembles an escape sequence. However, unlike
ordinary escape sequences, which can appear only in character constants and string
literals. universal character names may also be used in identifiers. This feature
allows programmers to use their native languages when defining names for vari-
ables, functions, and the like.

***************************page_682***************************
25.5

EOF macro » 22.2

25.5  The <wchar.h> Header (C99) 657

There arc two ways to write a universal character name (\udddd and
\Udddddddd), where each d is a hexadecimal digit. In the form \Udddddddd, the
d’s form an eight-digit hexadecimal number that identifies the UCS code point of
the desired character. The form \udddd can be used for characters whose code
points have hexadecimal values of FFFF or less, which includes all characters in
the Basic Multilingual Plane.

For example, the UCS code point for the Greek letter B is 000003B2, so the
universal character name for this character is \U000003B2 (or \U000003b2.
since the case of hexadecimal digits doesn’t matter). Because the first four hexa-
decimal digits of the UCS code point are O, we can also use the \u notation. writ-
ing the character as \u03B2 or \u03b2. The code point values for UCS (which
match those for Unicode) can be found at www nicode.org/charts/.

Not all universal character names may be used in identifiers; the C99 standard
contains a list of which ones are allowed. Also, an identifier may not begin with a
universal character name that represents à digit.

The <wchar .h> Header (C99)
Extended Multibyte and Wide-Character Utilities

The <wchar .h> header provides functions for wide-character input/output and
wide-string manipulation. The vast majority of functions in <wchar .h> are
wide-character versions of f'unctions from other headers (primarily <stdio.h>
and <string.h>).

The <wchar .h> header declares several types and macros, including the fol-
lowine:

u mbstate t — ÀA value of this type can be used to store the conversion state
when a sequence of multibyte characters is converted to a sequence of wide
characters or vicc versa.

m wint t — An integer type whose values represent extended characters.

u WEOF — À macro representing a wint t value that’s different from any
extended character. WEOF is used in much the same way as EOF. typically to
indicate an error or end-of-file condition.

Note that <wchar .h> provides functions for wide characters but not multi-
byte characters. That’s because C”s ordinary library functions are capable of deal-
ing with multibyte characters, so no special functions are needed. For example. the
fprint£f function allows its format string to contain multibyte characters.

Most wide-character functions behave the same as a function that belongs Lo
another part of the standard library. Usually, the only changes involve arguments
and return values of type wchar t instead of char (or wchar t * instead of
char *). In addition, arguments and return values that represent character
counts are measured in wide characters rather than bytes. In the remainder of this
section, l’H indicate which other library function (if any) corresponds to each

***************************page_683***************************
658 Chapter 25

standard streams >22.7

{reopen function >22.2

errno variable > 24,2

fgetpos function > 227

Ésetpos function »22,7

International Features

wide-character function. ! won't discuss the wide-character function further un-
less there's à significant difference between it and its “non-wide” counterpart.

Stream Orientation

Before we look at the input/output functions provided by <wchar .h>, it’s impor-
tant to understand stream orientation, a concept that doesn’t exist in C89.

Every stream is either byte-oriented (the traditional orientation) or wide-
oriented (data is written to the stream as wide characters). When a stream is first
opened, it has no orientation. (In particular. the standard streams stdin, stdout,
and stderr have no orientation at the beginning of program execution.) Perform-
ing an operation on the stream using a byte input/output function causes the stream
to become byte-oriented: performing an operation using a wide-character input/
output function causes the stream to become wide-oriented. The orientation of a
stream can also be sclected by calling the Ewide function (described later in this
section). À stream retains its orientation as long as it remains open. Calling the
freopen function to reopen the stream wil! remove îts orientation.

When wide characters are written to a wide-oriented stream, they are con-
verted to multibyte characters before being stored in the file that is associated with
the stream. Conversely. when input is read from a wide-oriented stream. the multi-
byte characters found in the stream are converted to wide characters. The multibyte
encoding used in a file is similar to that used for characters and strines within à
program. except that encodings used in files may contain embedded null bytes.

Each wide-oriented stream has an associated mbstate_ t object, which keeps
track of the stream’s conversion state. An encoding error occurs when a wide char-
acter written to a stream doesn’t correspond to any multibyte character, or when a
sequence of characters read from a stream doesn’t form a valid multibyte character.
In either case, the value of the EILSEQ macro (defined in the <errno.h> header)
Is stored in the errno variable to indicate the nature of the error.

Once a stream is byte-oriented, il’s illegal to apply a wide-character input/out-
put function to that stream. Similarly, its illegal to apply a byte input/output func-
tion to a wide-oriented stream. Other stream functions may be applied to streams
of either orientation, although there are a few special considerations for wide-ori-
ented streams:

m Binary wide-oriented streams are subject to the file-positioning restrictions of
both text and binary streams.

m After à file-positioning operation on a wide-oriented stream, à wide-character
output function may end up overwriting part of a multibyte character. Doing
so leaves the rest of the file in an indeterminate state.

m Calling fgetpos for a wide-oriented stream retrieves the stream's
mbstate_t object as part of the fpos_ t object associated with the stream.
À later call of £setpos using this Épos t object will restore the
mostate_ t object to its previous value.

***************************page_684***************************
 

25.5  The <wchar.h> Header (C99) 659

Formatted Wide-Character Input/Output Functions

int

int

int

Iænt

int

int

int

int

int

int

int
int

fwprintf (FILE * restrict stream,
const wchar t * restrict format,
fwscanf (FILE * restrict stream,
const wchar t * restrict format,
swprintf (wchar t * restrict s, size t n,
const wchar t * restrict format,
swscanf (const wchar t * restrict s,
const wchar t * restrict format,
vfwprint£f(FILE * restrict stream,
const wchar t * restrict format,
va _list arg);
vfiwscanf (FILE * restrict stream,
const wchar t * restrict format,
va_list arg);
vswprintf (wchar t * restrict s, size t n,
const wchar t * restrict format,
va_list arg) ;
vswscanf (const wchar t * restrict s,
const wchar t * restrict format,
va_list arg);
vwprintf (const wchar t * restrict format,
va_list arg);
vwscanf (const wchar t * restrict format,
va_list arg);
wprintf (const wchar t * restrict format,
wscanf (const wchar t * restrict format,

;
)z

The f'unctions in this group are wide-character versions of the formatted input/out-
put functions found in <stdio.h> and described in Section 22.3. The
<wchar .h> functions have arguments of type wchar t * instead of char *,
but their behavior is mostly the same as the <stdio.h> functions. Table 25.11
shows the correspondence between the <stdio.h> functions and their wide-
character counterparts. Unless mentioned otherwise, each function in the left col-
umn behaves the same as the function(s) to its right.

AIl functions in this group share several characteristics:

u All have a format string, which consists of wide characters.

m .….print£ functions, which return the number of characters written, now
return the count in wide characters.

m The %n conversion specifier refers to the number of wide characters written so
far (in the case of à …print£f function) or read so far (in the case of a
…scanf function).

***************************page_685***************************
660 Chapter 25

Table 25.11

Formatted Wide-Character
Input/Output Functions
and Their <stdio.h>
Equivalents

fwprintf

iwscanf

swprintf

International Features

 

 

<wchar.h> Function <stdio.h> Equivalent
Ewprintf fprintf
fwscanf Iscanf
swprintf snprint£. sprintf
swscanf sscanf
vfwprintf vfprintf
vÉwscanf vÉscant
vswprintÉ vsnprint£.vsprint£
vswscanf vsscanf
vwprint£ vprint£
vwscanf vscanf
wprint£ printf
wscanf scanf

 

 

 

Additional differences between £wprint£ and fprintf include the fol-
lowineg:

m The %c conversion specifier is used when the corresponding areument has
type int. Ifthe 1 length modifier is present (making the conversion #1 c). the
argument 1s assumed to have type wint_ t. In either case, the corresponding
argument is written as a wide character.

u The $s conversion specifier is used with a pointer Lo a character array, which
may contain multibyte characters. (Fprint£ has no special provision for
multibyte characters.) If the 1 length modifier is present, as in 51 s, the corre-
sponding argument should be an array containinge wide characters. In either
case, the characters in the array are wrilten as wide characters. (With
Éprint£. the %1s specification also indicates an array of wide characters,
but they’re converted to multibyte characters before being written.)

Unlike fscan£, the £wscan£ function reads wide characters. The $c. %s.
and % [ conversions require special mention. Each of these causes wide characters
to be read and then converted to multibyte characters before being stored in à char-
acler array. Éwscan£ uses un mbstate t object to keep track of the state of the
conversion during this process; the object is set to zero at the beginning of each
conversion. If the 1 length modifier is present (making the conversion $1c. %1s.
or =1 [), then the input characters are not converted but instead arc stored directly
in an array of wchar_t clements. Thus, il’s necessary to use 31s when reading à
string of wide characters if the intent is to store them as wide characters. If &s is
used instead, wide characters will be read from the input stream but converted to
multibyte characters before being stored.

swprint£ writes wide characters into an array of wchar t elements, It’s
similar to sprint£ and snprint£ but not identical to either one. Like
snprintË. it uses the parameter n to limit the number of (wide) characters that it
will write. However, swprint£f returns the number of wide characters actually
written, not including the null character. In this respect, it resembles sprintf
rather than snprint£, which returns the number of characters that would have
been written (not including the null character) had there been no length restriction.

***************************page_686***************************
vswprintf

Table 25.12
Wide-Character Input/
Output Functions and
Their <stdio.h>
Equivalents

 

25.5 The <wchar.h> Header (C99) 661

swprintf returns a negative value if the number of wide characters to be written
is n or more, which differs from the behavior of both sprint f and snprintf.
vswprintf is equivalent tà swprint£, with arg replacing the variable
argument list of swprint£. Like swprint£, which 1s similar—but not identi-
cal—to sprintf and snprintf, the vswprintf function is a combination of
vsprint£ and vsnprint£Ë. If an attempt is made to write n or more wide char-
acters, vswprint £ returns a negative integer, In a manner similar to swprintéË.

Wide-Character Input/Output Functions

wint t fgetwc (FILE *stream) ;
wchar t *fgetws(wchar t * restrict s, int n,
FILE * restrict stream) ;

wint t fputwc(wchar t c, FILE *stream) ;

int fputws (const wchar t * restrict s,
FILE * restrict stream) ;

int fwide (FILE *stream, int mode) ;

wint & getwc (FILE *stream) ;

wint t getwchar (void) ;

wint t putwc(wchar t c, FILE *stream) ;

wint t putwchar(wchar t c);

wint t ungetwc(wint _ t c, FILE *stream) ;

The functions in this group are wide-character versions of the character inpul/out-
put functions found in <stdio.h> and described in Section 22.4. Table 25.12
shows the correspondence between the <stdio.h> functions and their wide-
character counterparts. Às the table shows, £wide 1s the only truly new function.

 

 

 

 

<wchar.h> Function _ <stdio.kh> Fquivalent

fgetwc igetc
fgetws Îigets
fputwc EÉputc
fputws Iputs
Éwide —
getwc getc

getwchar getchar
putwc putc

putwchar putchar
ungetwc ungetc

 

Unless otherwise indicated, you can assume that each <wchar.h> function
listed in Table 25.12 behaves like the correspondine <stdio.h> function. How-
ever, one minor difference is common to most of these functions. To indicate an
error or end-of-file condition, some <stdio.h> character VO functions return
EOF. The equivalent <wchar .h> f'unctions return WEOF instead.

***************************page_687***************************
662 Chapter 25

fgetwc
getwc
getwchar
fgetws

fpuitwce
puiwc
puitwchar
fpuiws

fwide

International Features

There's another twist that affects the wide-character input functions. À call of
à function that reads a single character (fgetwc, getwc. and getwchar) may
fail because the bytes found in the input stream don*t form a valid wide character
or there aren’t enough bytes available. The result is un encoding error. which
causes the function to store EILSEQ in errno and return WEOF. The fgetws
function, which reads a string of wide characters. may also fail because of an

encoding error, in which case it returns a null pointer.

Wide-character output functions may also encounter encoding errors. Functions
that write a single character (£putwc, putwc, and putwchar) store EILSEOQ in
errno and return WEOF if an encoding error occurs. However, the fputws func-
tion, which writes a wide-character string, is different: it returns EOF (not WEOF) 1f
an encoding error occurs.

The £wide function doesn’t correspond to any C89 function. fwide is used
to determine the current orientation of a stream and, if desired, attempt to set its
orientation. The mode parameter determines the behavior of the function:

#w mode > 0. Attempts to make the stream wide-oriented if it has no orientation.
u mode <0. Attempts to make the stream byte-oriented if it has no orientation.
u mode = 0. The orientation is not changed.

Éwide doesn't change the orientation if the stream already has one.

The value returned by £fwide depends on the orientation of the stream after
the call. The return value is positive if the stream has wide orientation, negative if
it has byte orientation, and zero if it has no orientation.

General Wide-String Utilities

The <wchar .h> header provides a number of functions that perform operations
on wide strings. These are wide-character versions of functions that belong to the
<stdlib.h> and <string.h> headers.

Wide-String Numeric Conversion Functions

double wcstod(const wchar t * restrict nptr,
wchar t ** restrict endptr);
float wcstof (const wchar t * restrict nptr,
wchar t ** restrict endptr) ;
long double westold(const wchar t * restrict nptr,
wchar _ t ** restrict endptr) ;
long int wcestol (const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base) ;
long long int wcestoll (const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base) ;

***************************page_688***************************
Table 25.13

Wide-String Numeric
Conversion Functions and
Their <stdlib.h>
Equivalents

25.5  The <wchar.h> Header (C99) 663

unsigned long int wcstoul(

const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base) ;

unsigned long long int wcstoull(

const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base) ;

The functions in this group are wide-character versions of the numeric conversion
functions found in <stdlib. h> and described in Scction 26.2. The <wchar .h>
functions have arguments of type wchar_t * and wchar t ** instead of char
* and char **, but their behavior is mostly the same as the <stdlib.h> func-
tions. Table 25.13 shows the correspondence between the <stdlib. h> functions

and their wide-character counterparts.

 

 

 

<wchar.h> Function — <stdlib.h> Equivalent
westod strtod
westof strtof
wostold strtold
westol strtol
wcestoll strtoll
westoul strtoul
wecstoull strtoull

 

 

Wide-String Copying Functions

wchar t

wchar L

wchar E

wchar L

*wcscpy (wchar t * restrict s1,

const wchar t * restrict s2);

*weosncpy(wchar t * restrict sl,

const wchar t * restrict s2,

size t n);
*wmemcpy (wchar t * restrict s1l,

const wchar t * restrict s2,

size t n);

*wmemmove (wchar t *s1, const wchar t *s2,

size t n);

The functions in this group are wide-character versions of the string copying func-
tions found in <string.h> and described in Section 23.6. The <wchar.h>
functions have arguments oftype wchar t * instead of char *, but their behavior
is mostly the same as the <string.h> functions. Table 25.14 shows the corre-
spondence between the <string .h> functions and their wide-character counter-

parts.

***************************page_689***************************
664 Chapter 25

Table 25.14
Wide-String Copying
Functions and Their
<string.h>
Equivalents

Table 25.15

Wide-String Concatenation
Functions and Their
<string.h> Equivalents

International Features

 

 

 

<wchar.h> Function … <string.h> Equivalent
WCSCHPY strcpy
wcSsNncpy strnepy
wmemcpy memcpy
wmemmove memmove

 

 

Wide-String Concatenation Functions

wchar t *wcscat (wchar t * restrict sl,
const wchar t * restrict s2);
wchar E *wvesncat (wchar t * restrict sl,
const wchar t * restrict s2,
size t n);

The functions in this group are wide-character versions of the string concatenation
functions found in <string. h> and described in Section 23.6. The <wchar .h>
functions have arguments of type wchar t * instead of char *. but their behavior
is mostly the same as the <string.h> functions. Table 25.15 shows the corre-

spondence between the <string .h> functions and their wide-character counter-
parts.

 

<wchar.h> F‘unction — <string.h> Equivalent

 

wescat strcat
wcsncat strncat

 

 

 

Wide-String Comparison Functions

int wcscmp (const wchar t *s1, const wchar t *s2);
int wcscoll (const wchar t *s1, const wchar t *s2);
int wcsneomp(const wchar t *s1, const wchar t *s2,
size t n);
size t wcsxfrm(wchar t * restrict s1l,
const wchar t * restrict s2,
size t n);
int wmemcmp (const wchar t * sl, const wchar t * s2,
size t n);

The functions in this group are wide-character versions of the string comparison
functions found in <string.h> and described in Section 23.6. The
<wchar .h> functions have arguments of type wchar t * instead of char *.
but their behavior is mostly the same as the <string. h> functions. Table 25.16
shows the correspondence between the <string.h> functions and their wide-
character counterparts.

***************************page_690***************************
Table 25.16

Wide-String Comparison

Functions and Their
<strina.h>
Equivalents

Table 25.17
Wide-String Search
Functions and Their

<string.h>

Equivalents

wcestok

25.5  The <wchar .h> Header (C99) 665

 

 

 

<wchar.h>Function <string.h> Equivalent
wcscmp strcomp
wcscoll strcoll
wcsncomp strncmp
wecsxfrm strxfrm
wmememp memcmp

 

 

Wide-String Search Functions

wchar t *weschr (const wchar_t *s, wchar E c);
size t wcscspn(const wchar_t *s1, const wchar t *s2);
wchar t *wecspbrk (const wchar t *s]l,
const wchar t *s2);

wchar t *wecsrchr(const wchar t *s, wchar £ C) ;
size t wesspn(const wchar t *s1, const wchar t *s2);
wchar t *wesstr (const wchar C *s1,

const wchar t *s2);
wchar t *westok(wchar t * restrict sl,

const wchar t * restrict s2,

wchar t ** restrict ptr);
wchar t *wmemchr (const wchar t *s, wchar t c,

size t n);

The functions in this group are wide-character versions of the string search fune-
tions found in <string.h> and described in Section 23.6. The <wchar .h>
functions have arguments of type wchar_t * and wchar_t ** instead of char
* and char **, but their behavior is mostly the same as the <string.h> fune-
tions. Table 25.17 shows the correspondence between the <string .h> functions
and their wide-character counterparts.

 

 

<wchar.h>Function … <string.h> Equivalent
weschr strchr
wcecscspn strespn
wcspbrk strpbrk
wesrchr strrchr
wcsspn strspn
wcsstr strstr
westok strtok
wmemchr memchr

 

 

 

The wostok function serves the same purpose as strtok, but is used some-
what differently, thanks to its third parameter. (strtok has only two parameters.)
To understand how wcstok works. we'll first need to review the behavior of
strtok.

***************************page_691***************************
666

Chapter 25

International Features

 

We saw in Section 23.6 that strtok searches a string for a “token*—a
sequence of characters that doesn’t include certain delimiting characters. The call
strtok(s1l, s2) scans the s1 string for a nonempty sequence of characters
that are nor in the s2 string. strtok marks the end of the token by storing a null
character in s1 just after the last character in the token: it then returns a pointer to
the first character in the token.

Later calls of strtok can find additional tokens in the same string. The call
strtok (NULL, s2) continues the search begun by the previous strtok call.
Às before, strtok marks the end of the token with a null character, and then
returns a pointer to the beginning of the token. The process can be repeated until
strtok returns a null pointer, indicating that no token was found.

One problem with strtok is that it uses a static variable to keep track of a
search, which makes it impossible to use strtok to conduct simultancous
searches on two or more strings. Thanks to its extra parameter, wcestok doesn't
have this problem.

The first two parameters to wcstok are the same as for strtok (except that
they point to wide strings, of course). The third parameter, ptr, will point to a
variable of type wchar t *. The function will save information in this variable
that enables later calls of wcstok to continue scanning the same string (when the
first argument is à null pointer). When the search is resumed by a subsequent call
of westok, a pointer to the same variable should be supplied as the third argu-
ment:; the value of this variable must not be changed between calls of weostok.

To see how wcstok works, let’s redo the example of Section 23.6. Assume
that str, p, and q are declared as follows:

wchar t str[)] = L" April 28,1998";
wchar t *p, *q;

Our initial call of westok will pass str as the first argument:
p = westok(str, L" \t", &q);

p now points to the first character in April, which is followed by a null wide
character. Calling westok with a null pointer as its first argument and &g as thc
third argument causes it to resume the search from where it left off:

p = wcstok (NULL, L" \t,", &q) ;

After this call, p points to the first character in 28, which is now terminated by a
null wide character. À final call of westok locates the year:

p = westok (NULL, L" \t", &G);

p now points to the first character in 1998.
Miscellaneous Functions

size t wcslen (const wchar t *s);
wchar_t *wmemset (wchar_t *s, wchar t c, size t n);

***************************page_692***************************
Table 25.18
Miscellaneous Wide-String
Functions and Their
<string.h> Equivalents

wesftime

 

25.5  The <wchar. h> Header (C99) 667

The functions in this group are wide-character versions of the miscellaneous
string functions found in <string.h> and described in Section 23.6. The
<wchar .h> functions have arguments of type wchar t * instead of char *,
but their behavior is mostly the same as the <string.h> functions. Table 25.18
shows the correspondence between the <string.h> functions and their wide-
character counterparts.

 

<wchar.h> Function _ <string.h> Equivalent

 

wcslen strlen
wmemset memset

 

 

 

Wide-Character Time-Conversion Functions

size t wesftime (wchar t * restrict s, size t maxsize,
const wchar t * restrict format,
const struct tm * restrict timeptr) ;

The wesftime function is the wide-character version of strftime, which
bclongs to the <t ime .h> header and is described in Section 26.3.

Fxtended Multibyte/Wide-Character Conversion Utilities

We'll now examine <wchar.h> functions that perform conversions between
multibyte characters and wide characters. Five of these functions (mbrlen,
mbrtowc, wertomb, mbsrtowcs, and wcsrtombs) correspond to the multi-
byte/wide-character and _multibyte/wide-string conversion functions declared in
<stdlib.h>. The <wchar.h> functions have an additional parameter, a
pointer to a variable of typc mbstate t. This variable keeps track of the state of
the conversion of a multibyte character sequence to a wide-character sequence (or
vice versa), based on the current locale. As a result, the <wchar .h> functions are
“restartable”; by passing a pointer to an mbstate t variable modified by a previ-
ous function call, we can “restart”’ the function using the conversion state from that
call. One advantage of this arrangement is that it allows two functions to share the
same conversion state. For example, calls of mbrtowc and mbsrtowcs that are
Used to process a single multibyte character string could share an mbstate t
variable.

The conversion state stored in an mbstate_t variable consists of the current
shift state plus the current position within a multibyte character. Setting the bytes
of an mbstate_t variable to zero puts it in the initial conversion state, signifying
that no multibyte character is yet in progress and that the initial shift state is in
effect:

mbstate t state;

memset (&state, '\0', sizeof (state) ) ;

***************************page_693***************************
668

Chapter 25

btowc

wctob

mbsinit

International Features

Passing &state to one of the restartable functions causes the conversion to begin
in the initial conversion state. Once an mbstate t variable has been altered by
one of these functions, it should not be used to convert a different multibyte char-
acter sequence, nor should 1t be used to perform a conversion in the opposite direc-
tion. Attempting to perform either action causes undefined behavior. Using the
variable after a change in the LC _ CTYPE category of a locale also causes unde-
fined behavior.

Single-Byte/Wide-Character Conversion Functions

wint t btowc(int c);
int wctob(wint t c);

The functions in this group convert single-byte characters to wide characters and
vice versa.

The btowc function returns WEOF 1f c is equal to EOF or if c (when cast to
unsigned char) isn’t a valid single-byte character in the initial shift state. Oth-
erwise, btowc returns the wide-character representation of c.

The wctob function is the opposite of btowc. Ît returns EOF if c doesn’t
correspond to one multibyte character in the initial shift state. Otherwise, it returns
the single-byte representation of c.

Conversion-State Functions

int mbsinit (const mbstate t *ps);

This group consists of a single function, mbsinit, which returns a nonzero value
If ps 1s a null pointer or it points to an mbstate_ t variable that describes an ini-
tial conversion state.

Restartable Multibyte/Wide-Character Conversion Functions

size t mbrlen(const char * restrict s, size t n,
mbstate t * restrict ps);
size t mbrtowc(wchar t * restrict pwc,
const char * restrict s, size t n,
mbstate t * restrict ps);
size t wcertomb(char * restrict s, wchar t wc,
mbstate t * restrict ps);

The functions in this group are restartable versions of the mblen. mbtowc, and
wctomb functions, which belong to <stdlib.h> and are discussed in Section
25.2. The newer mbrlen, mbrtowc, and wertomb functions differ from their
<stdlib.h> counterparts in several ways:

***************************page_694***************************
mbrlen

mbrtowc

wcerilomb

 

29.5  The <wchar.h> Header (C99) 669

= morlen, mbrtowc, and wcrtomb have an additional parameter named ps.
When one of these functions is called. the corresponding argument should
point to a variable of type mbstate_t;the function will store the state of the
conversion in this variable. If the argument corresponding to ps is a null
pointer, the function will use an internal variable to store the conversion state.
(Atthe beginning of program execution, this variable is set to the initial con-
version state.)

u When the s parameter is a null pointer, the older mblen. mbtowc, and
wctomb functions return a nonzero value if multibyte character encodings
have state-dependent encodines (and zero otherwise). The newer functions
don t have this behavior.

# mbrlen, mbrtowc, and wcrtomb return a value of type size_t instead of
int, the return type of the older functions.

À call ofmbrlen 1s equivalent to the call
mbrtowc (NULL, s, n, ps)

except that if ps is a null pointer, then the address of an internal variable is used
instead.
If s is a null pointer, à call of mbrtowc is equivalent to the call

mbrtowc (NULL, "", 1, ps)

Otherwise, a call of mbrtowc examines up to n bytes pointed to by s to see if they
complete a valid multibyte character. (Note that a multibyte character may already
be in progress prior to the call, as tracked by the mbstate_t variable to which
ps points.) IF so, these bytes are converted into a wide character. The wide charac-
ter is stored in the location pointed to by pwc as long as pwc isn’t null. If this char-
acter is the null wide character, the mbstate t variable used during the call is
left in the initial conversion state.

mbrtowc has a variety of possible return values. It returns O if the conversion
produces a null wide character. It returns a number betwcen | and n if the conver-
sion produces a wide character other than null, where the value returned is the
number of bytes used to complete the multibyte character. It returns —2 if the n
bytes pointed to by s aren’t enough to complete a multibyte character (although
the bytes themselves were valid). Finally, it returns —1 if an encoding error occurs
(the function encounters bytes that don'1 form à valid multibyte character). In the
last case, mbrtowc also stores EILSEQ in errno.

If s is a null pointer, a call of wortomb is equivalent to

wertomb (bu£f, L'\0', ps)

where bu£ is an internal buffer. Otherwise, wertomb converts wc from a wide
character into à multibyte character, which it stores in the array pointed to by s.
If wc is a null wide character, wertomb stores a null byte. preceded by a shift
sequence if one is necessary to restore the initial shift state. In this case, the

***************************page_695***************************
670

Chapter 25

mbsriowces
wesrtombs

International Features

mbstate_t variable used during the call is left in the initial conversion state.
wertomb returns the number of bytes that it stores, including shift sequences. If
wc isn’t a valid wide character, the function returns —! and stores EILSEO in
errno.

Restartable Multibyte/Wide-String Conversion Functions

size t mbsrtowcs (wchar t * restrict dst,
const char ** restrict src,
size t len,
mbstate t * restrict ps);
size t wcsrtombs (char * restrict dst,
const wchar t ** restrict src,
size t len,
mbstate t * restrict ps);

The mbsrtowcs and wcsrtombs functions are restartable versions of
mbstowcs and wostombs, which belong to <stdlib.h> and are discussed in
Section 25.2. mbsrtowcs and wosrtombs are the same as their <stdlib.h>
counterparts, excepl for the following differences:

u mbosrtowcs and wesrtombs have an additional parameter named ps.
When one of these functions is called. the corresponding argument should
point to a variable oftype mbstate t;the function will store the state of the
conversion in this variable. If the argument corresponding to ps is a null
pointer, the function will use an internal variable to store the conversion state.
(At the beginning of program execution, this variable is set to the initial con-
version state.) Both functions update the state as the conversion proceeds. !f
the conversion stops because a null character is reached, the mbstate t
vartable will be left in the initial conversion state.

m The src parameter, which represents the array containing characters to be
converted (the source array), is a pointer to a pointer for mbsrtowcs and
wesrtombs. (In the older mbstowcs and woestombs functions, the corre-
sponding parameter was simply a pointer.) This change allows mbsrtowcs
and wesrtombs to keep track of where the conversion stopped. The pointer
to which src points is set to null if the conversion stopped because a null
character was reached. Otherwise, this pointer is set Lo point just past the last
source character converted.

u The dst parameter may be a null pointer, in which case the converted charac-
ters aren’t stored and the pointer to which src points isn*t modified.

m When either function encounters an invalid character in the source array, it
stores EILSEQ in errno (in addition to returning —1, as the older functions
do).

***************************page_696***************************
25.6

<ctype .h> header »23.5

25.6 The <wctype.h> Header (C99) 671

The <wctype.h> Header (C99)
Wide-Character Classification and Mapping Utilities

The <wctype.h> header is the wide-character version of the <ctype.h>
header. <ctype.h> provides two kinds of functions: character-classification
functions (like isdigit, which tests whether a character is a digit) and character
case-mapping functions (like toupper, which converts a lower-case letter to
upper case). <wctype.h> provides similar functions for wide characters.
although it differs from <ctype .h> in one important way: some of the functions
in <wctype .h> are ““extensible”’ meaning that they can perform custom charac-
ter classification or case mappineg.

<wctype .h> declares three types and a macro. The wint_ t type and the
WEOF macro were discussed in Section 25.5. The remaining types are wctype _t,
whose values represent locale-specific character classifications, and wctrans t,
whose values represent locale-specific character mappings.

Most of the functions in <wctype .h> require a wint t argument. The
value of this argument must be a wide character (a wchar t valuëe) or WEOF.
Passing any other argument causes undefined behavior.

The behavior of the functions in <wctype .h> is affected by the LC_CTYPE
category of the current locale.

Wide-Character Classification Functions

int
int
int
int
int
int
int
int
int
int
int
int

iswalnum(wint_t
iswalpha (wint t
iswblank (wint t
iswentrl (wint t
iswdigit (wint t
iswgraph(wint t
iswlower (wint t
iswprint (wint t
iswpunct (wint t
iswspace (wint t
iswupper (wint t

wc) ;
wc) ;
Wc ) ;
wc) ;
wWc) ;
Wc ) ;
wWCc) ;
wC ) ;
wc) ;
Wc) ;
wc) ;

iswxdigit (wint t wc);

Each wide-character classification function returns a nonzero value if its argument
has a particular property. Table 25.19 lists the property that each function tests.
The descriptions in Table 25.19 1gnore some of the subtleties of wide charac-
ters. For example, the definition of iswgraph in the C99 standard states that it
“tests for any wide character for which iswprint 1s true and iswspace is false,”

***************************page_697***************************
672 Chapter 25

Table 25.19
Wide-Character
Classification Functions

wcliype

International Features

 

Function

Test

 

iswalnum (wc)
iswalpha (wc)
iswblank (wc)
iswentrl (wc)
iswdigit (wc)
iswgraph (wc)
iswlower (wc)
iswprint (wec)
iswpunct (wc)
iswspace (wc)
iswupper (wc)

Is wc alphanumeric?

1s wc alphabetic?

Is we a blank?}

[s wc a control character?

[s wc a decimal digit”

Is wc a printing character (other than a space)”
[s wc à lower-case letter?

Is wc a printine character (including a space)?
[s wc punctuation?

[Is wc à white-space character?

[s wC an upper-case letter’

 

 

iswxdigit (wc) Is wc a hexadecimal digit”

 

‘The standard blank wide characters are space (L' ')und horizontal tab
(L'\t').

leaving open the possibility that more than one wide character is considered to be à
“space.” See Appendix D for more detailed descriptions of these functions.

In most cases, the wide-character classification functions are consistent with
the corresponding functions in <ctype.h>: if a <ctype .h> function returns a
nonzero value (indicating ““true”) for à particular character, then the corresponding
<wctype .h> function will return true for the wide version of the same character.
The only exception involves white-space wide characters (other than space) that
are also printing characters, which may be classified differently by iswgraph
and iswpunct than by isgraph and ispunct. For example. a character for
which isgraph returns true may cause iswgraph to return false.

Extensible Wide-Character Classification l’unctions

int iswctype(wint t wc, wctype t desc);
wctype t wctype(const char *property) ;

Each of the wide-character classification functions just discussed is able to test a
single fixed condition. The wctype and iswctype functions—which are de-
signed to be used together—make it possible to test for other conditions as well.

The wctype function is passed a string describing a class of wide characters:
it returns a wctype t value that represents this class. For example. the call

wctype ("upper")

returns a wctype t value representing the class of upper-case letters. The C99
standard requires that the following strines be allowed as arguments to wctype:

"blank"
"punct"

udigitu
‘ upper"

"entrl"
U Space U

"alnum"
"lower"

" 81ph8 "
"pI‘iDt "l

"graph"
"xdigit"

Additional strings may be provided by an implementation. Which strings are legal
arguments lo0 wctype at a given time depends on the LC _ CTYPE category of the

***************************page_698***************************
iswetype

towlower
itowupper

wctrans

25.6  The <wctype.h> Header (C99) 673

current locale; the 12 strings listed above are legal in all locales. 1f wctype 1s
passed a string that’s not supported in the current locale, 1t returns zero.

À call of the iswctype function requires two parameters: wc (a wide char-
acter) and desc (a value returned by wotype). iswctype returns a nonzero
value rf wc belongs to the class of characters corresponding to desc. For example,
the call

iswctype (wc, wctype ("alnum'") )
is equivalent to
iswalnum (wc)

wctype and iswctype are most useful when the argument to wctype Is à
string other than the standard ones listed above.

Wide-Character Case-Mapping Functions

wint t towlower(wint t wc);
wint t towupper (wint t wc);

The towlower and towupper functions are the wide-character counterparts of
tolower and toupper. For example. towlower returns the lower-case ver-
sion of its argument. if the argument is an upper-case letter; otherwise. it returns
the argument unchanged. As usual. there may be quirks when dcaling with wide
characters. For example, more than one lower-case version of a letter may exist in
the current locale, in which case towlower 1s allowed to return any one of them.

Extensible Wide-Character Case-Mapping Functions

wint t towctrans(wint t wc, wctrans t desc) ;
wctrans t wctrans(const char *property) ;

The wctrans and towctrans functions are used together to support general-
ized wide-character mapping.

The wctrans function is passed a string describing a character mapping: 1t
returns a wctrans_ t value that represents the mapping. For example, the call

wectrans ("tolower")

returns àawctrans t value representing the mapping of upper-case letters to low-
er case. The C99 standard requires that the strings "tolower" and "toupper"
be allowed as arguments to wctrans. Additional strings may be provided by an
implementation. Which strings are legal arguments to wctrans at a given time
depends on the LC CTYPE category of the current locale; "tolower" and
"coupper" are legal in all locales, lf wctrans is passed a string that's not sup-
ported in the current locale, it returns zero.

***************************page_699***************************
674

Chapter 25

lowctrans

> ©

International Features

À call of the towctrans function requires two parameters: wc (a wide char-
acter) and desc (a value returned by wctrans). towctrans maps wc lo
another wide character based on the mapping specified by desc. For example, the
call

towctrans (wc, wctrans ("tolower") )
1s equivalent to
towlower (wc)

towctrans is most useful in conjunction with implementation-defined map-
pines.

Q & À

How long is the locale information string returned by setlocale? [p. 644]

There’s no maximum length, which raises a question: how can we set aside space
for the string if we don't know how long it will be? The answer, of course, is
dynamic storage allocation. The following program fragment (based on a similar
example in Harbison and Steele’s C: À Reference Manual) shows how to deter-
mine the amount of memory needed, allocate the memory dynamically, and then
copy the locale information into that memory:

char *temp, *old_locale;

temp = setlocale(LC ALL, NULL) ;
if (temp == NULL) {

/* locale information not available */
}

old locale = malloc(strlen(temp) + 1);
if (old _ locale == NULL) Ç{

/* memory allocation failed */
}

strcpy (old _locale, temp) ;
We can now switch to a different locale and then later restore the old locale:
setlocale(LC ALL, ""); /* switches to native locale */

setlocale(LC ALL, old_locale) ; /* restores old locale */

Why does C provide both multibyte characters and wide characters?
Wouldn°t cither one be enough by itself? [p. 648]

The two encodings serve different purposes. Multibyte characters are handy for
input/output purposes, since 1/O devices are often byte-oriented. Wide characters.
on the other hand, are more convenient to work with inside a program, since
every wide character occupies the same amount of space. Thus, a program might

***************************page_700***************************
Section 25.1

Section 25.2

2.

 

Exercises 675

read multibyte characters, convert them to wide characters for manipulation
within the program, and then convert the wide characters back to multibyte form
for output.

Unicode and UCS seem to be pretty much the same. What’s the difference
between the two’ [p. 650]

Both contain the same characters, and characters are represented by the same code
points in both. Unicode is more than just a character set. though. For example, Uni-
code supports “bidirectional display order ” Some languages, including Arabic and
Hebrew, allow text to be written from right to left instead of left to right. Unicode
is capable of specifying the display order of characters, allowing text to contain
some characters that are to be displayed from left to right along with others that go
from right to left.

Exercises

Determine which locales are supported by your compiler.

The Shift-JIS encoding for kanji requires either one or two bytes per character. If the first
byte of a character is between Ox81 and OxS9f or between Oxe0 and Oxef, a second byte
is required. (Any other byte is treated as a whole character.) The second byte must be
between Ox40 and Ox7e or between Ox80 and Oxfc. (AII ranges are inclusive.) For each
of the following strings. give the value that the mbcheck function of Section 25.2 will
return when passed that string as its argument, assuming that multibyte characters are
encoded using Shift-JIS in the current locale.

(a) "\x05\x87\x8B0\x36\xed\xaa "
(b) "\x20\xe4\x50\x88\x3 E "

(c) "\xde\xad\xbe\xef "

(d) "\x8a\x60\x92\x74\x41"

One of the useful properties of UTF-8 is that no sequence of bytes within a multibyte char-
acter can possibly represent another valid multibyte character. Does the Shift-JIS encoding
for kanji (discussed in Exercise 2) have this property?

Give à C string literal that represents each of the following phrases. Assume that the charac-
ters à, è, é, Ë, Î, 6. Ü, and ü are represented by single-byte Latin-! characters. (You*Il need to
look up the Latin-1 code points for these characters.) For example, the phrase déjà vu could
be represented by the string "d\xe9j\xe0 vu".

(a) Côte d'Azur

(b) crème brûlée

(c) crème fraîche

(d) Fahrvergniigen

(e) rête-à-tête

Repeat Exercise 4, this time using the UTF-8 multibyte encoding. For example. the phrase
déjà vu could be represented by the string "d\\xc3 \xa9j\xc3\xa0 vu".

***************************page_701***************************
676 Chapter 25

Section 25.3

® 6.
T.
® !
2.

International Features

Modify the following program fragment by replacing as many characters as possible by tri-
graphs.

while ((orig char = getchar()) != EOF) {
new char = orig char “ KEY;
if (isprint (orig char) && isprint (new_char))
putchar (new _char) ;
else
putchar (orig_char) ;

}

(C99) Modify the program fragment in Exercise 6 by replacing as many tokens as possible
by digraphs and macros defined in <iso646.h>.

Programming Projects

Write a program that tests whether your compiler*s "" (native) locale is the same as its "C"
locale.

Write à program that obtains the name of a locale from the command line and then displays
the values stored in the corresponding 1conv structure. For example, if the locale is
"f£fi FI" (Finland), the output of the program might look like this:

decimal_point = ","
thousands sep = " "
grouping = 3

mon _ decimal _point = ","
mon thousands _ sep "
mon grouping 3
positive _sign = ""
negative sign = "-"
currency _ symbol = "EUR"
frac_digits = 2
p cs precedes =
n cs precedes = O
p_sep by space = 2
n sep by space
p _sign posn = l
n sign posn = l
int curr symbol = "EUR "
int frac _ digits = 2
int_p_cs _ precedes = O
int n cs precedes = O
int_p_sep by space = 2
int _n sep by space
int p sign posn = l
int n sign posn = l

O

H
V

Il
&

For readability, the characters in grouping and mon_grouping should be displayed as
decimal numbers.

***************************page_702***************************
26

26.1

Miscellaneous Library
Functions

Ît is the user who should parametrize
procedures, not their creators.

<stdarg.h>, <stdlib.h>, and <time.h>—the only C89 headers that
weren't covered in previous chapters—are unlike any others in the standard library.
The <stdarg .h> header (Section 26.!) makes it possible to write functions with
a variable number of arguments. <stdlib.h> (Section 26.2) is an assortment of
functions that don t fit into one of the other headers. The <time .h> header (Sec-
tion 26.3) allows programs to work with dates and times.

 

The <stdarg.h> Header: Variable Arguments

type va _ arg(va list ap, rype) ;

void va _ copy(va list dest, va list src);
void va _ end(va list ap);

void va _start (va _ list ap, parmN) ;

Functions such as print£ and scanf have an unusual property: they allow any
number of arguments. The ability to handle a variable number of arguments isn’t
limited to library functions. as it turns out. The <stdarg. h> header provides the
tools we’Il need to write our own functions with variable-length argument lists.
<stdarg.h> declares one type (va_list) and defines several macros. In C89,
there are three macros, named va_start, va_arg, and va_end. which can be
thought of as functions with the prototypes shown above. C99 adds a function-like
macro named va_copy.

677

 

***************************page_703***************************
678 Chapter 26  Miscellaneous Library Functions

To see how these macros work, we’ll use them to write a function named
max_int that finds the maximum of any number of integer arguments. Here”s
how we might call the function:

max int (3, 10, 30, 20)

The first argument specifies how many additional arguments will follow. This call
of max _ int will return 30 (the largest of the numbers 10, 30, and 20).
Here’s the definition of the max_int function:

int max_int (int n, ...) /* n must be at least 1 */

va_list ap;
int i, current, largest;

va_start (ap, n) ;
largest = va_arg(ap, int);

for (i = 1; i < n; i++) [(
current = va arg(ap, int) ;
if (current > largest)
largest = current ;
}

va_end (ap) ;
return largest ;

}

The ... symbol in the parameter list (kKnown as an e/lipsis) indicates that the
parameter n is followed by a variable number of additional parameters.

The body of max int begins with the declaration of a variable of type
va_list:

va_list ap;

Declaring such a variable is mandatory for max_int to be able to access the argu-
ments that follow n.
va_start The statement

va_start (ap, n) ;

indicates where the variable-length part of the argument list begins (in this case,
after n). À function with a variable number of arguments must have at least one
“normal” parameter; the ellipsis always goes at the end of the parameter list, after
the last normal parameter.

va_arg The statement

largest = va_arg(ap, int);

fetches max_int's second argument (the one after n), assigns it to largest,
and automatically advances to the next argument. The word int indicates that we
expect max_int's second argument to have int type. The statement

***************************page_704***************************
va_end

va_copy

/

default argument promotions » 9.3

26.1  The <stdarg.h> Header: Variable Arguments 679

current = va arg(ap, int);

fetches max_int's remaining arguments, one by one, as it is executed inside a
loop.

 

Don't forget that va_arg always advances to the next argument after fetching the
current one. Because of this property, we couldn’t have written max _int*s loop in
the following way:

for (i = 1; i < n; i++)
if (va arg(ap, int) > largest) /*** WRONG ***/
largest = va arg(ap, int);

 

The statement
va_end (ap) ;

is required to ‘“clean up” before the function returns. (Or, instead of returning, the
function might call va_start and traverse the argument list again.)

The va_copy macro copies src (a va_list value) into dest (also a
va_list). The usefulness of va_copy lies in the fact that multiple calls of
va_arg may have been made using src before it’s copied into dest, thus pro-
cessing some of the arguments. Calling va_copy allows a function to remember
where 1t is in the argument list so that it can later return to the same point to reex-
amine an argument (and possibly the arguments that follow it).

Each call of va_start or va_copy must be paired with a call of va_end.
and the calls must appear in the same function. AIl calls of va_arg must appear
between the call of va_start (or va_copy) and the matching call of va_end.

 

When a function with a variable argument list is called, the compiler performs the
default argument promotions on all arguments that match the ellipsis. In particular,
char and short arguments are promoted to int, and float values are pro-
moted to double. Consequently, it doesn’t make sense to pass types such as
char, short. or float to va_arg, since arguments—after promotion—will
never have one of those types.

 

Calling a Function with a Variable Argument List

Calling a function with a variable argument list is an inherently risky proposition.
Âs far back as Chapter 3, we saw how dangerous it can be to pass the wrong argu-
ments to print£ and scan£. Other functions with variable argument lists are
equally sensitive. The primary difficulty is that a funcetion with a variable argument
list has no way to determine the number of arguments or their types. This informa-
tion must be passed into the function and/or assumed by the function. max_int
relies on the first argument to specify how many additional arguments follow; it

***************************page_705***************************
680

Chapter 26 Miscellaneous Library Functions

vfprintf
vprintf
vsprintf

æ

assumes that the arguments are of type int. Functions such as print£ and
scan£ rely on the format string, which describes the number of additional argu-
ments and the type of each.

Another problem has to do with passing NULL as an argument. NULL is usu-
ally defined to represent O. When O is passed to a function with a variable argu-
ment list, the compiler assumes that it represents an integer—there’s no way it can
tell that we want it to represent the null pointer. The solution is to add a cast, writ-
ing (void *) NULL or (void *) O instead of NULL. (See the Q&AÀ section at
the end of Chapter 17 for more discussion of this point.)

The v..print£ Functions

int v£printf (FILE * restrict stream,
const char * restrict format,

va _list arg) ; from <stdio.h>
int vprintf (const char * restrict £ormat,
va list arg) ; from <stdio.h>

int vsnprintf (char * restrict s, size t n,

const char * restrict format,

va_list arg); from <stdio.h>
int vsprint£ (char * restrict s,

const char * restrict format,

va_list arg) ; from <stdio.h>

The vfprint£, vprintE. and vsprint£ functions (the “v…print£ func-
tions’’) belong to <stdio.h>. We*re discussing them in this section because
they’re invariably used in conjunction with the macros in <stdarg.h>. C99 adds
the vsnprint£ function.

The v…printf functions are closely related to fprint£, print£, and
sprint£. Unlike these functions, however, the v….printf functions have a
fixed number of arguments. Each function’s last argument is a va_list value.
which implies that it will be called by a function with a variable argument list. In
practice, the v….printf functions are used primarily for writing “wrapper” func-
tions that accept a variable number of arguments, which are then passed to a
v..print£ function.

As an example, let’s say that we’re working on a program that needs to display
error messages from time to time. We’d like each message to begin with à prefix of
the form

** Error n:

where n is 1 for the first error message and increases by one for each subsequent
error. To make it easier to produce error messages, we’Il write a function named
error£ that’s similar to print£, but adds ** Error n: to the beginning of

***************************page_706***************************
vsnprintf

æ

vfscanf
vscanf
vsscanf

 

V

26.1  The <stdarg.h> Header: Variable Arguments 681

its output and always writes to stderr instead of stdout. We'll have errorf
call v£print£ to do most of the actual output. Here’s what error£ might look
Hike:

int errorf (const char *format, ...)
static int num errors = 0;
int n:

va_list ap;

num_errors++;
Eprint£f(stderr, "** Error %d: ", num errors) ;
va_start (ap, format) ;

n vfprintf (stderr, £ormat, ap) ;

va_end (ap) ;

fprint£f (stderr, "\n") ;

return n;

The wrapper function—error£, in our example—is responsible for calling
va_start prior to calling the v.….print£ function and for calling va_end after
the v.….print£ function returns. The wrapper function 1s allowed to call va_arg

one or more times before calling the v.….print£ function.
The vsnprint£ function was added to the C99 version of <stdio.h>. lIt

corresponds to snprint£ (discussed in Section 22.8), which 1s also a C99 func-
tion.

The v.….scanf Functions

int vfscanf (FILE * restrict stream,
const char * restrict format,

va_list arg); from <stdio.h>
int vscanf (const char * restrict format,
va_list arg); from <stdio.h>

int vsscanf (const char * restrict s,
const char * restrict format,
va_list arg); from <stdio.h>

C99 adds a set of ‘“v….scanf functions” to the <stdio.h> header. vÉfscanft,
vscanf. and vsscanf are equivalent to fscan£. scan£. and sscanf.
respectively, except that they have a va_list parameter through which a variable
areument list can be passed. Like the v….print£ functions, each v….scan£ func-
tion is designed to be called by a wrapper function that accepts a variable number
of arguments, which it then passes to the v.….scanf function. The wrapper func-
tion is responsible for calling va_start prior to calling the v….scan£ function
and for calling va_end after the v….scan£ function returns.

***************************page_707***************************
682

Chapter26 Miscellaneous Library Functions

26.2

The <stdlib.h> Header: General Utilities

<stdlib.h> serves as a catch-all for functions that don°t fit into any of the other
headers. The functions in <stdlib.h> fall into eight groups:

Numeric conversion functions

Pseudo-random sequence generation functions
Memory-management functions
Communication with the environment
Searching and sorting utilities

Integer arithmetic functions
Multibyte/wide-character conversion functions
Multibyte/wide-string conversion functions

We’I1 look at each group in turn, with three exceptions: the memory management
functions, the multibyte/wide-character conversion functions, and the multibyte/
wide-string conversion functions.

The memory-management functions (malloc, calloc, realloc, and
free) permit a program to allocate a block of memory and then later release it or
change its size. Chapter 17 describes all four functions in some detail.

The multibyte/wide-character conversion functions are used to convert a
multibyte character to a wide character or vice-versa. The multibyte/wide-string
conversion functions perform similar conversions between multibyte strings and
wide strings. Both groups of functions are discussed in Section 25.2.

Numeric Conversion Functions

double atof (const char *nptr) ;

int atoi (const char *nptr) ;
long int atol (const char *nptr) ;
long long int atoll (const char *nptr) ;

double strtod(const char * restrict nptr,
char ** restrict endptr) ;
float strtof (const char * restrict nptr,
char ** restrict endptr) ;
long double strtold(const char * restrict nptr,
char ** restrict endptr) ;

long int strtol (const char * restrict nptr,
char ** restrict endptr, int base) ;

***************************page_708***************************
atof
atoi
atol

&rrno vatiable >24,2

strtod
strtol
strtoul

HUGE_VAL macro »23.3

 

26.2 The <stdlib.h> Header: General Utilities 683

Jlong long int strtoll (const char * restrict nptr,
char ** restrict endptr,
int base) ;

unsigned long int strtoul (

const char * restrict nptr,

char ** restrict endptr, int base) ;
unsigned long long int strtoull(

const char * restrict nptr,

char ** restrict endptr, int base) ;

The numeric conversion functions (or “string conversion functions,' as they’re
known in C89) convert strings containing numbers in character form to their
equivalent numeric values. Three of these functions are fairly old, another three
were added when the C89 standard was created, and five more were added in
C99.

AIl the numeric conversion functions—whether new or old—work in much
the same way. Each function attempts to convert a string (pointed to by the nptr
parameter) to a number. Each function skips white-space characters at the begin-
ning of the string, treats subsequent characters as part of a number (possibly begin-
ning with a plus or minus sign}, and stops at the first character that can*t be part of
the number. In addition, each function returns zero if no conversion can be per-
formed (the string is empty or the characters following any initial white space
don’t have the form the function is looking for).

The old functions (atoË, atoi, and atol) convert a string to a double,
int, or long int value, respectively. Unfortunately, these functions lack any
way to indicate how much of the string was consumed during a conversion. More-
over, the functions have no way to indicate that a conversion was unsuccessful.
(Some implementations of these functions may modify the errno variable when a
conversion fails, but that’s not guaranteed.)

The C89 functions (strtod, strtol, and strtoul) are more sophisti-
cated. For one thing, they indicate where the conversion stopped by modifying the
variable that endptr points to. (The second argument can be a null pointer if
we're not interested in whère the conversion ended.) To check whether a function
was able to consume the entire string, we can just test whether this variable points
to a null character. If no conversion could be performed, the variable that endptr
points to is given the value of nptr (as long as endptr isn’t a null pointer).
What's more, strtol and strtoul have a base argument that specifies the
base of the number being converted. All bases between 2 and 36 (inclusive) are
supported.

Besides being more versatile than the old functions, strtod, strtol, and
strtoul are better at detecting errors. Each function stores ERANGE in errno
If a conversion produces a value that’s outside the range of the function’s return
type. In addition, the strtod function returns plus or minus HUGE VAL:; the

***************************page_709***************************
684 Chapter 26 Miscellaneous Library Functions

<limits.h> macros » 23.2

atoll
strtof
striold
strioll
strtoull

e F3 1

PROGRAM

it&numconv.c

strtol and strtoul functions return the smallest or largest values of their
respective return types. (strtol returns either LONG MIN or LONG MAX, and
strtoul returns ULONG _ MAX.)

C99 adds the atoll, strtof, strtold, strtoll, and strtoull
functions. atoll is the same as the atol function. except that it converts a
string to a long long int value. strtof and strtold are the same as
strtod, except that they convert a string to a £float or long double value,
respectively. strtoll 1s the same as strtol, except that it converts a string to
à long long int value. strtoull 1s the same as strtoul, except that it
converts a string to an unsigned long long int value. C99 also makes a
small change to the floating-point numeric conversion functions: the string passed
to strtod (as well as its newer cousins, strtof and strtold) may contain a
hexadecimal floating-point number, infinity, or NaN.

Testing the Numeric Conversion Functions

The following program converts a string to numeric form by applying each of the
six numeric conversion functions that exist in C89. After calling the strtod.
strtol. and strtoul functions, the program also shows whether each conver-
sion produced a valid result and whether it was able to consume the entire string.
The program obtains the input string from the command line.

/* Tests C89 numeric conversion functions */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>

#define CHK VALID printf(" %s gs\n",
errno != ERANGE ? "Yes" : "No ",
*ptr —— I\Ol ? "Yes"! . "NO")

\
\

int main(int argec, char *argv[])

{

char *ptr;

if (argc != 2) |
printf ("usage: tnumconv string\n") ;
exit (EXIT FAILURE) ;

}

printf ("Function Return Value\n") ;
printf(r-------- _ ------------ \n") ;

print£ ("atof 3g\n", atof (argv[1] )) ;
print£ ("atoi sd\n", atoi (argv[1])) ;
print£ ("atol 71d\n\n", atol (argv [1] ) ) ;

print£ ("Function Return Value Valid? "
"String Consumed?\n"

***************************page_710***************************
errno
printf

 

26.2 The <stdlib.h> Header: General Utilities 685

0 ;
"strtod 3-12g", strtod(argv[1], &ptr));

CHK VALID;

e€rrno

0 ;

printf ("strtol 3-121d", strtol (argv[1], &ptr, 10));
CHK VALID;

errno

0 ;

print£ ("strtoul +-12lu", strtoul (argv[1], &ptr, 10));
CHK VALID;

return 0;

If 3000000000 is the command-line argument, the output of the program
might have the following appearance:

Function

strtod
strtol
strtoul

Return Value

— = æ æ

3e+09
2147483647
2147483647

_ = = = = — - —. —

3e+09 Yes Yes
2147483647 No Yes
3000000000 Yes Yes

On many machines. the number 3000000000 1s too large to represent as a long
integer, although it’s valid as an unsigned long integer. The atoi and atol func-
tions had no way to indicate that the number represented by their argument was out
of range. In the output shown, they returned 2147483647 (the largest long integer),
but the C standard doesn’t guarantee this behavior. The strtoul function per-
lormed the conversion correctly; strtol returned 2147483647 (the standard
requires it to return the largest long inteser) and stored ERANGE In errno.
If 123.456 is the command-line argument, the output will be

Function

_ =— ——

strtod
strtol
strtoul

Return Value
123.456

123

123

Return Value Valid? String Consumed?

— — — - — — — —— —— — —

123.456 Yes Yes
123 Yes No
123 Yes No

***************************page_711***************************
686

Chapter 26 Miscellaneous Library Functions

rand

srand

time function »26.3

AI six functions treated this string as a valid number, although the integer func-
tions stopped at the decimal point. The strtol and strtoul functions were
able to indicate that they didn’t completely consume the string.

If £oo 1s the command-line argument, the output will be

Function Return Value

atof 0
atoi 0
atol 0

Function Return Value Valid? String Consumed?

æ æ æ — — — —— —— — — —

strtod 0 Yes No
strtol 0 Yes No
strtoul 0 Yes No

AIl the functions looked at the letter £ and immediately returned zero. The str…
f'unctions didn’t change errno, but we can tell that something went wrong from
the fact that the functions didn’t consume the string.

Pseudo-Random Sequence Generation Functions

int rand (void) ;
void srand (unsigned int seed}) ;

The rand and srand functions support the generation of pseudo-random num-
bers. These functions are useful in simulation programs and game-playing pro-
grams (to simulate a dice roll or the deal in a card game, for example).

Each time it’s called, rand returns a number between O and RAND MAX (a
macro defined in <stdlib.h>). The numbers returned by rand aren°t actually
random; they're generated from a ‘‘“seed” value. To the casual observer, however,
rand appears to produce an unrelated sequence of numbers.

Calling srand supplies the seed value for rand. If rand is called prior to
srand, the seed value is assumed to be !. Each seed value determines a particular
sequence of pseudo-random numbers; srand allows us to select which sequence
we want.

À program that always uses the same seed value will always get the same
sequence of numbers from rand. This property can sometimes be useful: the pro-
gram behaves the same way each time it’s run, making testing easier. However, we
usually want rand to produce a different sequence each time the program is run.
(AÀ poker-playing program that always deals the same cards isn’t likely to be popu-
lar.) The easiest way to “randomize” the seed values is to call the time function,
which returns a number that encodes the current date and time. Passing time’s
return value to srand makes the behavior of rand vary from one run to the next.
See the guess.c and guess2 .c programs (Section 10.2) for examples of this
technique.

***************************page_712***************************
PROGRAM

trand.c

26.2 The <stdlib.h> Header: General Utilities 687

Testing the Pseudo-Random Sequence Generation Functions

The following program displays the first five values returned by the rand func-
tion. then allows the user to choose a new seed value. The process repeats until the
user enters zero as the seed.

/* Tests the pseudo-random sequence generation functions */

#include <stdio.h>
#include <stdlib.h>

int main (void)

{

int i, seed;

printf ("This program displays the first five values of "
"rand.\n") ;

for (;;) |
for (i = O; i < 5; i++)
printf("%$d ", rand());
print£ ("\n\n") ;

printf ("Enter new seed value (0 to terminate) : ");
scanf ("%d", &seed) ;
L1f (seed == O)

break ;

srand (seed) ;

}

return 0;

Here’s how a session with the program might look:

This program displays the first five values of rand.
1804289383 8846930886 1681692777 1714636915 1957747793

Enter new seed value (0 to terminate) : 100
6777411240 6119111301 5166877479 1039653884 8070098556

Enter new seed value (O to terminate): 1
1804289383 8846930886 1681692777 1714636915 1957747793

Enter new seed value (0 to terminate): O

There are many ways to write the rand function, so there’s no guarantee that
every version of rand will generate the numbers shown here. Note that choosing l
as the seed gives the same sequence of numbers as not specifying the seed at all.

Communication with the Environment

void abort (void) ;
int atexit (void (*func) (void) ) ;

***************************page_713***************************
688 Chapter 26

Q

exit

atexit

_ Exit

signal function >24.3

abort

getenv

Miscellaneous Library Functions

void exit (int status) ;

void _Exit (int status) ;

char *getenv (const char *name) ;
int system(const char *string) ;

The functions in this group provide a simple interface to the operating system,
allowing programs to (1) terminate, either normally or abnormally, and return à
status code to the operaling system. (2) fetch information from the user’s environ-
ment, and (3) execute opcrating system commands. One of the functions, Exit,
is « C99 addition.

Pertorming the call exit (n) anywhere in a program is normally equivalent
to exceuting the stalement return n; in main: the program terminates. and n is
returned to the operating system as a status code. <stdlib.h> defines the mac-
ros EXIT_FAILURE and EXIT _SUCCESS. which can be used as arguments to
exit. The only other portable argument to exit is O, which has the same mcan-
Ing as EXIT_SUCCESS. Returning status codes other than these is legal but not
necessarily portable to all operating systems.

When a program terminates, it usually performs a few final actions behind the
scenes, including flushing output buffers that contain unwritten data, closing open
streams, and deleting temporary files. We may have other “clean-up” actions that
we'd like à program to perform at termination. The atexit function allows us to
“register” a function Lo be called upon program termination. To register à function
named cleanup, for example, we could call atexit as follows:

atexit (cleanup) ;

When we pass a function pointer to atexit, it stores the pointer away for future
reference. If the program later terminates normally (via a call of exit or a
return statement in the main function). any function registered with atexit
will be called automatically. (If two or more functions have been registered, they're
called in the reverse of the order in which they were registered.)

The _Exit function is similar to exit. However. Exit doesn't call func-
tions that have been registered with atexit, nor does it call any signal handlers
previously passed to the signal function. Also. _ Exit doesn't necessarily flush
output buffers, close open streams, or delete temporary files—whether these
actions are performed is implementation-defined.

abort 1s also similar to exit. but calling it causes abnormal program termi-
nation. Functions registered with atexit aren’t called. Depending on the imple-
mentation, it may be the case that output buffers containing unwritten data aren‘t
flushed, streams aren°t closed, and temporary files aren*t deleted. abort returns
an implementation-defined status code indicating unsuccessful termination.

Many operating systems provide an “environment”: a set of strings that
describe the user’s characteristics. These strings typically include the path to be
searched when the user runs a program. the type of the user's terminal (in the case
of à multi-user system), and so on. For example, a UNTX search path might look

***************************page_714***************************
system

bsearch

26.2 The <stdlib.h> Header: General Utilities 689

something like this:
PATH=/usr/local/bin:/bin:/usr/bin:.

getenv provides access to any string in the user’s environment. To find the cur-
rent value of the PATH string, For example, we could write

char *p = getenv ("PATH") ;

p now points to the string "/usr/l1ocal/bin:/bin:/usr/bin: .". Be care-
ful with getenv: it returns a pointer to a statically allocated string that may be
changed by a later call of the function.

The system function allows a C program to run another program (possibly
an operating system command). The argument to system is à string containing à
command, similar to one that we’d enter at the operating system prompt. For
example, suppose that we’re writing a program that needs a listing of the files in
the current directory. À UNIX program would call system in the following way:

system("1s >myfiles") ;

This call invokes the UNIX command 1s and asks it to write a listing of the cur-
rent directory into the file named myfiles.

The return value of system is implementation-defined. system typically
returns the termination status code from the program that we asked 1it to run; test-
ing this value allows us to check whether the program worked properly. Calling
system with a null pointer has à special meaning: the function returns à nonzero
value if a command processor 1s available.

Searching and Sorting Utilities

void *bsearch(const void *key, const void *base,
size t nmemb, size t size,
int (*compar) (const void *,
const void *));
void qsort (void *base, size t nmemb, size t size,
int (*compar) (const void *, const void *));

The bsearch function searches a sorted array for a particular value (the “’key”).
When bsearch is called, the key parameter points to the key, base points to the
array, nmemb is the number of elements in the array, size is the size of each ele-
ment (in bytes), and compar is a pointer to a comparison function. The compari-
son function is similar to the one required by qsort: when passed pointers to the
key and an array element (in that order). the function must return a negative, Zero,
or positive integer depending on whether the key is less than, equal to, or greater
than the array element. bsearch returns a pointer to an element that matches the
key: if it doesn’{ find a match, bsearch returns a null pointer.

***************************page_715***************************
690

Chapter 26  Miscellaneous Library Functions

qsort

PROGRAM

airmiles.c

Although the C standard doesn°t require it to, bsearch normally uses the
binary search algorithm to search the array. bsearch first compares the key with
the element in the middle of the array; if there’s a match, the function returns. If
the key 1s smaller than the middle element, bsearch limits its search to the first
half of the array; 1f the key is larger, bsearch searches only the last half of the
array. bsearch repeats this strategy until it finds the key or runs out of elements
to search. Thanks to this technique, bsearch is quite fast—searching an array of
1000 elements requires only 10 comparisons at most; searching an array of
1,000,000 elements requires no more than 20 comparisons.

Section 17.7 discusses the qsort function, which can sort any array.
bsearch works only for sorted arrays, but we can always use qsort to sort an
array prior to asking bsearch to search it.

Determining Air Mileage

Our next program computes the air mileage from New York City to various inter-
national cities. The program first asks the user to enter a city name, then displays
the mileage to that city:

Enter city name: Shanghai
Shanghai is 7371 miles from New York City.

The program will store city/mileage pairs in an array. By using bsearch to
search the array for a city name, the program can easily find the corresponding
mileage. (Mileages are from /nfoplease.com.)

/* Determines air mileage from New York to other cities */

#finclude <stdio.h>
#include <stdlib.h>
#include <string.h>

struct city _ info |
char *city;
int miles;

}7

int compare _cities (const void *key _ ptr,
const void *element ptr) ;

int main (void)
char city _name (81] ;
struct city info *ptr;
const struct city info mileage[] =

{{"Berlin", 3965}, {"Buenos Aires", 5297},
{"Cairo", 5602}, {"Calceutta", 7918},
{"Cape Town", 7764}, {"Caracas", 2132},
{"Chicago", 713}, {"Hong Kong", 8054 },
{"Honolulu", 4964}, {"Istanbul", 4975},

***************************page_716***************************
abs
labs

div

26.2 The <stdlib.h> Header: General Utilities 691

{"Lisbon", 3364}, {"London", 3458},
{"Los Angeles", 2451}, {"Manila", 8498},
{"Mexico City", 2094}, {"Montreal", 320},
{"Moscow", 4665}, {"Paris", 3624 },
{"Rio de Janeiro", 4817}, {"Rome", 4281},
{"San Francisco", 2571}, {"Shanghai", 7371},
{"Stockholm", 3924}, {"Sydney", 9933},
{"Tokyo", 6740}, {"Warsaw", 4344},
{"Washington", 205 } } ;

print£f ("Enter city name: ") ;

scan£ ("%80[*\n]", city name) ;

ptr = bsearch(city name, mileage,
sizeof (mileage) / sizeof (mileage [0]),
sizeof (mileage [0]), compare cities) ;
if (ptr != NULL)
print£("%s is %d miles from New York City.\n",
city name, ptr->miles) ;
else
print£("%s wasn't found.\n", city name) ;

return 0;

;

int compare _cities(const void *key ptr,
const void *element ptr)

return stromp((char *) key ptr,
((struct city info *) element ptr) ->city) ;
}

Integer Arithmetic Functions

int abs (int ]) ;
long int labs (long int y);
long long int llabs(long long int j);

div t div(int numer, int denom) ;
ldiv _ t ldiv(long int numer, long int denom) ;
lldiv t 11ldiv(long long int numer,

long long int denom) ;

The abs function returns the absolute value of an int value; the 1abs function
returns the absolute value of a long int value.

The div function divides its first argument by its second, returning a div t
value. div t 1s a structure that contains both a quotient member (named quot)
and a remainder member (rem). For example, if ans is a div t variable, we
could write

ans = div(5, 2);
print£ ("Quotient: %d Remainder: %d\n', ans.quot, ans.rem) ;

***************************page_717***************************
 

692

Chapter 26  Miscellaneous Library Functions

|div

Le F4 AN

Ilabs
Ildiv

æ

26.3

Table 26.1
Members of the
tm Structure

The 1div function is similar but works with long integers: it returns an 1div t
structure. which also has quot and rem members. (The div_ t and1div t types
are declared in <stdlib.h>.)

C99 provides two additional functions. The 11abs function returns the abso-
lute value of a long long int value. 11div 1s similar to div and 1div, except
that it divides two long long int values and returns an 11div t structure.
(The 11div t type was also added in C99.)

The <time.h> Header: Date and Time

The <time .h> header provides functions for determining the time (including the
date), performing arithmetic on time values, and formatting times for display.
Before we explore these functions, however, we need to discuss how times are
stored. <time .h> provides three types, each of which represents a different way
to store a time:

# clock t: À time value measured in “clock ticks.”
= time t: À compact, encoded time and date (a calendar time).

u struct tm: À time that has been divided into seconds. minutes. hours, and
so on. À value of type struct tm is often called a broken-down time. Table
26.1 shows the members of the tm structure. AIl members are of type int.

 

 

 

 

Minimuim — Maximum
Name Description Value Value
tm_sec Seconds after the minute 0 61*
tm_min Minutes after the hour 0 59
tm_hour Hours since midnight 0 23
tm_mday Day of the month l 31
tm_mon Months since January 0 |l
tm year Years since 1900 0 —
tm_wday Days since Sunday 0 6
tm_yday Days since January | 0 365
tm_isdst = Daylight Saving Time flag r ri

 

* Allows for two extra ‘’leap seconds.” In C99, the maximum value 1s 60.
*Positive if Dayhight Saving Time is in effect, zero if it's not in effect, and
negative if this information 1s unknown.

These Lypes are used for different purposes. À clock_t value is good only
for representing a time duration; time_t and struct tm values can store an
entire date and time. time t values are tightly encoded, so they occupy little
space. struct tm values require much more space, but they’re often easier Lo
work with. The C standard states that clock_t and time_t must be “’arithmetic
types, ‘ but leaves it at that. We don’t even know if clock_t and time_ t values
are stored as integers or floating-point numbers.

We're now ready to look at the functions in <time.h>. which fall into two
groups: time manipulation functions and time conversion funcetions.

***************************page_718***************************
clock

time

26.3  The <time.h> Header: Date and Time 693

Time Manipulation Functions

clock t clock (void) ;

double difftime (time t timel, time t timeO);
time t mktime(struct tm *timeptr) ;

time t time(time t *timer) ;

The clock function returns a clock t value representing the processor time
used by the program since execution began. To convert this value to seconds, we
can divide it by CLOCKS PER SEC, a macro defined in <time.h>.

When clock is used to determine how long a program has been running, il°s
customary to call it twice: once at the beginning of main and once just before the
program terminates:

#include <stdio.h>
#Hinclude <time.h>

int main(void)

(

clock t start_clock = clock();

printf ("Processor time used: %g sec.\n",
(clock() - start clock) / (double) CLOCKS PER _ SEC) ;
return 0;

}

The reason for the initial call of clock is that the program will use some proces-
sor time before it reaches main, thanks to hidden “start-up” code. Calling clock
at the beginning of main determines how much time the start-up code requires so
that we can subtract it later.

The C89 standard says only that clock t is an arithmetic type; the type of
CLOCKS PER SEC is unspecified. As a result, the type of the expression

(clock() - start clock) / CLOCKS PER SEC

may vary from one implementation to another, making it difficult to display using
print£. To solve the problem. our example converts CLOCKS_PER SEC lo
double, forcing the entirc expression to have type double. In C99, the type of
CLOCKS PER SEC is specified to be clock_t. but clock_t is still an imple-
mentation-defined type.

The time function returns the current calendar time. If its argument isn't a
null pointer, time also stores the calendar time in the object that the argument
points to. time’s ability to return a time in two different ways is an historical
quirk, but it gives us the option of writing either

l

cur_time time (NULL) ;

OT

***************************page_719***************************
694

Chapter 26 Miscellaneous Library Functions

difftime

mktime

time (&cur time) ;

where cur_time is à variable of type time t.

The difftime function returns the difference between t imeo (the earlier
time) and timel, measured in seconds. Thus, to compute the actual running time
of a program (not the processor time). we could use the following code:

#Hinclude <stdio.h>
#include <time.h>

int main(void)

{

time_t start _ time = time (NULL) ;

print£ ("Running time: %g sec.\n",
difftime (time (NULL), start_time));
return 0;

}

The mktime function converts a broken-down time (stored in the structure
that its argument points to) into a calendar time, which it then returns. As a side
effect, mktime adjusts the members of the structure according to the following
rules:

= mktime changes any members whose values aren’t within their legal ranges
(see Table 26.1). Those alterations may in turn require changes to other mem-
bers. If tm_sec is too large, for example, mktime reduces it to the proper
range (0-59), adding the extra minutes to tm_min. If tm_min is now too
large, mkt ime reduces it and adds the extra hours to tm_hour. If necessary,
the process will continue to the tm_mday, tm_mon. and tm_year mem-
bers.

u After adjusting the other members of the structure (if necessary), mktime
sets tm_wday (day of the week) and tm_yday (day of the year) to their cor-
rect values. There’s never any need to initialize the values of tm_wday and
tm_yday before calling mktime; it ignores the original values of these
members.

mktime's ability to adjust the members of a tm structure makes it useful for
time-related arithmetic. As a example, let’s use mktime to answer the following
question: If the 2012 Olympics begin on July 27 and end 16 days later. what is the
ending date? We'Il start by storing July 27, 2012 in a tm structure:

struct tm t;

t.tm mday = 27;
t.tm mon = 6; /* July */
t.tm year = 112; /* 2012 */

We'Il also initialize the other members of the structure (except tm_wday and
tm_yday) to ensure that they don’t contain undefined values that could affect the
answer:

***************************page_720***************************
26.3  The <time.h> Header: Date and Time 695

t.tm sec = Q0;
t.tm min = 0;
t.tm hour = 0;
t.tm isdst = -l;

Next, we’Il add 16 to the tm_mday member:
t.tm mday += 16;

That leaves 43 in tm_mday, which is out of range for that member. Calling
mktime will bring the members of the structure back into their proper ranges:

mktime (&t) ;

We'Il discard mkt ime’s return value, since we're interested only in the function's
effect on t. The relevant members of t now have the following values:

Member Value Meaning
tm_mday 12 12
tm_mon 7 August
tm_year 112 2012
tm_wday 0 Sunday

tm_yday 224 225th day of the year

Time Conversion Functions

char *asctime (const struct tm *timeptr) ;

char *ctime (const time t *timer) ;

struct tm *gmtime (const time t *timer) ;

struct tm *localtime (const time t *timer) ;

size t strftime(char * restrict s, size t maxsize,
const char * restrict format,
const struct tm * restrict timeptr) ;

The time conversion functions make it possible to convert calendar times to bro-
ken-down times. They can also convert times (calendar or broken-down) to string
form. The following figure shows how these functions are related:

 

   
           

 

<— Mktime
Calendar time - }L——4/ Broken-down time
time_t gmtime struct tm
\ localtime

ctin\ asctime strftime
. A #

{ Character string

 

***************************page_721***************************
696 Chapter 26  Miscellaneous Library Functions

gmtime
localtime

QaA

asctime

ctime

strftime

sprintf function »22.8

locales » 25.1

e 8

The figure includes the mktime function, which the C standard classifies as a
“manipulation” function rather than a “conversion” function.

The gmtime and 1ocaltime fUunctions are similar. When passed a pointer
to a calendar time, both return a pointer to a structure containing the equivalent
broken-down time. localtime produces a local time, while gmt ime's return
value is expressed in UTC (Coordinated Universal Time). The return value of
gmtime and localtime points to a statically allocated structure that may be
changed by a later call of either function.

The asctime (ASCII time) function returns a pointer to a null-terminated
string of the form

Sun Jun 3 17:48:34 2007\n

constructed from the broken-down time pointed to by its argument.
The ctime function returns a pointer Lo à string describing a local time. If

cur_time 1s a variable of type time t, the call
ctime (&cur time)

is equivalent to

asctime (localtime (Scur time))

The return value of asctime and ctime points to à statically allocated string
that may be changed by a later call of either function.

The strftime function, like the asctime function, converts a broken-
down time to string form. Unlike asctime., however, it gives us a great deal of
control over how the time is formatted. In fact, str£ftime resembles sprintf
in that it writes characters into a string s (the first argument) according to a for-
mat string (the third argument). The format string may contain ordinary characters
(which are copied into s unchanged) along with the conversion specifiers shown
in Table 26.2 (which are replaced by the indicated strings). The last argument
points to a tm structure, which is used as the source of date and time information.
The second argument 1s a limit on the number of characters that can be stored in
s.

The str£time function, unlike the other functions in <time .h>, is sensi-
tive to the current locale. Changing the LC TIME category may affeet the behav-
jor of the conversion specifiers. The examples in Table 26.2 are strictly For the " C"
locale; in a German locale, the replacement for %A might be Dienstag instead of
Tuesday.

The C99 standard spells out the exact replacement strings for some of the con-
version specifiers in the "C" localc. (C89 didn't go into this level of detail.) Table
26.3 lists these conversion specifiers and the strings they’re replaced by.

C99 also adds a number of str£time conversion specifiers. as Table 26.2
shows. One of the reasons for the additional conversion specifiers is the desire to
support the ISO 8601 standard.

***************************page_722***************************
Table 26.2
Conversion Specifiers for
the str£ftime Function

Table 26.3
Replacement Strings for
str£time Conversion

Specifiers in the
"C" Locale

26.3  The <time.h> Header: Date and Time

697

 

Conversion

Replacement

 

 

 

 

 

sa Abbreviated weekday name (e.g., Sun)
SA Full weekday name (e.g… Sunday)
%b Abbreviated month name (e.e…. Jun)
=B Full month name (e.g., June)
$c Complete day and time (e.g.…. Sun Jun 3 17:48:34 2007)
20 Year divided by 100 and truncated to an integer (00—-99)
sd Day of month (01—31)
%D" Equivalent to 3m/*d/%y
ze* Day of month (1—31): à single digit is preceded by a space
SF! Equivalent to SY-%4m-%$d
sg' Last two digits of ISO 5601 week-based year (00—99)
&G' JSO 8601 weck-based year
sh' Equivalent to b
sH Hour on 24-hour clock (00—23)
“I Hour on 12-hour clock (01—12)
3j Day of year (001—366)
=m Month (01-12)
SM Minute (00-59)
an' New-line character
sp AM/PM designator (AM or PM)
%r" |2-hour clock time (e.g.. 05:48:34 PM)
sR* Equivalent to $H : 3M
$s Second (00—61): maximum value in C99 1s 60
st* Horizontal-tab character
ST" Equivalent to SH: $M : $S
u! ISO 8601 weekday (1-7); Monday is !
SU Week number (00—53): first Sunday 1s beginning of week 1
sv' [ISO 8601 week number (01-53)
sw Weekday (0-6): Sunday 1s O
sW Week number (00—53): first Monday 1s beginning of week 1
=x Complete date (e.g., 06/03/07)
=X Complete time (e.g.. 17 : 48 : 34)
Sy Last two digits of year (00—99)
=Y Year
sz! Offset from UTC in ISO 8601 format (e.g.. -0530 or +0200)
s2 Time zone name or abbreviation (e.g.. EST)
% 3
*C99 only
Conversion Replacement
sa First three characters of $A
SA One of "Sunday". "Monday". …, "Saturday"
b First three characters of %B
sB One ol "January", "February", …. "December"
sC Equivalent to "5a %b %e %T %Y"
sp Onc of "AM" or " PM"
$r Equivalent to "5I:$M:5S %p"
*x Equivalent to "3m/%d/3y"
X Equivalent to $T
sZ Implementation-defined

 

 

 

 

 

***************************page_723***************************
698

Chapter 26  Miscellaneous Library Functions

PROGRAM

 

 

ISO 8601

ISO 8601 is an international standard that describes ways of representing dates
and times. Ît was originally published in 1988 and later updated in 2000 and 2004.
According to this standard, dates and times are entirely numeric (i.e., months are
not represented by names) and hours are expressed using the 24-hour clock.

There are a number of ISO 8601 date and time formats, some of which are
directly supported by strftime conversion specifiers in C99. The primary ISO
8601 date format (YYYY-MM-DD) and the primary time format (hh:mm:ss) corre-
spond to the %F and %T conversion specifiers, respectively.

ISO 8601 has a system of numbering the weeks of a year; this system is sup-
ported by the %g, G, and %V conversion specifiers. Weeks begin on Monday, and
week 1 is the week containing the first Thursday of the year. Consequently, the first
few days of January (as many as three) may belong to the last week of the previous
year. For example, consider the calendar for January 2011:

January 2011

 

 

Mo  Tu We Th Fr Sa Su Year — Week
l 2 2010 52
3 4 5 6 7 8 9 2011 l
K [l 12 1 |I4 15 16 2011 2
17 18 9 20 21 22 23 2011 3
24 25 26 27 28 29 30 2011 4
31 2011 5

 

 

 

January 6 is the first Thursday of the year, so the week of January 3—9 is week 1.
January 1 and January 2 belong to the last week (week 52) of the previous year. For
these two dates, strftime will replace %g by 10, %G by 2010, and %V by 52. Note
that the last few days of December will sometimes belong to week 1 of the foilowing
year, this happens whenever December 29, 30, or 31 is a Monday.

The %z conversion specifier corresponds to the ISO 8601 time zone specifica-
tion: —hhmm means that a time zone is hh hours and mm minutes behind UTC; the
string +hhmm indicates the amount by which a time zone is ahead of UTC.

 

 

C99 allows the use of an E or O character to modify the meaning of certain
strftime conversion specifiers. Conversion specifiers that begin with an E or O
modifier cause à replacement to be performed using an alternative format that
depends on the current locale. If an alternative representation doesn’t exist in the
current locale, the modifier has no effect. (In the "C" locale, E and O are ignored.)
Table 26.4 lists all conversion spcecifiers that are allowed to have E or O modifiers.

Displaying the Date and Time

Let’s say we need a program that displays the current date and time. The program's
first step, of course, is to call the time function to obtain the calendar time. The

***************************page_724***************************
Table 26.4

E- and O-Modified
Conversion Specifiers
for the strftime

Function (C99 only)

26.3  The <time. h> Header: Date and Time 699

 

Conversion Replacement

 

Alternative date and time representation

Name of base year (period) in alternative representation

Alternative date representation

Alternative time representation

Offset from %EC (ycar only) in alternative representation

Full alternative year representation

Day of month, using alternative numeric symbols (filled with leading
zeros or with leading spaces 1f there is no alternative symbol for zero)

d d d Æ d P 0
O & 6l t3 d 0 0j
«x no

Q <<

 

sOe Day of month, using alternative numeric symbols (filled with leading
spaces)

sOH Hour on 24-hour clock, using alternative numeric symbols

OI Hour on 12-hour clock, using alternative numeric symbols

sOm Month. using alternative numeric symbols

OM Minute, using alternative numeric symbols

3OS Second, using alternative numeric symbols

sou ISO 8601 weekday as a number in alternative representation,
where Monday is l

OU Week number. using alternative numeric symbols

sOV ISO 8601 week number, using alternative numeric symbols

sOw Weekday as a number, using alternative numeric symbols

OW Week number, using alternative numeric symbols

sOy Last two digits of year, using alternative numeric symbols

 

second step 1s to convert the time Lo string form and print it. The easiest way to do
the second step is to call ctime, which returns a pointer to à string containing à
date and time, then pass this pointer to puts or printé£.

So far, so good. But what if we want the program to display the date and time
in a particular way? Let’s assume that we need the following format, where O6 is
the month and 03 1s the day of the month:

06-03-2007 = 5:48p

The ctime function always uses the same format for the date and time, so it’s no
help. The strftime function is better: using it, we can almost achieve the
appearance that we want. Unfortunately, str£time won't let us display a one-
digit hour without a leading zero. Also, str£time uses AM and PM instead of a
and p.

When strftime isn’t good enough, we have another alternative: convert the
calendar time to a broken-down time, then extract the relevant information from
the tm structure and format it ourselves using printf£ or a similar function. We
might even use str£time to do some of the formatting before having other func-
tions complete the job.

The following program Illustrates the options. It displays the current date and
time in three formats: the one used by ct ime, one close to what we want (created
using strftime), and the desired format (created using print£). The ctime
version 1s easy to do, the str£time version is a little harder, and the printf
version 1s the most difficult.

***************************page_725***************************
700

Chapier 26  Miscellaneous Library Functions

datetime.c

/* Displays the current date and time in three formats */

Hinclude <stdio.h>
#include <time.h>

int main(void)
{
time t current = time (NULL) ;
struct tm *ptr;
char date time (21] ;
int hour;
char am or pm;

/* Print date and time in default format */
puts (ctime (&current) ) ;

/* Print date and time, using strftime to format */
strf£ftime (date time, sizeof (date time),

"5m-5d-Y “I:%MSp\n", localtime (&current) ) ;
puts (date _time) ;

/* Print date and time, using printf to format */
ptr = localtime (&current ) ;
hour = ptr->tm hour;
if (hour <= 11)
am_or _ pm = 'a';
else {
hour -= 12;
am _ or_pm = 'p';
}
1if (hour == O)
hour = 12;
print£f("%.2d-%.2d-%d %2d:%.2d%c\n", ptr->tm mon + 1,
ptr->tm mday, ptr->tm year + 1900, hour,
ptr->tm min, am or pm) ;

return O0;

The output of datetime. c will have the following appearance:

Sun Jun 3 17:48:34 2007
06-03-2007  05:48PM

06-03-2007  5:48p

Q & À

Although <stdlib.h> provides a number of functions that convert strings
to numbers, there don’t appear to be any functions that convert numbers to
strings. What gives?

***************************page_726***************************
sprintéf function »22.8

nan function » 23.4

“Q:

À:

automatic storage duration » 78.2

setvbu£f function »22.2

æ

Q & À 701

Some C libraries supply functions with names like itoa that convert numbers to
strings. Using these functions isn‘t a great idea, though: they aren’t part of the C
standard and won’t be portable. The best way to perform this kind of conversion is
to call a function such as sprint£ that writes formatted output into a string:

char str (20];
int i;

sprintf (str, "%d", i); /* writes i into the string str */

Not only is sprint£ portable, but it also provides a great deal of control over the
appearance of the number.

The description of the strtod function says that C99 allows the string argu-
ment to contain a hexadecimal floating-point number, infinity, or NaN. What
Is the format of these numibers? [p. 684]

À hexadecimal floating-point number begins with Ox or OX, followed by one or
more hexadecimal digits (possibly including a decimal-point character). and then
possibly a binary exponent. (See the O&A at the end of Chapter 7 for a discus-
sion of hexadecimal floating constants, which have a similar—but not identical—
format.) Infinity has the form INF or INFINITY: any or all of the letters may be
lower-case. NaN 1s represented by the string NAN (again ignoring case). possibly
followed by a pair of parentheses. The parentheses may be empty or they may
contain a series of characters, where each character is a letter, digit, or under-
score. The characters may be used to specify some of the bits in the binary repre-
sentation of the NaN value, but their exact meaning is implementation-defined.
The same kind of character sequence—which the C99 standard calls an n-char-
sequence—is also used 1n calls of the nan function.

 

You said that performing the call exit (7) anywhere in a program is nor-
mally equivalent to executing the statement return ; inmain. When would
it not be equivalent? [p. 688])

There are two issues. First. when the main function returns, the lifetime of its
local variables ends (assuming that they have automatic storage duration. as they
will unless they‘re declared to be static). which isn°t true if the exit function
is called. À problem will occur if any action that takes place at program termina-
tton—such as calling a function previously registered using atexit or flushing
an output stream buffer—requires access to one of these variables. In particular, à
program might have called setvbuf and used one of main’s variables as a
buffer. Thus, in rare cases a program may behave improperly if it attempts to return
from main but work if it calls exit instead.

The other issue occurs only in C99. which makes it legal for main to have a
return type other than int 1f an implementation explicitly allows the programmer
to do so. In these circumstances, the call exit (n) isn’t necessarily equivalent to
executing return n; in main. In fact, the statement return n; may be illegal
((f main is declared to return void, for example).

***************************page_727***************************
702

Section 26.1 1.

Chapter26  Miscellaneous Library Functions

A:
signal function »>24.3

longjmp function > 24.4

> &

Is there a relationship between the abort function and SIGABRT signal? [p.
688]

Yes. À call of abort actually raises the SIGABRT signal. If there’s no handler for
SIGABRT, the program terminates abnormally as described in Section 26.2. If à
handler has been installed for SIGABRT (by a call of the signal function), the
handler is called. If the handler returns, the programn then terminates abnormally.
However. if the handler doesn’t return (it calls longjmp, for example), then the
program doesn°’t terminate.

Why do the div and 1div functions exist? Can’t we just use the / and %
operators? [p. 692]

div and ldiv aren’t quite the same as / and %. Recall from Section 4.1 that
applying / and % lo negative operands doesn’t give à portable result in C89. If i or
j is negative, whether the value of i / j is rounded up or down is implementation-
defined, as 1s the sign of i % j. The answers computed by div and 1div, on the
other hand, don’'t depend on the implementation. The quotient 1s rounded toward
Zzero: the remainder is computed according to the formula n = q x d + r, where n 1s
the original number, @ is the quotient, d is the divisor, and r 1s the remainder. Here
are a few examples:

n d q ï

—- 3 2 -l
In C99, the / and % operators are guaranteed to produce the same result as div
and 1ldiv.

Efficiency 1s the other reason that div and 1div exist. Many machines have
an instruction that can compute both the quotient and remainder, so calling div or
1div may be faster than using the / and % operators separately.

Where does the name of the gmtime function come from? [p. 696]

The name gmt ime stands for Greenwich Mean Time (GMT), referring to the local
(solar) time at the Royal Observatory in Greenwich, England. In 1884, GMT was
adopted as an international reference time, with other time zones expressed as
hours “behind GMT” or ‘’ahead of GMT. In 1972, Coordinated Universal Time
(UTC)—a system based on atomic clocks rather than solar observations—replaced
GMT as the international time reference. By adding a “leap second” once every
few years, UTC 1s kept synchronized with GMT to within 0.9 second. so for all but
the most precise time measurements the two systems are identical.

Exercises

Rewrite the max_int function so that, instead of passing the number of integers as the first
argument, we must supply O as the last argument. Hint: max_int must have at least onc

***************************page_728***************************
Section 26.2

Qn

® 7.

@ °
10.

Exercises 703

“normal” parameter, so you can’”t remove the parameter n. Instead, assume that !t represents
one of the numbers to be compared.

Write a simplified version of printf in which the only conversion specification 1s 3d, and
all arguments after the first are assumed to have int type. If the function encounters à %
character that’s not immediately followed by a d character, 1t should ignore both characters.
The function should use calls of putchar to produce all output. You may assume that the
format string doesn’t contain escape sequences.

Extend the function of Exercise 2 so that it allows two conversion specifications: %d and
%s. Each %d in the format string indicates an int argument, and each %s indicates a char
* (string) areument.

Write a function named display that takes any number of arguments. The first argument
must be an integer. The remaining arguments will be strings. The first argument specifies
how many strings the call contains. The function will print the strings on a single line, with
adjacent strings separated by one space. For example, the call

display(4, "Special", "Agent", "Dale", "Cooper") ;
will produce the following output:

Special Agent Dale Cooper

Write the following funetion:
char *vstrcat (const char *first, ...):

AIl arguments of vstrcat are assumed to be strings, except for the last argument, which
must be a null pointer (cast to char * type). The function returns a pointer to a dynamically
allocated string containing the concatenation of the arguments. vstrcat should return a
null pointer if not enough memory 1s available. Hirr: Have vstrcat go through the argu-
ments twice: once to determine the amount of memory required for the returned string and
once to copy the arguments Into the string.

Write the following function:
char *max pair(int num pairs, ...);

The arguments of max_pair are assumed to be “pairs” of integers and strings: the value of
num_pairs indicates how many pairs will follow. (À pair consists of an int argument
followed by a char * argument). The function scarches the integers to find the largest one;
it then returns the string argument that follows 1t. Consider the following call:

max _ pair(5, 180, "Seinfeld", 180, "I Love Lucy",
39, "The Honeymooners", 210, "Al] in the Family",
86, "The Sopranos")

The largest int argument is 210, so the function returns "A11 in the Family". which
follows it in the argument list.

Explain the meaning of the following statement, assuming that value 1s à variable of type
long int and p 1S à varitable of type char *:

value = strtol(p, &p, 10);
Write à statement that randomly assigns one of the numbers 7, 11,15, or 19 to the variable n.
Write a function that returns a random double value d in the range 0.0 <d<1.0.

Convert the following calls of atoi, atol, and atoll into calls of strtol, strtol,
and strtoll, respectively.

***************************page_729***************************
704 Chapter 26 Miscellaneous Library Functions

|l.

Section 26.3 | 2.

1 3.

»

(a) atoi (str)
(b) atol (str)
(c) atoll(str)

Although the bsearch function is normally used with a sorted array, it will sometimes
work correctly with an array that is only partially sorted. What condition must an array sat-
isfy to guarantee that bsearch works properly for a particular key? Hint: The answer
appears in the C standard.

Write a function that. when passed a year, returns à time_t valuc representing 12:00 a.m.
on the first day of that year.

Section 26.3 described some of the ISO 8601 date and time formats. Here are a few more:

(a) Yeur followed by day of yeur: YYYY-DDD, where DDD is a number between 001 and
366

(b) Year. weck, and day of week: YYYY—Wiwwwr—D, wherce ww is a number between 01 and
53. and D is a digit betwcen | through 7, beginning with Monday and ending with Sun-
day

(c) Combined date and time: "YYY-MM-DDThh:inm:ss

Give strftime strines that correspond to cach of these formats.

Programming Projects

(a) Write à program that calls the rand function 1000 times, printing the low-order bit of
each value it returns (O 1f the return value is even, 1 if itl’s odd). Do you see any patterms?
(Often, the last few bits of rand's return value aren’t especially random.)

(b) How can we improve the randomness of rand for generating numbers within a small
range?

Write a program that tests the atexit l'unction. The program should have two functions
(in addition to main), one of which prints That 's all, and the other fo1lks !. Use the
atexit function to register both to be called at program termination. Make sure they're
called in the proper order, so that we see the message That's all, folks! on the
scrèen.

Write a program that uses the clock function to measure how long it takes qsort to sort
an array of 1000 integers that are originally in reverse order. Run the program for arrays of
10000 and 100000 Integers as well.

Write a program that prompts the user For a date (month, day, and year) and an integer n,
then prints the date that's n days later.

Write a program that prompts the user to enter two dates, then prints the difference between
them, measured in days. Hint: Use the mktime and difftime functions.

Write programs that display the current date and time in each of the following formats. Use
strftime to do all or most of the formattine.

(a) Sunday, June 3, 2007 05:48p
(b) Sun, 3 Jun 07 17:48
(c) 06/03/07 5:48:34 PM

***************************page_730***************************
21

271

 

Additional C99 Support for
Mathematics

Simplicity does not precede complexity, but follows it.

This chapter completes our coverage of the standard library by describing five
headers that are new in C99. These headers. like some of the older ones, provide
support for working with numbers. However. the new headers are more specialized
than the old ones. Some of them will appeal primarily to engineers, scientists, and
mathematicians, who may need complex numbers as well as greater control over
the representation of numbers and the way foating-point arithmetic is performed.

The first two sections discuss headers related to the integer types. The
<stdint .h> header (Section 27.1) declares integer types that have a specified
number of bits. The <inttypes .h> header (Section 27.2) provides macros that
are useful for reading and writing values of the <stdint .h> types.

The next two sections describe C99’s support for complex numbers. Section
2°1.3 includes a review of complex numbers as well as a discussion of C99's com-
plex types. Section 27.4 then covers the <complex.h> header, which supplies
l'unctions that perform mathematical operations on complex numbers.

The headers discussed in the last two sections are related to the fFloating types.
The <tgmath .h> header (Section 27.5) provides type-generic macros that make
it easier to call library functions in <complex.h> and <math.h>. The fune-
tions in the <fenv.h> header (Section 27.6) give programs access to floating-
point status flags and control modes.

The <stdint .h> Header (C99): Integer Types

The <stdint .h> header declares integer types containing a specified number
of bits. In addition, it defines macros that represent the minimum and maxi-
mum values of these types as well as of integer types declared in other headers.

705

***************************page_731***************************
 

706 Chapter 27  Additional C99 Support for Mathematics

<limits .h> header »23.2

sign bit >7.!

(These macros augment the ones in the <limits.h> header.) <stdint .h>
also defines parameterized macros that construct integer constants with specific
types. There are no functions in <stdint .h>.

The primary motivation for the <stdint .h> header lies in an observation
made in Section 7.5, which discussed the role of type definitions in making pro-
grams portable. For example, if i is an int variable, the assignment

i = 100000;

is fine if int is a 32-bit type but will fail if int is a 16-bit type. The problem is
that the C standard doesn’t specify exactly how many bits an int value has. The
standard does guarantee that the values of the int type must include all numbers
between —32767 and +32767 (which requires at least 16 bits), but that’s all it has to
say on the matter. In the case of the variable i, which needs to be able to store
100000, the traditional solution is to declare i to be of some type T, where T Is a
type name created using typede£. The declaration of T can then be adjusted
based on the sizes of integers in a particular implementation. (On a 16-bit machine,
T would need to be 1long int, but on a 32-bit machine, it can be int.) This 1s the
strategy that Section 7.5 discusses.

If your compiler supports C99, there’s à better technique. The <stdint .h>
header declares names for types based on the width of the type (the number of bits
used to store values of the type, including the sign bit, if any). The typedef
names declared in <stdint .h> may refer to basic types (such as int, un-
signed int, and long int) or to extended integer types that are supported by a
particular implementation.

<stdint .h> Types

The types declared in <stdint .h> fall into five groups:

u Exact-width integer types. Each name of the form intN t represents a
signed integer type with N bits, stored in two’s-complement form. (Two's
complement, a technique used to represent signed integers in binary. is nearly
universal among modern computers.) For example, a value of type int16_t
would be a 16-bit signed integer. A name of the form uint/NV_ t represents an
unsigned integer type with N bits. An implementation is required to provide
both intN t anduintN t for N=8, 16, 32, and 64 if it supports integers
with these widths.

n Minimum-width integer types. Each name of the form int_least/N £ rep-
resents a signed integer type with at least N bits. À name of the form
uint least/N t represents an unsigned integer type with N or more bits.
<stdint .h> is required to provide at least the following minimum-width
types:
int least8 t uint least8_t
int leastl6 t uint least16 t

***************************page_732***************************
27.i  The <stdint .h> Header (C99): Integer Types 707

int least32 t uint least32 t
int _ least64 t uint least64 t

u Fastest mininmum-width integer types. Each name of the form
int_fast/N t represents the fastest signed integer type with at least N bits.
(The meaning of “fastest” is up to the implementation. If there‘s no reason to
classify a particular type as the fastest, the implementation may choose any
signed integer type with at least N bits.) Each name of the form
uint fast/N t represents the fastest unsigned integer type with N or more
bits. <stdint .h> is required to provide at least the Following fastest mini-
mum-width types:

int _ fast8 t uint fast8 t

int fast16 t uint fasti6 t
int fast32 t uint fast32 t
int fast64 t uint fast64 t

u Integer types capable of holding object pointers. The intptr t type repre-
sents a signed integer type that can safely store any void * value. More pre-
cisely, if a void * pointer is converted to intptr t type and then back to
void *, the resulting pointer and the original pointer will compare equal. The
uintptr _ t type is an unsigned integer type with the same property as
intptr _t. The <stdint .h> header isn’t required to provide either type.

= Greatest-width integer types. intmax t is a signed integer type that
includes alt values that belong to any signed integer type. uintmax t is an
unsigned integer type that includes alt values that belong to any unsigned inte-
ger type. <stdint .h> is required to provide both types, which might be
wider than long long int.

The names in the first three groups are declared using typedef.

An implementation may provide exact-width integer types, minimum-width
integer types, and fastest minimum-width integer types for values of N in addition
to the ones listed above. Also, N isn’t required to be a power of 2 (although it will
normally be a multiple of 8). For example, an implementation might provide types
named int24 t anduint24 t.

Limits of Specified-Width Integer Types

For each signed integer type declared in <stdint .h>, the header defines macros
that specify the type’s minimum and maximum values. For each unsigned integer
type, <stdint .h> defines a macro that specifies the type's maximum value. The
first three rows of Table 27.1 show the values of these macros for the exact-width
integer types. The remaining rows show the constraints imposed by the C99 stan-
dard on the minimum and maximum values of the other <stdint . h> types. (The
precise values of these macros are implementation-defined.) All macros in the
table represent constant expressions.

***************************page_733***************************
708

Table 271
<stdint .h> Limit
Macros for Specified-
Width Integer Types

<stddef .h> header »21.4
<signal .h> header » 24.3

<wchar .h> header » 25.5

integer constants > 7.1

integer promotions » 7.4

Chapter27  Additional C99 Support for Mathematics

 

 

 

 

 

 

Name Value Description
INTN _ MIN —(29")  Minimum intW t value
INTN _MAX 25111 Maximum intN t value
UINTN _ MAX 2"-1  Maximum uintN t value
INT LEASTN MIN — <—(2""—I) Minimum int_leastW t value
INT_LEASTN MAX 229111 Muximum int leastN t value
UINT LEASTN MAX >2Y_1 Maximum uint least/M t value
INT FASTN MIN <-(2""_1)  Minimum int_fastN t value
INT _ FASTN MAX 22%!_1 Maximum int fastN t value
UINT FASTN MAX 22W_]  Maximum uint_fastN t value
INTPTR MIN <—(2'°—1)  Minimum intptr_t value
INTPTR MAX 225_1 Maximum intptr_t value
UINTPTR MAX >2'°_1  Maximum uintptr_t value
INTMAX MIN <—(2°_1)  Minimum intmax t value
INTMAX MAX 2293_}  Maximum intmax_t value
UINTMAX MAX 22°—|  Maximum uintmax_t value

 

 

 

Limits of Other Integer Types

When the C99 committee created the <stdint .h> header, they decided that 1t
would be a good place to put macros describing the limits of integer types besides
the ones declared in <stdint .h> itself. These types are ptrdif£f t,size t.
and wchar_t (which belong to <stddef .h>). sig_atomic_t (declared in
<signal .h>), and wint t (declared in <wchar .h>). Table 27.2 lists these
macros and shows the value of each (or any constraints on the value imposed by
the C99 standard). In some cases, the constraints on the minimum and maximum
values of a type depend on whether the type is signed or unsigned. The macros in
Table 27.2, like the ones in Table 27.1, represent constant expressions.

Macros for Integer Constants

The <stdint .h> header also provides function-like macros thar are able to con-
vert an integer constant (expressed in decimal, octal, or hexadecimal, but without a
U and/or L suffix) into a constant expression belonging to a minimum-width inte-
ger type or greatest-width integer type.

For each int leastN t lype declared in <stdint .h>, the header
defines a parameterized macro named INTN C that converts an integer constant to
this type (possibly using the integer promotions). For each uint _ leastW t
type, there’s a similar parameterized macro named UINTN C. These macros are
useful for initializing variables, among other things. For example. 1f à is a variable
oftype int _ least32 t. writing

***************************page_734***************************
Table 27.2
<stdint .h> Limit
Macros for Other
Integer Types

217.2

QaÂÀ

 

 

27.2 The <inttypes.h> Header (C99) 709
Name Value Description
PTRDIFF MIN <—65535 Minimum ptrdif£_t value
PTRDIFF MAX >+65535 Maximum ptrdif£f t value

 

<—127 (if signed)
O (if unsigned)

>+127 (if signed)

2255 (if unsigned)

SIG _ ATOMIC MIN Minimum sig_atomic_t value

SIG ATOMIC _MAX Maximum sig_atomic_t valué

 

 

 

 

 

 

SIZE MAX 265535 Maximum size_ t value
<127 (if sivne
WCHAR MIN s-127 (Ïr.blg'ÏCd) Minimum wchar t value
-— O (if unsigned) —
z+127 (if signed) ue u
WCHAR MAX >255 (if unsigned) Maximum wchar_t value
<—32 1f sione ‘ Û
WINT MIN <-32767 (Ï[,5'°IÏLd) Minimum wint t value
— O (if unsigned) _
>+32767 (if signed) 5 , ,Ç
WINT MAX >65535 (if unsigned) Maximum wint_ t value
i = 100000;

is problematic, because the constant 100000 might be too large to represent using
type int (if int is a 16-bit type). However, the statement
i = INT32 C(100000) ;
is safe. f int least32_t represents the int type, then INT32_C(100000)
has type int. But if int least32 t corresponds to long int. then
INT32 _ C(100000) has type long int.

<stdint .h> has two other parameterized macros. INTMAX C converts an
integer constant to type intmax_t, and UINTMAX C converts an integer con-
stant to type uintmax t.

The <inttypes.h> Header (C99)
Format Conversion of Integer Types

The <inttypes .h> header is closely related to the <stdint .h> header, the
topic of Section 27.1. In fact, <inttypes .h> includes <stdint .h>, so pro-
erams that include <inttypes .h> don’t need to include <stdint .h> as well.
The <inttypes. h> hcader extends <stdint .h> in two ways. First, it defines
macros that can be used in .print f and .…scanf£ format strings for inpuVoutput
of the integer types declared in <stdint .h>. Second, it provides functions for
working with greatest-width integers.

***************************page_735***************************
710

Chapter 27  Additional C99 Support for Mathematics

Macros for Format Specifiers

The types declared in the <stdint .h> header can be used to make programs more
portable, but they create new headaches for the programmer. Consider the problem
of displaying the value of the variable i, where i has type int_least32_£. The
statement

printf("i = %d\n", i);

may not work, because i doesn’t necessarily have int type. [fint_least32_t
is another name for the 1ong int type, then the correct conversion specification 1s
&1d, not %d. In order to use the .print£ and …scan£ functions in a portable
manner, we need a way to write conversion specifications that correspond to each
of the types declared in <stdint .h>. That’s where the <inttypes .h> header
comes in. For each <stdint .h> type, <inttypes.h> provides a macro that
expands into a string literal containing the proper conversion specifier for that type.
Each macro name has three parts:

# The name begins with either PRI or SCN, depending on whether the macro
will be used in a call of a .printf£ function or a ….scan£ function.

u Next comes a one-letter conversion specifier (d or i for a signed type; O, U, x,
or X for an unsigned type).

# The last part of the name indicates which <stdint .h> type is involved. For
example, the name of a macro that corresponds to the int_least/V_£ type
would end with LEASTN.

Let's return to our previous example, which involved displaying an integer of
type int least32_t. Instead of using d as the conversion specifier, we'll
switch to the PRIALEAST32 macro. To use the macro, we'll split the printf
format string into three pieces and replace the d in %d by PRIdLEAST32:

print£("i = $" PRIALEAST32 "\n", i);

The value of PRIGLEAST32 is probably either "d" (if int_least32_t is the
same as the int type) or "1d" (if int_least32_t is the same as long int).
Let’s assume that it’s "1d" for the sake of discussion. After macro replacement,
the statement becomes

printf("i = $" nldu n\nn' l),

Once the compiler joins the three string literals into one (which it will do automat-
ically). the statement will have the following appearance:

printf("i = %1d\n", i);

Note that we can still include flags, a fField width, and other options in our conver-
sion specification; PRIALEAST32 supplies only the conversion specifier and pos-
sibly a leng(h modifier, such as the letter 1.

Table 27.3 lists the <inttypes .h> macros.

***************************page_736***************************
 

 

 

272  The <inttypes.h> Header (C99) 741
Table 27.3 …printE£ Macros for Signed Integers
F0m}ﬂl-s_Peclﬁ°f Macros PRIdN _ PRIdLEASTM —PRIdFASTN — PRIdAMAX  PRIdPTR
In cinttypes.h> PRIIiN — PRIiILEASTM =—PRIiFASTM —PRIiMAX  PRIiPTR

 

…print£ Macros for Unsigned Integers

PRION — PRIOLEASTM —PRIOoFASTN — PRIOMAX  PRIOPTR
PRIuN  PRIULEASTM —PRIUFASTN —PRIUMAX  PRIUPTR
PRIxN — PRIXLEASTM =—PRIxFASTM —PRIxMAX — PRIxPTR
PRIXN _ PRIXLEASTM —PRIXFASTM —PRIXMAX  PRIXPTR

…scanf Macros for Signed Integers

SCNdN SCNALEASTM —SCNdFASTN —SCNAMAX — SCNAdPTR
SCNiN  SCNiLEASTM — SCNiFASTM — SCNiMAX — SCNiPTR

…scan£ Macros for Unsigned Integers

SCNON SCNOLEASTN —SCNoFASTN —SCNoMAX — SCNoPTR
SCNuN  SCNULEASTMN —SCNUFASTN SCNUMAX — SCNuPTR
SCNxN SCNXLEASTMN —SCNxFASTM —SCNxMAX — SCNxPTR

 

 

 

 

 

 

 

 

Functions for Greatest-Width Integer Types

intmax t imaxabs (intmax t j);
imaxdiv t imaxdiv(intmax t numer, intmax t denom) ;
intmax t strtoimax (const char * restrict nptr,
char ** restrict endptr,
int base) ;
uintmax t strtoumax(const char * restrict nptr,
char ** restrict endptr,
int base) ;
intmax_ t wcstoimax (const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base) ;
uintmax_t wcstoumax(const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base) ;

In addition to defining macros, the <inttypes .h> header provides functions for
working with greatest-width integers, which were introduced in Section 27.1. A
greatest-width integer has type intmax t (the widest signed integer type sup-
ported by an implementation) or uintmax_t (the widest unsigned integer type).
These types might be the same width as the long long int type, but they could
be wider. For example, long long int might be 64 bits wide and intmax t

and uintmax_ t might be 128 bits wide.
imaxabs The imaxabs and imaxdiv functions are greatest-width versions of the
imaxdiv _ integer arithmetic functions declared in <stdlib.h>. The imaxabs function
<städlib.h>header>262 _ returns the absolute value of its argument. Both the argument and the return value
have type intmax t. The imaxdiv function divides its first argument by its

***************************page_737***************************
712

Chapter 27  Additional C99 Support for Mathematics

strtoimax
strtoumax

westoimax
westoumax

<wchar .h> header » 25.5

217.3

second. returning an imaxdiv_t value. imaxdiv £ is a structure that contains
both a quotient member (named quot) and a remainder member (rem); both
members have type intmax_ t.

The strtoimax and strtoumax functions are greatest-width versions of
the numeric conversion functions of <stdlib.h>. The strtoimax function is
the same as strtol and strtoll, except that it returns a value of type int -
max t. The strtoumax function is equivalent to strtoul and strtoull.
excepl that 1l returns a value of type uintmax_ t. Both strtoimax and str-
toumax return zero if no conversion could be performed. Both functions store
ERANGE in errno if a conversion produces a value that’s outside the range of the
function’s return type. In addition, strtoimax returns the smallest or largest
intmax_t value (INTMAX MIN or INTMAX MAX); strtoumax returns the

largest uintmax_t value, UINTMAX MAX.
The westoimax and westoumax functions are greatest-width versions of

the wide-string numeric conversion functions of <wchar .h>. The westoimax
function is the same as wcstol and wostoll, except that it returns a value of
type intmax t. The westoumax function is equivalent to westoul and wes-
toull, except that it returns a value of type uintmax _ t. Both wcstoimax and
wcecstoumax return zero if no conversion could be performed. Both functions
store ERANGE in errno if a conversion produces a value that’s outside the range
of the function”s return type. In addition, wcestoimax returns the smallest or larg-
est intmax_t value (INTMAX MIN or INTMAX _ MAX); westoumax returns
the largest uintmax_t value, UINTMAX MAX.

Complex Numbers (C99)

Complex numbers are used in scientific and engineermg applications as well as
in mathematics. C99 provides several complex types, allows operators to have
complex operands, and adds a header named <complex .h> to the standard
library. There's a catch. though: complex numbers aren’t supported by all im-
plementations of C99. Section 14.3 discussed the difference between a hosted
C99 implementation and a /reestanding implementation. À hosted implementa-
tion must accept any program that conforms to the C99 standard. whereas a
freestandine implementation doesn't have to compile programs that use com-
plex types or standard headers other than <float .h>, <is0o646.h>, <lim-
its.h>, <stdarg.h>. <stdbool.h>, <stddef .h>, and <stdint.h>.
Thus, a freestanding implementation may lack both complex types and the
<complex.h> header.

We'l1 start with a review of the mathematical definition of complex numbers
and complex arithmetic. We“Il then look at C99’s complex types and the operations
that can be performed on values of these types. Coverage of complex numbers con-
tinues in Section 27.4, which describes the <complex .h> header.

***************************page_738***************************
27.3  Complex Numbers (C99) 713

Detinition of Complex Numbers

Let i be the square root of —1 (a number such that /* =—1). à is known as the imagi-
nary unit; engineers often represent it by the symbol / instead of i. À complex
number has the form a + bi, where a and b are real numbers. a is said to be the real
part of the number, and b is the rmaginary part. Note that the complex numbers
include the real numbers as a special case (when b = 0).

Why are complex numbers useful? For one thing, they allow solutions to prob-
lems that are otherwise unsolvable. Consider the equation x" + ! = 0, which has no
solution if x is restricted to the real numbers. If complex numbers are allowed,
there are two solutions: x= / and x =-i.

Complex numbers can be thought of as points in a two-dimensional space
known as the complex plane. Fach complex number—a point in the complex
plane—is represented by Cartesian coordinates, where the real part of the number
corresponds to the x-coordinate of the point, and the imaginary part corresponds
to the y-coordinate. For example, the complex numbers 2 + 2.5i, 1 — 3i, —3 — 2i,
and —3.5 + |.5i can be plotted as follows:

 

 

[maginary

axis

À

3___

e2+2.57

2.….
e—3,5+1.57

l.._
—— —— eul
-3 2 —I 1 2 3 P

_—
e—3—2i —2-

—3 <1 —3/

 

An alternative system known as polar coordinates can also be used to specify
à point on the complex plane. With polar coordinates, a complex number z is repre-
sented by the values r and 6, where r is the length of a line segment from the origin
to z, and Gis the angle between this segment and the real axis:

lmaginary
GxIs

SD

 

 

***************************page_739***************************
 

714

Chapter 27  Additional C99 Support for Mathematics

r is called the absolute value of z. (The absolute value 1s also known as the normn,
modulus, or magnitude.) 6 is said to be the argument (or phase angle) of z. The
absolute value of a + bi is given by the following equation:

|la+bi| = Ja? + b?

For additional information about converting from Cartesian coordinates to
polar coordinates and vice versa, see the Programming Projects at the end of the
chapter.

Complex Arithmetic

The sum of two complex numbers is found by separately adding the real parts of
the two numbers and the imaginary parts. For example,

(3—25)+(105+35)=(3+1.5)+&2+3)i= 4541

The difference of two complex numbers is computed in à similar manner, by sepa-
rately subtracting the real parts and the imaginary parts. For example,

(3—25) — (1.5 + 35) = (3 — [.5) + (-2 — 3)à1= 1.5 — Sr

Multiplying complex numbers is done by multiplying each term of the first
number by each term of the second and then summing the products:

(3—25) x (1.5+3) = (3 x 1.5) + (3 x 31) + (-2i x 1.5) + (=2i x 31)
=45+9i-3i-6i7= 105 +6i

Note that the identity /* = —1 is used to simplify the result.

Dividing complex numbers is a bit harder. First, we need the concept of the
complex conjugate of a number, which is found by switching the sign of the num-
ber’s imaginary part. For example, 7 — 4i is the conjugate of 7 + 4i, and 7 + 4i is the
conjugate of 7 — 4i. We’1l use z to denote the conjugate of a complex number z.

The quotient of two complex numbers y and z is given by the formula

M2 = YrË(z25

It turns out that zz* is always a real number, so dividing zz into yzŸ is easy (just
divide both the real part and the imaginary part of yz* separately). The following
example shows how to divide 10.5 + 67 by 3 — 2!:

10.5+ 6i _ (10.5+61)(3+2i) _ 19.5+39i
3—2i (3 —21)(3 + 21) 13

 

= 1.5+3i

Complex Types in C99

C99 has considerable built-in support for complex numbers. Without including any
library headers, we can declare variables that represent complex numbers and then
perform arithmetic and other operations on these variables.

***************************page_740***************************
27.3  Complex Numbers (C99) 715

C99 provides three complex types, which were first introduced in Section 7.2:
float _Complex, double _Complex. and long double _Complex.
These types can be used in the same way as other types in C: to declare variables,
parameters, return types, array elements, members of structures and unions, and so
forth. For example, we could declare three variables as follows:

float _Complex x;
double _Complex y;
long double _Complex z;

Each of these variables 1s stored just like an array of two ordinary floating-point
numbers. Thus, y 1s stored as two adjacent double values, with the first value
containing the real part of y and the second containing the imaginary part.

C99 also allows implementations to provide imaginary types (the keyword
_Imaginary is reserved for this purpose) but doesn’t make this a requirement.

Operations on Complex Numbers

Complex numbers may be used in expressions, although only the following opera-
tors allow complex operands:

n Unary + and -

u Jogical negation (!)

n sizeof

m Cast

u Mulliplicative (* and / only)
u Additive (+ and -)

n Equality (== and ! =)

u Logical and (&&)

# Logicalor(||)

m Conditional (? :)

u Simple assignment (=)

u Compound assignment (*=, /=, +=, and -= only)
n Comma (,)

Some notable omissions from the list include the relational operators (<, <=, >,
and >=), along with the increment (++) and decrement (- -) operators.

Conversion Rules for Complex Types

Section 7.4 described the C99 rules for type conversion, but without covering the
complex types. ll’s now time to rectify that situation. Before we get to the conver-
sion rules, though, we'Il need some new terminology. For each floating type there is
a corresponding real type. In the case of the real floating types (float, double,
and long double), the corresponding real type is the same as the original type.

***************************page_741***************************
716

Chapter 27  Additional C99 Support for Mathematics

For the complex types, the corresponding real type is the original type without the
word__Complex. (The corresponding real type for £loat _ Complex is float,
for example.)

We're now ready to discuss the general rules that govern type conversions
involving complex types. l'Il group them into three categories.

= Complex to complex. The first rule concerns conversions from one complex
type to another, such as converting from float _Complex to double
_ Complex. In this situation, the real and imaginary parts are converted sepa-
rately, using the rules for the corresponding real types (see Section 7.4). In our
example, the real part of the £loat _Complex value would be converted to
double, yielding the real part of the double Complex value: the imagi-
nary part would be converted to double in a similar fashion.

u Realto complex. When a value of à real type is converted to a complex type,
the real part of the number 1s converted using the rules for converting from one
real type to another. The imaginary part of the result 1s set to posilive or
unsigned zero.

= Complex to real. When a value of a complex type ts converted to a real typè,
the imaginary part of the number is discarded; the real part is converted using
the rules for converting from one real type to another.

One particular set of type conversions, known as the usual arithmetic conver-
sions, are automatically applied to the operands of most binary operators. There
are special rules for performing the usual arithimetic conversions when at least one
of the two operands has à complex type:

1. 1{ the corresponding real type of either operand is long double. convert
the other operand so that its corresponding real type is long double.

2. Otherwise, 1f the corresponding real type of either operand is double,
convert the other opcrand so that its corresponding real type is double.

3. Otherwise, one of the operands must have float as its corresponding real
type. Convert the other operand so that its corresponding real type 1s also
float.

À real operand still belongs to a real type after conversion, and a complex operand
still belongs to a complex type.

Normally, the goal of the usual arithmetic conversions 1s to convert both
operands to a common type. However. when a real operand 1s mixed with a com-
plex operand, performing the usual arithmetic conversions causes the operands to
have a common real type, but not necessarily the same type. For example, add-
ing a float operand and a double Complex operand causes the float
operand to be converted to double rather than double Complex. The type
of the result will be the complex type whose corresponding real type matches the
common rceal type. In our example, the type of the result will be double
_ Complex.

***************************page_742***************************
27.4

Table 27.4
<complex.h> Macros

<stdbool .h> header » 21.5

27.4  The <complex.h> Header (C99): Complex Arithmetic 717

The <complex.h> Header (C99): Complex
Arithmetic

As we saw in Section 27.3, C99 has significant built-in support for complex num-
bers. The <complex .h> header provides additional support in the form of math-
ematical functions on complex numbers, as well as some very useful macros and a
pragma. Let’s look at the macros first.

<complex.h> Macros

The <complex.h> header defines the macros shown in Table 27.4.

 

 

 

 

Name Value
complex _Complex
_Complex _ I Imaginary unit; has type const float _Complex
I _Complex_I

 

complex serves as an alternative name for the awkward _Complex keyword.
We’ve seen a situation like this before with the Boolean type: the C99 committee
chose a new keyword (_Bool) that shouldn’t break existing programs, but pro-
vided a better name (bool) as a macro defined in the <stdbool .h> header.
Programs that include <complex.h> may use complex instead of _Complex,
just as programs that include <stdbool .h> may use bool rather than _Bool.

The I macro plays an important role in C99. Thère’s no special language fea-
ture for creating a complex number from its real part and imaginary part. Instead, a
complex number can be constructed by multiplying the imaginary part by I and
adding the real part:

double complex dc = 2.0 + 3.5 # I;

The value of the variable dc is 2 + 3.51.

Note that both Complex_I and I represent the imaginary unit /. Presum-
ably most programmers will use I rather than _Complex I. However, since I
might already be used in existing code for some other purpose, Complex_I is
available as a backup. If the name I causes a conflict, it can always be undefined:

#include <complex.h>
#undef I

The programmer might then define a different—but still shorr—name for i, such as
J

#define J Complex I

***************************page_743***************************
718

 

 

Chapter 27  Additional C99 Support for Mathematics

#pragma directive > 4.5

Also note that the type of _ Complex I (and hence the type of I) is float
_ Complex, not double _Complex. When 1it’s used in expressions, I will auto-
matically be widened to double Complex or long double Complex if
necessary.

The CX LIMITED RANGE Pragma

The <complex.h> header provides à pragma named CX LIMITED RANGE
that allows the compiler to use the following standard formulas for multiplication,
division, and absolute value:

(a+bi)Xx(c+di) = (ac—-bd)+(bc+ad)i
(a + bi)/(c + di) = [(ac + bd)+ (be —ad)i]/(c? + d”)

|la+bi| = Ja?+b?

Using these formulas may cause anomalous results in some cases because of over-
flow or underflow; moreover, the formulas don’t handle infinities properly.
Because of these potential problems, C99 doesn’t use the formulas without the
programmer’s permission.

The CX LIMITED_RANGE pragma has the following appearance:

#pragma STDC CX LIMITED RANGE on-off-switch

where on-off-switch is either ON, OFF, or DEFAULT. If the pragma is used with the
value ON, it allows the compiler to use the formulas listed above. The value OFF
causes the compiler to perform the calculations in à way that’s safer but possibly
slower. The default setting, indicated by the DEFAULT choice, is equivalent to
OFF.

The duration of the CX LIMITED _ RANGE pragma depends on where it’s
used in a program. When it appears at the top level of a source file, outside any
external declarations, it remains in effect until the next CX LIMITED RANGE
pragma or the end of the file. The only other place that a CX LIMITED RANGE
pragma might appear is at the beginning of a compound statement (possibly the
body of a function); in that case, the pragma remains in effect until the next
CX _LIMITED _ RANGE pragma (even one inside a nested compound statement) or
the end of the compound statement. Àt the end of a compound statement, the state
of the switch returns to its value before the compound statement was entercd.

<complex.h> Functions

The <complex .h> header provides functions similar to those in the C99 version
of <math.h>. The <complex.h> functions are divided into groups, just as they
were in <math.h>: trigonometric, hyperbolic, exponential and logarithmic, and
power and absolute-value. The only functions that are unique to complex numbers
are the manipulation functions, the last group discussed in this section.

***************************page_744***************************
errno variable »24.2

Cacos

27.4  The <complex.h> Header (C99): Complex Arithmetic __ 719

Each <complex.h> function comes in three versions: a float complex
version, a double complex version, and a long double complex version.
The name of the float complex version ends with f, and the name of the
long double complex version ends with 1.

Before we delve into the <complex.h> functions, a few general comments
are in order. First, as with the <math . h> functions. the <complex .h> functions
expect angle measurements to be in radians, not degrees. Second, when an error
occurs, the <complex.h> functions may store a value in the errno variable,
but aren°t required to.

There’s one last thing we'll need before tackling the <complex.h> func-
tions. The term branch cut often appears in descriptions of functions that might
conceivably have more than one possible return value. In the realm of complex
numbers, choosing which value 10 return creates a branch cut: a curve (often just a
line) in the complex plane around which a function is discontinuous. Branch cuts
are usually not unique, but rather are determined by convention. An exact definition
of branch cuts takes us further into complex analysis than l’d like to go, so l’Il sim-
ply reproduce the restrictions from the C99 standard without further explanation.

Trigonometric Functions

double complex cacos (double complex Zz);
float complex cacosf (float complex z) ;
long double complex cacosl (long double complex z);

double complex casin (double complex z) ;
float complex casinf (float complex z);
long double complex casinl (long double complex z);

double complex catan (double complex z);
float complex catanf (float complex z) ;
long double complex catanl (long double complex z);

double complex ccos (double complex z);
float complex ccosf (float complex z);
long double complex ccosl (long double complex z);

double complex csin (double complex z) ;
float complex csinf (float complex z);
long double complex csinl(long double complex z);

double complex ctan (double complex z);
float complex ctanf(float complex z);
long double complex ctanl (long double complex Z) ;

The cacos function computes the complex arc cosine, with branch cuts outside the
interval [=1, +1] along the real axis. The return value lies in a strip mathematically
unbounded along the imaginary axis and in the interval [O, x] along the real axis.

***************************page_745***************************
720 Chapter 27  Additional C99 Support for Mathematics

casin

catan

CCcos
Csin
ctan

cacosh

casinh

catanh

The casin function computes the complex arc sine, with branch cuts outside
the interval [—1, +1] along the real axis. The return value lies in a strip mathemati-
cally unbounded along the imaginary axis and in the interval [-x/2. +7/2] along the

real axis.

The catan function computes the complex arc tangent, with branch cuts out-
side the interval [-i, +i] along the imaginary axis. The return value lies in a strip math-
ematically unbounded along the imaginary axis and in the interval [—7/2. +7/2] along
the real axis.

The ccos function computes the complex cosine, the csin function com-
putes the complex sine, and the ctan function computes the complex tangent.

Hyperbolic Functions

double complex cacosh (double complex Z) ;
float complex cacoshf (float complex Zz) ;
long double complex cacoshl (long double complex z);

double complex casinh(double complex Z) ;
float complex casinhf (float complex z) ;
long double complex casinhl (long double complex zZ);

double complex catanh(double complex z);
float complex catanhf (float complex Zz) ;
long double complex catanhl (long double complex 2) ;

double complex ccosh(double complex z) ;
filoat complex ccoshf (float complex z) ;
long double complex ccoshl (long double complex zZ);

double complex csinh(double complex z) ;
float complex csinhf (float complex z) ;
long double complex csinhl (long double complex Zz);

double complex ctanh(double complex z) ;
float complex ctanhf (float complex z);
long double complex ctanhl (long double complex z);

The cacosh function computes the complex arc hyperbolic cosine, with a branch
cut at values less than 1 along the real axis. The return value lies in a half-strip of
nonnegative values along the real axis and in the interval [—i, +ic] along the imag-
inary axis.

The casinh function computes the complex arc hyperbolic sine, with branch
cuts outside the interval [=i. +i] along the imaginary axis. The return value lies in a
strip mathematically unbounded along the real axis and in the interval [-i/2,
+ix/2] along the imaginary axis.

The catanh function computes the complex arc hyperbolic tangent, with
branch cuts outside the interval [—1, +1] along the real axis. The return value lies in

***************************page_746***************************
ccosh
csinh
ctanh

cexp
clog

cabs
cpow

csart

27.4  The <complex.h> Header (C99): Complex Arithmetic _ 721

a strip mathematically unbounded along the real axis and in the interval [-i7/2,
+i/2] along the imaginary axis.

The ccosh function computes the complex hyperbolic cosine, the csinh
function computes the complex hyperbolic sine. and the ctanh function com-
putes the complex hyperbolic tangent.

Exponential and Logarithmic Functions

double complex cexp (double complex Z) ;
float complex cexpf(flIoat complex z);
long double complex cexpl (long double complex z);

double complex clog(double complex z);
float complex clogf (float complex Zz) ;
long double complex c1!ogl (10ng double complex z);

The cexp function computes the complex base-e exponential value.

The clog function computes the complex natural (base-e) logarithm, with a
branch cut along the negative real axis. The return value lies in a strip mathemati-
calty unbounded along the real axis and in the interval [-ix, +ix] along the imagi-
nary axis.

Power and Absolute-Value Functions

double cabs (double complex z);
float cabsf (float complex z);
long double cabsl (long double complex z);

double complex cpow(double complex x,
double complex y) ;
float complex cpowf (float complex x,
float complezx y) ;
long double complex cpowl (Iong double complex x,
long double complex y) ;

double complex csgrt (double complex Z) ;
float complex csgrtf (float complex z) ;
long double complex csqrtl (long double complex z) ;

The cabs function computes the complex absolute value.

The cpow function returns x raised to the power y, with a branch cut for the
first parameter along the negative real axis.

The csart function computes the complex square root, with a branch cut
along the negative real axis. The return value lies in the right half-plane (including
the imaginary axis).

***************************page_747***************************
122

 

Chapter 27 Additional C99 Support for Mathematics

carg

cimag
conj
cproj

creal

PROGRAM

Manipulation Functions

double carg(double complex z);
float cargf (float complex z);
long double cargl (long double complex z) ;

double cimag (double complex z);
float cimagf (float complex Z2) ;
long double cimagl (long double complex z);

double complex conj (double complex Z);
float complex conjf(float complex Z);
long double complex conjl (long double complex Z) ;

double complex cproj (double complex Z) ;
float complex cprojf (float complex z);
long double complex cprojl (long double complex Zz);

double creal (double complex Z);
float crealf(float complex z);
long double creall(long double complex Z);

The carg function returns the argument (phase angle) of z, with a branch cut
along the negative real axis. The return value lies in the interval [—7, +7).

The cimag function returns the imaginary part of z.

The conj function returns the complex conjugate of z.

The cproj function computes a projection of z onto the Riemann sphere.
The return value is equal to z unless one of its parts is infinite, in which case
cproj returns INFINITY + I * copysign(0.0, cimag(z)).

The creal function returns the real part of z.

Finding the Roots of a Quadratic Equation
The roots of the quadratic equation
ax+bx+c=0

are given by the quadratie formula:
p —h + Jb? — 4ac
2a
In general, the value of x will be a complex number, because the square root of b* —

4ac is imaginary if b* — 4ac (known as the discriminant) is less than 0.
For example, suppose that a = 5, b = 2, and c = |, which gives us the equation

Sx7+2x+1=0

The value of the discriminant is 4 — 20 = —16, so the roots of the equation will be

***************************page_748***************************
quadratic.c

217.5

27.5  The <tgmath.h> Header (C99): Type-Generic Math 723

complex numbers. The following program, which uses several <complex.h>
functions, computes and displays the roots.

/* Finds the roots of the equation 5x**2 + 2x + 1 = O */

#include <complex.h»>
#include <stdio.h>

int main(void)

(
double a = 5, b = 2, c = l;
double complex discriminant sqrt = csqrt (b * b - 4 * a * C);
double complex root1l = (-b + discriminant sqrt) / (2 * a);
double complex root2 (-b - discriminant sgrt) / (2 * a);

printf ("rooti =
print£ ("root2

%gi\n", creal (root1), cimag(root1)) ;
gi\n", creal (root2), cimag (root2)) ;

J
Æe

o\e

q +
g +

return 0;

}

Here’s the output of the program:

rootil = -0.2 + O0.4i
root2 = -0.2 + -0.4i

The quadratic.c program shows how to display a complex number by
extracting the real and imaginary parts and then writing each as a floating-point
number. printf lacks conversion specifiers for complex numbers, so there's no
easier technique. There’s also no shorteut for reading complex numbers; a program
will need to obtain the real and imaginary parts separately and then combine them
into a single complex number.

The <tgmath.h> Header (C99): Type-Generic
Math

The <tgmath. h> header provides parameterized macros with names that match
functions in <math.h> and <complex.h>. These type-generic macros can
detect the types of the arguments passed to them and substitute a call of the appro-
priate version of a <math.h> or <complex.h> function.

In C99, there are multiple versions of many math functions, as we saw in Sec-
tions 23.3, 23.4, and 27.4. For example, the sqrt function comes in a double
version (sqrt), a float version (sart£), and a long double version
(sart1), as well as three versions for complex numbers (csqrt, csqrt£, and
csqrtl). By using <tgmath.h>, the programmer can simply invoke sqrt
without having to worry about which version is needed: the call sqrt (x) could
be a call of any of the six versions of sqrt, depending on the type of x.

***************************page_749***************************
 

724 Chapter 27  Additional C99 Support for Mathematics

Table 27.5
Type-Generic Macros in

<tgmath.h> (Group 1)

Table 27.6
Type-Generic Macros in
<tgmath.h> (Group 2)

One advantage of using <tgmath.h> is that calls of math functions become
easier to write (and read!). More importantly, a call of à type-generic macro won't
have to be modified in the future should the type of its argument(s) change.

The <tgmath. h> header includes both <math.h> and <complex.h>, by
the way, so including <tgmath .h> provides access to the functions in both headers.

Type-Generic Macros

The type-generic macros defined in the <tgmath.h> header fall into three
groups. depending on whether they correspond to functions in <math.h>,
<complex .h>, or both headers.

Table 27.5 lists the type-generic macros that correspond to functions in both
<math.h> and <complex.h>. Note that the name of each type-generic macro
matches the name of the ‘‘unsuffixed” <math.h> function (acos as opposed to
acos£ or acosl, for example).

 

 

 

<math.h>  <complex.h> =— Type-Generic
Function Function Macro
acos Cacos acos
asin casin asin
atan catan atan
acosh cacosh acosh
asinh casinh asinh
atanh caâtanh atanh
cos CCOS COs
sin csin sin
tan ctan tan
cosh Cccosh cosh
sinh csinh sinh
tanh ctanh tanh
exp cexp exp
log clog log
pow Cpow pow
sqrt csqrt sqrt
£abs cabs fabs

 

 

The macros in the second group (Table 27.6) correspond only to functions in
<math.h>. Each macro has the same name as the unsuffixed <math.h> func-
tion. Passing a complex argument to any of these macros causes undefined behavior.

 

 

atan2 fma l1round remainder
cbrt fmax log10 remquo
ceil fmin loglp rint
copysign =— fmod l0g2 round

erf frexp logb scalbn
erfc hypot lrint scalbln
exp2 ilogb lround tgamma
expml ldexp nearbyint trunc
fdim lgamma  nextafîter

floor llrint  nexttoward

 

 

***************************page_750***************************
Table 27.7
Type-Generic Macros in
<tgmath.h> (Group 3)

Q&À

QaAÀ

 

275  The <tgmath.h> Header (C99): Type-Generic Math 725

The macros in the final group (Table 27.7) correspond only to functions in
<complex.h>.

 

carg con] creal
cimag  Cproj

 

 

 

Between the three tables, all functions in <math.h> and <complex.h>
that have multiple versions are accounted for, with the exception of mod£Ë.

Invoking a Type-Generic Macro

To understand what happens when a type-generic macro is invoked, we first need
the concept of a generic parameter. Consider the prototypes for the three versions
of the nextafter function (from <math.h>):

double nextafter (double x, double y) ;
float nextafterf (float x, float y);
long double nextafterl (long double x, long double y);

The types of both x and y change depending on the version of nextafter, so
both parameters are generic. Now consider the prototypes for the three versions of
the nexttoward function:

double nexttoward (double x, long double y) ;
float nexttowardf (float x, long double y);
lJong double nexttowardl (long double x, long double y) ;

The first parameter is generic, but the second is not (it always has type long
double). Generic parameters always have type double (or double complex)
in the unsuffixed version of a function.

When a type-generic macro 1s invoked, the first step 1s to determine whether 1t
should be replaced by a <math.h> function or a <scomplex .h> function. (This
step doesn’t apply to the macros in Table 27.6. which are always replaced by a
<math.h> function, or the macros in Table 27.7, which are always replaced by a
<complex.h> function.) The rule 1s simple: 1f any argument corresponding to a
generic parameter is complex, then a <complex.h> function is chosen: other-
Wise, à <math.h> function is selected.

The next step is to deduce which version of the <math.h> function or
<complex.h> function is being called. Let’s assume that the function being
called belongs to <math.h>. (The rules for the <complex .Hh> case are analo-
gous.) The following rules are used, in the order listed:

|. lf any argument corresponding to a generic parameter has type 1long dou-
ble, the long double version of the function 1s called.

2. If any argument corresponding to à generic parameter has type double or
any integer type, the double version of the function 1s called.

3. Otherwise, the Float version of the function is called.

Rule 2 1s à litlle unusual: it states that an integer argument causes the double ver-
sion of a function to be called, not the £loat version. which you might expect.

***************************page_751***************************
726

 

Chapter 27  Additional C99 Support for Mathematics

217.6

As an example, assume that the following variables have been declared:

int i;

float Ê;

double d;

long double ld;

£float complex ËÊc;

double complex dc;

long double complex ldc;

For each macro invocation in the left column below, the corresponding function
call appears in the right column:

Macro Equivalent
Invocation Function Call
sqrt (i) sqrt (i)
sqrt (f) sqrtf(£f)
sqrt (d) sqrt (d)
sqrt (1d) sqrtl (1d)
sart (£c) csqrt£f (£c)
sqrt (dc) csqrt (dc)

sqrt (ldc) csqrtl (1dc)

Note that writing sqrt (i) causes the double version of sqrt to be called, not
the float version.

These rules also cover macros with more than one parameter. For example, the
macro invocation pow (1d, £) will be replaced by the call powl (1d, £). Both
of pow’s parameters are generic; because one of the arguments has type long
double, rule ! states that the long double version of pow will be called.

The <fenv.h> Header (C99): Floating-Point
Environment

IEEE Standard 754 is the most widely used representation for floating-point num-
bers. (This standard is also known as IEC 60559, which is how the C99 standard
refers to it.) The purpose of the <fenv .h> header is to give programs access {o
the floating-point status flags and control modes specified in the IEEE standard.
Although <fenv.h> was designed in a general fashion that allows it to work with
other floating-point representations, supporting the IEEE standard was the reason
for the header’s creation.

A discussion of why programs might need access to status flags and control
modes is beyond the scope of this book. For good examples, see “What every com-
puter scientist should know about floating-point arithmetic” by David Goldberg
(ACM Computing Surveys, vol. 23, no. ! (March 1991): 5—48), which can be found
on the Web.

***************************page_752***************************
276 The <fenv.h> Header (C99): Floating-Point Environment = 727

Floating-Point Status Flags and Control Modes

Section 7.2 discussed some of the basic properties of IEEE Standard 754. Sec-
tion 23.4, which covered the C99 additions to the <math.h> header, gave addi-
tional detail. Some of that discussion. particularly concerning exceptions and
rounding directions, is directly relevant to the < fenv .h> header. Before we con-
tinue, let’s review some of the material from Section 23.4 as well as define a few
new terms.

A floating-point status flag is a system variable that’s set when a floating-
point exception is raised. In the IEEE standard. there are five types of floating-
point exceptions: overflow, underflow, division by zero, invalid operation (the
result of an arithmetic operation was NaN), and inexact (the result of an arithmetic
operation had to be rounded). Each exception has a corresponding status flag.

The <fenv.h> header declares a type named fexcept t thals used for
working with the floating-point status flags. An fexcept_ t object represents
the collective value of these flags. Although fexcept t can simply be an inte-
cer type, with single bits representing individual flags, the C99 standard doesn’t
make this a requirement. Other alternatives exist, including the possibility that
fexcept t is a structure, with one member for each exception. This member
could store additional information about the corresponding exception, such as the
address of the floating-point instruction that caused the exception to be raised.

A floating-point control mode is à system variable that may be set by a pro-
gram to change the future behavior of floating-point arithmetic. The IEEE standard
requires a “directed-rounding” mode that controls the rounding direction when a
number can’t be represented exactly using a floating-point representation. There
are four rounding directions: (1) Round toward nearest. Rounds to the nearest rep-
resentable value. If a number falls halfway between two values, it’s rounded to the
“even” value (the one whose least significant bit is zero). (2) Round toward zero.
(3) Round toward positive infinity. (4) Round toward negative infinity. The default
rounding direction is round toward nearest. Some implementations of the IEEE
standard provide two additional control modes: à mode that controls rounding pre-
cision and a “trap enablement” mode that determines whether a floating-point pro-
cessor will trap (or stop) when an exception 1s raised.

The term floating-point environment refers to the combination of floating-
point status flags and control modes supported by a particular implementation. À
value of type fenv t represents an entire floating-point environment. The
fenv t type, like the fexcept_t type. 1s declared in <£env.h>.

<fenv.h> Macros

The <fenv.h> header potentially defines the macros listed in Table 27.8. Only
two of these macros (FE _ ALL EXCEPT and FE DFL ENV) are required, how-
ever. An implementation may define additional macros not listed in the table; the
names of these macros must begin with FE_ and an uppercase letter.

***************************page_753***************************
728

 

Chapter 27  Additional C99 Support for Mathematics

Table 27.8
<fenv.h> Macros

Hpragma directive > 14.5

 

 

Name Value Description
FE DIVBYZERO Integer constant Defined only if the corresponding floating- |
FE _INEXACT expressions whose = point exception is supported by the imple-
FE _ INVALID bits do not overlap — mentalion. An implementation may define

FE OVERFLOW
FE_UNDERFLOW

additional macros that représent floating-
point exceptions.

 

FE ALL EXCEPT

See description

Bitwise or of all floating-point exception
macros defined by the implementation. Has
the value O 1f no such macros are defined.

 

FE DOWNWARD
FE TONEAREST
FE TOWARDZERO

Integer constant
expressions with
distinet nonnega-

Defined only 1if the corresponding rounding
direction can be retricved and set via the
fegetround and fesetround func-

 

 

 

FE UPWARD tive values tions. An implementation may define addi-
tional macros that represent rounding
directions. [

FE DFL ENV À value of type Represents the default (program start-up) |

floating-point environment. An implemen-
tation may define additional macros that
represent floating-point environments.

const fenv t *

 

 

The FENV _ ACCESS Pragma

The <fenv.h> header provides a pragma named FENV _ACCESS that’s used to
notify the compiler of a program’s intention to use the functions provided by this
header. Knowine which portions of a program will use the capabilities of
<fenv.h> 1s important for the compiler, because some common optimizations
can'i be performed if control modes don’t have their customary settings or may
change during program execution.

The FENV _ACCESS pragma has the following appearance:

#pragma STDC FENV ACCESS on-off-switch

where on-off-switch is either ON. OFF, or DEFAULT, If the pragma is used with the
value ON, 1t informs the compiler that the program might test floating-point status
flags or alter a floating-point control mode. The value OFF indicates that flags
won't be tested and default control modes are in effect. The meaning of DEFAULT
Is implementation-defined; it represents cither ON or OFF.

The duration of the FENV _ ACCESS pragma depends on where it's used in a
program. When 1t appears at the top level of a source file, outside any external dec-
larations, it remains in effect until the next FENV ACCESS pragma or the end of
the file. The only other place that an FENV ACCESS pragma might appear is at
the beginning of a compound statement (possibly the body of a function); in that
case, the pragma remains in effect until the next FENV _ ACCESS pragma (even
one inside à nested compound statement) or the end of the compound statement. Àt
the end of a compound statement, the state of the switch returns to its value before
the compound statement was entered.

I£s the programmer’s responsibility to use the FENV ACCESS pragma lo
indicate regions of a program in which low-level access to floating-point hardware

***************************page_754***************************
feclearexcept

fegetexcepiflag

feraiseexcept

 

276  The <fenv.h> Header (C99): Floating-Point Environment = 729

is needed. Undefined behavior occurs if a program tests floating-point status fags
Or runs under non-default control modes in a region for which the value of the
pragma switch is OFF.

Typically, an FENV_ACCESS pragma that specifies the ON switch would be
placed at the beginning of a function body:

void f (double x, double y)

{

#pragma STDC FENV ACCESS ON

7

The function £ may test floating-point status flags or change control modes as
needed. Ât the end of £'s body, the pragma switch will return to its previous state.

When a program goes from an FENV_ACCESS “off” region to an “on” region
during execution. the foating-point status flags have unspecified values and the
control modes have their default settines.

Floating-Point Exception Functions

int feclearexcept (int excepts) ;
int fegetexceptflag(fexcept t *flagp, int excepts) ;
int feraiseexcept (int excepts) ;
int fesetexceptflag (const fexcept t *flagp,
int excepts) ;
int fetestexcept (int excepts),

The <fenv.h> functions are divided into three groups. Functions in the first
group deal with the floating-point status flags. Each of the five functions has an
int parameter named excepts, which is the bitwise or of one or more of the
floating-point exception macros (the first group of macros listed in Table 27.8). For
example, the «rgument passed to one of these functions might be FE_INVALID |
FE_OVERFLOW | FE _ UNDERFLOW, to represent the combination of these three
status flags. The argument may also be zero, to indicate that no flags are selected.

The feclearexcept function attempts to clear the floating-point excep-
tions represented by excepts. Ît returns zero if excepts is Zero or if all
specified exceptions were successfully cleared: otherwise, it returns a nonzero
value.

The fegetexceptflag function attempts to retrieve the states of the
floating-point status flags represented by excepts. This data is stored in the
fexcept_t object pointed to by flagp. The fegetexceptflag function
returns zero if the states of the status flags were successfully stored: otherwise, it
returns a nonzero value.

The feraiseexcept function attempts to raise supported floating-point
exceptions represented by excepts. It is implementation-defined whether
feraiseexcept also raises the inexact floating-point exception whenever it

***************************page_755***************************
730

Chapter 27  Additional C99 Support for Mathematics

fesetexceptflag

fetestexcept

fegetround

fesetround

raises the overflow or underflow exception. (Implementations that conform to the
IEEE standard will have this property.) feraiseexcept returns zero if
excepts is Zero or if all specified exceptions were successfully raised; otherwise,
it returns a nonzero value.

The fesetexcept flag function attempts to set the floating-point status
flags represented by excepts. The states of the flags are stored in the
fexcept_t object pointed to by £lagp; this object must have been set by a pre-
vious call of fegetexceptflag. Moreover, the second argument in the prior
call of fegetexceptflag must have included all floating-point exceptions rep-
resented by excepts. The fesetexcept£flag function returns zero if
excepts is zero or if all specified exceptions were successfully set; otherwise, it
returns a nonzero value.

The fetestexcept function tests only those floating-point status flags
represented by excepts. Ît returns the bitwise or of the floating-point excep-
tlon macros corresponding to the flags that are currently set. For example, if the
value of excepts is FE INVALID | FE OVERFLOW | FE UNDERFLOMW, the
fetestexcept function might return FE_INVALID | FE UNDERFLON, in-
dicating that, of the exceptions represented by FE_INVALID, FE OVERFLOW,
and FE UNDERFLOW, only the flags for FE_INVALID and FE _UNDERFLOW
are currently set.

Rounding Functions

int fegetround (void) ;
int fesetround(int round) ;

The fegetround and fesetround functions are used to determine the round-
ing direction and modify it. Both functions rely on the rounding-direction macros
(the third group in Table 27.8).

The fegetround function returns the value of the rounding-direction macro
that matches the current rounding direction. If the current rounding direction can*t
be determined or doesn’t match any rounding-direction macro, fegetround
returns a negative number.

When passed the value of a rounding-direction macro, the fesetround
function attempts to establish the corresponding rounding direction. Tf the call is
successful, £feset round returns zero; otherwise, it returns a nonzero value.

Environment Functions

int fegetenv(fenv t *envp);

int feholdexcept (fenv t *envp) ;

int fesetenv(const fenv t *envp);
int feupdateenv{(const fenv t *envp);

***************************page_756***************************
fegetenv

feholdexcept

fesetenv

feupdateenv

Q:

A:

freestanding implementation > 14.3

 

Q & À 731

The last four functions in <fenv.h> deal with the entire floating-point environ-
ment, not just the status flags or control modes. Each function returns zero if it suc-
cceds at the operation it was asked to perform. Otherwise, it returns a nonzero
value.

The fegetenv function attempts to retrieve the current floating-point envi-
ronment from the processor and store it in the object pointed to by envp.

The feholdexcept function (1) stores the current floating-point environ-
ment in the object pointed to by envp, (2) clears the floating-point status flags,
and (3) attempts lo install a non-stop mode—if available—for all floating-point
exceptions (so that future exceptions won’t cause a trap or stop).

The fesetenv function attempts to establish the Floating-point environment
represented by envp, which either points to a floating-point environment stored
by a previous call of fegetenv or £feholdexcept, or is equal to a floating-
point environment macro such as FE DFL ENV. Unlike the feupdateenv
function, fesetenv doesn’t raise any exceptions. If a call of fegetenv is used
to save the current floating-point environment. then a later call of fesetenv can
restore the environment to its previous state.

The feupdateenv function attempts to (1) save the currently raised float-
ing-point exceptions, (2) install the floating-point environment pointed to by
envp, and (3) raise the saved exceptions. envp either points to a floating-point
environment stored by a previous call of Fegetenv or feho1ldexcept, or is
equal to a floating-point environment macro such as FE_DFL ENV.

Q & À

If the <inttypes .h> header includes the <stdint .h> header, why do we
need the <stdint .h> header at all? [p. 709]

The primary reason that <stdint .h> exists as a separate header is so that pro-
grams in a freestanding implementation may include it. (C99 requires conforming
implementations—both hosted and freestanding—to provide the <stdint .h>
header, but <inttypes.h> is required only for hosted implementations.) Even
in a hosted environment. it may be advantageous to include <stdint .h> rather
than <inttypes .h> to avoid defining all the macros that belong to the latter.

There are three versions of the mod£ function in <math.h>, so why isn°t
there a type-generic macro named mod£f? [p. 725]

Let’s take a look at the prototypes for the three versions of modf:

double mod£ (double value, double *iptr) ;
float modf£ (£float value, float *iptr) ;
long double mod£fl (long double value, long double #iptr) ;

modf£ 1s unusual in that it has a pointer parameter, and the type of the pointer isn’t
the same among the three versions of the function. (Frexp and remquo have a

***************************page_757***************************
 

732 Chapter 27  Additional C99 Support for Mathematics

usual arithmotic conversions > 7,4

À:

Section 27.1

Q:

D

pointer parameter, but it always has int * type.) Having a type-generic macro for
mod£ would pose some difficult problems. For example, the meaning of mod£ (d,
&£). where d has type double and £ has type £loat, 1s unclear: are we calling
the mod£ function or the mod£ £ function? Rather than develop a complicated set
of rules for a single function (and probably taking into account that mod£ isn°t a
very popular function), the C99 committee chose not to provide a type-generic
mod£f macro.

When à <tgmath.h> macro is invoked with an integer argument, the double
version of the corresponding function is called. Shouldn’t the £Ioat version be
called, according to the usual arithmetic conversions? [p. 725]

We're dealinge with a macro, not à function, so the usual arithmetic conversions
don’t come into play. The C99 committee had to create a rule for determining
which version of a function would be called when an integer argument is passed to
a <tgmath.h> macro. Although the committee at one point considered having
the float version called (for consistency with the usual arithmetic conversions),
they eventually decided that choosing the double version was better. First, it’s
safer: converting an integer to float may cause a loss of accuracy. especially for
integer types whose width is 32 bits or more. Second, it causes fewer surprises for
the programmer. Suppose that i is an integer variable. If the <tgmath.h> header
isn’t included, the call sin(i) calls the sin function. On the other hand, if
<tgmath.h> às included, the call sin (i ) invokes the sin macro: because i is
an integer, the preprocessor replaces the sin macro with the sin function, and the
end result is the same.

When a program invokes one of the type-generic macros in <tgmath.h>,
how does the implementation determine which function to call? Is there a way
for a macro to test the types of its arguments?

One unusual aspect of <tgmath .h> is that its macros need to be able to test the
types of the arguments that are passed to them. C has no features for testing types,
so 1t would normally be impossible to write such a macro. The <tgmath.h>
macros rely on special facilities provided by a particular compiler to make such
testing possible. We don’t know what these facilities are, and they’ré not guaran-
teed to be portable from one compiler to another.

Exercises

(C99) Locate the declarations of the intN t and uintW c types in the <stdint .h>
header installed on your system. Which values of N are supported?

(C99) Write the parameterized macros INT32 _ C(n), UINT32 C(n). INT64 C(n),
and UINT64 C(n), assuming that the int type and long int types are 32 bits wide and
the long long int type is 64 bits wide. Hinr: Use the ## preprocessor operator to attach

***************************page_758***************************
Section 27.2

Section 27.5

3.

4.

Programming Projects 733

a suffix to n containing a combination of L and/or U characters. (See Section 7.1 for à dis-
cussion of how to use the L and U suffixes with integer constants.)

(C99) In each of the following statements, assume that the variable à has the indicated orig-
inal type. Using macros from the <inttypes .h> header, modify each statement so that Il
will work correctly if the type of i is changed to the indicated new type.

(au) print£f("=d", i); Original type: int New type: int8 t
(b) print£("%12.4d", i); Original type: int New type: int32 t
(c) printf("%-60", i); Original type: unsigned int Newtype: uintl6_t
(d) print£f ("%#x", 1) ; Original type: unsigned int New type: uint64_t

(C99) Assume that the following variable declarations are in effect:

int 12;
float ÊÉ;
double d;

long double 1ld;

float complex Êfc;

double complex dc;

long double complex ldc;

Each of the following is an invocation of à macro in <tgmath.h>. Show what it will look
like after preprocessing, when the macro has been replaced by a f'unction from <math.h>
or <complex.h>.

(a) tan(i)

(b) fabs(£)

(c) asin(d)

(d) exp (1d)

(e) log(fc)

(f) acosh(dc)

(g) nexttoward (d, l1d)
(h) remainder (£, i)
(1) copysign(d, 1d)
(ÿ) carg(i)

(kK) cimag(£f)

(1) conj (1dc)

Programming Projects

(C99) Make the following modifications to the quadratic. c program of Section 27.4:

(a) Have the user enter the coefficients of the polynomial (the values of the variables a, b,
and c).

(b) Have the program test the discriminant before displaying the values of the roots. If the
discriminant is negative, have the program display the roots in the same way as before. If it’s
nonnegative, have the program display the roots as real numbers (without an imaginary part).
For example, if the quadratic equation is x"+x—-2=0,the output of the program would be

rootl = 1l
root2 = -2

***************************page_759***************************
734

Chapter 27  Additional C99 Support for Mathematics

(c) Modify the program so that it displays a complex number with a negative imaginary
part as à — bi instead of a + —bi. For example. the output of the program with the original
coefficients would be

rooti = -0.2 + O.4i
root2 = -0.2 - 0O0.4i

(C99) Write a program that converts a complex number in Cartesian coordinates to polar
form. The user will enter à and b (the real and imaginary parts of the number); the program
will display the values of r and 6

(C99) Write a program that converts a complex number in polar coordinates to Cartesian
form. After the user enters the values of r and 6, the program will display the number in the
form a + bi, where

a=rcos 60
b=rsin 6

(C99) Write a program that displays the nth roots of unity when given a positive integer n.
The mth roots of unity are given by the formula e*** where k is an integer between 0 and
n—l.

***************************page_760***************************
 

APPENDIX A
C Operators

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Precedence Name Symbol(s) Associativity
| Array subscripting [] Left
| Function call () Left
| Structure and union member s. —-> Left
| Increment (postfix) ++ Left
] Decrement (postfix) _- Left
2 Increment (prefix) ++ Right
2 Decrement (prefix) __ Right
2 Address & Right
2 Indirection * Right
2 Unary plus + Right
2 Unary minus - Right
2 Bitwise complement - Right
2 Logical negation ! Right
2 Size sizeoËf Right
3 Cast () Right
à Multiplicative * / % Left
5 Additive + - Left
6 Bitwise shift << >> Left
7 Relational < > «= >= Left
8 Equality == 1= Left
9 Bitwise and & Left
10 Bitwise exclusive or 7 Left
[1 Bitwisc inclusive or | Left
12 Logical and && Left
13 Logical or | | Left
14 Conditional ?: Right
15 Assignment = * /= % Right

+= -= <e<e= >>=
&= s= l =
16 Comma Î Left

 

 

735

***************************page_761***************************

***************************page_762***************************
2

// comments

identifiers

keywords

returning from main

4

/ and % operators

APPENDIX B
C99 versus C89

This appendix lists many of the most significant differences between C89 and C99.
(The smaller differences are too numerous to mention here.) The headings indicate
which chapter contains the primary discussion of each C99 feature. Some of the
changes attributed to C99 actually occurred earlier, in Amendment | to the C89
standard; these changes are marked “Amendment 1."

C Fundamentals

C99 adds a second kind of comment, which begins with / /.

C89 requires compilers to remember the first 31 characters of identifiers: in C99,
the requirement is 63 characters. Only the first six characters of names with external
linkage are significant in C89. Moreover, the case of letters may not matter. In C99,
the first 31 characters are significant, and the case of letters 1s taken into account.

Five keywords are new in C99: inline, restrict. Bool, Complex, and
_Imaginary.

In C89, if a program reaches the end of the main function without executing a
return statement. the value returned to the operating system is undefined. In C99,
ifmain is declared to return an int, the program returns 0 to the operating system.

Expressions

The C89 standard states that if either operand is negative, the result of an integer
division can be rounded either up or down. Moreover, if i or j 1s negative, the sign
of i % j dcpends on the implementation. In C99, the result of à division 1s always
truncated toward zero and the value of i % j has the same sign as i.

737

***************************page_763***************************
738

5

_Bool fype

6

for siatements

/

long long
integer types

extended integer types

long long integer
constants

types of integer
constants

hexadecimal floating
constants

implicit conversions

8

designated initializers

variable-length arrays

9

no default return type

mixed declarations
and statements

Appendix B _ C99 versus C89

Selection Statements

C99 provides a Boolean Lype named _Bool; C89 has no Boolean type.

Loops

In C99, the first expression in a £or statement can be replaced by a declaration,
allowing the statement to declare its own control variable(s).

Basic Types

C99 provides two additional standard integer types, long long int and un-
signed long long int.

In addition to the standard integer types, C99 allows implementation-defined
extended signed and unsigned integer types.

C99 provides a way to indicate that an integer constant has type long long int
or unsigned long long int.

C99's rules for determining the type of an integer constant are different from those
in C89.

C99 provides a way to write floating constants in hexadecimal.

The rules for implicit conversions in C99 are somewhat different from the rules in
C89, primarily because of C99’s additional basic types.

Arrays

C99 supports designated initializers, which can be used to initialize arrays, struc-
tures, and unions.

In C99, the length of an array may be specified by an expression that’s not con-
stant, provided that the array doesn’t have static storage duration and 1ts declara-
tion doesn’t contain an initializer.

Functions

If the return type of a function is omitted in C89, the function is presumed to return
a value of type int. In C99, it’s illegal to omit the return type of a function.

In C89, declarations must precede statements within a block (including the body of
a function). In C99, declarations and statements can be mixed, as long as each vari-
able is declared prior to the first statement that uses the variable.

***************************page_764***************************
declaration or definition
required prior to
function call

variable-length
array parameters

static array
parameters

compound literals

declaration ofmain

return statement
without expression

14

addiïtional predefined
macros

emply macro
arguments

macros with a variable
number of arguments

__func___ identitier

standard pragmas

_Pragma operator

16

structure type
compaltibility

Appendix B  C99 versus C89 739

C99 requires that either a declaration or a definition of a function be present prior
to any call of the function. C89 doesn’t have this requirement; if a function is
called without a prior declaration or definition, the compiler assumes that the func-
tion returns an int value.

C99 allows variable-length array parameters. In a function declaration, the * sym-
bol may appear inside brackets to indicate a variable-length array parameter.

C99 allows the use of the word static in the declaration of an array parameter,
indicating a minimum length for the first dimension of the array.

C99 supports the use of compound literals, which allow the creation of unnamed
array and structure values.

C99 allows main to be declared in an implementation-defined manner, with a
return type other than int and/or parameters other than those specified by the
standard.

In C89, executing a return statement without an expression in a non-void func-
tion causes undefined behavior (but onty 1f the program attempts to use the value
returned by the function). In C99, such a statement is 1llegal.

The Preprocessor

C99 provides several new predefined macros.

C99 allows any or all of the arguments in a macro call to be empty, provided that
the call contains the correct number of commas.

In C69, a macro must have a fixed number of arguments. if it has any at all. C99
allows macros that take an unlimited number of arguments.

In C99,the __ func __ identifier behaves like a string variable that stores the
name of the currently executing function.

In C89, there are no standard pragmas. C99 has three: CX LIMITED RANGE,
FENV ACCESS, and FP CONTRACT.

C99 provides the _Pragma operator, which is used in conjunction with the
#pragma directive.

Structures, Unions, and Enumerations

In C89, structures defined in different files are compatible 1f their members have
the same names and appear in the same order, with corresponding members having

***************************page_765***************************
740

trailing comma in
enumerations

17

restricted pointers

flexible array members

18

block scopes for
selection and iteration
statementis

array, structure, and
union initializers

inline functions

21

<stdbool .h> header

22

.…print£ conversion
specifications

.…scant conversion
specifications

snprint£ function

23

additional macros in
<float .h> header

Appendix B  C99 versus C89

compatible types. C99 also requires that either both structures have the same tag or
neither has à tag.

In C99, the last constant in an enumeration may be followed by a comma.

Advanced Uses of Pointers

C99 has a new keyword, restrict, that can appear in the declaration of a pointer.

C99 allows the last member of a structure to be an array of unspecified length.

Declarations

In C99, selection statements (i£ and switch) and iteration statements (while,
do. and £or)—along with the “inner” statements that they control—are consid-
ered to be blocks.

In C89, a brace-enclosed initializer for an array, structure, or union must contain
only constant expressions. In C99, this restriction applies only if the variable has
static storage duration.

C99 allows functions to be declared inline.

The Standard Library

The <stdbool .h> header, which defines the boo1, true. and false macros,
Is new in C99.

Input/Output

The conversion specifications for the ….print£ functions have undergone a num-
ber of changes in C99, with new length modifiers, new conversion specifiers, the
ability to write infinity and NaN, and support for wide characters. Also, the $1e.

<1E, S1f, %1g, and $1G conversions are legal in C99; they caused undefined
behavior in C89.

In C99, the conversion specifications for the …scan£ functions have new length
modifiers, new conversion specifiers, the ability to read infinity and NaN, and sup-
port for wide characters.

C99 adds the snprint £ function to the <stdio.h> header.

Library Support for Numbers and Character Data

C99 adds the DECIMAL DIG and FLT EVAL METHOD macros to the
<float .h> header.

***************************page_766***************************
additional macros in
<limits.h> header

math_errhandling
macro

additional functions in
<math.h> header

24

EILSEQ Macro

25

digraphs

<iso646.h> header

universal character
names

<wchar .h> header

<wctype .h> header

26

va_copy macro

additional functions in
<stdio.h> header

additional functions in
<stdlib.h> header

additional str£time
conversion specifiers

Appendix B  C99 versus C89 741

In C99. the <limits.h> header contains three new macros that describe the
characteristics of the long long int types.

C99 gives implementations a choice of how to inform a program that an error
has occurred in a mathematical function: via a value stored in errno, via a
floating-point exception, or both. The value of the math errhandling mac-
ro (defined in <math.h>) indicates how errors are signaled by a particular
implementation.

C99 adds two new versions of most <math.h> functions, one for £loat and one
for long double. C99 also adds a number of completely new functions and
function-like macros to <math.h>.

Error Handling

C99 adds the EILSEQ macro to the <errno .h> header.

International Features

Digraphs, which are two-character symbols that can be used as substitutes for the
[, 1. {. }. #. and ## tokens, are new in C99. (Amendment !)

The <iso646 .h> header, which defines macros that represent operators contain-
ing the characters &. |. —, !. and *. is new in C99. (Amendment 1)

Universal character names, which provide a way to embed UCS characters in the
source code of a program, are new in C99.

The <wchar .h> header. which provides functions for wide-character input/out-
put and wide string manipulation, is new in C99. (Amendment !)

The <wctype .h> header. the wide-character version of <ctype.h>. is new in
C99. <wctype.h> provides l'unctions for classifying and changing the case of
wide characters. (Amendment |l)

Miscellaneous Library Functions

C99 adds a f'unction-like macro named va_copy lo the <stdarg. h> header.

C99 adds the vsnprintf, vfscan£f, vscan£. and vsscanf functions lo the
<stdio .h> header.

C99 adds five numeric conversion functions, the _Ex1t function, and long long
versions of the abs and div functions to the <stdlib.h> header.

C99 adds a number of new strftime conversion specifiers. It also allows the use
of an E or O character to modify the meaning of certain conversion specifiers.

***************************page_767***************************
742 Appendix B  C99 versus C89

21

<stdint .h> header

<inttypes.h> header

complex types

<complex.h> header

<tgmath.h> header

<fenv.h> header

Additional C99 Support for Mathematics

The <stdint .h> header, which declares integer types with specified widths, is
new in C99.

The <inttypes .h> header, which provides macros that are useful for input/out-
put of the integer types in <stdint .h> is new in C99.

C99 provides three complex types: float _Complex, double Complex,
and long double Complex.

The <complex. H> header, which provides functions that perform mathematical
operations on complex numbers, is new in C99.

The <tgmath.h> header, which provides type-generic macros that make it easier
to call librarÿ functions in <math.h> and <complex.h>, is new in C99.

The <£env.h> header, which gives programs access to floating-point status flags
and control modes, is new in C99.

***************************page_768***************************
2

identifiers

keywords

unary +

D

switch

 

APPENDIX C
C89 versus K&R C

This appendix lists most of the significant differences between C89 and K&R C
(the language described in the first edition of Kernighan and Ritchie’s The C Pro-
gramming Language). The headings indicate which chapter of this book discusses
each C89 feature. This appendix doesn’t address the C library, which has changed
much over the years. For other (less important) differences between C89 and K&R
C, consult Appendices À and C in the second edition of K&R.

Most of today's C compilers can handle all of C89, but this appendix is useful
if you to happen to encounter older programs that were originally written for pre-
C89 compilers.

C Fundamentals

In K&R C, only the first eight characters of an identifier are significant.

K&R C lacks the keywords const, enum, signed, void, and volatile. In
K&R C, the word entry 1s a keyword.

Expressions

K&R C doesn't support the unary + operator.

Selection Statements

In K&R C, the controlling expression (and case labels) in a switch statement
must have type int after promotion. In C89. the expression and labels may be of
any integral type, including unsigned int and long int.

743

***************************page_769***************************
T44

7

unsigned types
signed

number suffixes

long float

long double

ESCApe SeEquences

size t

usual arithmetic
conversions

9

function definitions

function declarations

Appendix C _ C89 versus K&R C

Basic Types

K&R C provides only one unsigned type (unsigned int).
K&R C doesn’t support the signed type specifier.

K&R C doesn’t support the U (or u) suffix to specify that an integer constant 1s
unsigned, nor does it support the F (or £) suffix to indicate that a floating constant
is to be stored as a float value instead of a double value. In K&R C. the L (or
1) suffix can’t be used with floating constants.

K&R C allows the use of long float as a synonym for double; this usage
isn’t legal in C89.

K&R C doesn’t support the long double type.

The escape sequences \a. \v, and \ ? don’texist in K&R C. Also, K&R C doesn't
support hexadecimal escape sequences.

In K&R C. the sizeof operator returns a value of type int: in C89, it returns a
value of type size t.

K&R C requires that £loat operands be converted to double. Also, K&R C
specifies that combining a shorter unsigned integer with a longer signed integer
always produces an unsigned result.

Functions

In a C89 function definition. the types of the parameters are included in the param-
eter list:

double square (double x)

{

return x * x;

}

K&R C requires that the types of parameters be specified in separate lists:

double square (x)
double x;

(

return x * x;

}

A C89 function declaration (prototype) specifies the types of the function’s param-
eters (and the names as well, 1f desired):

double square (double x) ;
double square (double) ;
int rand (void) ;

/* alternate £form */
/* no parameters */

***************************page_770***************************
function calls

void

12

pointer subtraction

13

string literals

string initialization

14

#elift, #error,
#pragma

#, ##, defined

16

structure and union
members and tags

whole-structure
operations

enumerations

Appendix C _ C89 versus K&R C 745

A K&R C function declaration omits all information about parameters:

double square () ;
int rand() ;

When a K&R C definition or declaration 1s used, the compiler doesn’t check that
the function 1s called with arguments of the proper number and type. Furthermore,
the arguments aren’t automatically converted to the types of the corresponding
parameters. Instead, the integral promotions are performed, and £float arguments
are converted to double.

K&R C doesn't support the void type.

Pointers and Arrays

Subtracting two pointers produces an int value in K&R C but a ptrdif£ t
value in C89.

Strings

In K&R C, adjacent string literals aren’t concatenated. Also. K&R C doesn't pro-
hibit the modification of string hterals.

In K&R C, an initializer for a character array of length n 1s limited to n — ! charac-
ters (leaving room for a nul] character at the end). C8&9 allows the initializer to have
length n.

The Preprocessor

K&R C doesn't support the #eli £, #error. and #pragma directives.

K&R C doesn't support the #, ##. and de£ined operators.

Structures, Unions, and Enumerations

In C89, each structure and union has its own name space for members; structure
and union tags are kept in à separate name space. K&R C uses a single name space
for members and tags, so members can’t have the same name (with some excep-
tions). and members and tags can’t overlap.

K&R C doesn’t allow structures to be assigned, passed as arguments. or returned
by functions.

K&R C doesn’t support enumerations.

***************************page_771***************************
746

17

void *

pointer mixing

pointers to functions

18

const andvolatile

initialization of arrays,
structures, and unions

25

wide characters

trigraph sequences

26

variable arguments

Appendix C C89 versus K&R C

Advanced Uses of Pointers

In C89, void * 1s used as a “generic” pointer type; for example. malloc returns
a value of type void *. In K&R C, char * 1s used for this purpose.

K&R C allows pointers of different types to be mixed in assignments and compar-
isons. In C89, pointers of type void * can be mixed with pointers of other types,
but any other mixing isn’t allowed without casting. Similarly, K&R C allows the
mixing of integers and pointers in assignments and comparisons; C89 requires
casting.

If p£ 1s a pointer to a function, C89 permits using either (*p£) (.….) orp£ (...) to
call the function. K&R C allows only (*p£) (...).

Declarations

K&R C doesn’t support the const and volatile type qualifiers.

K&R C doesn’t allow the initialization of automatic arrays and structures, nor does
it allow initialization of unions (regardless of storage duration).

International Features

K&R C doesn’t support wide character constants and wide string literals.

K&R C doesn’t support trigraph sequences.

Miscellaneous Library Functions

K&R C doesn’t provide a portable way to write functions with a variable number
of arguments, and it lacks the . . . (cllipsis) notation.

***************************page_772***************************
A

PPENDIX D

 

Standard Library Functions

This appendix describes all library functions supported by C89 and C99. When
using this appendix, please keep the following points in mind:

In the interest of brevity and clarity, l’ve omitted many details. Some functions
(notably printf and scan£ and their variants) are covered in depth else-
where in the book, so their descriptions here are minimal. For more informa-
tion about a function (including examples of how 1it’s used), see the section(s)
Histed in italic at the lower right corner of the function’s description.

Âs in other parts of the book, italics are used to indicate C99 differences. The
names and prototypes of functions that were added in C99 are shown in italics.
Changes to C89 prototypes (the addition of the word restrict to the decla-
ration of certain parameters) are also italicized.

Function-like macros are included in this appendix (with the exception of the

type-generic macros in <tgmath.h>). Each prototype for a macro is fol-
lowed by the word mmacro.

In C99. some <math.h> functions have threée versions (one each for float,
double, and 1long double). AlI three are grouped into a single entry,
under the name of the double version. For example, there’s only one entry
(under acos) for the acos, acosË£, and acos1l functions. The name of each
additional version (acosf and acosl, in this example) appears to the left of
its prototype. The <complex.h> functions, which also come in three ver-
sions, are treated in a similar fashion.

Most of the <wchar .h> functions are wide-character versions of functions
found in other headers. Unless there’s à significant difference in behavior, the

 

*This material is adapted from international standard ISO/IEC 9599:1999.

747

***************************page_773***************************
748

Appendix D _ Sitandard Library Functions

description of each wide-character function simply refers the reader to the cor-
responding function found elsewhere.

m lf some aspect of a function's behavior 1s described as implementation-
defined, that means that it depends on how the C library is implemented. The
function will always behave consistently, but the results may vary from one
system to another. (In other words, check the manual to see what happens.)
Undefined behavior, on the other hand. 1s bad news: not only may the behavior
vary between systems, but the program may act strangely or even crash.

m The descriptions of many <math.h> functions refer to the terms domain
error and range error. The way in which these errors are indicated changed
between C89 and C99. For the C89 treatment of these errors, see Section 23.3.
For the C99 treatment, see Section 23.4.

u The behavior of the following functions 1s affected by the current locale:

<ctype.h> AIl functions

<stdio.h> Formatted input/output functions

<stdlib.h>  Multibyte/wide-character conversion functions, numeric
conversion functions

<string.h> strcoll.strxfrm

<time.Hh> strftime

<wchar .h> wescoll. wosftime, wosxfrm, formatted input/output
functions. numeric conversion functions, extended
multibyte/wide-character conversion functions

<wctype.h>  AII functions

The isalpha function, for example, usually checks whether a character lies
between a and z or A and Z. In some locales, other characters are considered
alphabetic as well.

 

 

 

abort  Abort Program <stdlib.h>
void abort (void) ;
Raises the SIGABRT signal. If the signal isn't caught (or 1f the signal handler re-
turns), the program terminates abnormally and returns an implementation-defined
code indicating unsuccessful termination. Whether output buffers are flushed, open
streams are closed, or temporary files are removed 1s implementation-defined.
26.2
abs  Integer Absolute Value <stdlib.h>
int abs(int y) ;
Returns _ Absoluteé value of j. The behavior 1s undefined if the absolute value of j can’t be
represented. 26.2
acos … Arc Cosine <math.h>
double acos (double x) ;
acosf float acosf (float x);
acosl long double acosl (long double x);

***************************page_774***************************
Returns

 

Appendix D _ Standard Library Functions 749

Arc cosine of x; the return value is in the range O to T. À domain error occurs 1F x

 

 

 

 

 

 

isn’t between — ! and +1. 23.3
acosh  Arc Hyperbolic Cosine (C99) <math.h>
double acosh (double x) ;
acoshf float acoshf (float x);
acoshl! long double acoshl (long double x);
Returns _ Arc hyperbolic cosine of x; the return value is in the range O to +. À domain error
occurs if x is less than 1. 23.4
asctime … Convert Broken-Down Time to String <time.h>
char *asctime (const struct tm *timeptr) ;
Returns À pointer to a null-terminated string of the form
Sun Jun 3 17:48:34 2007\n
constructed from the broken-down time in the structure pointed to by timeptr.
26.3
asin Arc Sine <math.h>
double asin (double x) ;
asinf float asinf (float x);
asinl long double asinl (long double x) ;
Returns _ Arc sine of x; the return value is in the range —7/2 to +/2. À domain crror occurs
f X isn't between — | and +1. 23.3
asinh Arc Hyperbolic Sine (C99) <math.h>
double asinh (double x) ;
asinhf float asinhf (float x);
asinhl] long double asinhl (long double x) ;
Returns _ Arc hyperbolic sine of x. 23.4
assert  Assert Truth of Expression <assert .h>
void assert (scalar expression) ; macro
If the value of expression is nonzero, assert does nothing. If the value is
zero, assert writes a message to stderr (specifying the text of expression,
the name of the source file containing the assert, and the line number of the
assert); it then terminates the program by calling abort. To disable assert.
define the macro NDEBUG before including <assert .h>. C99 changes: The
argument is allowed to have any scalar type: C89 specifies that the type is int.
Also, C99 requires that the message written by assert include the name of the
function in which the assert appears; C89 doesn’t have this requirement. _ 24.7
atan Arc Tangent <math.h>
double atan (double x);
atanf float atanf (float x);

***************************page_775***************************
 

 

 

 

 

 

750 Appendix D _ Standard Library Functions
atanl long double atanl (long double x);
Returns _ Arc tangent of x: the return value is in the range —/2 to +7/2. 23.3
atanz2  Arc Tangent of Quotient <math.h>
double atan2 (double y, double x) ;
atanZf float atan2f (float y, float x);
atan2l long double atan21 (long double y, long double x);
Heturns _ Arc tangent of y/x: the return value is in the range — to +. À domain error may
occur 1f x and y are both zero. 23.3
atanh Arc Hyperbolic Tangent (C99) <math.h>
double atanh (double x),;
atanhf float atanhf (filoat x) ;
atanhl : long double atanhl (long double x);

Returns _ Arc hyperbolic tangent of x. A domain error occurs if x is not between —1 and +1.

À range error may occur if x is equal to —! or +1. 23.4
atexit … Register Function to Be Called at Program Exit <stdlib.h>

int atexit (void (*func) (void)) ;

Registers the function pointed to by func as a termination function. The function

will be called if the program terminates normally (via return or exit but not

abort).

Returns  Zero if successful, nonzero if unsuccessful (an implementation-dependent limit
has been reached). 26.2

atof  Convert String to Floating-Point Number <stdlib.h>
double atof (const char *nptr) ;

Returns À double value corresponding to the longest initial part of the string pointed to
by nptr that has the form of a floating-point number. Returns zero if no conver-
sion could be performed. The function’s behavior is undefined if the number can*t
be represented. 26.2

atoi … Convert String to Integer <stdlib.h>
int atoi (const char *nptr) ;

Returns An int value corresponding to the longest initial part of the string pointed to by
nptr that has the form of an integer. Returns zero if no conversion could be per-
formed. The function’s behavior is undefined if the number can*t be represented.

26.2
atol  Convert String to Long Integer <stdlib.h>
long int atol (const char *nptr) ;

Returns À long int value corresponding to the longest initial part of the string point-

ed to by nptr that has the form of an integer. Returns zero if no conversion

***************************page_776***************************
Appendix D _ Standard Library Functions 751

could be performed. The function’s behavior is undefined if the number can’t be

 

 

 

 

 

represented. 26.2
atoll  Convert String to Long Long Integer (C99) <stdlib.h>
long long int atoll (const char *nptr) ;

Returns A long long int value corresponding to the longest initial part of the string
pointed to by nptr that has the form of an integer. Returns zero if no conversion
could be performed. The function's behavior is undefined 1f the number can’t be
represented. 26.2

bsearch  Binary Search <stdlib.h>

void *bsearch(const void *key, const void *base,

size t memb, size t size,

int (*compar) (const void *,

const void *));

Searches for the value pointed to by key in the sorted array pointed to by base.
The array has nmemb elements, each size bytes long. compar 1s a pointer to a
comparison function. When passed pointers to the key and an array element, in
that order, the comparison function must return a negative, Zzero, or positive inte-
ger, depending on whether the key is less than. equal to, or greater than the array
element.

Returns A pointer to an array element that tests equal to the key. Returns à null pointer if
the key isn’t found. 26.2

btowc  Convert Byte to Wide Character (C99) <wchar .h>
wint t btowc(int c);

Returns  Wide-character representation of c. Returns WEOF if c is equal to EOF or if c
(when cast to unsigned char) isn’t a valid single-byte character in the initial
shift state. 25.5

cabs  Complex Absolute Value (C99) <complex.h>
double cabs (double complex Z2);

cabsf float cabsf (float complex Z) ;

cabsl Jlong double cabsl (long double complex z) ;

Returns  Complex absolute value of z. 274

cacos — Complex Arc Cosine (C99) <complex. h>
double complex cacos (double complex Z);
cacosf float complex cacosf (float complex Z) ;
cacosl Jlong double complex cacosl (long double complex z);
Returns  Complex arc cosine of z, with branch cuts outside the interval [-!, +1] along the

real axis. The return value lies in a strip mathematically unbounded along the
imaginary axis and in the interval [O, %] along the real axis. 27.4

***************************page_777***************************
752

Appendix D _ Standard Library Functions

 

cacosh

cacoshf

Complex Arc Hyperbolic Cosine (C99)

<complex.h>

double complex cacosh (double complex z) ;
float complex cacoshf (float complex z);

 

 

 

 

 

cacosh! long double complex cacoshl (long double complex z);
Returns  Complex arc hyperbolic cosine of z, with a branch cut at values less than | along
the real axis. The return value lies in a half-strip of nonnegative values along the
real axis and in the interval [-i, +i] along the imaginary axis. 27.4
calloc  Al/ocate and Clear Memory Block <stdlib.h>
void *calloc(size t nmemb, size t size);
Allocates a block of memory for an array with nmemb elements. each with size
bytes. The block is cleared by setting all bits to zero.
Returns _ À pointer to the beginning of the block. Returns a null pointer if a block of the
requested size can’t be allocated. 17,3
Carg  Complex Argument (C99) <complex.h>
double carg(double complex z);
cargf M float cargf (float complex z);
cargl _ long double cargl (long double complex z);
Returns _ Argument (phase angle) of z, with a branch cut along the negative real axis. The
return value lies in the interval [=—7, +x]. 27.4
casin … Complex Arc Sine (C99) <complex. h>
double complex casin (double complex z);
casinf float complex casinf (float complex z);
casinl long double complex casinl (long double complex z);
Returns  Complex arc sine of z. with branch cuts outside the interval [—1. +1] along the real
axis. The return value lies in a strip mathematically unbounded along the imagi-
nary axis and in the interval [-x/2, +7/2] along the real axis. 27.4
casinh  Complex Arc Hyperbolic Sine (C99) <complex.h>
double complex casinh(double complex z);
casinhf ; float complex casinhf (float complex z);
casinhl!  long double complex casinhl (long double complex z);
Returns  Complex arc hyperbolic sine of z, with branch cuts outside the interval [=i, +/]
along the imaginary axis. The return value lies in a strip mathematically unbounded
along the real axis and in the interval [-i/2, +ix/2] along the imaginary axis. 274
catan … Complex Arc Tangent (C99) <complex.h>
double complex catan (double complex z);
catanf ; float complex catanf (float complex z);
catanl long double complex catanl (long double complex z);

***************************page_778***************************
Appendix D _ Standard Library Functions 753

 

 

 

 

 

 

 

Returns  Complex arc tangent of z, with branch cuts outside the interval [-i, +i] along the
imaginary axis. The return value lies in a strip mathematically unbounded along
the imaginary axis and in the interval [+1/2, +7/2] along the real axis. 27.4
catanh  Complex Arc Hyperbolic Tangent (C99) <complex.h>
double complex catanh (double complex z);
catanhf float complex catanhf (float complex zZ);
catanhl! Jlong double complex catanhl (long double complex zZ);
Returns  Complex arc hyperbolic tangent of z, with branch cuts outside the interval [-!, +1]
along the real axis. The return value lies in a strip mathematically unbounded
along the real axis and in the interval |-iz/2. +ix/2] along the imaginary axis. 27.4
cbrt  Cube Root (C99) <math.h>
double cbrt (double x);
cbrtf float cbrtf(float x);
cbrtl Jlong double cbrtl (long double x);
Returns Real cube root of x. 23.4
Ccos — Complex Cosine (C99) <complex.h>
double complex ccos (double complex z);
ccosf float complex ccosf (float complex z);
ccosl Jlong double complex ccosl (long double complex z);
Returns  Complex cosine of z. 27.4
ccosh  Complex Hyperbolic Cosine (C99) <complex.h>
double complex ccosh(double complex z);
ccoshf float complex ccoshf (float complex z);
ccosh! Jlong double complex ccoshl (long double complex z);
Returns  Complex hyperbolic cosine of z. 27.4
ceil  Ceiling <math.h>
double ceil (double x) ;
ceilf float ceilf(float x);
ceill Jlong double ceill (long double x);
Returns  Smallest integer that is greater than or equal to x. 23.3
cexp … Complex Base-e Exponential (C99) <complex.h>
double complex cexp (double complex z);
cexpf float complex cexpf (float complex z);
cexpl long double complex cexpl (long double complex z);
Returns  Complex base-e exponential of z. 27.4
cimag  Imaginary Part of Complex Number (C99) <complex.h>

double cimag (double complex z);

***************************page_779***************************
754

Appendix D _ Standard Library Functions

 

cimagf :float cimagf (float complex z);

cimagl :long double cimagl (long double complex z);

Returns _ Imaginary part of z. 27.4
clearerr Clear Stream Error <stdio.h>

void clearerr (FILE *stream) ;

Clears the end-of-file and error indicators for the stream pointed to by stream.

 

22.3

Clock  Processor Clock <time.h>
clock t clock (void) ;

Returns _ Elapsed processor time (measured in “clock ticks”) since the beginning of program

execution. (To convert into seconds, divide by CLOCKS PER SEC.) Returns
(clock_t) (-1) if the time is unavailable or can*t be represented. 26.3

 

clog

clogf
clogl

Returns

Complex Natural Logarithm (C99) <complex.h>

double complex clog(double complex z);
float complex clogf (float complex z);
long double complex clogl (long double complex z);

Complex natural (base-e) logarithm of z, with a branch cut along the negative real
axis. The return value lies in à strip mathematically unbounded along the real axis
and in the interval [-ix. +ixc] along the imaginary axis. 27.4

 

 

 

 

CONn]j … Complex Conjugate (C99) <complex.h>
double complex conj (double complex z);
conjf float complex conjf(float complex z);
conjl  long double complex conjl(long double complex z) ;
Returns  Complex conjugate of z. 27.4
copysign  Copy Sign (C99) <math.h>
double copysign (double x, double y);
copysign£ float copysign£f (float x, Ffloat y);
copysignl long double copysignl (long double x, long double y) ;
Returns _ À value with the magnitude of x and the sign of y. 23.4
COS — Cosine <math.h>
double cos (double x) ;
cosf float cosf(float x);
cosl long double cosl (long double x);
Returns _ Cosine of x (measured in radians). 23.3
Ccosh  Hyperbolic Cosine <math.h>
double cosh(double x) ;
coshf ; float coshf(float x);

***************************page_780***************************
Appendix D _ Standard Library Functions 755

 

 

 

 

 

 

coshl 1long double coshl (long double x);
Returns Hyperbolic cosine of x. À range error occurs if the magnitude of x is too large.
23.3
cpow  Complex Power (C99) <complex.h>
double complex cpow(double complex x,
double complex y) ;
cpowf float complex cpowf (float complex x,
float complex y);
cpowl Iong double complex cpowl (long double complex x,
long double complex y) ;
Returns x raised to the power y, with a branch cut for the first parameter along the negative
real axis. 27.4
cpro]j  Complex Projection (C99) <complex.h>
double complex cproj (double complex z);
cprojf float complex cprojf(float complex z);
cprojl Jlong double complex cprojl (long double complex z);
Returns  Projection of z onto the Riemann sphere. z is returned unless one of its parts IS
infinite, in which case the return value is INFINITY + I * copysign(0.0,
cimag(z)). 27.4
creal  Real Part of Complex Number (C99) <complex.h>
double creal (double complex Zz) ;
crealf  float crealf(float complex Z);
creall Jlong double creall (long double complex z);
Returns Real part of z. 27.4
csin  Complex Sine (C99) <complex.h>
double complex csin (double complex z) ;
csinf float complex csinf (float complex z);
csinl 1long double complex csinl (long double complex z) ;
Returns  Complex sine of z. 27.4
csinh  Complex Hyperbolic Sine (C99) <complex.h>
double complex csinh(double complex z);
csinhf float complex csinhf (float complex z);
csinhl Jlong double complex csinhl (long double complex Z) ;
Returns  Complex hyperbolic sine of z. 27.4
csqrt  Complex Square Root (C99) <complex.h>
double complex csgrt (double complex Zz);
csqrtf float complex csqrtf(float complex 2);
csqrtl long double complex csgqrtl(long double complex Z ) ;

***************************page_781***************************
 

 

 

 

 

 

 

756 Appendix D _ Standard Library Functions
Heturns  Complex square root of z, with a branch cut along the negative real axis. The
return value lies in the right half-plane (including the imaginary axis). 27.4
ctan  Complex Tangent (C99) <complex.h>
double complex ctan (double complex z);
ctanf ; float complex ctanf (float complex z);
ctanl long double complex ctanl (long double complex z);
Returns  Complex tangent of z. 27.4
ctanh  Complex Hyperbolic Tangent (C99) <complex.h>
double complex ctanh (double complex z);
ctanhf float complex ctanhf (float complex z);
ctanhl _ long double complex ctanhl (long double complex z);
Returns  Complex hyperbolic tangent of z. 27.4
ctime … Convert Calendar Time to String <time.h>
char *ctime (const time t *timer) ;
Returns _ À pointer to a string describing a local time equivalent to the calendar time pointed
to by timer. Equivalent to asctime (localtime (timer)). 26.3
difftime  Time Difference <time.h>
double difftime (time t timel, time t timeo) ;
Heturns _ Difference between timeo (the earlier time) and time1. measured in seconds.
26.3
div  Integer Division <stdlib.h>
div_t div(int numer, int denom) ;
Returns À div-_t structure containing members named quot (the quotient when numer
is divided by denom) and rem (the remainder). The behavior is undefined if either
part of the result can’t be represented. 26.2
erf Error Function (C99) <math.h>
double erf (double x) ;
erff float erff(float x);
erf!l long double erfl(long double x);
Returns _ erf(x), where erf is the Gaussian error function. 23.4
erfc  Complementary Error Function (C99) <math.h>
double erfc (double x) ;
erfcf£f float erfcf(float x);
erfcl! 1long double erfcl (long double x);
Returns erftc(x) = | — erf(x), where erf is the Gaussian error function. A range error occurs
If x 18 too large. 23.4

***************************page_782***************************
Appendix D _ Standard Library Functions 757

 

 

 

 

 

 

exit — Exit ffom Program <stdlib.h>
void exit (int status) ;
Calls all functions registered with atexit, fushes all output buffers, closes all
open streams, removes any files created by tmpfile. and terminates the pro-
gram. The value of status indicates whether the program terminated normally.
The only portable values for status are 0 and EXIT_SUCCESS (both indicate
successful termination) plus EXIT_FAILURE (unsuccessful termination).
9.5, 26.2
_ Exit  Exit from Program (C99) <stdlib.h>
void _Exit (int status);
Causes normal program termination. Doesn’t call functions registered_with
atexit or signal handlers registered with signal. The status returned is deter-
mined in the same way as for exit. Whether output buffers are flushed, open
streams are closed, or temporary files are removed is implementation-defined.
26.2
exp — Base-e Exponential <math.h>
double exp (double x) ;
expf float expf(float x);
expl long double expl (long double x);
Returns e raised to the power x. À range error occurs if the magnitude of x is too large.
23.3
exp2  Base-2 Exponential (C99) <math.h>
double exp2 (double x) ;
exp2f  float exp2f (float x);
exp21 Jlong double exp21(1ong double x);
Returns 2 raised to the power x. À range error occurs if the magnitude of x is too large.
23.4
expml _ Base-e Exponential Minus 1 (C99) <math.h>
double expm1 (double x) ;
expmlf  float expmif (float x);
expmll long double expm1l (long double x);
Returns e raised to the power x. minus |. À range error occurs if x is Loo large. 23.4
£abs  Floating Absolute Value <math.h>
double £abs (double x) ;
fabsf  float fabsf (float x);
fabs] 1long double fabsl(long double x);
Returns _ Absolute value of x. 23.3

***************************page_783***************************
 

 

 

 

 

 

758 Appendix D _ Standard Library Functions
fclose Close File <stdio.h>
int fclose (FILE *stream) ;
Closes the stream pointed to by stream. Flushes any unwritten output remaining
in the stream’s buffer. Deallocates the buffer if it was allocated automatically.
Returns _ Zero 1f successful, EOF if an error was detected. 22.2
fdim  Positive Difference (C99) <math.h>
double fdim(double x, double y);
fdimf float fdimf (float x, float y);
fdiml _ long double fdiml (long double x, 1ong double y);
Returns _ Positive difference of x and y:
x-y 1Ifx>y
+0 {fx<y
À range error may oceur. 23.4
feclearexcept  Clear Floating-Point Exceptions (C99) <fenv.h>
int feclearexcept (int excepts) ;
Attempts to clear the floating-point exceptions represented by excepts.
Returns  Zero if excepts is zero or if all specified exceptions were successfully cleared:
otherwise, returns a nonzero value. 27.6
fegetenv  Get Floating-Point Environment (C99) <fenv.h>
int fegetenv(fenv t *envp);
Attempts to store the current floating-point environment in the object pointed to by
envp.
Returns  Zero if the environment was successfully stored: otherwise, returns a nonzero
value. 27.6
fegetexceptflag  Get Floating-Point Exception Flags (C99) <f£env.h>
int fegetexceptflag(fexcept t *flagp, int excepts) ;
Atlempts to retrieve the states of the floating-point status flags represented by
excepts and store them in the object pointed to by £lagp.
Returns _ Zero if the states of the status flags were successfully stored: otherwise, returns a
nonzero value. 27.6
fegetround Get Floating-Point Rounding Direction (C99) <fenv.h>
int fegetround (void) ;
Returns _ Value of the rounding-direction macro that represents the current rounding direc-

tion. Returns a negative value if the current rounding direction can*t be determined
or doesn’t match any rounding-direction macro. 27.6

***************************page_784***************************
 

 

 

 

 

 

 

Appendix D _ Standard Library Functions 759
feholdexcept  Save Floating-Point Environment (C99) <fenv.h>
int feholdexcept (fenv_t *envp) ;
Saves the current floating-point environment in the object pointed to by envp.
clears the floating-point status flags, and attempts to install a non-stop mode for all
floating-point exceptions.
Returns Zero if non-stop floating-point exception handling was successfully installed; oth-
erwise, returns a nonzero value. 27.6
feof  Test for End-of-File <stdio.h»>
int feof (FILE *stream) ;
Returns A nonzero value if the end-of-file indicator is set for the stream pointed to by
stream; otherwise, returns Zéro. 22.3
feraiseexcept _ Raise Floating-Point Exceptions (C99) <fenv.h>
int feraiseexcept (int excepts) ;
Attempts to raise supported floating-point exceptions represented by excepts.
Returns Zero if excepts is zero or if all specified exceptions were successfully raised:
otherwise, returns a nonzero value. 27.6
ferror Test for File Error <stdio.h>
int ferror (FILE *stream) ;
Returns A nonzero value if the error indicator is set for the stream pointed to by stream;
otherwise, returns zero. 22.3
fesetenv  Set Floating-Point Environment (C99) <fenv.h>
int fesetenv(const fenv t *envp);
Attempts to establish the fMoating-point environment represented by the object
pointed to by envp.
Returns Zero if the environment was successfully established: otherwise, returns a nonzero
value. 27.6
fesetexceptflag  Set Floating-Point Exception Flags (C99) <fenv.h>
int fesetexceptflag(const fexcept t *flagp,
int excepts) ;
Attempts to set the floating-point status flags represented by excepts to the
states stored in the object pointed to by £lagp.
Returns Zero if excepts is Zero or if all specified exceptions were successfully set: other-
wise, returns a nonzero value. 27.6
fesetround  Set Floating-Point Rounding Direction (C99) <fenv.h>

int fesetround (int round) ;

***************************page_785***************************
760 Appendix D _ Standard Library Functions

Attempts to establish the rounding direction represented by round.

 

 

 

 

 

 

Returns _ Zero 1f the requested rounding direction was established; otherwise, returns a non-
Zero value. 27.6
fetestexcept  Test Floating-Point Exception Flags (C99) <fenv.h>
int fetestexcept (int excepts) ;
Returns  Bitwise or of the fMoating-point exception macros corresponding to the currently
set flags for the exceptions represented by excepts. 27.6
feupdateenv  Update Floating-Point Environment (C99) <fenv.h>
int feupdateenv (const fenv t *envp);
Attempts to save the currently raised floating-point exceptions. install the floating-
point environment represented by the object pointed to by envp, and then raise the
saved exceptions.
Returns Zero if all actions were successfully carried out; otherwise, returns a nonzero
value. 27.6
fflush  Flush File Buffer <stdio.h>
int fflush(FILE *stream) ;
Writes any unwritten data in the buffer associated with stream, which points to a
stream that was opened for output or updating. If stream is a null pointer.
fflush flushes all su'eams that have unwritten data stored in a buffer.
Returns _ Zero 1f successful, EOF 1f à Write error occurs. 22.2
fgetc  Read Character from File <stdio.h>
int fgetc (FILE *stream) ;
Reads à character from the stream pointed to by stream.
Returns  Character read from the stream. Lf fgetc encounters the end of the stream, it sets
the stream’s end-of-file indicator and returns EOF. If a read error occurs, Égetc
sets the stream’s crror indicator and returns EOF. 22.4
fÉgetpos Get File Position <stdio.h>
int fgetpos (FILE * restrict stream,
fpos t * restrict pos) ;
Stores the current position of the stream pointed to by stream in the object
pointed to by pos.
Returns  Zero if successful. If the call fails, returns a nonzero value and stores an implemen-
tation-defined positive value in errno. 22.7
fgets Read String from File <stdio.h>

char *fgets(char * restrict s, int n,
FILE * restrict stream) ;

***************************page_786***************************
Appendix D _ Standard Library Functions 761

Reads characters from the stream pointed to by stream and stores them in the
array pointed to by s. Reading stops at the first new-line character (which is stored
in the string), when n — | characters have been read, or at end-of-file. £gets
appends a null character to the string.

 

 

 

 

 

 

Returns s (a pointer to the array in which the input is stored). Returns a null pointer if a
read error occurs or fgets encounters the end of the stream before it has stored
any characters. 22.5
fgetwc  Read Wide Character from File (C99) <wchar .h>
wint t fgetwc (FILE *stream) ;
Wide-character version of £getc. 25.5
Fgetws  Read Wide String from File (C99) <wchar .h>
wchar t *fgetws (wchar t * restrict s, int n,
FILE * restrict stream) ;
Wide-character version of Égets. 25.5
£floor Floor <math.h>
double floor (double x) ;
floorf float floorf (float x);
floor1 Jlong double floor1l(long double x);
Returns _ Largest integer that is less than or equal to x. 23.3
fma  Floating Multiply-Add (C99) <math.h>
double fma (double x, double y, double z);
fmaf  float fmaf(float x, float y, float z);
fmal 1long double fmal (long double x, long double y,
long double z);
Returns (x x y)+ z. The result is rounded only once, using the rounding mode correspond-
ing to FLT ROUNDS. À range error may occur. 23.4
fmax  Floating Maximum (C99) <math.h>
double fmax (double x, double y);
fmaxf float fmaxf (float x, float y);
fmax]! 1long double fmaxl (long double x, long double y);
Returns  Maximum of x and y. If one argument is a NaN and the other is numeric, the
numeric value 1s returned. 23.4
fmin — Floating Minimum (C99) <math.h>
double fmin (double x, double y);
fminf float fminf (float x, float y);
fminl Jong double fminl (long double x, long double y);
Returns  Minimum of x and y. If one argument is a NaN and the other is numeric, the

numeric value ts returned. 23.4

***************************page_787***************************
762 Appendix D _ Standard Library Functions

 

 

 

 

 

 

fmod  Floating Modulus <math.h>
double fmod (double x, double y) ;
fmodf float fmodf (float x, float y);
fmodl!  long double fmodl (1ong double x, long double y);
Returns  Remainder when x is divided by y. 1f y is zero, either a domain error occurs or
Zero 1s returned. 23.3
fopen  Open File <stdio.h>
FILE *Éopen(const char * restrict filename,
const char * restrict mode) ;
Opens the file whose name is pointed to by filename and associates it with a
stream. mode specifies the mode in which the file is to be opened. Clears the error
and end-of-file indicators for the stream.
Returns À file pointer to be used when performing subsequent operations on the file.
Returns a null pointer if the file can’t be opened. 22.2
fpclassi£fy  Floating-Point Classification (C99) <math.h>
int fpclassify (real-floating x) ; macro
Returns  Either FP_INFINITE, FP_NAN, FP_NORMAL, FP_SUBNORMAL, or FP_ZERO,
depending on whether x 1s infinity, not a number, normal. subnormal, or zero.
respectively. 23.4
Éprint£  Formatted File Write <stdio.h>
int fprintf (FILE * restrict stream,
const char * restrict format, ...);
Writes output to the stream pointed to by stream. The string pointed to by
format specifies how subsequent arguments will be displayed.
Returns  Number of characters written. Returns a negative value if an error occurs. 22.3
fputc  Write Character to File <stdio.h>
int fputc(int c, FILE *stream) ;
Writes the character c to the stream pointed to by stream.
Returns c (the character written). If a write error occurs, fputc sets the stream's error
indicator and returns EOF. 22.4
Éputs  Write String to File <stdio.h>
int fputs(const char * restrict s,
FILE * restrict stream) ;
Writes the string pointed to by s to the stream pointed to by stream.
Returns _ À nonnegative value if successful. Returns EOF if a write error occurs. 22.5

***************************page_788***************************
Appendix D _ Standard Library Functions 763

 

 

 

 

 

 

Éfputwc  Write Wide Character to File (C99) <wchar .h>
wint t fputwc(wchar t c, FILE *stream) ;
Wide-character version of £Éputc. 25.5
fputws  Write Wide String to File (C99) <wchar.h»>
int fputws (const wchar t * restrict s,
FILE * restrict stream) ;

Wide-character version of fputs. 25.5
fread  Read Block from File <stdio.h>
size t fread(void * restrict ptr, size t size,

size t nmemb, FILE * restrict stream) ;
Attempts to read nmemb elements, each size bytes long, from the stream pointed
to by stream and store them in the array pointed to by ptr.
Returns  Number of elements actually read. This number will be less than nmemb if fread
encounters end-of-file or a read error occurs. Returns zero if either nmemb or
size 1s Zero. 22.6
free Free Memory Block <stdlib.hs
void free (void *ptr) ;
Releases the memory block pointed to by ptr. (If ptr is a null pointer, the call
has no effect.) The block must have been allocated by à call of calloc, malloc,
orrealloc. 17.4
freopen — Reopen File <stdio.h>
FILE *freopen (const char * restrict filename,
const ckar * restrict mode,
FILE * restrict stream) ;
Closes the file associated with stream, then opens the file whose name is pointed
to by filename and associates it with stream. The mode parameter has the
same meaning as in a call of fopen. C99 change: 1f £ilename 1s a null pointer,
Éreopen attempts to change the strean’s mode to that specified by mode.
Returns Value of stream if the operation succeeds. Returns à null pointer if the file can’t
be opened. 22.2
frexp — Split into Fraction and Exponent <math.hs>
double frexp (double value, int *exp) ;
frexpf float frexpf (float value, int *exp);
frexpl 1long double frexp1 (long double value, int *exp);

Splits value into a fractional part f and an exponent » in such a way that

value =/x 2"

***************************page_789***************************
764 Appendix D _ Standard Library Functions

fis normalized so that either 0.5 < /< 1 orf= 0. Stores n in the object pointed to by

 

 

 

 

 

exp.
Returns f, the fractional part of value. 23.3
Éscan£t  Formatted File Read <stdio.h>
int fscanf (FILE * restrict stream,
const char * restrict format, ...);
Reads input items from the stream pointed to by stream. The string pointed to by
Éormat specifies the format of the items to be read. The arguments that follow
format point to objects in which the items are to be stored.
Returns  Number of input items successfully read and stored. Returns EOF if an input fail-
ure occurs before any items can be read. 22.3
fseek  File Seek <stdio.h>
int fseek (FILE *stream, long int offset, int whence) ;
Changes the file position indicator for the stream pointed to by stream. If
whence is SEEK SET, the new position is the beginning of the file plus of fset
bytes. 1f whence is SEEK _ CUR, the new position is the current position plus
offset bytes. If whence is SEEK _ END, the new position is the end of the file
plus offset bytes. The value of offset may be negative. For text streams,
either offset must be zero or whence must be SEEK SET and offset a
value obtained by a previous call of Étell. For binary streams, f£seek may not
support calls in which whence is SEEK END.
Returns _ Zero 1f the operation 1s successful. nonzero otherwise. 22,7
fsetpos Set File Position <stdio.h>
int fsetpos (FILE *stream, const Épos t *pos) ;
Sets the file position indicator for the stream pointed to by stream according to
the value pointed to by pos (obtained from a previous call of fgetpos).
Returns _ Zero if successful. If the call fails, returns a nonzero value and stores an implemen-
tation-defined positive value in errno. 22.7
ftell  Determine File Position <stdio.h>
long int ftell (FILE *stream) ;
Returns Current file position indicator for the stream pointed to by stream. If the call
fails, returns -1L and stores an implementation-defined positive value in errno.
221
fwide Get and Set Stream Orientation (C99) <wchar .h>

int fwide (FILE *stream, int mode) ;

Determines the current orientation of a stream and, if desired, attempts to set its
orientation. If mode 1s greater than zero, fwide tries to make the stream wide-
oriented if it has no orientation. If mode 1s less than zero, it tries to make the

***************************page_790***************************
Appendix D  Standard Library Functions 765

stream byte-oriented 1F it has no orientation. If mode 1s zero, the orientation is not
changed.

 

 

 

 

 

 

Returns _ À positive value if the stream has wide orientation after the call, a negative value 1f
it has byte orientation, or zero 1f it has no orientation. 25.5
fwprintf  Wide-Character Formatted File Write (C99) <wchar .h>
int fwprintf (FILE * restrict stream,
const wckar t * restrict format, ...);
Wide-character version of fprint£. 25.5
EÉwrite  Write Block to File <stdio.h>
size t fwrite(const void * restrict ptr, size t size,
size t nmemb, FILE * restrict stream) ;
Writes nmemb elements, each size bytes long, from the array pointed to by ptr
to the stream pointed to by stream.
Returns  Number of elements actually written. This number will be less than nmemb f a
write error occurs. In C99. returns zero if either nmemb or size 1s Zzero. 22,6
{wscan£f£  Wide-Character Formatted File Read (C99) <wchar .h>
int fwscanf (FILE * restrict stream,
const wchar t * restrict format, ...);
Wide-character version of £scanf. 25.5
getc  Read Character from File <stdio.h>
int getc (FILE *stream) ;
Reads a character from the stream pointed to by stream. Nore: getc 1s normally
implemented as a macro: it may evaluate stream more than once.
Returns  Character read from the stream. If getc encounters the end of the stream, it sets
the stream’s end-of-file indicator and returns EOF. If a read error occurs, getc sets
the stream's error indicator and returns EOF. 22.4
getchar Read Character <stdio.h>
int getchar (void) ;
Reads a character from the stdin stream. Note: getchar 1s normally imple-
mented as a macro.
Returns  Character read from the stream. If getchar encounters the end of the stream, 1t
sels the stream’s end-of-file indicator and returns EOF. I{f à read error occurs,
getchar sets the stream’s error indicator and returns EOF. 7.3, 22.4
getenv  GetEnvironment String <stdlib.h>

char *getenv (const char *name) ;

Searches the operating system’s environment list to see if any string matches the
one pointed to by name.

***************************page_791***************************
 

 

 

 

 

 

 

766 Appendix D _ Standard Library Functions

Returns À pointer to the string associated with the matching name. Returns a null pointer if
no match 1s found. 26.2

gets Read String <stdio.h>
char *gets (char *s) ;

Reads characters from the stdin stream and stores them in the array pointed to
by s. Reading stops at the first new-line character (which 1s discarded) or at end-
of-file. gets appends à null character to the string.

Returns s (a pointer to the array in which the input is stored). Returns à null pointer if a
read error occurs or gets encounters the end of the stream before it has stored any
characters. 13.3, 22.5

getwc  Read Wide Character from File (C99) <wchar.h>
wint t getwc(FILE *stream) ;
Wide-character version of getc. 25.5
getwchar Read Wide Character (C99) <wchar .h>
wint_t getwchar (void) ;
Wide-character version of getchar. 25.5
gmtime — Convert Calendar Time to Broken-Down UTC Time <time.h>
struct tm *gmtime (const time t *timer) ;

Returns À pointer to à structure containing a broken-down UTC time equivalent to the cal-
endar time pointed to by timer. Returns a null pointer 1f the calendar time can't
be converted to UTC. 26.3

hypot  Hypotenuse (C99) <math.h>
double hypot (double x, double y);

hypot£ float hypotf (float x, float y);

hypotl 1Iong double hypotl (long double x, long double y);

Returns Jx* + y" (the hypotenuse of a right triangle with legs x and y). À range error may

OCCUF. 23.4
ilogb Unbiased Exponent (C99) <math.h>
int ilogb (double x) ;
ilogb£f int ilogbf (float x);
ilogb] int ilogbl (long double x) ;

Returns  Exponent of x as a signed integer; equivalent to calling the corresponding 1ogb
function and casting the returned value to type int. Returns FP ILOGBO if x is
zero, INT _MAX if x 1s infinite, and FP_ILOGBNAN if x is a NaN; a domain error
or range error may occur in these cases. 23.4

imaxabs  Greatest-Width Integer Absolute Value (C99) <inttypes.h>

intmax t imaxabs (intmax t j);

 

***************************page_792***************************
Appendix D _ Standard Library Functions 767

 

 

 

 

 

 

 

 

 

Returns _ Absolute value of j. The behavior is undefined if the absolute value of j can’t be
represented. 27.2
imaxdiv  Greatest-Width Integer Division (C99) <inttypes.h>
imaxdiv t imaxdiv(intmax t numer, intmax t denom) ;
Returns _ À structure of type imaxdiv t containing members named quot (the quotient
when numer is divided by denom) and rem (the remainder). The behavior 1s
undefined if either part of the result can’t bc represented. 27.2
isalnum  Test for Alphanumeric <ctype.h>
int isalnum(int c) ;
Returns À nonzero value if c is alphanumeric and zero otherwise. (c is alphanumeric if
either isalpha (c) or isdigit (c) 1s true.) 23.5
isalpha  Test for Alphabetic <ctype.h>
int isalpha (int c) ;
Returns À nonzero value if c is alphabetic and zero otherwise. In the "C" locale, c is
alphabetic if either islower (c) or isupper (c) is true. 23.5
1isblank  Test for Blank (C99) <ctype.h>
int isblank(int c);
Returns _ À nonzero value if c is a blank character that is used to separate words within a
line of text. In the "C" locale. the blank characters are space (" ‘) and horizontal
tab (" \t£"). 23.5
isontrl  Test for Control Character <ctype.h>
int iscentrl (int c);
Returns À nonzero value 1f c is a control character and zero otherwise. 23.5
isdigit  Testfor Digit <ctype.h>
int isdigit (int c);
Returns _ À nonzero value 1f C is a decimal disit and zero otherwise. 23.5
isfinite Test for Finite Number (C99) <math.h>
int isfinite (real-floatine x) ; mMacro
Returns _ À nonzero value if x is finite (zero, subnormal, or normal, but not infinite or NaN)
and zero otherwise. 23.4
isgraph  Test for Graphical Character <ctype.h>
int isgraph(int c);
Returns _ À nonzero value if C is à printing character (except a space) and zero otherwise.
23.5
isgreater Test for Greater Than (C99) <math.h>

int isgreater (real-floating x, real-floatinge y) ; mMmacro

***************************page_793***************************
 

 

 

 

 

 

 

 

 

768 Appendix D _ Standard Library Functions
Returns _ (x) > (y). Unlike the > operator, isgreater doesn’t raise the invalid Foating-
point exception if one or both of the arguments 1S a NaN. 23.4
isgreaterequal  Test for Greater Than or Equal (C99) <math.h>
int isgreaterequal (real-floating x, real-floating y) ; Macro
Returns (x) >= (y). Unlike the >= operator, isgreaterequal doesn’t raise the
invalid floating-point exception if one or both of the arguments 1s a NaN. 23.4
isin£ Test for Infinity (C99) <math.h>
int isinf (real-floating x) ; macro
Returns À nonzero value if x is infinity (positive or negative) and zero otherwise. 23.4
isless  Test for Less Than (C99) <math.h>
int isless (real-floating x, real-floating y) ; macro
Returns (x) < (y). Unlike the < operator. isless doesn’t raise the invalid floating-
point exception if one or both of the arguments 1s a NaN. 23.4
1islessequal  Test for Less Than or Equal (C99) <math.h>
int islessequal (real-floatinge x, real-floatine y) ; Macro
Returns  (x) <= (y). Unlike the <= operator, islessequal doesn't raise the invalid
Foating-point exception 1f one or both of the arguments 1s a NaN. 23.4
islessgreater Testfor Less Than or Greater Than (C99) <math.h>
int islessgreater (real-floating x, real-floating y) ; IMacro
Returns  (x) < (y) || (x) > (y). Unlike this expression, islessgreater doesn’t
raise the invalid floating-point exceplion if one or both of the arguments is a NaN;
also, x and y are evaluated only once. 23.4
islower Test for Lower-Case Letter <ctype.h>
int islower (int C);
Returns À nonzero value if c 1s a lower-case letter and zero otherwise. 23.5
isnan — Test for NaN (C99) <math.h>
int isnan (real-floating Xx) ; Macro
Returns À nonzero value 1f x iS a NaN value and zero otherwise. 23.4
isnormal  Testfor Normal Number (C99) <math.h>
int isnormal (real-floating x) ; macro
Returns À nonzero value if x has a normal value (not zero, subnormal, infinite. or NaN)
and zero otherwise. 23.4
isprint  Test for Printing Character <ctype.h>

int isprint (int C);

***************************page_794***************************
Appendix D _ Standard Library Functions 769

 

 

 

 

 

 

 

Heturns _ À nonzero value if C is à printing character (including a space) and zero otherwise.

23.5

ispunct  Test for Punctuation Character <ctype.h>
int ispunct (int c);

Returns À nonzero value if C is a punctuation character and zero otherwise. AlI printing
characters except the space (" ‘) and the alphanumeric characters are considered
punctuation. C99 change: In the "C" locale, all printing characters except those
for which isspace or isalnumis true are considered punctuation. 23.5

isspace Test for White-Space Character <ctype.h>
int isspace (int c);

Reiurns À nonzero value if C is a white-space character and zero otherwise. In the "C"
locale, the white-space characters are space (" ‘'). form feed (" \£'), new-line
("\n'). carriage return (" \r'), horizontal tab (" \t " ). and vertical tab (" \v").

23.5
isunordered  Testfor Unordered (C99) <math.h>
int isunordered (real-floating x, real-floating y) ; Macro

Returns 1 if x and y are unordered (at least one is a NaN) and 0 otherwise. 23.4

isupper Test for Upper-Case Letter <ctype.h>
int isupper (int c),;
Returns À nonzero value if C is an upper-case letter and zero otherwise. 23.5
iswalnum  Test for Alphanumeric Wide Character (C99) <wctype.h>
int iswalnum(wint t wc);

Returns À nonzero value if wc is alphanumeric and zero otherwise. (wc is alphanumeric if

either iswalpha (wc) or iswdigit (wc) is true.) 25.6
iswalpha  Test for Alphabetic Wide Character (C99) <wctype .h>
int iswalpha (wint t wc);

Returns À nonzero value if wc is alphabetic and zero otherwise. (wc is alphabetic if
iswupper (wc) or iswlower (wc) is true. or if wc is one of a locale-specific
set of alphabetic wide characters for which none of iswentrl, iswdigit.
iswpunct, or iswspace 1s true.) 25.6

iswblank  Test for Blank Wide Character (C99) <wctype.h>
int iswblank(wint t wc);

Returns À nonzero value if wc is à standard blank wide character or one of a locale-specific

set of wide characters for which iswspace is true and that are used to separate
words within à line of text, In the "C" locale, iswblank returns true only for the
standard blank characters: space (L' ‘) and horizontal tab (L'\t'). 25.6

***************************page_795***************************
 

 

770 Appendix D  Standard Library Functions
iswontr1  Test for Control Wide Character (C99) <wctype.h>
int iswentrl (wint t wc);
Returns À nonzero value if wc is à control wide character and zero otherwise. 25.6
iswctype Test Type of Wide Character (C99) <wctype.h>
int iswctype (wint t wc, wctype t desc);
Returns A nonzero value if the wide character wc has the property described by desc.

(desc must be a value returned by a call of wotype; the current setting of the
LC_CTYPE category must be the same during both calls.) Returns zero otherwise.

 

 

 

 

 

 

25.6

iswdigit  Test for Digit Wide Character (C99) <wctype.h>
int iswdigit (wint € wc);

Returns À nonzero value if wc corresponds to a decimal digit and zero otherwise. 25.6

iswgraph  Test for Graphical Wide Character (C99) <wctype.h>
int iswgraph(wint t wc);

Returns A nonzero value if iswprint (wc) is true and iswspace (wc) is false.

Returns zero otherwise. 25.6

iswlower  Test forLower-Case Wide Character (C99) <wctype .h>
int iswlower (wint t wc);

Returns À nonzero value if wc corresponds to a lower-case letter or is one of a locale-

specific set of wide characters for which none of iswentrl, iswdigit.

iswpunct, or iswspace is true. Returns zero otherwise. 25.6

i1swprint  Test for Printing Wide Character (C99) <wctype.h»>
int iswprint (wint € wc);

Returns À nonzero value if wc is à printing wide character and zero otherwise. 25.6

iswpunct  Test for Punctuation Wide Character (C99) <wctype.h>
int iswpunct (wint t wc);

Returns À nonzero value if wc is a printing wide character that is one of a locale-specific

set of punctuation wide characters for which neither iswspace nor iswalnum

1s true. Returns zero otherwise. 25.6

iswspace  Test for White-Space Wide Character (C99) <wctype.h>
int iswspace (wint t wc);

Returns A nonzero value if wc is one of a locale-specific set of white-space wide characters

for which none of iswalnum, iswgraph, or iswpunct 1s true. Returns zero
otherwise. 25.6

***************************page_796***************************
 

 

 

 

 

 

 

 

Appendix D  Standard Library Functions 771
iswupper Test for Upper-Case Wide Character (C99) <wctype.h>
int iswupper (wint t wc);
Returns À nonzero value if wc corresponds to an upper-case letter or is one of a locale-
specific set of wide characters for which none of iswentrl, iswdigit.
iswpunct, or iswspace is true. Returns zero otherwise. 25.6
iswxdigit  Test for Hexadecimal-Digit Wide Character (C99) <wctype.h>
int iswxdigit (wint _ E wc);
Returns À nonzero value if wc corresponds to a hexadecimal digit (0-9, a-£f, A-F) and
zero otherwise. 25.6
isxdigit  Test for Hexadecimal Digit <ctype.h>
int isxdigit (int c);
Returns _ À nonzero value if c is a hexadecimal digit (0—9, a-f, A-F) and zero otherwise.
23.5
labs  Long Integer Absolute Value <stdlib.h>
long int labs(long int j);
Returns _ Absolute value of j. The behavior is undefined if the absolute value of j can’t be
represented. 26.2
ldexp  Combine Fraction and Exponent <math.h>
double 1dexp (double x, int exp);
ldexpf float 1dexpf(float x, int exp) ;
Jldexpl  long double 1dexpl(long double x, int exp);
Returns _x x 2°"P. A range error may oceur. 23.3
ldiv  Long Integer Division <stdlib.h>
ldiv t lIdiv(long int numer, long int denom) ;
Returns An 1div t structure containing members named quot (the quotient when
numer 1s divided by denom) and rem (the remainder). The béehavior is undefined
if either part of the result can*t be represented. 26.2
lgamma _ Logarithm of Gamma Function (C99) <math.h>
double 1Igamma (double x) ;
lgammaf float lgammaf (float x);
lgammal long double 1gammal (long double x) ;
Returns _ In(IF(<)l), where F is the gamma function. À range error occurs if x is too large
and may occur if x is a negative integer or zero. 23.4
lIabs  Long Long Integer Absolute Value (C99) <stdlib.h>

long long int 1labs(long Iong int j);

***************************page_797***************************
 

 

 

 

 

 

772 Appendix D _ Standard Library Functions
Returns _ Absolute value of j. The behavior is undefined if the absolute value of j can’t be
represented. 26.2
11div  Long Long Integer Division (C99) <stdlib.h>
1ldiv t 1lldiv(long long int numer,
long long int denom) ;
Returns An l1ldiv t structure containing members named quot (the quotient when
numer is divided by denom) and rem (the remainder). The behavior 1s undefined
if either part of the result can’t be represented. 26.2
llrint  Round to Long Long Integer Using Current Direction (C99) <math.h>
long long int 1lrint (double x) ;
1llrintf 1long long int llrintf(float x);
1l1lrint! J1long long int 11lrintl (long double x);
Returns x rounded to the nearest integer using the current rounding direction. IË the
rounded value is outside the range of the long long int type. the result 1s
unspecified and a domain or range error may occur. 23.4
1l1round  Round to Nearest Long Long Integer (C99) <math.h>
long long int 1lround (double x) ;
l1lroundf 1long long int l1lroundf (float x) ;
11roundl! 1long long int l1lroundl (long double x);
Returns x rounded to the nearest integer, with halfway cases rounded away from zero. If
the rounded value is outside the range of the long long int type, the result is
unspecified and a domain or range error may occeur. 23.4
localeconv  Get Locale Conventions <locale.h>
struct lconv *localeconv (void) ;
Reiturns _ À pointer to à structure containing information about the current locale. 25.1
localtime  Convert Calendar Time to Broken-Down Local Time <time.h>
struct tm *localtime (const time t *timer) ;
Returns À pointer to a structure containing a broken-down local time equivalent to the cal-
endar time pointed to by timer. Returns a null pointer if the calendar time can’t
be converted to local time. 26.3
log  Natural Logarithm <math.h>
double log(double x) ;
logf float logf (float x);
log! 1long double logl(long double x);
Returns Logarithm of x to the base e. À domain error occurs if x is negative. À range error

may occeur 1f x is Zero. 23.3

***************************page_798***************************
 

 

 

 

 

 

Appendix D _ Standard Library Functions 773
log10  Common Logarithm <math.h>
double log10 (double x) ;
logl0f  float logl0f (float x);
1log101 _ long double 109g101 (long double x);
Returns _ Logarithm of x to the base 10. À domain error occurs if x is negative. À range
error may occur if x is Zero. 23.3
loglp  Natural Logarithm of 1 Plus Argument (C99) <math.h>
double log1p (double x) ;
loglpf  float logipf (float x);
log1lpl 1long double 1og1p1 (long double x);
Returns  Logarithm of ! + x to the base e. À domain error occurs if x is less than —1. À
range error may occur if x 1s equal to — 1. 23.4
log2  Base-2 Logarithm (C99) <math.h>
double log2 (double x) ;
log2f float log2f(float x);
log21 1long double 10g21(long double x) ;
Returns _ Logarithm of x to the base 2. À domain error occurs if x is negative. À range error
may occur if x is Zero. 23.4
logb  Radix-Independent Exponent (C99) <math.h>
double l1ogb (double x) ;
logb£ float logbf (float x);
logbl] 1long double 1logbl (long double x);
Returns _ log,(Ixl). where r is the radix of floating-point arithmetic (defined by the macro
FLT RADIX, which typically has the value 2). À domain error or range error may
occur 1f x is Zero. 23.4
longjmp  Nonlocal Jump <setjmp.h>
void longjmp (jmp_buf env, int val);
Restores the environment stored in env and returns from the call of setjmp that
originally saved env. If val 1s nonzero. it will be setjmp's return value: if val
is O, setjmp returns 1. 24.4
Ilrint  Round to Long Integer Using Current Direction (C99) <math.h>
long int lrint (double x);
lrintf long int 1rintf(float x);
Jlrintl 1long int 1rintl (long double x) ;
Returns x rounded to the nearest integer using the current rounding direction. Tf the

rounded value is outside the range of the long int type, the result is unspecified
and a domain or range error may occur. 23.4

***************************page_799***************************
77& — Appendix D Standard Library Functions

 

 

 

 

 

lround  Round to Nearest Long Integer (C99) <math.h>
long int 1round (double x) ;
Ilroundf 1long int Iroundf (float x);
lround!l 1long int 1roundl (l1long double x);

Returns x rounded to the nearest integer, with halfway cases rounded away from zero. If
the rounded value ts outside the range of the long int type. the result is unspeci-
filed and a domain or range error may oceur. 23.4

malloc  A/ocate Memory Block <stdlib.h>
void *malloc(size t size);
Allocates a block of memory with si ze bytes. The block 1s not cleared.

Returns À pointer to the beginning of the block. Returns a null pointer if a block of the
requested size can’t be allocated. 17.2

mblen  Length of Multibyte Character <stdlib.h>
int mblen(const char *s, size t n);

Returns  If s is a null pointer, returns a nonzero or zero value, dépending on whether or not
multibyte characters have state-dependent encodings. Lf s points to a null charac-
ter, returns zero. Otherwise, returns the number of bytes in the multibyte character
pointed to by s; returns —1 1f the next n or fewer bytes don’t form a valid multibyte
character. 25.2

mbrlen  Length of Multibyte Character — Restartable (C99) <wchar.h»>
size t mbrlen(const char * restrict s, size t n,

mbstate t * restrict ps);

Determines the number of bytes in the array pointed to by s that are required to
complete a multibyte character. ps should point to an object of type mbstate t
that contains the current conversion state. À call of mbrlen is equivalent Lo
mbrtowc (NULL, s, n, ps)
except that if ps is à null pointer, the address of an internal objeet is used instead.

Returns  See mbrtowc. 25.5

mbrtowc  Convert Multibyte Character to Wide Character — Restartable <wchar .h>

(C99)

size t mbrtowc (wchar t * restrict pvwc,
const char * restrict s, size t n,
mbstate t * restrict ps);

If s is a null pointer, a call of mbrtowc 1s equivalent to
mbrtowc (NULL, "", 1, ps)

Otherwise, mbrtowc examines up to n bytes in the array pointed Lo by s to see if

***************************page_800***************************
Returns

 

Appendix D _ Standard Library Functions 776

they complete a valid multibyte character. If so, the multibyte character is con-
verted into a wide character. If pwc isn’t a null pointer, the wide character is stored
in the object pointed to by pwc. The value of ps should be a pointer to an object of
type mbstate t that contains the current conversion state. If ps is a null pointer,
mbrtowc uses an internal object to store the conversion state. If the result of the
conversion is the null wide character, the mbstate t object used during the call
is left in the initial conversion state.

0 if the conversion produces a null wide character. Returns a number between |
and n if the conversion produces a wide character other than null, where the value
returned is the number of bytes used to complete the multibyte character. Returns
(size t) (-2) if the n bytes pointed to by s weren’t enough to complete a
multibyte character. Returns (size t) (-1) and stores EILSEQ in errno if an
encoding error occurs. 25.5

 

mbsinit

Returns

Test for Initial Conversion State (C99) <wchar .h>

int mbsinit (const mbstate t *ps);

À nonzero value if ps is a null pointer or it points to an mbstate t object that
describes an initial conversion state: otherwise, returns zero. 25.5

 

mbsrtowcs

Returns

Convert Multibyte String to Wide String — Restartable (C99) <wchar.h>

size t mbsrtowcs (wchar t * restrict dst,
const char ** restrict src,
size t len, mbstate t * restrict ps);

Converts a sequence of multibyte characters from the array indirectly pointed to
by src into a sequence of corresponding wide characters. ps should point to an
object of type mbstate_t that contains the current conversion state. If the argu-
ment corresponding to ps is a null pointer, mbsrtowcs uses an internal object to
store the conversion state. If dst isn’t a null pointer, the converted characters are
stored in the array that it points to. Conversion continues up to and including à ter-
minating null character, which is also stored. Conversion stops earlier if a
sequence of bytes is encountered that doesn’t form a valid multibyte character
or—if dst isn’t a null pointer—when len wide characters have been stored in
the array. If dst isn’t a null pointer, the object pointed to by src is assigned
either a null pointer (if a terminating null character was reached) or the address
just past the last multibyte character converted (if any). If the conversion ends at a
null character and if dst isn't a null pointer, the resulting state is the initial con-
version state.

Number of multibyte characters successfully converted, not including any termi-
nating null character. Returns (size t) (-1) and stores EILSEQ in errno if
an invalid multibyte character is encountered. 25.5

 

mbstowcs

Convert Multibyte String to Wide String <stdlib.h>

size t mbstowcs (wchar t * restrict pwcs,
const char * restrict s, size t n);

***************************page_801***************************
776 Appendix D _ Standard Library Functions

Returns

Converts the sequence of multibyte characters pointed to by s into a sequence of
wide characters, storing at most n wide characters in the array pointed to by pwcs.
Conversion ends if à null character is encountered; it is converted into a null wide
character.

Number of array elements modified, not including the null wide character, if any.
Returns (size _t) (-1) tf an invalid multibyte character is encountered. — 252

 

mbtowc

Returns

Convert Multibyte Character to Wide Character <stdlib.h>

int mbtowc(wchar t * restrict pwc,
const char * restrict s, size t n);

If s isn’ta null pointer, converts the multibyte character pointed to by s into a wide
character; at most n bytes will be examined. Lf the multibyte character is valid and
pwc isn’t a null pointer, stores the value of the wide character in the object pointed
to by pwc.

If s is a null pointer, returns a nonzero or zero value, depending on whether or not
multibyte characters have state-dependent encodings. Lf s points to a null charac-
ter, returns zero. Otherwise, returns the number of bytes in the multibyte character
pointed to by s; returns —l if the next n or fewer bytes don*t form a valid multibyte
character. 25.2

 

memchr

Returns

Search Memory Block for Character <string.h»>
void *memchr (const void *s, int c, size t n);

À pointer to the first occurrence of the character c amonsg the first n characters of
the object pointed to by s. Returns a null pointer if c isn’t found. 23.6

 

memcmp

Returns

Compare Memory Blocks <string.h>
int mememp (const void *s1, const void *s2, size t n);

À negalive, zero, or positive integer, depending on whether the first n characters of
the object pointed to by s1 are less than. equal to, or greater than the first n char-
acters of the object pointed to by s2. 23.6

 

memcpy

Returns

Copy Memory Block <string.h>

void *memcpy (void * restrict sl,
const void * restrict s2, size t n);

Copies n characters from the object pointed to by s2 into the object pointed to by
s1. The behavior 1s undefined 1f the objects overlap.

s1 (a pointer to the destination). 23.6

 

memmove

Returns

Copy Memory Block <string.h>
void *memmove (void *s1, const void *s2, size t n);

Copies n characters from the object pointed to by s2 into the object pointed to by
sl. Will work properly if the objects overlap.

s1 (a pointer to the destination). 23.6

***************************page_802***************************
Appendix D _ Standard Library Functions _ 777

 

 

 

 

 

 

memset  /nitialize Memory Block <string.h>
void *memset (void *s, int c, size t n);
Stores c in each of the first n characters of the object pointed to by s.
Returns _s (a pointer to the object). 23.6
mktime  Convert Broken-Down Local Time to Calendar Time <time.h>
time t mktime(struct tm *timeptr) ;
Converts a broken-down local time (stored in the structure pointed to by time-
ptr) into a calendar time. The members of the structure aren't required to be
within their legal ranges; also, the values of tm_wday (day of the week) and
tm_yday (day of the year) are ignored. mkt ime stores values in tm_wday and
tm _ yday after adjusting the other members to bring them into their proper
ranges.
Returns À calendar time corresponding to the structure pointed to by timeptr. Returns
(time t) (-1) if the calendar time can’t be represented. 26.3
mod£  Split into Integer and Fractional Parts <math.h>
double modf (double value, double *iptr) ;
modff float modff (float value, float *iptr) ;
modfl 1long double modf]l (1long double value, long double *iptr);
Splits value into integer and fractional parts; stores the integer part in the object
pointed to by iptr.
Returns  Fractional part of value. 23.3
nan — Create NaN (C99) <math.h>
double nan(const char *tagp) ;
nanf float nanf (const char *tagp) ;
nanl long double nanl (const char *tagp) ;
Returns A “quiet” NaN whose binary pattern is determined by the string pointed to by
tagp. Returns zero 1f quiet NaNs aren’t supported. 23.4
nearbyint  Round to Integral Value Using Current Direction (C99) <math.h»>
double nearbyint (double x) ;
nearbyintf float nearbyintf (float x);
nearbyintl 1long double nearbyintl (long double x) ;
Returns x rounded to an integer (in floating-point format) using the current rounding direc-
tion. Doesn*t raise the irexact floating-point exception. 23.4
nextafter Next Number After (C99) <math.h>
double nextafter (double x, double y);
nextafterf float nextafterf (float x, float y);
nextafter! 1long double nextafterl (long double x, long double y);

***************************page_803***************************
 

 

 

 

 

 

778 Appendix D _ Standard Library Functions
Returns _ Next representable value after x in the direction of y. Returns the value just before
x 1f y < x or the value just after x if x < y. Returns y if x equals y. À range error
may occur if the magnitude of x is the largest representable finite value and the
result is infinite or not representable. 23.4
nexttoward Next Number Toward (C99) <math.h>
double nexttoward(double x, long double y);
nexttowardf float nexttowardf (float x, long double y);
nexttowardl long double nexttoward]l (1long double x, long double y);
Returns _ Next representable value after x in the direction of y (sce nextafter). Returns
y converted to the function’s type if x equals y. 23.4
perror PrinitError Message <stdio.h>
void perror (const char *s) ;
Writes the following message to the stderr stream:
String : error-message
string is the string pointed to by s and error-message is an implementation-defined
message that matches the one retumed by the call strerror (errno). 24.2
pow  Power <math.h>
double pow(double x, double y);
powf float powf (float x, float y);
powl 1long double powl (long double x, long double y);
Returns x raised to the power y. À domain or range error may occur in certain cases, which
vary between C89 and C90. 23.3
print£  Formatted Write <stdio.h>
int printf (const char * restrict format, ...);
Writes output lo the stdout stream. The string pointed to by format specifies
how subsequent arguments wil] be displayed.
Returns  Number of characters written. Returns a negative value if an error occurs. 3.1, 22.3
putc  Write Character to File <stdio.h>
int putc(int c, FILE *stream) ;
Writes the character c to the stream pointed to by stream. Note: putc is nor-
mally implemented as a macro; it may evaluate stream more than once.
Refturns c (the character written). If à write error occurs, putc sets the stream’s error indi-
cator and returns EOF. 22.4
putchar  Write Character <stdio.h>

int putchar (int c);

Writes the character c to the stdout stream. Note: putchar is normally imple-
mented as a macro.

 

 

***************************page_804***************************
Appendix D _ Standard Library Functions _ 779

 

 

 

 

 

 

 

Returns c (the character written). If a write error occurs, putchar sets the stream’s error
indicator and returns EOF. 7.3, 22.4
puts  Write String <stdio.h>
int puts(const char *s) ;
Writes the string pointed to by s to the stdout stream, then writes a new-line
character.
Returns A nonnegative value if successful. Returns EOF 1f a write error occurs. … 13.3, 22.5
putwc  Write Wide Character to File (C99) <wchar .h>
wint t putwc(wchar t c, FILE *stream) ;
Wide-character version of putc. 25.5
putwchar  Write Wide Character (C99) <wchar .h>
wint t putwchar (wchar t c);
Wide-character version of putchar. 25.5
qsort Sort Array <stdlib.h>
void qsort (void *base, size t nmemb, size t size,
int (*compar) (const void *, const void *));
Sorts the array pointed to by base. The array has nmemb elements, each size
bytes long. compar is a pointer to a comparison function. When passed pointers
to two array elements, the comparison function must return a negative, zero. Or
positive integer, depending on whether the first array element is less than, equal to,
or greater than the second. 17.7, 26.2
raise  Raise Signal <signal.h>
int raise (int sig) ;
Raises the signal whose number is sig.
Returns Zero if successful, nonzero otherwise. 24.3
rand  Generate Pseudo-Random Number <stdlib.h>
int rand (void) ;
Returns A pseudo-random integer between O and RAND _MAX (inclusive). 26.2
realloc FResize Memory Block <stdlib.h>
void *realloc(void *ptr, size t size);
ptr is assumed to point to a block of memory previously obtained from calloc.
malloc, or realloc. realloc allocates a block of size bytes, copying the
contents of the old block 1f necessary.
Returns À pointer to the besinning of the new memory block. Returns à null pointer if a

block of the requested size can’t be allocated. 17,3

***************************page_805***************************
780 Appendix D Standard Library Functions

 

 

 

 

 

 

remainder  Remainder (C99) <math.h>
double remainder (double x, double y);
remainderf float remainderf (float x, float y);
remainder! long double remainderl (long double x, long double y);
Returns _x — ny. where n is the integer nearest the exact value of x/y. (If x/y is halfway
between two integers, n 1s even.) If x — ny = O, the return value has the same sign
as x. 1f y 1s zero, either a domain error occurs or zero 1s returned. 23.4
remove … Remove File <stdio.h>
int remove (const char *filename) ;
Deletes the file whose name 1s pointed to by filename.
Returns _ Zero 1f successful, nonzero otherwise. 22.2
remquo … Remainder and Quotient (C99) <math.h>
double remquo (double x, double y, int *quo) ;
remquof float remquof (float x, float y, int *quo);
remquol long double remquol (long double x, long double y,
int *quo) ;
Computes both the remainder and the quotient when x is divided by y. The object
pointed to by quo is modified so that it contains n low-order bits of the integer
quotient Ix/yl, where n 1s implementation-defined but must be at least three. The
value stored in this object will be negative if x/y < 0.
Returns  Same value as the corresponding remainder function. If y is zero, either a
domain error occurs or zero 1s returned. 23.4
rename =— Rename File <stdio.h>
int rename (const char *old, const char *new) ;
Changes the name of a file. o1d and new point to strings containing the old name
and new name, respectively.
Returns  Zero 1f the renaming 1s successful. Returns a nonzero value 1f the operation fails
(perhaps because the old file 1s currently open). 22.2
rewind  Rewind File <stdio.h>
void rewind (FILE *stream) ;
Sets the file position indicator for the stream pointed to by stream to the begin-
ning of the file. Clears the error and end-of-file indicators for the stream. 22.7
rint — Round to Integral Value Using Current Direction (C99) <math.h>
double rint (double x) ;
rintf float rintf(float x);
rintl] 1long double rintl (long double x);
Returns x rounded lo an integer (in floating-point format) using the current rounding direc-

***************************page_806***************************
Appendix D _ Standard Library Functions 781

tion. May raise the inexact floating-point exception if the result has a different

 

 

 

 

 

 

value than x. 23.4
round  Round to Nearest Integral Value (C99) <math.h>
double round (double x) ;
roundf float roundf (float x);
roundl 1Iong double round1 (long double x);
Returns x rounded to the nearest integer (in floating-point format). Halfway cases are
rounded away from zero. 23.4
scalbln  Scale Floating-Point Number Using Long Integer (C99) <math.h»>
double scalbln (double x, long int n);
scalbinf  float scalblnf (float x, long int n);
scalbinl Jlong double scalbln]l (long double x, long int n);
Returns xx FLT RADIX", computed in an efficient way. À range error may occur. . 23.4
scalbn  Scale Floating-Point Number Using Integer (C99) <math.h>
double scalbn (double x, int n);
scalbnf float scalbnf (float x, int n);
scalbn!l J1long double scalbnl (long double x, int n);
Returns _x x FLT RADIX", computed in an efficient way. À range error may occur. … 23.4
scan£  Formatted Read <stdio.h>
int scanf (const char * restrict format, ...);
Reads input items from the stdin stream. The string pointed to by format spec-
ifies the format of the items to be read. The arguments that follow format point
to objects in which the items are to be stored.
Returns  Number of input items successfully read and stored. Returns EOF if an input fail-
ure occurs before any items can be read. 3.2, 22.3
setbu£ Set Buffer <stdio.h>
void setbuf (FILE * restrict stream,
char * restrict buf) ;
If buË isn’t a null pointer, a call of setbuf is equivalent to:
(void) setvbuf (stream, buf, _IOFBF, BUFSIZ) ;
Otherwise, it’s equivalent to:
(void) setvbuf (stream, NULL, _IONBF, O0); 22.2
setjmp  Prepare for Nonlocal Jump <setjmp.h>
int setjmp(jmp_buf env) ; macro
Stores the current environment in env for use in a later call of longjmp.
Returns Zero when called directly. Returns a nonzero value when returning from a call of

longjmp. 24.4

***************************page_807***************************
782

Appendix D _ Standard Library Functions

 

setlocale

Returns

Set Locale <locale.hs

char *setlocale(int category, const char *locale) ;

Sets a portion of the program’s locale. category indicates which portion is
affected. locale points to a string representing the new locale.

If Locale is a null pointer, returns a pointer Lo the string associated with cate-

gory for the current locale. Otherwise, returns a pointer to the string associated

with category for the new locale. Returns à null pointer if the operation fails.
25.1

 

setvbuf

Returns

Set Buffer

int setvbuf (FILE * restrict stream,
char * restrict buf,
int mode, size t size);

<stdio.h>

Changes the buffering of the stream pointed to by stream. The value of mode
can be either _IOFBF (full buffering), _ IOLBF (line buffering). or _IONBF (no
buffering). If bu£ is a null pointer, a buffer is automatically allocated if needed.
Otherwise, bu£ points to a memory block that can be used as the buffer; size is
the number of bytes in the block. Note: setvbu£ must be called after the stream
Is opened but before any other operations are performed on it.

Zero if the operation is successful. Returns a nonzero value if mode is invalid or
the request can*t be honored. 22.2

 

signal

Install Signal Handler <signal .h>

void (*signal (int sig, void (*func}) (int))) (int) ;

Installs the function pointed to by £unc as the handler for the signal whose num-
ber is sig. Passing SIG_DFL as the second argument causes default handling for
the signal; passing SIG_IGN causes the signal to be ignored.

 

 

 

Returns À pointer to the previous handler for this signal; returns SIG ERR and stores a
positive value in errno if the handler can*t be installed. 24.3
Eligﬂlhüit Sign Bit (C99) <math.h>
int signbit (real-floating x) ; Macro
Returns _ À nonzero value if the sign of x is negative and zero otherwise. The value of x may
be any number, including infinity and NaN. 23.4
sin Sine <math.h>
double sin (double x) ;
sinf ; float sinf(float x);
sinl 1long double sinl (long double x);
Returns _ Sine of x (measured in radians). 23.3
Ssinh Hyperbolic Sine <math.h>

double sinh (double x) ;

***************************page_808***************************
Appendix D _ Standard Library Functions 783

 

 

 

 

 

sinhf float sinhf (float x);
sinhl! Jlong double sinhl (long double x) ;
Returns Hyperbolic sine of x. À range error occurs 1f the magnitude of x is too large. 23.3
snprintf Bounded Formatted String Write (C99) <stdio.h>
int snprintf(char * restrict s, size t n,
const char * restrict format, ...);
Equivalent to fprint£, but stores characters in the array pointed to by s instead
of writine them to a stream. No more than n — 1 characters will be written to the
array. The string pointed to by format specifies how subsequent arguments will
be displayed. Stores a null character in the array at the end of output.
Returns  Number of characters that would have been stored in the array (not including the
null character’) had there been no length restriction. Returns a negative value if an
encoding error occurs. 22.8
sprint£  Formatted String Write <stdio.h>
int sprintf (char * restrict s,
const char * restrict format, ...);
Equivalent to fprint£, but stores characters in the array pointed to by s instead
of writing them to a stream. The string pointed to by format specifies how subse-
quent arguments will be displayed. Stores a null character in the array at the end of
output.
Returns  Number of characters stored in the array, not including the null character. In C99,
returns a negative value 1f an encoding error oceurs. 22.8
sqrt  Square Root <math.h>
double sqrt (double x) ;
saqrtf  float sartf(float x);
sqrtl long double sgrtl(long double x) ;
Returns Nonnegative square root of x. À domain error occurs if x is negative. 23.3
srand  Seed Pseudo-Random Number Generator <stdlib.h>
void srand (unsigned int seed}) ;
Uses seed to initialize the sequence of pseudo-random numbers produced by call-
ing rand. 26.2
sscanft  Formatted String Read <stdio.h>

int sscanf (const char * restrict s,
const char * restrict format, ...);

Equivalent to fscanf. but reads characters from the string pointed to by s instead
of reading them from a stream. The string pointed to by format specifies the for-
mat of the items to be read. The arguments that follow format point to objects in
which the items are to be stored.

***************************page_809***************************
 

 

 

784 Appendix D _ Standard Library Functions
Returns  Number of input items successfully read and stored. Returns EOF if an input fail-
ure occurs before any items could be read. 22.8
strcat  String Concatenation <string.h»>
char *strcat (char * restrict si,
const char * restrict s2);
Appends characters from the string pointed to by s2 to the string pointed to by s1.
Returns s1 (a pointer to the concatenated string). 13.5, 23.6
strchr … Search String for Character <string.h>
char *strchr (const char *s, int C);
Returns _ À pointer to the first occurrence of the character c in the string pointed to by s.
Returns a null pointer if c isn’t found. 23.6
Streomp — String Comparison <string.hs
int streomp(const char *s1, const char *s2);
Returns _ À negative, zero, or positive integer, depending on whether the string pointed to by

S1 is less than, equal to, or greater than the string pointed to by s2. 13.5, 23.6

 

 

 

 

strcoll String Comparison Using Locale-Specific Collating <string.h>
Sequence
int strcoll (const char *s1, const char *s2) ,

Returns _ À negative, zero, or positive integer, depending on whether the string pointed to by
s1 is less than, equal to, or greater than the string pointed to by s2. The comparison
is performed according to the rules of the current locale’s LC_COLLATE category.

23.6
strcopy  String Copy <string.h>
char *strcpy (char * restrict sl,
const char * restrict s2);
Copies the string pointed to by s2 into the array pointed to by s1.
Returns s1 (a pointer to the destination). 13.5, 23.6
Strcespn  Search String for Initial Span of Characters Not in Set <string.h>
size t strospn(const char *s1, const char *s2);

Returns  Length of the longest initial segment of the string pointed to by s1 that doesn’t
contain any character in the string pointed to by s2. 23.6

Sstrerror Convert Error Number to String <string.h»>
char *strerror (int errnum) ;

Returns À pointer to a string containing an error message corresponding to the value of

errnum. 24.2

***************************page_810***************************
Appendix D _ Standard Library Functions … 785

 

 

 

 

 

strftime  Write Formatted Date and Time to String <time.h>
size t strftime(char * restrict s, size_t maxsize,
const char * restrict format,
const struct tm * restrict timeptr) ;
Stores characters in the array pointed to by s under control of the string pointed to
by format. The format string may contain ordinary characters, which are copied
unchanged. and conversion specifiers, which are replaced by values from the struc-
ture pointed to by timeptr. The maxsize parameter limits the number of char-
acters (including the null character) that can be stored.
Returns Number of characters stored (not including the terminating null character). Returns
zero if the number of characters to be stored (including the null character) exceeds
maxsize. 26.3
strlen  String Lengih <string.h»>
size t strlen(const char *s) ;
Returns Length of the string pointed to by s, not including the null character. 13.5, 23.6
strncat  Bounded String Concatenation <string.h>
char *strncat (char * restrict sl,
const char * restrict s2, size t n);
Appends characters from the array pointed to by s2 to the string pointed to by
s1. Copying stops when a null character is encountered or n characters have been
copied.
Returns s1 (a pointer to the concatenated string). 13.5, 23.6
strnomp — Bounded String Comparison <string.h>
int strnemp(const char *s1, const char *s2, size t n);
Returns A negative, zero, or positive integer, depending on whether the first n characters of
the array pointed to by s1 are less than, equal to, or greater than the first n charac-
ters of the array pointed to by s2. Comparison stops if a null character is encoun-
tered in either array. 23.6
strnepy — Bounded String Copy <string.h>
char *strncpy (char * restrict sl,
const char * restrict s2, size t n);
Copies the first n characters of the array pointed to by s2 into the array pointed to
by s1. IF it encounters à null character in the array pointed to by s2, strncpy
adds null characters to the array pointed to by s1 until a total of n characters have
been written.
Returns s1 (a pointer to the destination). 13.5, 23.6

***************************page_811***************************
786 Appendix D Standard Library Functions

 

strpbrk

Returns

Search String for One of a Set of Characters <string.h>

char *strpbrk(const char *s1, const char *s2),

À pointer to the leftmost character in the string pointed to by s1 that matches any
character in the string pointed to by s2. Returns a null pointer if no match is found.
23.6

 

strrchr

Returns

Search String in Reverse for Character <string.h>
char *strrchr (const char *s, int c);

À pointer to the last occurrence of the character c in the string pointed to by s.
Returns a null pointer if c isn’t found. 23.6

 

strspn

Returns

Search String for Initial Span of Characters in Set <string.h>
size t strspn(const char *sl1, const char *s2) ;

Length of the longest initial segment in the string pointed to by s1 that consists
entirely of characters in the string pointed to by s2. 23.6

 

strstr

Returns

Search String for Substring <string.h>
char *strstr(const char *s1, const char *s2);

À pointer to the first occurrence in the string pointed to by s1 of the sequence of
characters in the string pointed to by s2. Returns a null pointer if no match is
found. 23.6

 

strtod

Returns

Convert String to Double <stdlib.h>

double strtod(const char * restrict nptr,
char ** restrict endptr) ;

Skips white-space characters in the string pointed to by nptr, then converts subse-
quent characters into a double value. If endptr isn’t a null pointer, strtod
modifies the object pointed to by endptr so that it points to the first leftover char-
acter. If no double value is f'ound, or if it has the wrong form, strtod stores
nptr in the object pointed to by endptr. If the number is too large or small to
represent, it stores ERANGE in errno. C99 changes: The string pointed to by
nptr may contain a hexadecimal floating-point number, infinity, or NaN.
Whether ERANGE is stored in errno when the number is too small to represent 1s
Implementation-defined.

The converted number. Returns zero if no conversion could be performed. If the
number 1s too large to represent, returns plus or minus HUGE_VAL, depending on
the number’s sign. Returns zero if the number is too small to represent. C99
change: 1f the number is too small to represent, strtod returns a value whose
magnitude is no greater than the smallest normalized positive double. 26.2

 

strtof

Convert String to Float (C99) <stdlib.h>

float strtof (const char * restrict nptr,
char ** restrict endptr) ;

***************************page_812***************************
Returns

 

Appendix D _ Standard Library Functions 787

strtof is identical to strtod, except that it converts a string to a float value.

The converted number. Returns zero if no conversion could be performed. If the
number is too large to represent, returns plus or minus HUGE_VALF, depending on
the number's sign. If the number is too small to represent, returns a value whose
magnitude is no greater than the smallest normalized positive £loat. 26.2

 

strtoimax

Returns

Convert String to Greatest-Width Integer (C99) <inttypes.h>

intmax t strtoimax (const char * restrict nptr,
char ** restrict endptr, int base) ;

strtoimax is identical to strtol, except that it converts a string to a value of
type intmax_t (the widest signed integer lype).

The converted number. Returns zero if no conversion could be performed. If the
number can*t be represented, returns INTMAX MAX or INTMAX MIN, depending
on the number’s sign. 27.2

 

strtok

Returns

Search String for Token <string.h»>

char *strtok (char * restrict sl,
const char * restrict s2);

Searches the string pointed to by s1 for a ‘“token’’ consisting of characters not in
the string pointed to by s2. IF a token exists, the character following it is changed
to a null character. If s1 is a null pointer, a search begun by the most recent call of
strtok is continued; the search begins immediately after the null character at the
end of the previous token.

À pointer to the first character of the token. Returns a null pointer if no token could
be found. 23.6

 

strtol

Returns

Convert String to Long Integer <stdlib.h»>

long int strtol (const char * restrict nptr,
char ** restrict endptr, int base) ;

Skips white-space characters in the string pointed to by nptr, then converts subse-
quent characters into a long int value. IF base 1s between 2 and 36, it is used as
the radix of the number. If base is zero, the number is assumed to be decimal
unless it begins with O (octal) or with Ox or OX (hexadecimal). If endptr isn’ta
null pointer, strtol modifies the object pointed to by endptr so that it points
to the first leftover character. If no long int value 1s found, or 1f 1t has the wrong
form, strtol stores nptr in the object pointed to by endptr. If the number
can’t be represented, it stores ERANGE In errno.

The converted number. Returns zero if no conversion could be performed. If the
number can’t be represented, returns LONG MAX or LONG MIN, depending on the
number’s sign. 26.2

 

strtold

Convert String to Long Double (C99) <stdlib.h>

long double strtold(const char * restrict nptr,
char ** restrict endptr) ;

***************************page_813***************************
788

Appendix D _ Standard Library Functions

Returns

strtold s identical to strtod, except that it converts à string to a long dou-
ble value.

The converted number. Returns Zero if no conversion could be performed. If the num-
ber is too large to represent, returns plus or minus HUGE_VALL, depending on the
number’s sign. If the number is too smaill to represent, returns a value whose mag-
nitude is no greater than the smallest normalized positive 1long double. 26.2

 

strtoll

Returns

Convert String to Long Long Integer (C99) <stdlib.h>

long long int strtoll (const char * restrict nptr,
char ** restrict endptr,
int base) ;

strtoll is identical to strtol, except that it converts à string to a 1long long
int value.

The converted number. Returns zero if no conversion could be performed. If the
number can’t be represented. returns LLONG _ MAX or LLONG MIN, depending on
the number’s sign. 26.2

 

strtoul

Returns

Convert String to Unsigned Long Integer <stdlib.h>

unsigned long int strtoul (const char * restrict nptr,
char ** restrict endptr,
int base) ;

strtoul is identical to strtol, except that it converts a string to an
unsigned long int value.

The converted number. Returns zero if no conversion could be performed. IF the
number can't be represented, returns ULONG MAX. 26.2

 

strtoull

Returns

Convert String to Unsigned Long Long Integer (C99) <stdlib.h>

unsigned long long int strtoul1l(
const char * restrict nptr,
char ** restrict endptr, int base) ;

strtoull is identical to strtol. except that it converts à string to an
unsigned long long int value.

The converted number. Returns zero if no conversion could be performed. IF the
number can't be represented. returns ULLONG MAX. 26.2

 

strtoumax

Returns

Convert String to Unsigned Greatest-Width Integer (C99) <inttypes.h>

uintmax_t strtoumax(const char * restrict nptr,
char ** restrict endptr,
int base);

strtoumax is identical to strtol. except that it converts a string to a value of
type uintmax_t (the widest unsigned integer type).

The converted number. Returns zero if no conversion could be performed. If the
number can°t be represented, returns UINTMAX MAX. 27.2

***************************page_814***************************
 

Appendix D _ Standard Library Functions 789

 

 

 

 

 

strxfrm » Transform String <string.h>
size t strxfrm(char * restrict sl,
const char * restrict s2, size t n);
Transforms the string pointed to by s2, placing the first n characters of the
result—including the null character—in the array pointed to by s1. Calling
stremp with two transformed strings should produce the same outcome (nega-
tive, Zero, or positive) as calling strcoll with the original strines. If n is zero,
s1 1s allowed to be a null pointer.
Returns  Length of the transformed strine. If this value is n or more, the contents of the
array pointed to by s1 are indeterminate. 23.6
swprintf  Wide-Character Formatted String Write (C99) <wchar .h>
int swprintf (wchar t * restrict s, size t n,
const wchar t * restrict format, ...);
Equivalent to fwprint£, but stores wide characters in the array pointed to by s
instead of writing them to a stream. The string pointed to by format specifies
how subsequent arguments will be displayed. No more than n wide characters will
be written to the array, including a terminating null wide character.
Returns  Number of wide characters stored in the array, not including the null! wide charac-
ter. Returns a negative value 1f an encoding error occurs or the number of wide
characters to be written is n or more. 25.5
Swscanft  Wide-Character Formatted String Read (C99) <wchar .h>
int swscanf (const wchar t * restrict s,
const wchar t * restrict format, ...);
Wide-character version of sscanf. 25.5
system  Perform Operating-System Command <stdlib.h>
int system(const char *string) ;
Passes the string pointed to by string to the operating system’s command pro-
cessor (shell) to be executed. Program termination may occur as a result of execut-
ing the command.
Returns lf string is a null pointer, returns a nonzero value if a command processor is
available. If string isn’t a null pointer. system returns an implementation-
defined value (if it returns at all). 26.2
tan — Tangent <math.h»>
double tan (double x) ;
tanf float tanf (float x);
tanl long double tanl(long double x);
Returns  Tangent of x (measured in radians). 23.3

***************************page_815***************************
 

 

 

 

 

 

 

790 Appendix D  Standard Library Functions
tanh  Hyperbolic Tangent <math.h>
double tanh(double x) ;
tanhf : float tanhf (float x);
tanhl 1long double tanhl (1ong double x);
Returns  Hyperbolic tangent of x. 23.3
Cgamma … Gamma Function (C99) <math.h>
double tgamma (double x) ;
tgammaf :Mfloat tgammak (float x);
tgammal long double tgammal (long double x);
Returns T (x), where L'is the gamma function. À domain error or range error may occur if x
Is a negative integer or zero. À range error may occur if the magnitude of x is too
large or too small. 23.4
time … Current Time <time.h>
time t time(time t *timer) ;
Returns  Current calendar time. Returns (time _ t) (-1) if the calendar time isn’t avail-
able. If timer isn’t a null pointer, also stores the return value in the object pointed
to by timer. 26.3
tmpfile  Create Temporary File <stdio.h>
FILE *tmpfile (void) ;
Creates a temporary file that will automatically be removed when it’s closed or the
program ends. Opens the file in "wb+" mode.
Returns _ À file pointer to be used when performing subsequent operations on the file.
Returns a null pointer if a temporary file can’t be created. 22.2
tmpnam  Generate Temporary File Name <stdio.h>
char *tmpnam(char *s) ;
Generates a name for a temporary file. If s is a null pointer, tmpnam stores the file
name in a static object. Otherwise, it copies the file name into the character array
pointed to by s. (The array must be long enough to store L_tmpnam characters.)
Returns _ À pointer to the file name. Returns a null pointer if a file name can°t be generated.
22.2
tolower  Convert to Lower Case <ctype.h>
int tolower (int c);
Returns  If c is an upper-case letter, returns the corresponding lower-case letter. If c isn’t an
upper-case letter, returns c unchanged. 23.5
toupper  Convertto Upper Case <ctype.h>

int toupper (int c);

***************************page_816***************************
Appendix D _ Standard Library Functions 791

 

 

 

 

 

 

Returns If c is a lower-case letter, returns the corresponding upper-case letter. If C isn’l a
lower-case letter, returns c unchanged. 23.5
Cowctrans — Transliterate Wide Character (C99) <wctype .h>
wint t towctrans(wint t wc, wctrans t desc);
Returns  Mapped value of wc using the mapping described by desc. (desc must be a
value returned by a call of wctrans; the current setting of the LC CTYPE cate-
gory must be the same during both calls.) 25.6
towlower  Convert Wide Character to Lower Case (C99) <wctype.h»>
wint t towlower(wint t wc);
Returns If iswupper (wc) is true, returns a corresponding wide character for which
iswlower is true in the current locale, if such a character exists. Otherwise,
returns wc unchanged. 25.6
Lowupper  Convert Wide Character to Upper Case (C99) <wctype.h>
wint t towupper (wint t wc);
Returns If iswlower (wc) is true, returns a corresponding wide character for which
iswupper is true in the current locale, if such a character exists. Otherwise,
returns wc unchanged. 25.6
trunc  Truncate to Nearest Integral Value (C99) <math.h>
double trunc (double x);
truncf float truncf (float x) ;
truncl 1long double truncl (long double x) ;
Returns x rounded to the integer (in floating-point format) nearest to it but no larger in
magnitude. 23.4
ungetc  Unread Character <stdio.h>
int ungetc(int c, FILE *stream) ;
Pushes the character c back onto the stream pointed to by stream and clears the
stream*s end-of-file indicator. The number of characters that can be pushed back
by consecutive calls of ungetc varies; only the first call is guaranteed to succeed.
Calling a file positioning function (f£seek, fsetpos, or rewind) causes the
pushed-back character(s) to be lost.
Returns c (the pushed-back character). Returns EOF 1f an attempt 1s made to push back
EOF or to push back too many characters without a read or file positioning opera-
tion. 22.4
ungetwc _ Unread Wide Character (C99) <wchar .h>

wint t ungetwc(wint t c, FILE *stream) ;

Wide-character version of ungetc. 25.5

***************************page_817***************************
 

 

 

 

 

 

 

792 Appendix D _ Standard Library Functions
va arg  Fetch Argument from Variable Argument List <stdarg.h>
fype va_arg(va list ap, type) ; IMacro
Fetches an argument in the variable argument list associated with ap. then modi-
fies ap so that the next use of va_arg fetches the following argument. ap must
have been initialized by va_start (or va_copy in C99) prior to the first use of
va_arg.
Returns  Value of the argument, assuming that its type (after the default argument promo-
tions have been applied) is compatible with /ype. 26.1
va COpPYyY  Copy Variable Argument List (C99) <stdarg.h>
void va copy(va _list dest, va _list src); macro
Copies src into dest. The value of dest will be the same as if va_start had
been applied to dest followed by the same sequence of va_arg applications that
was used to reach the present state of src. 26.1
va end  End Processing of Variable Argument List <stdarg.h>
void va _ end(va _list ap); Mmacro
Ends the processing of the variable argument list associated with ap. 26.1
va start Start Processing of Variable Argument List <stdarg.h>
void va_start (va _ list ap, parmn) ; IMacro
Must be invoked before accessing a variable argument list. Tnitializes ap for later
use by va_arg and va_end. parmN is the name of the last ordinary parameter
(the one followed by , .. .). 26.1
vfprint£f  Formatted File Write Using Variable Argument List <stdio.h>
int v£fprint£ (FILE * restrict stream,
const char * restrict fornmat,
va_list arg) ;
Equivalent to fprint£ with the variable argument list replaced by arg.
Returns  Number of characters written. Returns a negative value if an error occurs. 26.1
vÉfscanft Formatted File Read Using Variable Argument List (C99) <stdio.h>
int vfscanf (FILE * restrict stream,
const char * restrict format,
va_list arg) ;
Equivalent to £scan£ with the variable argument list replaced by arg.
Returns  Number of input ilems successfully read and stored. Returns EOF if an input fail-
ure occurs before any items can be read. 26.1
vÉwprintf  Wide-Character Formatted File Write Using Variable <wchar .h>

Argument List (C99)

***************************page_818***************************
Appendix D _ Standard Library Functions — 793

int vfwprintf(FILE * restrict stream,
const wchar t * restrict format,
va list arg);

 

 

 

 

 

Wide-character version of vfprint£. 25.5
vfwscanf  Wide-Character Formatted File Read Using Variable <wchar .h>
Argument List (C99)
int vfwscanf (FILE * restrict stream,
const wchar t * restrict format,
va _ list arg);
Wide-character version of vfscanf. 25.5
vprint£  Formatted Write Using Variable Argument List <stdio.h>
int vprint£ (const char * restrict format, va list arg) ;
Equivalent to print£ with the variable argument list replaced by ara.
Returns  Number of characters written. Returns a negative value if an error occurs. 26.1
vscan£t  Formatted Read Using Variable Argument List (C99) <stdio.h>
int vscanf (const char * restrict format, va _list arg);
Equivalent to scan£ with the variable argument list replaced by aro.
Returns  Number of input items successfully read and stored. Returns EOF 1f an input fail-
ure occurs before any items can be read. 26.1
vsnprint£  Bounded Formatted String Write Using Variable Argument <stdio.h»>
List (C99)
int vsnprintf (char * restrict s, size t n,
const char * restrict format,
va_list arg) ;
Equivalent to snprintf with the variable argument list replaced by arg.
Returns  Number of characters that would have been stored in the array pointed to by s (not
including the null character) had there been no length restriction. Returns a nega-
tive value if an encoding error occurs. 26.1
vsprint£  Formaited String Write Using Variable Argument List <stdio.h>
int vsprintf (char * restrict s,
const char * restrict format,
va_list arg) ;
Equivalent to sprintf withthe variable argument list replaced by arc.
Returns  Number of characters stored in the array pointed to by s, not including the null

character. In C99, returns a negative value if an encoding error occurs. 26.1

***************************page_819***************************
794 Appendix D _ Standard Library Functions

 

 

 

 

 

 

VvSSscanf Formatted String Read Using Variable Argument List (C99) <stdio.h>
int vsscanf (const char * restrict s,
const char * restrict format,
va_list arg);
Equivalent to sscan£ with the variable argument list replaced by arg.
Returns  Number of input items successfully read and stored. Returns EOF if an input fail-
ure occurs before any items can be read. 26.1
vswprint£  Wide-Character Formatted String Write Using Variable <wchar .h>
Argument List (C99)
int vswprintf (wchar t * restrict s, size t n,
const wchar t * restrict format,
va_list arg) ;
Equivalent tà swprint£ with the variable argument list replaced by ara.
Returns  Number of wide characters stored in the array pointed to by s, not including the
null wide character. Returns a negative value if an encoding error occurs or the
number of wide characters to be written is n or more. 25.5
vswscanf Wide-Character Formatted String Read Using Variable <wchar.hs
Argument List (C99)
int vswscanf (const wchar t * restrict s,
const wchar t * restrict format,
va_list arg) ;
Wide-character version of vsscanf. 25.5
vwprintf  Wide-Character Formatted Write Using Variable Argument = <wchar.h>
List (C99)
int vwprintf (const wchar t * restrict format,
va_list arg);
Wide-character version of vprintf. 25.5
vwscan£ _ Wide-Character Formatted Read Using Variable Argument _ <wchar.h>
List (C99)
int vwscanf (const wchar t * restrict format,
va_list arg);
Wide-character version of vscanf. 25.5
wcrtomb … Convert Wide Characier to Multibyte Character — Restartable <wchar .h>

(C99)

size t wcrtomb(char * restrict s, wchar t wc,
mbstate t * restrict ps);

If s is a null pointer, à call of wertomb is equivalent to

wertomb (bu£, L'\0', ps)

***************************page_820***************************
Appendix D _ Standard Library Functions 795

where buf is an internal buffer. Otherwise, wertomb converts wc from a wide
character into a multibyte character (possibly including shift sequences). which it
stores in the array pointed to by s. The value of ps should be a pointer to an object
of type mbstate t that contains the current conversion state. If ps is a null
pointer, wertomb uses an internal object to store the conversion state. If wc is a
null wide character, wcertomb stores a null byte, preceded by a shift sequence if
necessary to restore the initial shift state, and the mbstate t object used during
the call is left in the initial conversion state.

 

 

 

 

 

 

 

Returns  Number of bytes stored in the array, including shift sequences. If wc isn’t a valid
wide character, returns (size _ t) (-1) and stores EILSEQ in errno. 25.5
woscat … Wide-String Concatenation (C99) <wchar .h>
wchar t *wcscat (wchar t * restrict sl,
const wchar t * restrict s2);
Wide-character version of strcat. 25.5
wcschr Search Wide String for Character (C99) <wchar .h>
wchar t *wcschr(const wchar t *s, wchar t c);
Wide-character version of strchr. 25.5
Wwcscmp … Wide-String Comparison (C99) <wchar .h>
int wescmp (const wchar t *s1, const wchar t *s2);
Wide-character version of stremp. 25.5
wcscoll  Wide-String Comparison Using Locale-Specific Collating <wchar.h>
Sequence (C99)
int wcscoll (const wchar t *s1, const wchar t *s2);
Wide-character version of strcoll. 25.5
wcscpy  Wide-String Copy (C99) <wchar .h>
wchar t *wcscpy(wchar t * restrict s1l,
const wchar t * restrict s2);
Wide-character version of strcpy. 25.5
wecscspn — Search Wide String for Initial Span of Characters Notin Set _ <wchar .h>
(C99)
size t wcscspn(const wchar t *s1, const wchar t *s2);
Wide-character version of strespn. 25.5
wocsftime  Write Formatted Date and Time to Wide String (C99) <wchar .h>

size t wocsftime(wchar t * restrict s, size t maxsize,
const wchar t * restrict format,
const struct tm * restrict timeptr) ;

Wide-character version of strftaime. 25.5

***************************page_821***************************
 

 

 

 

 

 

 

796 Appendix D _ Standard Library Functions
weslen  Wide-String Length (C99) <wchar.h>
size t wcslen(const wchar t *s);
Wide-character version of strlen. 25.5
wcecsncat — Bounded Wide-String Concatenation (C99) <wchar.h>
wchar t *wcsncat (wchar t * restrict sl,
const wchar t * restrict s2,
size t n);
Wide-character version of strncat. 25.5
WCSNCMD — Bounded Wide-String Comparison (C99) <wchar .h>
int wesncmp (const wchar t *s1, const wchar t *s2,
size t n);
Wide-character version of strncemp. 25.5
WCSNCDHDYy — Bounded Wide-String Copy (C99) <wchar .h>
wchar _ t *wecsncpy (wchar t * restrict s1l,
const wchar t * restrict s2,
size t n);
Wide-character version of strnopy. 25.5
wcspbrkK Search Wide String for One of a Set of Characters (C99) <wchar .h>
wchar_t *wcspbrk (const wchar t *sl,
const wchar t *s2);
Wide-character version of strpbrk. 25.5
wesrchr Search Wide String in Reverse for Character (C99) <wchar.h>
wchar_t *wesrchr(const wchar t *s, wchar t c);
Wide-character version of strrcehr. 25.5
wcsrtombs  Convert Wide String to Multibyte String — Restartable (C99) <wchar .h>

size t wcsrtombs (char * restrict dst,
Cconst wchar t ** restrict src,
size t len,
mbstate t * restrict ps);

Converts a sequence of wide characters from the array indirectly pointed to by
src into a sequence of corresponding multibyte characters that begins in the con-
version state described by the object pointed to by ps. If ps is a null pointer,
wcsrtombs uses an internal object to store the conversion state. If dst isn’t a
null pointer, the converted characters are then stored in the array pointed to by
dst. Conversion continues up to and including a terminating null wide character,
which is also stored. Conversion stops earlier if a wide character is reached that
doesn’t correspond to a valid multibyte character or—if dst isn’t a null pointer—

 

 

***************************page_822***************************
Appendix D _ Standard Library Functions 797

when the next multüibyte character would exceed the limit of 1en total bytes to be
stored in the array pointed to by dst. If dst isn’t a null pointer, the object pointed
to by src 1s assigned either a null pointer (if à terminating null wide character was
reached) or the address just past the last wide character converted (if any). If the
conversion ends at a null wide character, the resulting state is the initial conversion
state.

 

 

 

 

 

 

Returns  Number of bytes in the resulting multibyte character sequence, not including any
terminating null character. Returns (size t) (-1) and stores EILSEQ in
errno If a wide character is encountered that doesn’t correspond to a valid multi-
byte character. 25.5

Wcsspn  Search Wide String for Initial Span of Characters in Set (C99) <wchar .h>
size t wcsspn(const wchar t *s1, const wchar t *s2),
Wide-character version of strspn. 25.5

wcsstr  Search Wide String for Substring (C99) <wchar.h>
wchar t *wcsstr(const wchar t *s1, const wchar t *s2);
Wide-character version of strstr. 25.5
wecstod  Convert Wide String to Double (C99) <wchar.h>
double wcstod(const wchar t * restrict nptr,
wchar t ** restrict endptr);
Wide-character version of strtod. 25.5
wcstof  Convert Wide String to Float (C99) <wchar.h>
float wcstof (const wchar t * restrict nptr,
wchar t ** restrict endptr) ;
Wide-character version of strtof. 25.5
wcstoimax  Convert Wide String to Greatest-Width Integer (C99) <inttypes.h»>
intmax t wcstoimax (const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base) ;
Wide-character version of strtoimax. 27.2
wcstok  Search Wide String for Token (C99) <wchar.h>

wchar t *wcstok (wchar t * restrict sl,
const wchar t * restrict s2,
wchar t ** restrict ptr);

Searches the wide string pointed to by s1 for a “token” consisting of wide charac-
ters not in the wide string pointed to by s2. If a token exists, the character follow-
ing it is changed to a null wide character. If s1 is a null pointer, a search begun by
à previous call of wcstok is continued: the search begins immediately after the
null wide character at the end of the previous token. ptr points to an object of

***************************page_823***************************
798

Appendix D _ Standard Library Functions

type wchar t * that westok modifies to keep track of its progress. If s1 is a
null pointer, this object must be the same one used in a previous call of wostok; il
determines which wide string 1s to be searched and where the search 1s to begin.

 

 

 

 

 

 

Returns À pointer to the first wide character of the token. Returns a nult pointer if no token
could be found. 25.5
wostol  Convert Wide String to Long Integer (C99) <wchar .h>
long int wcstol (const wchar t * restrict nptr,
wchar t ** restrict endptr, int base) ;
Wide-character version of strtol. 25.5
wcstold  Convert Wide String to Long Double (C99) <wchar .h>
long double wcstold(const wchar t * restrict nptr,
wchar t ** restrict endptr) ;
Wide-character version of strtold. 25.5
wecstoll  Convert Wide String to Long Long Integer (C99) <wchar.h>
long long int wcstoll (const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base);
Wide-character version of strtol1l. 25.5
wcocstombs — Convert Wide String to Multibyte String <stdlib.h>
size t wcestombs (char * restrict s,
const wchar t * restrict pwcs,
size t n);
Converts a sequence of wide characters into corresponding multibyte characters.
pwcs points to an array containing the wide characters. The multibyte characters
are stored in the array pointed to by s. Conversion ends 1f a null character 1s stored
or if storing a multibyte character would exceed the limit of n bytes.
Returns  Number of bytes stored, not including the terminating null character, 1f any.
Returns (size _ t) (-1) if a wide character is encountered that doesn't corre-
spond to a valid multibyte character. 25.2
weostoul  Convert Wide String to Unsigned Long Integer (C99) <wchar .h>
unsigned long int wcstoul(
const wchar t * restrict nptr,
wchar t ** restrict endptr, int base) ;
Wide-character version of strtoul. 25.5
wcocstoull  Convert Wide String to Unsigned Long Long Integer (C99) — <wchar.h>

unsigned long long int wcstoull(
const wchar t * restrict nptr,
wchar t ** restrict endptr, int base) ;

Wide-character version of strtoull. 25.5

***************************page_824***************************
 

Appendix D _ Standard Library Functions 799

 

 

 

 

 

 

 

westoumax  Convert Wide String to Unsigned Greatest-Width Integer <inttypes.h>
(C99)
uintmax t wcstoumax (const wchar t * restrict nptr,
wchar t ** restrict endptr,
int base) ;
Wide-character version of strtoumax. 27.2
wcsx£frm  Transform Wide String (C99) <wchar.h>
size t wcsxfrm(wchar t * restrict sl,
const wchar t * restrict s2, size t n);
Wide-character version of strxfrm. 25.5
wctob Convert Wide Character to Byte (C99) <wchar .h>
int wctob(wint t c);
Returns _ Single-byte representation of c as an unsigned char converted to int. Returns
EOF If c doesn’t correspond to one multibyte character in the initial shift state.
25.5
wctomb … Convert Wide Character to Multibyte Character <stdlib.h>
int wctomb(char *s, wchar t wc);
Converts the wide character stored in wc into a multibyte character. If s isn’t a null
pointer. stores the result in the array that s points to.

Returns  If s is a null pointer, returns a nonzero or zero value, depending on whether or not
multibyte characters have state-dependent encodings. Otherwise, returns the num-
ber of bytes in the multibyte character that corresponds to wc: returns —! if we
doesn’{ correspond to a valid multibyte character. 25.2

wctrans  Define Wide-Character Mapping (C99) <wctype.h>
wetrans t wctrans (const char *property) ;

Returns  1f property identifies a valid mapping of wide characters accordine to the
LC_CTYPE category of the current locale, returns a nonzero value that can be used
as the second argument to the towctrans function; otherwise. returns zero.

25.6
wctype … Define Wide-Character Class (C99) <wctype.h»>
wctype_t wctype (const char *property) ;

Returns  If property identifies a valid class of wide characters according to the
LC _ CTYPE category of the current locale, returns a nonzero value that can be used
as the second argument to the iswotype function: otherwise. returns zero. 25.6

wmemchxr Search Wide-Character Memory Block for Character (C99) _ <wchar.h>

wchar t *wmemchr (const wchar t *s, wchar t c,
size t n);

Wide-character version of memchr. 25.5

***************************page_825***************************
 

 

 

 

 

 

800 Appendix D _ Standard Library Functions
wmemcmp =— Compare Wide-Character Memory Blocks (C99) <wchar.h>
int wmemcemp (const wchar t * s1, const wchar t * s2,
size t n);
Wide-character version of mememp. 25.5
wmemcpy  Copy Wide-Character Memory Block (C99) <wchar .h>
wchar _t *wmemcpy (wchar t * restrict sl,
const wchar t * restrict s2,
size t n);
Wide-character version of memcpy. 25.5
wmemmove … Copy Wide-Character Memory Block (C99) <wchar .h>
wchar t *wmemmove (wchar t *s1, const wchar t *s2,
size t n);
Wide-character version of memmove. 25.5
wmemset Initialize Wide-Character Memory Block (C99) <wchar .h>
wchar t *wmemset (wchar t *s, wchar t c, size t n);
Wide-character version of memset. 25.5
wprintf  Wide-Character Formatted Write (C99) <wchar.h>
int wprintf (const wchar t * restrict format, ...);
Wide-character version of printf. 25.5
wscan£t  Wide-Character Formatted Read (C99) <wchar.h>
int wscanf (const wchar t * restrict format, ...);

Wide-character version of scanf. 25.5

***************************page_826***************************
APPENDIX E

ASCII Character Set

 

Escape Sequence

 

 

 

 

 

 

Decimal = Oct Hex Char — Character
0 \ 0 \x00 nul 32 64 @ 96
] \1 \x01 soh (AA) 33 ! 65 À 97 a
2 \2 \x02 six (AB) | 34 " 66 B 98 b
3 \3 \x03 ex (AC) 35 # 67 C 99 C
d \ 4 \x04 eot: (XD) 36 $ 68 D 100 d
5 \5 \x05 enq (*E) 37 % | 69 E 101 e
6 \6 \x06 ack (*F) 38 & | 70 F 102 f
7 \ 7 \x07 \a bel (G) 39 ' 71 G 103 g
8 \10  \x08 \b bs  ("H) | 40 ( 72 H 104 h
9 \11  \x09 \t ht _ (A) 41 ) 73 I 105 i
10 \12 \xD0a \n f (N) 42 d 74 J 106 J
11 \13  \x0b \v v . (AK) | 43 + | 75 K 107 k
12 \14 : \xO0c \f f (PL) 44 76 L 108 |
13 \15 \x0d \r cr (AM) | 45 - 77 M 1090 m
14 \16  \x0e so  (AN) | 46 , 75 N 110 n
15 \17  \xOf si (FO) | 47 / 19 O 111 O
16 \20 \x10 dle (AP) 48 0 s0 P 112 p
17 \21 \x11 del (PQ) 49 ] 81 Q 113 CI
18 \22  \x12 dce2 (KR) 150 2 | 82 R |14 r
19 \23  \x13 de3 (*S) 51 3 83 S 115 s
20 \24  \x14 dc4 ("T) 52 4 s4 T 116 l
21 \25 \x15 nak (AU) 153" 5 185 U 117 u
22 \26  \x16 svn (V) 154 6186 V 118 v
23 \27  \x17 etb (AW) | 55 7 817 W 119 w
24 \30  \x18 can (AX) 56 8 SS X 120 x
25 \323  \x19 em (AY) | 57 9 89 Y 121 y
26 \32  \xla sub (AZ) 58 : 90 Z 122 Z
27 \33 . \xib esc 59 ; 01 [ 123 (
28 \34  \x1lc fs 660 < | 92 \ 124 |
29 \35  \x1d es 61 = | 93 | 125 }
30 \36 \xle ys 62 , > | 94 \ 126 -
31 \37 \x1f Us 63 ? 95 _ 127 - del

 

 

***************************page_827***************************

***************************page_828***************************
BIBLIOGRAPHY

The best book on programming for the layman is
“Alice in Wonderland"; but that's because it’s
the best book on anything for the layman.

C Programming

Feuer, À. R, The C Puzzle Book, Revised Printing. Addison-Wesley, Reading.
Mass., 1999. Contains numerous “puzzles”—small C programs whose output
the reader is asked to predict. The book shows the correct output of each pro-
gram and provides a detailed explanation of how it works. Good for testing
your C knowledge and reviewing the fine points of the language.

Harbison, S. P., III, and G. L. Steele, Jr.…, C: À Reference Manual, Fifth Edition,
Prentice-Hall, Upper Saddle River, N.J., 2002. The ultimate C reference—
essential reading for the would-be C expert. Covers both C89 and C99 in con-
siderable detail, with frequent discussions of implementation differences
found in C compilers. Not a tutorial—assumes that the reader is already well
versed in C.

Kernighan, B. W., and D. M. Ritchie, The C Programming Language, Second Edi-
tion, Prentice-Hall, Englewood Cliffs, N.J., 1988. The original C book. affee-
tionately known as K&R or simply “the White Book.” Includes both a tutorial
and a complete C reference manual. The second edition reflects the changes

made in C89.

Koenig, À.. C Traps and Pitfalls, Addison-Wesley, Reading, Mass., 1989. An
excellent compendium of common (and some not-so-common) C pitfalls.
Forewarned 1s forearmed.

Plauger, P. J.. The Standard C Library, Prentice-Hall, Englewood Cliffs, N.J.,
1992. Not only explains all aspects of the C89 standard library, but provides
complete source code! There’s no better way to learn the library than to study
this book. Even 1f your interest in the library is minimal, the book is worth get-
ting just for the opportunity to study C code written by a master.

803

***************************page_829***************************
804

Bibliography

Ritchie, D. M., The development of the C programming language, in History of
Programming Languages TI, edited by T. J. Bergin, Jr…. and R. G. Gibson. Jr.…
Addison-Wesley, Reading, Mass., 1996, pages 671-687. À brief history of C
written by the language’s designer for the Second ACM SIGPLAN History of
Programming Languages Conference, which was held in 1993. The article 1s
followed by transcripts of Ritchie’s presentation at the conference and the
question-and-answer session with the audience.

Ritchie, D. M., S. C. Johnson, M. E. Lesk, and B. W. Kernighan, UNIX time-
sharing system: the C programming language, Bell System Technical Journal
57, 6 (July-August 1978), 1991-2019. A famous article that discusses the
origins of C and describes the language as it looked in 1978.

Rosler, L., The UNIX system: the cvolution of C—past and future, AT&T Bell
Laboratories Technical Journal 63, 8 (October 1984), 1685—1699., Traces the
evolution of C from 1978 to 1984 and beyond.

Summit, S., C Programming FAQs: Frequently Asked Questions, Addison-Wesley.
Reading, Mass., 1996. An expanded version of the FAQ list that has appeared
for years in the Usenet comp.lang.c newsgroup.

van der Linden, P., Expert C Programming. Prentice-Hall, Englewood Cliffs, N.J..
1994, Written by one of the C wizards at Sun Microsystems, this book man-
ages to entertain and inform in equal amounts. With its profusion of anecdotes
and jokes, t makes learning the fine points of C seem almost fun.

UNIX Programming

Rochkind, M. J., Advanced UNIX Programming, Second Edition, Addison-Wesley,
Boston, Mass., 2004. Covers UNIX system calls in considerable detail. This
book, along with the one by Stevens and Rago, is a must-have for C program-
mers who use the UNIX operating system or one of its variants.

Stevens, W. R, and S. À. Rago, Advanced Programming in the UNIX Environment,
Second Edition, Addison-Wesley, Upper Saddle River. N.J.. 2005. An excel-
lent follow-up to this book for programmers working under the UNIX operat-
ing system. Focuses on using UNIX system calls, including standard C library
functions as well as functions that are specific to UNIX.

Programming in General

Bentley, J, Programming Pearls. Second Edition, Addison-Wesley, Readine,
Mass., 2000. This updated version of Bentley's classic programming book
emphasizes writing efficient programs, but touches on other topics that are
crucial for the professional programmer. The author’s light touch makes the
book as enjoyable to read as it 1s informative.

***************************page_830***************************
Bibliography 805

Kernighan, B. W., and R. Pike, The Practice of Programminge, Addison-Wesley,
Reading, Mass., 1999. Read this book for advice on programming style, choos-
ing the right algorithm, testing and debugging, and writing portable programs.
Examples are drawn from C, C++. and Java.

McConnell. S., Code Complete, Second Edition, Microsoft Press. Redmond, Wash..
2004. Tries to bridge the gap between programming theory and practice by pro-
viding down-to-carth coding advice based on proven research. Includes plenty
of examples in à variety of programming languages. Highly recommended.

Raymond, E. S, ed., The New Hacker's Dictionary, Third Edition. MIT Press, Cam-
bridge, Mass., 1996. Explains much of the jargon that programmers use, and it’s
éreal fun to read as well.

Web Resources

ANSI eStandards Store (webstore.ansi.org), The C99 standard (ISO/TEC
9899:1999) can be purchased at this site. Each set of corrections to the stan-
dard (known as a Technical Corrigendum) can be downloaded for free.

comp.lang.c Frequently Asked Questions (c-fag.com). Steve Summit’s FAQ list for
the comp.lang.c newsgroup 1s a must-read for any C programmer.

Dinkumware (vrww.dinkumware.com). Dinkumware is owned by P. J. Plauger. the
acknowledged master of the C and C++ standard libraries. The web site in-
cludes a handy C99 library reference, among other things.

Google Groups (groups.google.com). One of the best ways to find answers to pro-
gramming questions is to search the Usenet newsgroups using the Google
Groups search engine. If you have a question, it’s likely that someone else has
already asked the question on à newsgroup and the answer has been posted.
Groups of particular interest to C programmers include alr.comp.lang.learn.c-
ce++ (for C and C++ beginners), comp.lang.c (the primary C language group).
and comp.std.c (devoted to discussion of the C standard).

International Obfuscated C Code Contest (Grwiww.ioccc.org). Home of an annual con-
testin which participants vie to see who can write the most obscure C programs.

ISO/IEC JTC1/SC22/WG14 (wiww.open-std.org/jtc1/sc22/we14/). The official web
site of WG14, the international working group that created the C99 standard
and 1s responsible for updating it. Of particular interest among the many docu-
ments available at the site 1s the rationale for C99, which explains the reasons
for the changes made in the standard.

Lysator Geww./vsator.liu.se/c/). À collection of links to C-related web sites main-
tairned by Lysator, an academic computer society located at Sweden's Lin-
kôping University.
